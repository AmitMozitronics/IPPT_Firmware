CCS PCH C Compiler, Version 5.083, 13314               26-Feb-21 17:07

               Filename:   D:\Work\Projects\PWT\01_Code\PWT-V4.0\M1_Comm_Module\M1_Comm_Module.X\build\default\debug\_ext\1472\vmIMW_MCU1.lst

               ROM used:   18214 bytes (28%)
                           Largest free fragment is 47318
               RAM used:   3065 (86%) at main() level
                           3122 (88%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

*
00000:  GOTO   42C6
*
00008:  GOTO   00DA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  MOVLB  E
00066:  BTFSS  x2D.5
00068:  GOTO   0072
0006C:  BTFSC  x37.5
0006E:  GOTO   0372
00072:  BTFSS  x2D.1
00074:  GOTO   007E
00078:  BTFSC  x37.1
0007A:  GOTO   049A
0007E:  BTFSS  x29.5
00080:  GOTO   008A
00084:  BTFSC  x33.5
00086:  GOTO   0220
0008A:  MOVFF  0E,00
0008E:  MOVFF  0F,01
00092:  MOVFF  10,02
00096:  MOVFF  11,03
0009A:  MOVFF  0C,FE9
0009E:  MOVFF  07,FEA
000A2:  BSF    07.7
000A4:  MOVFF  08,FE1
000A8:  MOVFF  09,FE2
000AC:  MOVFF  0A,FD9
000B0:  MOVFF  0B,FDA
000B4:  MOVFF  12,FF3
000B8:  MOVFF  13,FF4
000BC:  MOVFF  14,FFA
000C0:  MOVFF  15,FF5
000C4:  MOVFF  16,FF6
000C8:  MOVFF  17,FF7
000CC:  MOVF   04,W
000CE:  MOVFF  06,FE0
000D2:  MOVFF  05,FD8
000D6:  RETFIE 0
000D8:  MOVLB  0
000DA:  MOVWF  1A
000DC:  MOVFF  FD8,1B
000E0:  MOVFF  FE0,1C
000E4:  MOVLB  0
000E6:  MOVFF  FE9,22
000EA:  MOVFF  FEA,1D
000EE:  MOVFF  FE1,1E
000F2:  MOVFF  FE2,1F
000F6:  MOVFF  FD9,20
000FA:  MOVFF  FDA,21
000FE:  MOVFF  FF3,28
00102:  MOVFF  FF4,29
00106:  MOVFF  FFA,2A
0010A:  MOVFF  FF5,2B
0010E:  MOVFF  FF6,2C
00112:  MOVFF  FF7,2D
00116:  MOVFF  00,24
0011A:  MOVFF  01,25
0011E:  MOVFF  02,26
00122:  MOVFF  03,27
00126:  MOVLB  E
00128:  BTFSS  x2C.5
0012A:  GOTO   0134
0012E:  BTFSC  x36.5
00130:  GOTO   01CA
00134:  MOVFF  24,00
00138:  MOVFF  25,01
0013C:  MOVFF  26,02
00140:  MOVFF  27,03
00144:  MOVFF  22,FE9
00148:  MOVFF  1D,FEA
0014C:  BSF    1D.7
0014E:  MOVFF  1E,FE1
00152:  MOVFF  1F,FE2
00156:  MOVFF  20,FD9
0015A:  MOVFF  21,FDA
0015E:  MOVFF  28,FF3
00162:  MOVFF  29,FF4
00166:  MOVFF  2A,FFA
0016A:  MOVFF  2B,FF5
0016E:  MOVFF  2C,FF6
00172:  MOVFF  2D,FF7
00176:  MOVF   1A,W
00178:  MOVFF  1C,FE0
0017C:  MOVFF  1B,FD8
00180:  RETFIE 0
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F66K40.h" 
.................... //////////// Standard Header file for the PIC18F66K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F66K40 
00182:  MOVLB  C
00184:  MOVF   x30,W
00186:  CLRF   01
00188:  SUBWF  x2F,W
0018A:  BC    0192
0018C:  MOVFF  C2F,00
00190:  BRA    01AA
00192:  CLRF   00
00194:  MOVLW  08
00196:  MOVWF  x31
00198:  RLCF   x2F,F
0019A:  RLCF   00,F
0019C:  MOVF   x30,W
0019E:  SUBWF  00,W
001A0:  BTFSC  FD8.0
001A2:  MOVWF  00
001A4:  RLCF   01,F
001A6:  DECFSZ x31,F
001A8:  BRA    0198
001AA:  MOVLB  0
001AC:  RETURN 0
*
003B4:  DATA 2F,61
003B6:  DATA 70,69
003B8:  DATA 2F,69
003BA:  DATA 70,70
003BC:  DATA 74,76
003BE:  DATA 32,2F
003C0:  DATA 3F,61
003C2:  DATA 3D,25
003C4:  DATA 75,26
003C6:  DATA 62,3D
003C8:  DATA 25,4C
003CA:  DATA 75,26
003CC:  DATA 63,3D
003CE:  DATA 25,4C
003D0:  DATA 75,26
003D2:  DATA 64,3D
003D4:  DATA 25,75
003D6:  DATA 26,65
003D8:  DATA 3D,25
003DA:  DATA 4C,75
003DC:  DATA 26,66
003DE:  DATA 3D,25
003E0:  DATA 75,26
003E2:  DATA 67,3D
003E4:  DATA 25,4C
003E6:  DATA 75,26
003E8:  DATA 68,3D
003EA:  DATA 25,4C
003EC:  DATA 75,26
003EE:  DATA 69,3D
003F0:  DATA 25,4C
003F2:  DATA 75,26
003F4:  DATA 6A,3D
003F6:  DATA 25,4C
003F8:  DATA 75,26
003FA:  DATA 6B,3D
003FC:  DATA 25,4C
003FE:  DATA 75,26
00400:  DATA 6C,3D
00402:  DATA 25,4C
00404:  DATA 75,26
00406:  DATA 6D,3D
00408:  DATA 25,4C
0040A:  DATA 75,26
0040C:  DATA 6E,3D
0040E:  DATA 25,4C
00410:  DATA 75,26
00412:  DATA 6F,3D
00414:  DATA 25,75
00416:  DATA 00,00
*
00432:  MOVLB  C
00434:  MOVF   x28,W
00436:  MULWF  x2A
00438:  MOVFF  FF3,01
0043C:  MOVFF  FF4,00
00440:  MULWF  x2B
00442:  MOVF   FF3,W
00444:  ADDWF  00,F
00446:  MOVF   x29,W
00448:  MULWF  x2A
0044A:  MOVF   FF3,W
0044C:  ADDWFC 00,W
0044E:  MOVWF  02
00450:  MOVLB  0
00452:  RETURN 0
00454:  CLRF   01
00456:  CLRF   02
00458:  CLRF   00
0045A:  CLRF   03
0045C:  MOVLB  C
0045E:  MOVF   x2A,W
00460:  BNZ   0466
00462:  MOVF   x29,W
00464:  BZ    0496
00466:  MOVLW  10
00468:  MOVWF  x2B
0046A:  BCF    FD8.0
0046C:  RLCF   x27,F
0046E:  RLCF   x28,F
00470:  RLCF   00,F
00472:  RLCF   03,F
00474:  MOVF   x2A,W
00476:  SUBWF  03,W
00478:  BNZ   047E
0047A:  MOVF   x29,W
0047C:  SUBWF  00,W
0047E:  BNC   048E
00480:  MOVF   x29,W
00482:  SUBWF  00,F
00484:  BTFSS  FD8.0
00486:  DECF   03,F
00488:  MOVF   x2A,W
0048A:  SUBWF  03,F
0048C:  BSF    FD8.0
0048E:  RLCF   01,F
00490:  RLCF   02,F
00492:  DECFSZ x2B,F
00494:  BRA    046A
00496:  MOVLB  0
00498:  RETURN 0
*
009CC:  TSTFSZ 01
009CE:  BRA    09D6
009D0:  TSTFSZ 02
009D2:  BRA    09D8
009D4:  BRA    09E4
009D6:  INCF   02,F
009D8:  MOVFF  00,FEE
009DC:  DECFSZ 01,F
009DE:  BRA    09D8
009E0:  DECFSZ 02,F
009E2:  BRA    09D8
009E4:  RETURN 0
*
01E20:  MOVLB  C
01E22:  CLRF   x19
01E24:  CLRF   x1A
01E26:  MOVLW  01
01E28:  MOVWF  x1B
01E2A:  CLRF   FDA
01E2C:  CLRF   FD9
01E2E:  MOVLW  0C
01E30:  MOVWF  x1E
01E32:  MOVLW  11
01E34:  MOVWF  x1D
01E36:  MOVLW  0C
01E38:  MOVWF  FEA
01E3A:  MOVLW  15
01E3C:  MOVWF  FE9
01E3E:  MOVFF  C1E,FE2
01E42:  MOVFF  C1D,FE1
01E46:  MOVFF  C1B,C1C
01E4A:  BCF    FD8.0
01E4C:  MOVF   FE5,W
01E4E:  MULWF  FEE
01E50:  MOVF   FF3,W
01E52:  ADDWFC x19,F
01E54:  MOVF   FF4,W
01E56:  ADDWFC x1A,F
01E58:  DECFSZ x1C,F
01E5A:  BRA    1E4A
01E5C:  MOVFF  C19,FDE
01E60:  MOVFF  C1A,C19
01E64:  CLRF   x1A
01E66:  BTFSC  FD8.0
01E68:  INCF   x1A,F
01E6A:  INCF   x1D,F
01E6C:  BTFSC  FD8.2
01E6E:  INCF   x1E,F
01E70:  INCF   x1B,F
01E72:  MOVF   x1B,W
01E74:  SUBLW  05
01E76:  BNZ   1E36
01E78:  MOVLB  0
01E7A:  RETURN 0
*
01F8A:  BTFSC  FD8.1
01F8C:  BRA    1F96
01F8E:  MOVLW  0C
01F90:  MOVWF  FEA
01F92:  MOVLW  21
01F94:  MOVWF  FE9
01F96:  MOVLB  C
01F98:  MOVF   x1C,W
01F9A:  XORWF  x20,W
01F9C:  ANDLW  80
01F9E:  MOVWF  x26
01FA0:  BTFSS  x1C.7
01FA2:  BRA    1FBA
01FA4:  COMF   x19,F
01FA6:  COMF   x1A,F
01FA8:  COMF   x1B,F
01FAA:  COMF   x1C,F
01FAC:  INCF   x19,F
01FAE:  BTFSC  FD8.2
01FB0:  INCF   x1A,F
01FB2:  BTFSC  FD8.2
01FB4:  INCF   x1B,F
01FB6:  BTFSC  FD8.2
01FB8:  INCF   x1C,F
01FBA:  BTFSS  x20.7
01FBC:  BRA    1FD4
01FBE:  COMF   x1D,F
01FC0:  COMF   x1E,F
01FC2:  COMF   x1F,F
01FC4:  COMF   x20,F
01FC6:  INCF   x1D,F
01FC8:  BTFSC  FD8.2
01FCA:  INCF   x1E,F
01FCC:  BTFSC  FD8.2
01FCE:  INCF   x1F,F
01FD0:  BTFSC  FD8.2
01FD2:  INCF   x20,F
01FD4:  CLRF   00
01FD6:  CLRF   01
01FD8:  CLRF   02
01FDA:  CLRF   03
01FDC:  CLRF   x21
01FDE:  CLRF   x22
01FE0:  CLRF   x23
01FE2:  CLRF   x24
01FE4:  MOVF   x20,W
01FE6:  IORWF  x1F,W
01FE8:  IORWF  x1E,W
01FEA:  IORWF  x1D,W
01FEC:  BZ    2046
01FEE:  MOVLW  20
01FF0:  MOVWF  x25
01FF2:  BCF    FD8.0
01FF4:  RLCF   x19,F
01FF6:  RLCF   x1A,F
01FF8:  RLCF   x1B,F
01FFA:  RLCF   x1C,F
01FFC:  RLCF   x21,F
01FFE:  RLCF   x22,F
02000:  RLCF   x23,F
02002:  RLCF   x24,F
02004:  MOVF   x20,W
02006:  SUBWF  x24,W
02008:  BNZ   201A
0200A:  MOVF   x1F,W
0200C:  SUBWF  x23,W
0200E:  BNZ   201A
02010:  MOVF   x1E,W
02012:  SUBWF  x22,W
02014:  BNZ   201A
02016:  MOVF   x1D,W
02018:  SUBWF  x21,W
0201A:  BNC   203A
0201C:  MOVF   x1D,W
0201E:  SUBWF  x21,F
02020:  MOVF   x1E,W
02022:  BTFSS  FD8.0
02024:  INCFSZ x1E,W
02026:  SUBWF  x22,F
02028:  MOVF   x1F,W
0202A:  BTFSS  FD8.0
0202C:  INCFSZ x1F,W
0202E:  SUBWF  x23,F
02030:  MOVF   x20,W
02032:  BTFSS  FD8.0
02034:  INCFSZ x20,W
02036:  SUBWF  x24,F
02038:  BSF    FD8.0
0203A:  RLCF   00,F
0203C:  RLCF   01,F
0203E:  RLCF   02,F
02040:  RLCF   03,F
02042:  DECFSZ x25,F
02044:  BRA    1FF2
02046:  BTFSS  x26.7
02048:  BRA    2060
0204A:  COMF   00,F
0204C:  COMF   01,F
0204E:  COMF   02,F
02050:  COMF   03,F
02052:  INCF   00,F
02054:  BTFSC  FD8.2
02056:  INCF   01,F
02058:  BTFSC  FD8.2
0205A:  INCF   02,F
0205C:  BTFSC  FD8.2
0205E:  INCF   03,F
02060:  MOVFF  C21,FEF
02064:  MOVFF  C22,FEC
02068:  MOVFF  C23,FEC
0206C:  MOVFF  C24,FEC
02070:  MOVLB  0
02072:  RETURN 0
*
03C06:  TBLRD*+
03C08:  MOVFF  FF6,C0E
03C0C:  MOVFF  FF7,C0F
03C10:  MOVF   FF5,W
03C12:  MOVLB  E
03C14:  BTFSS  x37.4
03C16:  BRA    3C14
03C18:  MOVWF  xDD
03C1A:  MOVFF  C0E,FF6
03C1E:  MOVFF  C0F,FF7
03C22:  MOVLB  C
03C24:  DECFSZ x0D,F
03C26:  BRA    3C2A
03C28:  BRA    3C2E
03C2A:  MOVLB  0
03C2C:  BRA    3C06
03C2E:  MOVLB  0
03C30:  RETURN 0
03C32:  MOVF   01,W
03C34:  CLRF   19
03C36:  BTFSC  FF2.7
03C38:  BSF    19.7
03C3A:  BCF    FF2.7
03C3C:  MOVFF  C0D,C2F
03C40:  MOVLW  64
03C42:  MOVLB  C
03C44:  MOVWF  x30
03C46:  MOVLB  0
03C48:  CALL   0182
03C4C:  BTFSC  19.7
03C4E:  BSF    FF2.7
03C50:  MOVFF  00,C0D
03C54:  MOVF   01,W
03C56:  MOVLW  30
03C58:  BNZ   3C6A
03C5A:  MOVLB  C
03C5C:  BTFSS  x0E.1
03C5E:  BRA    3C80
03C60:  BTFSC  x0E.3
03C62:  BRA    3C80
03C64:  BTFSC  x0E.4
03C66:  MOVLW  20
03C68:  BRA    3C72
03C6A:  MOVLB  C
03C6C:  BCF    x0E.3
03C6E:  BCF    x0E.4
03C70:  BSF    x0E.0
03C72:  ADDWF  01,F
03C74:  MOVF   01,W
03C76:  MOVLB  E
03C78:  BTFSS  x37.4
03C7A:  BRA    3C78
03C7C:  MOVWF  xDD
03C7E:  MOVLB  C
03C80:  CLRF   19
03C82:  BTFSC  FF2.7
03C84:  BSF    19.7
03C86:  BCF    FF2.7
03C88:  MOVFF  C0D,C2F
03C8C:  MOVLW  0A
03C8E:  MOVWF  x30
03C90:  MOVLB  0
03C92:  CALL   0182
03C96:  BTFSC  19.7
03C98:  BSF    FF2.7
03C9A:  MOVFF  00,C0D
03C9E:  MOVF   01,W
03CA0:  MOVLW  30
03CA2:  BNZ   3CB4
03CA4:  MOVLB  C
03CA6:  BTFSC  x0E.3
03CA8:  BRA    3CC2
03CAA:  BTFSS  x0E.0
03CAC:  BRA    3CC2
03CAE:  BTFSC  x0E.4
03CB0:  MOVLW  20
03CB2:  MOVLB  0
03CB4:  ADDWF  01,F
03CB6:  MOVF   01,W
03CB8:  MOVLB  E
03CBA:  BTFSS  x37.4
03CBC:  BRA    3CBA
03CBE:  MOVWF  xDD
03CC0:  MOVLB  C
03CC2:  MOVLW  30
03CC4:  ADDWF  x0D,F
03CC6:  MOVF   x0D,W
03CC8:  MOVLB  E
03CCA:  BTFSS  x37.4
03CCC:  BRA    3CCA
03CCE:  MOVWF  xDD
03CD0:  MOVLB  0
03CD2:  RETURN 0
03CD4:  MOVFF  FEA,C15
03CD8:  MOVFF  FE9,C14
03CDC:  MOVLB  C
03CDE:  SWAPF  x0E,W
03CE0:  IORLW  F0
03CE2:  MOVWF  x10
03CE4:  ADDWF  x10,F
03CE6:  ADDLW  E2
03CE8:  MOVWF  x11
03CEA:  ADDLW  32
03CEC:  MOVWF  x13
03CEE:  MOVF   x0E,W
03CF0:  ANDLW  0F
03CF2:  ADDWF  x11,F
03CF4:  ADDWF  x11,F
03CF6:  ADDWF  x13,F
03CF8:  ADDLW  E9
03CFA:  MOVWF  x12
03CFC:  ADDWF  x12,F
03CFE:  ADDWF  x12,F
03D00:  SWAPF  x0D,W
03D02:  ANDLW  0F
03D04:  ADDWF  x12,F
03D06:  ADDWF  x13,F
03D08:  RLCF   x12,F
03D0A:  RLCF   x13,F
03D0C:  COMF   x13,F
03D0E:  RLCF   x13,F
03D10:  MOVF   x0D,W
03D12:  ANDLW  0F
03D14:  ADDWF  x13,F
03D16:  RLCF   x10,F
03D18:  MOVLW  07
03D1A:  MOVWF  x0F
03D1C:  MOVLW  0A
03D1E:  DECF   x12,F
03D20:  ADDWF  x13,F
03D22:  BNC   3D1E
03D24:  DECF   x11,F
03D26:  ADDWF  x12,F
03D28:  BNC   3D24
03D2A:  DECF   x10,F
03D2C:  ADDWF  x11,F
03D2E:  BNC   3D2A
03D30:  DECF   x0F,F
03D32:  ADDWF  x10,F
03D34:  BNC   3D30
03D36:  MOVLW  0C
03D38:  MOVWF  FEA
03D3A:  MOVLW  0F
03D3C:  MOVWF  FE9
03D3E:  MOVLW  07
03D40:  ANDWF  x14,W
03D42:  BCF    x14.6
03D44:  ADDWF  FE9,F
03D46:  MOVLW  00
03D48:  ADDWFC FEA,F
03D4A:  MOVF   FE9,W
03D4C:  SUBLW  13
03D4E:  BNZ   3D58
03D50:  MOVF   FEA,W
03D52:  SUBLW  0C
03D54:  BNZ   3D58
03D56:  BSF    x14.6
03D58:  MOVF   FEF,W
03D5A:  MOVWF  00
03D5C:  BNZ   3D6E
03D5E:  BTFSC  x14.6
03D60:  BRA    3D6E
03D62:  BTFSC  x14.4
03D64:  BRA    3D82
03D66:  BTFSC  x14.3
03D68:  BRA    3D6E
03D6A:  MOVLW  20
03D6C:  BRA    3D74
03D6E:  BSF    x14.3
03D70:  BCF    x14.4
03D72:  MOVLW  30
03D74:  ADDWF  00,F
03D76:  MOVF   00,W
03D78:  MOVLB  E
03D7A:  BTFSS  x37.4
03D7C:  BRA    3D7A
03D7E:  MOVWF  xDD
03D80:  MOVLB  C
03D82:  MOVF   FEE,W
03D84:  BTFSS  x14.6
03D86:  BRA    3D4A
03D88:  MOVLB  0
03D8A:  RETURN 0
03D8C:  BTFSC  FD8.1
03D8E:  BRA    3D98
03D90:  MOVLW  0C
03D92:  MOVWF  FEA
03D94:  MOVLW  21
03D96:  MOVWF  FE9
03D98:  CLRF   00
03D9A:  CLRF   01
03D9C:  CLRF   02
03D9E:  CLRF   03
03DA0:  MOVLB  C
03DA2:  CLRF   x21
03DA4:  CLRF   x22
03DA6:  CLRF   x23
03DA8:  CLRF   x24
03DAA:  MOVF   x20,W
03DAC:  IORWF  x1F,W
03DAE:  IORWF  x1E,W
03DB0:  IORWF  x1D,W
03DB2:  BZ    3E0C
03DB4:  MOVLW  20
03DB6:  MOVWF  x25
03DB8:  BCF    FD8.0
03DBA:  RLCF   x19,F
03DBC:  RLCF   x1A,F
03DBE:  RLCF   x1B,F
03DC0:  RLCF   x1C,F
03DC2:  RLCF   x21,F
03DC4:  RLCF   x22,F
03DC6:  RLCF   x23,F
03DC8:  RLCF   x24,F
03DCA:  MOVF   x20,W
03DCC:  SUBWF  x24,W
03DCE:  BNZ   3DE0
03DD0:  MOVF   x1F,W
03DD2:  SUBWF  x23,W
03DD4:  BNZ   3DE0
03DD6:  MOVF   x1E,W
03DD8:  SUBWF  x22,W
03DDA:  BNZ   3DE0
03DDC:  MOVF   x1D,W
03DDE:  SUBWF  x21,W
03DE0:  BNC   3E00
03DE2:  MOVF   x1D,W
03DE4:  SUBWF  x21,F
03DE6:  MOVF   x1E,W
03DE8:  BTFSS  FD8.0
03DEA:  INCFSZ x1E,W
03DEC:  SUBWF  x22,F
03DEE:  MOVF   x1F,W
03DF0:  BTFSS  FD8.0
03DF2:  INCFSZ x1F,W
03DF4:  SUBWF  x23,F
03DF6:  MOVF   x20,W
03DF8:  BTFSS  FD8.0
03DFA:  INCFSZ x20,W
03DFC:  SUBWF  x24,F
03DFE:  BSF    FD8.0
03E00:  RLCF   00,F
03E02:  RLCF   01,F
03E04:  RLCF   02,F
03E06:  RLCF   03,F
03E08:  DECFSZ x25,F
03E0A:  BRA    3DB8
03E0C:  MOVFF  C21,FEF
03E10:  MOVFF  C22,FEC
03E14:  MOVFF  C23,FEC
03E18:  MOVFF  C24,FEC
03E1C:  MOVLB  0
03E1E:  RETURN 0
03E20:  MOVF   FE9,W
03E22:  MOVLB  C
03E24:  MOVWF  x11
03E26:  MOVLW  3B
03E28:  MOVWF  x18
03E2A:  MOVLW  9A
03E2C:  MOVWF  x17
03E2E:  MOVLW  CA
03E30:  MOVWF  x16
03E32:  CLRF   x15
03E34:  MOVLW  0A
03E36:  MOVWF  x13
03E38:  BSF    FD8.1
03E3A:  MOVLW  0C
03E3C:  MOVWF  FEA
03E3E:  MOVLW  0D
03E40:  MOVWF  FE9
03E42:  MOVFF  C10,C1C
03E46:  MOVFF  C0F,C1B
03E4A:  MOVFF  C0E,C1A
03E4E:  MOVFF  C0D,C19
03E52:  MOVFF  C18,C20
03E56:  MOVFF  C17,C1F
03E5A:  MOVFF  C16,C1E
03E5E:  MOVFF  C15,C1D
03E62:  MOVLB  0
03E64:  RCALL  3D8C
03E66:  MOVF   01,W
03E68:  MOVF   00,F
03E6A:  BNZ   3E92
03E6C:  MOVLB  C
03E6E:  MOVF   x13,W
03E70:  XORLW  01
03E72:  BTFSS  FD8.2
03E74:  BRA    3E7A
03E76:  MOVLB  0
03E78:  BRA    3E92
03E7A:  MOVF   x11,W
03E7C:  BZ    3E96
03E7E:  ANDLW  0F
03E80:  SUBWF  x13,W
03E82:  BZ    3E86
03E84:  BC    3EA6
03E86:  BTFSC  x11.7
03E88:  BRA    3EA6
03E8A:  BTFSC  x11.6
03E8C:  BRA    3E96
03E8E:  MOVLW  20
03E90:  BRA    3E98
03E92:  MOVLB  C
03E94:  CLRF   x11
03E96:  MOVLW  30
03E98:  ADDWF  00,F
03E9A:  MOVF   00,W
03E9C:  MOVLB  E
03E9E:  BTFSS  x37.4
03EA0:  BRA    3E9E
03EA2:  MOVWF  xDD
03EA4:  MOVLB  C
03EA6:  BCF    FD8.1
03EA8:  MOVFF  C18,C1C
03EAC:  MOVFF  C17,C1B
03EB0:  MOVFF  C16,C1A
03EB4:  MOVFF  C15,C19
03EB8:  CLRF   x20
03EBA:  CLRF   x1F
03EBC:  CLRF   x1E
03EBE:  MOVLW  0A
03EC0:  MOVWF  x1D
03EC2:  MOVLB  0
03EC4:  RCALL  3D8C
03EC6:  MOVFF  03,C18
03ECA:  MOVFF  02,C17
03ECE:  MOVFF  01,C16
03ED2:  MOVFF  00,C15
03ED6:  MOVLB  C
03ED8:  DECFSZ x13,F
03EDA:  BRA    3E38
03EDC:  MOVLB  0
03EDE:  RETURN 0
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VM_PIN_CONFIG_H_ 
.................... #define _VM_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // RS485 Communication Pin Mapping. 
.................... #define PIN_RS485_XMIT              PIN_E0 
.................... #define PIN_RS485_RCV               PIN_E1 
.................... #define PIN_RS485_RTS               PIN_G0			 
....................  
.................... // GPSR Communication PIN Mapping; SIM900/SIM800/Quectel. 
.................... #define PIN_GPRS_COMM_XMIT          PIN_G1 
.................... #define PIN_GPRS_COMM_RCV           PIN_G2 
....................  
.................... // UART -><- UART(IBU) Communication PIN Mapping. 
.................... #define PIN_IBU_RCV                 PIN_C7 
.................... #define PIN_IBU_XMIT                PIN_C6 
....................  
.................... // Extra UART PIN Mapping.(For Spare Purpose) 
.................... #define PIN_EXT_UART_XMIT           PIN_C0 
.................... #define PIN_EXT_UART_RCV            PIN_C1 
....................  
.................... // Digital Input(DI) PIN Mapping. 
.................... #define PIN_INPUT_DI_00             PIN_C2 
.................... #define PIN_INPUT_DI_01             PIN_C3 
....................  
.................... // Digital Output PIN Mapping. 
.................... #define PIN_OUT_DO_00               PIN_E5 
.................... #define PIN_OUT_DO_01               PIN_E4 
....................  
.................... // Spare Serial Clock and Serial Data PIN Mapping. 
.................... #define PIN_MCU1_SCLK               PIN_D6 
.................... #define PIN_MCU1_SDA                PIN_D5 
....................    
....................  
.................... #endif /* _VM_PIN_CONFIG_H_ */ 
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
....................  
.................... //********* CPU Settings ******************************************* 
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
01770:  MOVLW  0C
01772:  MOVWF  FEA
01774:  MOVLW  15
01776:  MOVWF  FE9
01778:  MOVF   FEF,W
0177A:  BZ    179E
0177C:  MOVLW  06
0177E:  MOVWF  01
01780:  MOVLW  BF
01782:  MOVWF  00
01784:  CLRWDT
01786:  DECFSZ 00,F
01788:  BRA    1784
0178A:  DECFSZ 01,F
0178C:  BRA    1780
0178E:  MOVLW  7A
01790:  MOVWF  00
01792:  DECFSZ 00,F
01794:  BRA    1792
01796:  BRA    1798
01798:  CLRWDT
0179A:  DECFSZ FEF,F
0179C:  BRA    177C
0179E:  RETURN 0
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ############### Using UART3 -> Configure for RS485 ########################## 
.................... #PIN_SELECT U3RX=PIN_E1 
.................... #PIN_SELECT U3TX=PIN_E0 
.................... #use rs232(baud=38400,UART3,stream=RS485,ERRORS) 
*
00418:  MOVLB  E
0041A:  BTFSS  x37.1
0041C:  BRA    041A
0041E:  MOVFF  EEE,2F
00422:  MOVFF  EEA,01
00426:  BTFSS  2F.1
00428:  BRA    042E
0042A:  BCF    xEE.4
0042C:  BSF    xEE.4
0042E:  MOVLB  0
00430:  RETURN 0
*
017A0:  MOVLB  E
017A2:  BTFSS  x37.0
017A4:  BRA    17A2
017A6:  MOVWF  xEB
017A8:  MOVLB  0
017AA:  RETURN 0
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
*
001AE:  MOVLB  E
001B0:  BTFSS  x36.5
001B2:  BRA    01B0
001B4:  MOVFF  F9C,2F
001B8:  MOVFF  F98,01
001BC:  BTFSS  2F.1
001BE:  BRA    01C4
001C0:  BCF    F9C.4
001C2:  BSF    F9C.4
001C4:  MOVLB  0
001C6:  GOTO   0208 (RETURN)
*
00DB2:  MOVLB  E
00DB4:  BTFSS  x36.4
00DB6:  BRA    0DB4
00DB8:  MOVWF  F99
00DBA:  MOVLB  0
00DBC:  RETURN 0
....................  
.................... //// ############### Using UART2 -> Configure for GPRS Module;EC20 ############### 
.................... //#PIN_SELECT U2RX=PIN_G2 
.................... //#PIN_SELECT U2TX=PIN_G1 
.................... //#use rs232(baud=115200,UART2,stream=GSM_M66,ERRORS) 
....................  
.................... // ################# Using UART2 -> Configure for LAN Module; USR_K3 ########### 
.................... #PIN_SELECT U5RX=PIN_E3 
.................... #PIN_SELECT U5TX=PIN_E2 
.................... #use rs232(baud=115200,UART5,stream=LAN_USR,ERRORS) 
*
00356:  MOVLB  E
00358:  BTFSS  x37.5
0035A:  BRA    0358
0035C:  MOVFF  EE0,2F
00360:  MOVFF  EDC,01
00364:  BTFSS  2F.1
00366:  BRA    036C
00368:  BCF    xE0.4
0036A:  BSF    xE0.4
0036C:  MOVLB  0
0036E:  GOTO   0390 (RETURN)
....................  
.................... #pragma priority INT_RDA,INT_RDA5,INT_RDA3 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                          time.c                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
*
01F22:  MOVLB  C
01F24:  CLRF   x12
.................... { 
....................     unsigned int8 ui8ReturnValue = 0; 
....................     switch(month) 
01F26:  MOVF   x10,W
01F28:  XORLW  00
01F2A:  MOVLB  0
01F2C:  BZ    1F5C
01F2E:  XORLW  02
01F30:  BZ    1F5C
01F32:  XORLW  06
01F34:  BZ    1F5C
01F36:  XORLW  02
01F38:  BZ    1F5C
01F3A:  XORLW  01
01F3C:  BZ    1F5C
01F3E:  XORLW  0E
01F40:  BZ    1F5C
01F42:  XORLW  02
01F44:  BZ    1F5C
01F46:  XORLW  0A
01F48:  BZ    1F64
01F4A:  XORLW  02
01F4C:  BZ    1F76
01F4E:  XORLW  06
01F50:  BZ    1F76
01F52:  XORLW  0D
01F54:  BZ    1F76
01F56:  XORLW  02
01F58:  BZ    1F76
01F5A:  BRA    1F80
....................     { 
....................        case JANUARY: 
....................        case MARCH: 
....................        case MAY: 
....................        case JULY: 
....................        case AUGUST: 
....................        case OCTOBER: 
....................        case DECEMBER: 
....................            ui8ReturnValue = 31; 
01F5C:  MOVLW  1F
01F5E:  MOVLB  C
01F60:  MOVWF  x12
....................            break; 
01F62:  BRA    1F82
....................        case FEBRUARY: 
....................             if(IsLeapYear) 
01F64:  MOVLB  C
01F66:  MOVF   x11,F
01F68:  BZ    1F70
....................             { 
....................                 ui8ReturnValue = 29; 
01F6A:  MOVLW  1D
01F6C:  MOVWF  x12
....................             } 
01F6E:  BRA    1F74
....................             else 
....................             { 
....................                 ui8ReturnValue = 28; 
01F70:  MOVLW  1C
01F72:  MOVWF  x12
....................             } 
....................             break; 
01F74:  BRA    1F82
....................        case APRIL: 
....................        case JUNE: 
....................        case SEPTEMBER: 
....................        case NOVEMBER: 
....................           ui8ReturnValue = 30; 
01F76:  MOVLW  1E
01F78:  MOVLB  C
01F7A:  MOVWF  x12
....................           break; 
01F7C:  BRA    1F82
01F7E:  MOVLB  0
....................        // error 
....................        default: 
....................            break; 
01F80:  MOVLB  C
....................     } 
....................      
....................     return ui8ReturnValue; 
01F82:  MOVFF  C12,01
01F86:  MOVLB  0
01F88:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... int1 LeapYear(unsigned int16 year) 
.................... { 
....................     if( ((year + 1900) % 400 == 0) ||  
....................         (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
01E7C:  MOVLW  6C
01E7E:  MOVLB  C
01E80:  ADDWF  x0D,W
01E82:  MOVWF  x0F
01E84:  MOVLW  07
01E86:  ADDWFC x0E,W
01E88:  MOVWF  x10
01E8A:  CLRF   19
01E8C:  BTFSC  FF2.7
01E8E:  BSF    19.7
01E90:  BCF    FF2.7
01E92:  MOVWF  x28
01E94:  MOVFF  C0F,C27
01E98:  MOVLW  01
01E9A:  MOVWF  x2A
01E9C:  MOVLW  90
01E9E:  MOVWF  x29
01EA0:  MOVLB  0
01EA2:  CALL   0454
01EA6:  BTFSC  19.7
01EA8:  BSF    FF2.7
01EAA:  MOVFF  00,C0F
01EAE:  MOVLB  C
01EB0:  MOVFF  03,C10
01EB4:  MOVF   x0F,F
01EB6:  BNZ   1EBC
01EB8:  MOVF   x10,F
01EBA:  BZ    1F12
01EBC:  MOVLW  6C
01EBE:  ADDWF  x0D,W
01EC0:  MOVWF  x0F
01EC2:  MOVLW  07
01EC4:  ADDWFC x0E,W
01EC6:  MOVWF  x10
01EC8:  MOVLW  03
01ECA:  ANDWF  x0F,F
01ECC:  CLRF   x10
01ECE:  MOVF   x0F,F
01ED0:  BNZ   1F1A
01ED2:  MOVF   x10,F
01ED4:  BNZ   1F1A
01ED6:  MOVLW  6C
01ED8:  ADDWF  x0D,W
01EDA:  MOVWF  x0F
01EDC:  MOVLW  07
01EDE:  ADDWFC x0E,W
01EE0:  MOVWF  x10
01EE2:  CLRF   19
01EE4:  BTFSC  FF2.7
01EE6:  BSF    19.7
01EE8:  BCF    FF2.7
01EEA:  MOVWF  x28
01EEC:  MOVFF  C0F,C27
01EF0:  CLRF   x2A
01EF2:  MOVLW  64
01EF4:  MOVWF  x29
01EF6:  MOVLB  0
01EF8:  CALL   0454
01EFC:  BTFSC  19.7
01EFE:  BSF    FF2.7
01F00:  MOVFF  00,C0F
01F04:  MOVLB  C
01F06:  MOVFF  03,C10
01F0A:  MOVF   x0F,F
01F0C:  BNZ   1F12
01F0E:  MOVF   x10,F
01F10:  BZ    1F1A
....................     { 
....................        return TRUE; 
01F12:  MOVLW  01
01F14:  MOVWF  01
01F16:  BRA    1F1E
....................     } 
01F18:  BRA    1F1E
....................     else 
....................     { 
....................         return FALSE; 
01F1A:  MOVLW  00
01F1C:  MOVWF  01
....................     } 
01F1E:  MOVLB  0
01F20:  RETURN 0
.................... } 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT) 
*
02074:  MOVLB  C
02076:  CLRF   x07
02078:  CLRF   x06
0207A:  CLRF   x05
0207C:  CLRF   x04
0207E:  BCF    x08.0
02080:  CLRF   x0A
02082:  CLRF   x09
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
02084:  MOVF   x02,F
02086:  BNZ   208E
02088:  MOVF   x03,F
0208A:  BTFSC  FD8.2
0208C:  BRA    255A
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
0208E:  MOVFF  C02,FE9
02092:  MOVFF  C03,FEA
02096:  MOVF   FEF,W
02098:  ADDWF  x04,F
0209A:  MOVLW  00
0209C:  ADDWFC x05,F
0209E:  ADDWFC x06,F
020A0:  ADDWFC x07,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
020A2:  MOVLW  01
020A4:  ADDWF  x02,W
020A6:  MOVWF  FE9
020A8:  MOVLW  00
020AA:  ADDWFC x03,W
020AC:  MOVWF  FEA
020AE:  MOVF   FEF,W
020B0:  CLRF   x0E
020B2:  CLRF   x0D
020B4:  CLRF   x0C
020B6:  MOVWF  x0B
020B8:  MOVFF  FEA,C10
020BC:  MOVFF  FE9,C0F
020C0:  MOVFF  C0E,C14
020C4:  MOVFF  C0D,C13
020C8:  MOVFF  C0C,C12
020CC:  MOVWF  x11
020CE:  CLRF   x18
020D0:  CLRF   x17
020D2:  CLRF   x16
020D4:  MOVLW  3C
020D6:  MOVWF  x15
020D8:  MOVLB  0
020DA:  RCALL  1E20
020DC:  MOVFF  C10,FEA
020E0:  MOVFF  C0F,FE9
020E4:  MOVF   00,W
020E6:  MOVLB  C
020E8:  ADDWF  x04,F
020EA:  MOVF   01,W
020EC:  ADDWFC x05,F
020EE:  MOVF   02,W
020F0:  ADDWFC x06,F
020F2:  MOVF   03,W
020F4:  ADDWFC x07,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
020F6:  MOVLW  02
020F8:  ADDWF  x02,W
020FA:  MOVWF  FE9
020FC:  MOVLW  00
020FE:  ADDWFC x03,W
02100:  MOVWF  FEA
02102:  MOVF   FEF,W
02104:  CLRF   x0E
02106:  CLRF   x0D
02108:  CLRF   x0C
0210A:  MOVWF  x0B
0210C:  MOVFF  FEA,C10
02110:  MOVFF  FE9,C0F
02114:  MOVFF  C0E,C14
02118:  MOVFF  C0D,C13
0211C:  MOVFF  C0C,C12
02120:  MOVWF  x11
02122:  CLRF   x18
02124:  CLRF   x17
02126:  MOVLW  0E
02128:  MOVWF  x16
0212A:  MOVLW  10
0212C:  MOVWF  x15
0212E:  MOVLB  0
02130:  RCALL  1E20
02132:  MOVFF  C10,FEA
02136:  MOVFF  C0F,FE9
0213A:  MOVF   00,W
0213C:  MOVLB  C
0213E:  ADDWF  x04,F
02140:  MOVF   01,W
02142:  ADDWFC x05,F
02144:  MOVF   02,W
02146:  ADDWFC x06,F
02148:  MOVF   03,W
0214A:  ADDWFC x07,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
0214C:  MOVLW  05
0214E:  ADDWF  x02,W
02150:  MOVWF  FE9
02152:  MOVLW  00
02154:  ADDWFC x03,W
02156:  MOVWF  FEA
02158:  MOVFF  FEC,C0E
0215C:  MOVF   FED,F
0215E:  MOVFF  FEF,C0D
02162:  MOVLB  0
02164:  RCALL  1E7C
02166:  MOVLB  C
02168:  BCF    x08.0
0216A:  BTFSC  01.0
0216C:  BSF    x08.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
0216E:  MOVLW  04
02170:  ADDWF  x02,W
02172:  MOVWF  FE9
02174:  MOVLW  00
02176:  ADDWFC x03,W
02178:  MOVWF  FEA
0217A:  CLRF   19
0217C:  BTFSC  FF2.7
0217E:  BSF    19.7
02180:  BCF    FF2.7
02182:  MOVFF  FEF,C2F
02186:  MOVLW  0C
02188:  MOVWF  x30
0218A:  MOVLB  0
0218C:  CALL   0182
02190:  BTFSC  19.7
02192:  BSF    FF2.7
02194:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
02198:  MOVLB  C
0219A:  CLRF   x0A
0219C:  MOVLW  01
0219E:  MOVWF  x09
021A0:  MOVLW  04
021A2:  ADDWF  x02,W
021A4:  MOVWF  FE9
021A6:  MOVLW  00
021A8:  ADDWFC x03,W
021AA:  MOVWF  FEA
021AC:  MOVF   FEF,W
021AE:  MOVF   x0A,F
021B0:  BNZ   221E
021B2:  SUBWF  x09,W
021B4:  BZ    21B8
021B6:  BC    221E
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
021B8:  MOVLW  01
021BA:  SUBWF  x09,W
021BC:  MOVWF  x0B
021BE:  MOVLW  00
021C0:  SUBWFB x0A,W
021C2:  MOVWF  x0C
021C4:  MOVLW  00
021C6:  BTFSC  x08.0
021C8:  MOVLW  01
021CA:  MOVWF  x0D
021CC:  MOVFF  C0B,C10
021D0:  MOVWF  x11
021D2:  MOVLB  0
021D4:  RCALL  1F22
021D6:  MOVFF  FEA,C0D
021DA:  MOVFF  FE9,C0C
021DE:  MOVLB  C
021E0:  CLRF   x14
021E2:  CLRF   x13
021E4:  CLRF   x12
021E6:  MOVFF  01,C11
021EA:  CLRF   x18
021EC:  MOVLW  01
021EE:  MOVWF  x17
021F0:  MOVLW  51
021F2:  MOVWF  x16
021F4:  MOVLW  80
021F6:  MOVWF  x15
021F8:  MOVLB  0
021FA:  RCALL  1E20
021FC:  MOVFF  C0D,FEA
02200:  MOVFF  C0C,FE9
02204:  MOVF   00,W
02206:  MOVLB  C
02208:  ADDWF  x04,F
0220A:  MOVF   01,W
0220C:  ADDWFC x05,F
0220E:  MOVF   02,W
02210:  ADDWFC x06,F
02212:  MOVF   03,W
02214:  ADDWFC x07,F
02216:  INCF   x09,F
02218:  BTFSC  FD8.2
0221A:  INCF   x0A,F
0221C:  BRA    21A0
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
0221E:  MOVLW  03
02220:  ADDWF  x02,W
02222:  MOVWF  01
02224:  MOVLW  00
02226:  ADDWFC x03,W
02228:  MOVWF  03
0222A:  MOVFF  01,C0B
0222E:  MOVWF  x0C
02230:  MOVWF  FEA
02232:  MOVFF  01,FE9
02236:  MOVFF  FEF,C0D
0223A:  MOVLW  04
0223C:  ADDWF  x02,W
0223E:  MOVWF  FE9
02240:  MOVLW  00
02242:  ADDWFC x03,W
02244:  MOVWF  FEA
02246:  MOVFF  FEF,C10
0224A:  MOVLW  00
0224C:  BTFSC  x08.0
0224E:  MOVLW  01
02250:  MOVWF  x0F
02252:  MOVWF  x11
02254:  MOVLB  0
02256:  RCALL  1F22
02258:  CLRF   19
0225A:  BTFSC  FF2.7
0225C:  BSF    19.7
0225E:  BCF    FF2.7
02260:  MOVFF  C0D,C2F
02264:  MOVFF  01,C30
02268:  CALL   0182
0226C:  BTFSC  19.7
0226E:  BSF    FF2.7
02270:  MOVLB  C
02272:  MOVFF  C0C,FEA
02276:  MOVFF  C0B,FE9
0227A:  MOVFF  00,FEF
....................       unixTime += (timeT->tm_mday) * 86400; 
0227E:  MOVLW  03
02280:  ADDWF  x02,W
02282:  MOVWF  FE9
02284:  MOVLW  00
02286:  ADDWFC x03,W
02288:  MOVWF  FEA
0228A:  MOVFF  FEA,C0D
0228E:  MOVFF  FE9,C0C
02292:  CLRF   x14
02294:  CLRF   x13
02296:  CLRF   x12
02298:  MOVFF  FEF,C11
0229C:  CLRF   x18
0229E:  MOVLW  01
022A0:  MOVWF  x17
022A2:  MOVLW  51
022A4:  MOVWF  x16
022A6:  MOVLW  80
022A8:  MOVWF  x15
022AA:  MOVLB  0
022AC:  RCALL  1E20
022AE:  MOVFF  C0D,FEA
022B2:  MOVFF  C0C,FE9
022B6:  MOVF   00,W
022B8:  MOVLB  C
022BA:  ADDWF  x04,F
022BC:  MOVF   01,W
022BE:  ADDWFC x05,F
022C0:  MOVF   02,W
022C2:  ADDWFC x06,F
022C4:  MOVF   03,W
022C6:  ADDWFC x07,F
....................        
....................       if(isLeapYear) 
022C8:  BTFSS  x08.0
022CA:  BRA    2374
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
022CC:  MOVLW  08
022CE:  ADDWF  x02,W
022D0:  MOVWF  01
022D2:  MOVLW  00
022D4:  ADDWFC x03,W
022D6:  MOVWF  03
022D8:  MOVFF  01,C0B
022DC:  MOVWF  x0C
022DE:  MOVFF  FEA,C0E
022E2:  MOVFF  FE9,C0D
022E6:  BCF    FD8.1
022E8:  MOVFF  C07,C1C
022EC:  MOVFF  C06,C1B
022F0:  MOVFF  C05,C1A
022F4:  MOVFF  C04,C19
022F8:  CLRF   x20
022FA:  MOVLW  01
022FC:  MOVWF  x1F
022FE:  MOVLW  51
02300:  MOVWF  x1E
02302:  MOVLW  80
02304:  MOVWF  x1D
02306:  MOVLB  0
02308:  RCALL  1F8A
0230A:  MOVFF  C0E,FEA
0230E:  MOVFF  C0D,FE9
02312:  MOVFF  03,C12
02316:  MOVFF  02,C11
0231A:  MOVFF  01,C10
0231E:  MOVFF  00,C0F
02322:  BSF    FD8.1
02324:  MOVLW  0C
02326:  MOVWF  FEA
02328:  MOVLW  15
0232A:  MOVWF  FE9
0232C:  MOVFF  03,C1C
02330:  MOVFF  02,C1B
02334:  MOVFF  01,C1A
02338:  MOVFF  00,C19
0233C:  MOVLB  C
0233E:  CLRF   x20
02340:  CLRF   x1F
02342:  MOVLW  01
02344:  MOVWF  x1E
02346:  MOVLW  6E
02348:  MOVWF  x1D
0234A:  MOVLB  0
0234C:  RCALL  1F8A
0234E:  MOVFF  C15,00
02352:  MOVFF  C16,01
02356:  MOVFF  C17,02
0235A:  MOVFF  C18,03
0235E:  MOVFF  C0C,FEA
02362:  MOVFF  C0B,FE9
02366:  MOVFF  01,FEC
0236A:  MOVF   FED,F
0236C:  MOVFF  00,FEF
....................       } 
02370:  BRA    2418
02372:  MOVLB  C
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
02374:  MOVLW  08
02376:  ADDWF  x02,W
02378:  MOVWF  01
0237A:  MOVLW  00
0237C:  ADDWFC x03,W
0237E:  MOVWF  03
02380:  MOVFF  01,C0B
02384:  MOVWF  x0C
02386:  MOVFF  FEA,C0E
0238A:  MOVFF  FE9,C0D
0238E:  BCF    FD8.1
02390:  MOVFF  C07,C1C
02394:  MOVFF  C06,C1B
02398:  MOVFF  C05,C1A
0239C:  MOVFF  C04,C19
023A0:  CLRF   x20
023A2:  MOVLW  01
023A4:  MOVWF  x1F
023A6:  MOVLW  51
023A8:  MOVWF  x1E
023AA:  MOVLW  80
023AC:  MOVWF  x1D
023AE:  MOVLB  0
023B0:  RCALL  1F8A
023B2:  MOVFF  C0E,FEA
023B6:  MOVFF  C0D,FE9
023BA:  MOVFF  03,C12
023BE:  MOVFF  02,C11
023C2:  MOVFF  01,C10
023C6:  MOVFF  00,C0F
023CA:  BSF    FD8.1
023CC:  MOVLW  0C
023CE:  MOVWF  FEA
023D0:  MOVLW  15
023D2:  MOVWF  FE9
023D4:  MOVFF  03,C1C
023D8:  MOVFF  02,C1B
023DC:  MOVFF  01,C1A
023E0:  MOVFF  00,C19
023E4:  MOVLB  C
023E6:  CLRF   x20
023E8:  CLRF   x1F
023EA:  MOVLW  01
023EC:  MOVWF  x1E
023EE:  MOVLW  6D
023F0:  MOVWF  x1D
023F2:  MOVLB  0
023F4:  RCALL  1F8A
023F6:  MOVFF  C15,00
023FA:  MOVFF  C16,01
023FE:  MOVFF  C17,02
02402:  MOVFF  C18,03
02406:  MOVFF  C0C,FEA
0240A:  MOVFF  C0B,FE9
0240E:  MOVFF  01,FEC
02412:  MOVF   FED,F
02414:  MOVFF  00,FEF
....................       } 
....................        
....................       i = 1970;  // Change done by Amit, initially it was i = 70; 
02418:  MOVLW  07
0241A:  MOVLB  C
0241C:  MOVWF  x0A
0241E:  MOVLW  B2
02420:  MOVWF  x09
....................       if(timeT->tm_year - 1970 >= 0) 
02422:  MOVLW  05
02424:  ADDWF  x02,W
02426:  MOVWF  FE9
02428:  MOVLW  00
0242A:  ADDWFC x03,W
0242C:  MOVWF  FEA
0242E:  MOVFF  FEC,C0C
02432:  MOVF   FED,F
02434:  MOVFF  FEF,C0B
02438:  MOVLW  B2
0243A:  SUBWF  x0B,F
0243C:  MOVLW  07
0243E:  SUBWFB x0C,F
....................       { 
....................          while(i < (timeT->tm_year)) 
02440:  MOVLW  05
02442:  ADDWF  x02,W
02444:  MOVWF  FE9
02446:  MOVLW  00
02448:  ADDWFC x03,W
0244A:  MOVWF  FEA
0244C:  MOVFF  FEC,03
02450:  MOVF   FED,F
02452:  MOVFF  FEF,01
02456:  MOVF   x0A,W
02458:  SUBWF  03,W
0245A:  BNC   24A2
0245C:  BNZ   2464
0245E:  MOVF   01,W
02460:  SUBWF  x09,W
02462:  BC    24A2
....................          { 
....................             isLeapYear = LeapYear(i); 
02464:  MOVFF  C0A,C0E
02468:  MOVFF  C09,C0D
0246C:  MOVLB  0
0246E:  RCALL  1E7C
02470:  MOVLB  C
02472:  BCF    x08.0
02474:  BTFSC  01.0
02476:  BSF    x08.0
....................             if(isLeapYear) 
02478:  BTFSS  x08.0
0247A:  BRA    248A
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
0247C:  MOVLW  85
0247E:  ADDWF  x05,F
02480:  MOVLW  E2
02482:  ADDWFC x06,F
02484:  MOVLW  01
02486:  ADDWFC x07,F
....................             } 
02488:  BRA    249A
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
0248A:  MOVLW  80
0248C:  ADDWF  x04,F
0248E:  MOVLW  33
02490:  ADDWFC x05,F
02492:  MOVLW  E1
02494:  ADDWFC x06,F
02496:  MOVLW  01
02498:  ADDWFC x07,F
....................             } 
....................             i++; 
0249A:  INCF   x09,F
0249C:  BTFSC  FD8.2
0249E:  INCF   x0A,F
024A0:  BRA    2440
....................          } 
....................       } 
....................       // To match GMT to IST we have to adjust 5hrs 30 mints.. 
....................       unixTime = unixTime - 19800;  // 19800 is the  
024A2:  MOVLW  58
024A4:  SUBWF  x04,F
024A6:  MOVLW  4D
024A8:  SUBWFB x05,F
024AA:  MOVLW  00
024AC:  SUBWFB x06,F
024AE:  SUBWFB x07,F
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
024B0:  MOVLW  07
024B2:  ADDWF  x02,W
024B4:  MOVWF  01
024B6:  MOVLW  00
024B8:  ADDWFC x03,W
024BA:  MOVWF  03
024BC:  MOVFF  01,C0B
024C0:  MOVWF  x0C
024C2:  MOVFF  FEA,C0E
024C6:  MOVFF  FE9,C0D
024CA:  BCF    FD8.1
024CC:  MOVFF  C07,C1C
024D0:  MOVFF  C06,C1B
024D4:  MOVFF  C05,C1A
024D8:  MOVFF  C04,C19
024DC:  CLRF   x20
024DE:  MOVLW  01
024E0:  MOVWF  x1F
024E2:  MOVLW  51
024E4:  MOVWF  x1E
024E6:  MOVLW  80
024E8:  MOVWF  x1D
024EA:  MOVLB  0
024EC:  RCALL  1F8A
024EE:  MOVFF  C0E,FEA
024F2:  MOVFF  C0D,FE9
024F6:  MOVFF  03,C12
024FA:  MOVFF  02,C11
024FE:  MOVFF  01,C10
02502:  MOVFF  00,C0F
02506:  MOVLW  04
02508:  MOVLB  C
0250A:  ADDWF  x0F,F
0250C:  MOVLW  00
0250E:  ADDWFC x10,F
02510:  ADDWFC x11,F
02512:  ADDWFC x12,F
02514:  BSF    FD8.1
02516:  MOVLW  0C
02518:  MOVWF  FEA
0251A:  MOVLW  15
0251C:  MOVWF  FE9
0251E:  MOVFF  C12,C1C
02522:  MOVFF  C11,C1B
02526:  MOVFF  C10,C1A
0252A:  MOVFF  C0F,C19
0252E:  CLRF   x20
02530:  CLRF   x1F
02532:  CLRF   x1E
02534:  MOVLW  07
02536:  MOVWF  x1D
02538:  MOVLB  0
0253A:  RCALL  1F8A
0253C:  MOVFF  C15,00
02540:  MOVFF  C16,01
02544:  MOVFF  C17,02
02548:  MOVFF  C18,03
0254C:  MOVFF  C0C,FEA
02550:  MOVFF  C0B,FE9
02554:  MOVFF  00,FEF
02558:  MOVLB  C
....................    } 
....................  
....................    return unixTime; 
0255A:  MOVFF  C04,00
0255E:  MOVFF  C05,01
02562:  MOVFF  C06,02
02566:  MOVFF  C07,03
0256A:  MOVLB  0
0256C:  GOTO   382C (RETURN)
.................... } 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime ( struct_tm * timeptr, char * szTime) 
.................... { 
....................    char szDay[8]; 
....................    char szMon[8]; 
....................     
....................    WeekdayAbbreviations(timeptr->tm_wday, szDay); 
....................    MonthAbbreviations(timeptr->tm_mon, szMon); 
....................     
....................    sprintf(szTime,"%s %s %d %02d:%02d:%02d %04Lu", 
....................       szDay, 
....................       szMon, 
....................       timeptr->tm_mday + 1, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + 1900)); 
....................        
....................    return szTime; 
.................... } 
....................  
.................... /* Converts the given calendar time (in seconds) to local time  
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime ( time_t * timer, char *szTime ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime(time_t * timer) 
02570:  MOVLB  C
02572:  BCF    x08.0
02574:  BCF    x08.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;//1970 is not a leap year 
....................  
....................    if(timer != NULL) 
02576:  MOVF   x02,F
02578:  BNZ   2580
0257A:  MOVF   x03,F
0257C:  BTFSC  FD8.2
0257E:  BRA    2960
....................    { 
....................       timeCounter = *timer; 
02580:  MOVFF  C03,03
02584:  MOVFF  C02,FE9
02588:  MOVFF  03,FEA
0258C:  MOVFF  FEF,C04
02590:  MOVFF  FEC,C05
02594:  MOVFF  FEC,C06
02598:  MOVFF  FEC,C07
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
0259C:  BCF    FD8.1
0259E:  MOVFF  C07,C1C
025A2:  MOVFF  C06,C1B
025A6:  MOVFF  C05,C1A
025AA:  MOVFF  C04,C19
025AE:  CLRF   x20
025B0:  MOVLW  01
025B2:  MOVWF  x1F
025B4:  MOVLW  51
025B6:  MOVWF  x1E
025B8:  MOVLW  80
025BA:  MOVWF  x1D
025BC:  MOVLB  0
025BE:  RCALL  1F8A
025C0:  MOVFF  03,C0C
025C4:  MOVFF  02,C0B
025C8:  MOVFF  01,C0A
025CC:  MOVFF  00,C09
025D0:  MOVLW  04
025D2:  MOVLB  C
025D4:  ADDWF  x09,F
025D6:  MOVLW  00
025D8:  ADDWFC x0A,F
025DA:  ADDWFC x0B,F
025DC:  ADDWFC x0C,F
025DE:  BSF    FD8.1
025E0:  MOVLW  0C
025E2:  MOVWF  FEA
025E4:  MOVLW  0D
025E6:  MOVWF  FE9
025E8:  MOVFF  C0C,C1C
025EC:  MOVFF  C0B,C1B
025F0:  MOVFF  C0A,C1A
025F4:  MOVFF  C09,C19
025F8:  CLRF   x20
025FA:  CLRF   x1F
025FC:  CLRF   x1E
025FE:  MOVLW  07
02600:  MOVWF  x1D
02602:  MOVLB  0
02604:  RCALL  1F8A
02606:  MOVFF  C0D,3B
0260A:  MOVFF  C0E,01
0260E:  MOVFF  C0F,02
02612:  MOVFF  C10,03
....................       g_lTime.tm_year = 70;//we are starting in 1970 
02616:  CLRF   3A
02618:  MOVLW  46
0261A:  MOVWF  39
....................        
....................       while(!done) 
0261C:  MOVLB  C
0261E:  BTFSC  x08.0
02620:  BRA    2708
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
02622:  BTFSC  x07.7
02624:  BRA    263C
02626:  MOVF   x07,W
02628:  SUBLW  01
0262A:  BNC   2672
0262C:  BNZ   263C
0262E:  MOVF   x06,W
02630:  SUBLW  E2
02632:  BNC   2672
02634:  BNZ   263C
02636:  MOVF   x05,W
02638:  SUBLW  84
0263A:  BNC   2672
0263C:  BTFSS  x08.1
0263E:  BRA    2672
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02640:  BCF    FD8.1
02642:  MOVFF  C07,C1C
02646:  MOVFF  C06,C1B
0264A:  MOVFF  C05,C1A
0264E:  MOVFF  C04,C19
02652:  CLRF   x20
02654:  MOVLW  01
02656:  MOVWF  x1F
02658:  MOVLW  51
0265A:  MOVWF  x1E
0265C:  MOVLW  80
0265E:  MOVWF  x1D
02660:  MOVLB  0
02662:  RCALL  1F8A
02664:  MOVFF  01,3D
02668:  MOVFF  00,3C
....................             break; 
0266C:  MOVLB  C
0266E:  BRA    2708
....................          } 
02670:  BRA    26C4
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
02672:  BTFSC  x07.7
02674:  BRA    2694
02676:  MOVF   x07,W
02678:  SUBLW  01
0267A:  BNC   26C4
0267C:  BNZ   2694
0267E:  MOVF   x06,W
02680:  SUBLW  E1
02682:  BNC   26C4
02684:  BNZ   2694
02686:  MOVF   x05,W
02688:  SUBLW  33
0268A:  BNC   26C4
0268C:  BNZ   2694
0268E:  MOVF   x04,W
02690:  SUBLW  7F
02692:  BNC   26C4
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02694:  BCF    FD8.1
02696:  MOVFF  C07,C1C
0269A:  MOVFF  C06,C1B
0269E:  MOVFF  C05,C1A
026A2:  MOVFF  C04,C19
026A6:  CLRF   x20
026A8:  MOVLW  01
026AA:  MOVWF  x1F
026AC:  MOVLW  51
026AE:  MOVWF  x1E
026B0:  MOVLW  80
026B2:  MOVWF  x1D
026B4:  MOVLB  0
026B6:  RCALL  1F8A
026B8:  MOVFF  01,3D
026BC:  MOVFF  00,3C
....................             break; 
026C0:  MOVLB  C
026C2:  BRA    2708
....................          } 
....................           
....................          if(isLeapYear) 
026C4:  BTFSS  x08.1
026C6:  BRA    26DA
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
026C8:  MOVLW  00
026CA:  SUBWF  x04,F
026CC:  MOVLW  85
026CE:  SUBWFB x05,F
026D0:  MOVLW  E2
026D2:  SUBWFB x06,F
026D4:  MOVLW  01
026D6:  SUBWFB x07,F
....................          } 
026D8:  BRA    26EA
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
026DA:  MOVLW  80
026DC:  SUBWF  x04,F
026DE:  MOVLW  33
026E0:  SUBWFB x05,F
026E2:  MOVLW  E1
026E4:  SUBWFB x06,F
026E6:  MOVLW  01
026E8:  SUBWFB x07,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
026EA:  INCF   39,F
026EC:  BTFSC  FD8.2
026EE:  INCF   3A,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
026F0:  MOVFF  3A,C0E
026F4:  MOVFF  39,C0D
026F8:  MOVLB  0
026FA:  CALL   1E7C
026FE:  MOVLB  C
02700:  BCF    x08.1
02702:  BTFSC  01.0
02704:  BSF    x08.1
02706:  BRA    261E
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
02708:  CLRF   38
....................       while(!done) 
0270A:  BTFSC  x08.0
0270C:  BRA    283A
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
0270E:  MOVLW  00
02710:  BTFSC  x08.1
02712:  MOVLW  01
02714:  MOVWF  x09
02716:  MOVFF  38,C10
0271A:  MOVWF  x11
0271C:  MOVLB  0
0271E:  RCALL  1F22
02720:  MOVFF  FEA,C0B
02724:  MOVFF  FE9,C0A
02728:  MOVLB  C
0272A:  CLRF   x14
0272C:  CLRF   x13
0272E:  CLRF   x12
02730:  MOVFF  01,C11
02734:  CLRF   x18
02736:  MOVLW  01
02738:  MOVWF  x17
0273A:  MOVLW  51
0273C:  MOVWF  x16
0273E:  MOVLW  80
02740:  MOVWF  x15
02742:  MOVLB  0
02744:  CALL   1E20
02748:  MOVFF  C0B,FEA
0274C:  MOVFF  C0A,FE9
02750:  MOVLB  C
02752:  BTFSC  x07.7
02754:  BRA    2774
02756:  MOVF   x07,W
02758:  SUBWF  03,W
0275A:  BNC   2778
0275C:  BNZ   2774
0275E:  MOVF   x06,W
02760:  SUBWF  02,W
02762:  BNC   2778
02764:  BNZ   2774
02766:  MOVF   x05,W
02768:  SUBWF  01,W
0276A:  BNC   2778
0276C:  BNZ   2774
0276E:  MOVF   00,W
02770:  SUBWF  x04,W
02772:  BC    2778
....................          { 
....................             break; 
02774:  BRA    283A
....................          } 
02776:  BRA    2838
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
02778:  MOVLW  00
0277A:  BTFSC  x08.1
0277C:  MOVLW  01
0277E:  MOVWF  x09
02780:  MOVFF  38,C10
02784:  MOVWF  x11
02786:  MOVLB  0
02788:  CALL   1F22
0278C:  MOVFF  FEA,C0B
02790:  MOVFF  FE9,C0A
02794:  MOVLB  C
02796:  CLRF   x14
02798:  CLRF   x13
0279A:  CLRF   x12
0279C:  MOVFF  01,C11
027A0:  CLRF   x18
027A2:  MOVLW  01
027A4:  MOVWF  x17
027A6:  MOVLW  51
027A8:  MOVWF  x16
027AA:  MOVLW  80
027AC:  MOVWF  x15
027AE:  MOVLB  0
027B0:  CALL   1E20
027B4:  MOVFF  C0B,FEA
027B8:  MOVFF  C0A,FE9
027BC:  MOVLB  C
027BE:  BTFSC  x07.7
027C0:  BRA    2838
027C2:  MOVF   03,W
027C4:  SUBWF  x07,W
027C6:  BNC   2838
027C8:  BNZ   27E0
027CA:  MOVF   02,W
027CC:  SUBWF  x06,W
027CE:  BNC   2838
027D0:  BNZ   27E0
027D2:  MOVF   01,W
027D4:  SUBWF  x05,W
027D6:  BNC   2838
027D8:  BNZ   27E0
027DA:  MOVF   00,W
027DC:  SUBWF  x04,W
027DE:  BNC   2838
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
027E0:  MOVLW  00
027E2:  BTFSC  x08.1
027E4:  MOVLW  01
027E6:  MOVWF  x09
027E8:  MOVFF  38,C10
027EC:  MOVWF  x11
027EE:  MOVLB  0
027F0:  CALL   1F22
027F4:  MOVFF  FEA,C0B
027F8:  MOVFF  FE9,C0A
027FC:  MOVLB  C
027FE:  CLRF   x14
02800:  CLRF   x13
02802:  CLRF   x12
02804:  MOVFF  01,C11
02808:  CLRF   x18
0280A:  MOVLW  01
0280C:  MOVWF  x17
0280E:  MOVLW  51
02810:  MOVWF  x16
02812:  MOVLW  80
02814:  MOVWF  x15
02816:  MOVLB  0
02818:  CALL   1E20
0281C:  MOVFF  C0B,FEA
02820:  MOVFF  C0A,FE9
02824:  MOVF   00,W
02826:  MOVLB  C
02828:  SUBWF  x04,F
0282A:  MOVF   01,W
0282C:  SUBWFB x05,F
0282E:  MOVF   02,W
02830:  SUBWFB x06,F
02832:  MOVF   03,W
02834:  SUBWFB x07,F
....................             g_lTime.tm_mon++; 
02836:  INCF   38,F
....................          } 
02838:  BRA    270A
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
0283A:  BCF    FD8.1
0283C:  MOVFF  C07,C1C
02840:  MOVFF  C06,C1B
02844:  MOVFF  C05,C1A
02848:  MOVFF  C04,C19
0284C:  CLRF   x20
0284E:  MOVLW  01
02850:  MOVWF  x1F
02852:  MOVLW  51
02854:  MOVWF  x1E
02856:  MOVLW  80
02858:  MOVWF  x1D
0285A:  MOVLB  0
0285C:  CALL   1F8A
02860:  MOVFF  00,37
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
02864:  MOVLB  C
02866:  CLRF   x14
02868:  CLRF   x13
0286A:  CLRF   x12
0286C:  MOVFF  37,C11
02870:  CLRF   x18
02872:  MOVLW  01
02874:  MOVWF  x17
02876:  MOVLW  51
02878:  MOVWF  x16
0287A:  MOVLW  80
0287C:  MOVWF  x15
0287E:  MOVLB  0
02880:  CALL   1E20
02884:  MOVF   00,W
02886:  MOVLB  C
02888:  SUBWF  x04,F
0288A:  MOVF   01,W
0288C:  SUBWFB x05,F
0288E:  MOVF   02,W
02890:  SUBWFB x06,F
02892:  MOVF   03,W
02894:  SUBWFB x07,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
02896:  BCF    FD8.1
02898:  MOVFF  C07,C1C
0289C:  MOVFF  C06,C1B
028A0:  MOVFF  C05,C1A
028A4:  MOVFF  C04,C19
028A8:  CLRF   x20
028AA:  CLRF   x1F
028AC:  MOVLW  0E
028AE:  MOVWF  x1E
028B0:  MOVLW  10
028B2:  MOVWF  x1D
028B4:  MOVLB  0
028B6:  CALL   1F8A
028BA:  MOVFF  00,36
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
028BE:  MOVLB  C
028C0:  CLRF   x0C
028C2:  CLRF   x0B
028C4:  CLRF   x0A
028C6:  MOVFF  36,C09
028CA:  MOVFF  C0C,C14
028CE:  MOVFF  C0B,C13
028D2:  MOVFF  C0A,C12
028D6:  MOVFF  36,C11
028DA:  CLRF   x18
028DC:  CLRF   x17
028DE:  MOVLW  0E
028E0:  MOVWF  x16
028E2:  MOVLW  10
028E4:  MOVWF  x15
028E6:  MOVLB  0
028E8:  CALL   1E20
028EC:  MOVF   00,W
028EE:  MOVLB  C
028F0:  SUBWF  x04,F
028F2:  MOVF   01,W
028F4:  SUBWFB x05,F
028F6:  MOVF   02,W
028F8:  SUBWFB x06,F
028FA:  MOVF   03,W
028FC:  SUBWFB x07,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
028FE:  BCF    FD8.1
02900:  MOVFF  C07,C1C
02904:  MOVFF  C06,C1B
02908:  MOVFF  C05,C1A
0290C:  MOVFF  C04,C19
02910:  CLRF   x20
02912:  CLRF   x1F
02914:  CLRF   x1E
02916:  MOVLW  3C
02918:  MOVWF  x1D
0291A:  MOVLB  0
0291C:  CALL   1F8A
02920:  MOVFF  00,35
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
02924:  MOVLB  C
02926:  CLRF   x0A
02928:  MOVFF  35,C09
0292C:  CLRF   19
0292E:  BTFSC  FF2.7
02930:  BSF    19.7
02932:  BCF    FF2.7
02934:  MOVFF  C0A,C29
02938:  MOVFF  35,C28
0293C:  CLRF   x2B
0293E:  MOVLW  3C
02940:  MOVWF  x2A
02942:  MOVLB  0
02944:  CALL   0432
02948:  BTFSC  19.7
0294A:  BSF    FF2.7
0294C:  MOVF   01,W
0294E:  MOVLB  C
02950:  SUBWF  x04,F
02952:  MOVF   02,W
02954:  SUBWFB x05,F
02956:  MOVLW  00
02958:  SUBWFB x06,F
0295A:  SUBWFB x07,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
0295C:  MOVFF  C04,34
....................    } 
....................     
....................    return &g_lTime; 
02960:  MOVLW  34
02962:  MOVWF  01
02964:  MOVLW  00
02966:  MOVWF  02
02968:  MOVLB  0
0296A:  GOTO   384A (RETURN)
.................... } 
.................... #endif 
....................  
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
*
041FA:  CLRF   19
041FC:  BTFSC  FF2.7
041FE:  BSF    19.7
04200:  BCF    FF2.7
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
04202:  MOVLB  C
04204:  CLRF   x29
04206:  MOVFF  BF7,C28
0420A:  MOVLW  03
0420C:  MOVWF  x2B
0420E:  MOVLW  E8
04210:  MOVWF  x2A
04212:  MOVLB  0
04214:  CALL   0432
04218:  BTFSC  19.7
0421A:  BSF    FF2.7
0421C:  MOVFF  02,91
04220:  MOVFF  01,90
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
04224:  MOVLW  01
04226:  MOVWF  x92
04228:  RETURN 0
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
*
00B0E:  MOVLB  C
00B10:  CLRF   x19
00B12:  CLRF   x18
00B14:  SETF   x1B
00B16:  SETF   x1A
00B18:  MOVLW  A0
00B1A:  MOVWF  x1D
00B1C:  MOVLW  01
00B1E:  MOVWF  x1C
00B20:  CLRF   x1E
00B22:  CLRF   x1F
00B24:  CLRF   x20
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
00B26:  MOVF   x17,W
00B28:  SUBWF  x1E,W
00B2A:  BNZ   0B2E
.................... 		{ 
.................... 			break; 
00B2C:  BRA    0B96
.................... 		} 
....................  
.................... 		uiByteCount++; 
00B2E:  INCF   x1E,F
.................... 		bShiftCount = 0; 
00B30:  CLRF   x1F
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
00B32:  MOVF   x1F,F
00B34:  BNZ   0B68
.................... 			{ 
.................... 				if (1 == uiByteCount) 
00B36:  DECFSZ x1E,W
00B38:  BRA    0B54
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
00B3A:  MOVLW  01
00B3C:  SUBWF  x1E,W
00B3E:  ADDWF  x15,W
00B40:  MOVWF  FE9
00B42:  MOVLW  00
00B44:  ADDWFC x16,W
00B46:  MOVWF  FEA
00B48:  MOVF   FEF,W
00B4A:  XORWF  x1A,W
00B4C:  MOVWF  x18
00B4E:  MOVFF  C1B,C19
.................... 				} 
00B52:  BRA    0B66
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
00B54:  MOVLW  01
00B56:  SUBWF  x1E,W
00B58:  ADDWF  x15,W
00B5A:  MOVWF  FE9
00B5C:  MOVLW  00
00B5E:  ADDWFC x16,W
00B60:  MOVWF  FEA
00B62:  MOVF   FEF,W
00B64:  XORWF  x18,F
.................... 				} 
.................... 			} 
00B66:  BRA    0B70
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
00B68:  MOVF   x1C,W
00B6A:  XORWF  x18,F
00B6C:  MOVF   x1D,W
00B6E:  XORWF  x19,F
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
00B70:  MOVLB  C
00B72:  INCF   x1F,F
....................  
.................... 			if (bShiftCount > 8) 
00B74:  MOVF   x1F,W
00B76:  SUBLW  08
00B78:  BC    0B7C
.................... 			{ 
.................... 				break; 
00B7A:  BRA    0B94
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
00B7C:  MOVF   x18,W
00B7E:  ANDLW  01
00B80:  MOVWF  x20
....................  
.................... 			uiCRC = uiCRC >> 1; 
00B82:  BCF    FD8.0
00B84:  RRCF   x19,F
00B86:  RRCF   x18,F
....................  
.................... 			if (1 == bShiftCarry) 
00B88:  DECFSZ x20,W
00B8A:  BRA    0B90
.................... 			{ 
.................... 				continue; 
00B8C:  BRA    0B32
.................... 			} 
00B8E:  BRA    0B92
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
00B90:  BRA    0B70
.................... 			} 
00B92:  BRA    0B32
.................... 		} 
00B94:  BRA    0B26
.................... 	} 
....................  
.................... 	return uiCRC; 
00B96:  MOVFF  C18,01
00B9A:  MOVFF  C19,02
00B9E:  MOVLB  0
00BA0:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
.................... #include "vmCircularQ.h" 
.................... /*  
....................  * File:   vmCircularQ.h 
....................  * Author: AmitDP 
....................  * 
....................  * Created on February 26, 2020, 2:17 PM 
....................  */ 
....................  
.................... #ifndef VM_CIRCULAR_Q_H 
.................... #define	VM_CIRCULAR_Q_H 
....................  
....................  
.................... #define SIZE_RCV_QUEUE 200 
....................  
.................... typedef struct _ST_RCV_QUEUE 
.................... { 
....................     int8 m_ui8QArr[SIZE_RCV_QUEUE]; 
....................     int8 m_ui8Front; 
....................     int8 m_ui8Rear; 
.................... } ST_RCV_QUEUE; 
....................  
.................... ST_RCV_QUEUE g_stRcvQueue; 
.................... unsigned int8 g_ui8ElementInQ = 0; 
....................  
.................... void InitializeRcvQ() 
.................... { 
....................     memset(g_stRcvQueue.m_ui8QArr, SIZE_RCV_QUEUE, 0); 
*
009E6:  MOVLW  01
009E8:  MOVWF  FEA
009EA:  MOVLW  13
009EC:  MOVWF  FE9
009EE:  MOVLW  C8
009F0:  MOVWF  00
009F2:  CLRF   02
009F4:  CLRF   01
009F6:  RCALL  09CC
....................     g_stRcvQueue.m_ui8Front = -1; 
009F8:  MOVLB  1
009FA:  SETF   xDB
....................     g_stRcvQueue.m_ui8Rear  = -1; 
009FC:  SETF   xDC
009FE:  MOVLB  0
00A00:  GOTO   458A (RETURN)
.................... } 
....................  
.................... //int isFull() 
.................... //{ 
.................... //    if( (front == rear + 1) || (front == 0 && rear == SIZE_RCV_QUEUE-1)) return 1; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... //int8 items[SIZE_RCV_QUEUE]; 
.................... //int front = -1, rear =-1; 
.................... unsigned int8 ElementsInQ(void) 
00A04:  MOVLW  0A
00A06:  MOVLB  B
00A08:  MOVWF  xF7
.................... { 
....................     unsigned int8 ui8Retval = 10; 
....................      
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
00A0A:  MOVLB  1
00A0C:  MOVF   xDB,W
00A0E:  SUBLW  FF
00A10:  BNZ   0A1E
....................     { 
....................         //return = 0; 
....................         ui8Retval = 0; 
00A12:  MOVLB  B
00A14:  CLRF   xF7
....................         return ui8Retval; 
00A16:  MOVFF  BF7,01
00A1A:  BRA    0A44
00A1C:  MOVLB  1
....................     } 
....................      
....................      
....................     if (g_stRcvQueue.m_ui8Front > g_stRcvQueue.m_ui8Rear) 
00A1E:  MOVF   xDB,W
00A20:  SUBWF  xDC,W
00A22:  BC    0A36
....................     { 
....................         //return = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
....................         ui8Retval = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
00A24:  MOVLW  C8
00A26:  BSF    FD8.0
00A28:  SUBFWB xDB,W
00A2A:  ADDWF  xDC,W
00A2C:  ADDLW  01
00A2E:  MOVLB  B
00A30:  MOVWF  xF7
....................     } 
00A32:  BRA    0A40
00A34:  MOVLB  1
....................     else 
....................     { 
....................         //return = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
....................         ui8Retval = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
00A36:  MOVF   xDB,W
00A38:  SUBWF  xDC,W
00A3A:  ADDLW  01
00A3C:  MOVLB  B
00A3E:  MOVWF  xF7
....................     } 
....................      
....................     return ui8Retval; 
00A40:  MOVFF  BF7,01
00A44:  MOVLB  0
00A46:  GOTO   4596 (RETURN)
.................... } 
....................  
.................... unsigned int8 IsQFull(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if( (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear + 1) || 
....................         (g_stRcvQueue.m_ui8Front == 0 && g_stRcvQueue.m_ui8Rear == SIZE_RCV_QUEUE - 1)) 
....................     { 
....................         // Queue is Full 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     }    
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int isEmpty() 
.................... //{ 
.................... //    if(front == -1) return 1; 
.................... //    return 0; 
.................... //} 
....................  
.................... unsigned int8 IsQEmpty(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if(g_stRcvQueue.m_ui8Front == -1) 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     return ui8RetVal; 
.................... } 
....................  
.................... //void enQueue(int element) 
.................... //{ 
.................... //    if(isFull()) printf("\n Queue is full!! \n"); 
.................... //    else 
.................... //    { 
.................... //        if(front == -1) front = 0; 
.................... //        rear = (rear + 1) % SIZE_RCV_QUEUE; 
.................... //        items[rear] = element; 
.................... //        printf("\n Inserted -> %d", element); 
.................... //    } 
.................... //} 
....................  
.................... void EnQueue(unsigned int8 ui8Element) 
.................... { 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = ui8Element; 
.................... } 
....................  
.................... unsigned int8 DeQueue(void) 
.................... { 
....................     unsigned int8 ui8Element = 0; 
....................     unsigned int8 ui8RetVal  = 0; 
....................      
....................     ui8RetVal = IsQEmpty(); 
....................     if(ui8RetVal) 
....................     { 
....................         ui8RetVal = 0; 
....................         //return 0; //?? 
....................     } 
....................     else 
....................     { 
....................         ui8Element = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         if (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear) 
....................         { 
....................             g_stRcvQueue.m_ui8Front = -1; 
....................             g_stRcvQueue.m_ui8Rear  = -1; 
....................         } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
....................         else 
....................         { 
....................             g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         } 
....................         //printf("\n Deleted element -> %d \n", ui8Element); 
....................         ui8RetVal = ui8Element; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int deQueue() 
.................... //{ 
.................... //    int element; 
.................... //    if(isEmpty()) { 
.................... //        printf("\n Queue is empty !! \n"); 
.................... //        return(-1); 
.................... //    } else { 
.................... //        element = items[front]; 
.................... //        if (front == rear){ 
.................... //            front = -1; 
.................... //            rear = -1; 
.................... //        } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
.................... //        else { 
.................... //            front = (front + 1) % SIZE_RCV_QUEUE; 
.................... //             
.................... //        } 
.................... //        printf("\n Deleted element -> %d \n", element); 
.................... //        return(element); 
.................... //    } 
.................... //} 
....................  
....................  
.................... #endif	/* VM_CIRCULAR_Q_H */ 
....................  
....................  
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
*
005EA:  MOVF   F98,W
.................... 	enable_interrupts(INT_RDA); 
005EC:  MOVLB  E
005EE:  BSF    x2C.5
005F0:  MOVLB  0
005F2:  GOTO   457E (RETURN)
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
008B8:  MOVLB  B
008BA:  CLRF   xF9
008BC:  CLRF   xFA
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
008BE:  MOVLW  C3
008C0:  ADDWF  xF7,W
008C2:  MOVWF  01
008C4:  MOVLW  00
008C6:  ADDWFC xF8,W
008C8:  MOVWF  03
008CA:  MOVLW  C4
008CC:  ADDWF  xF7,W
008CE:  MOVWF  FE9
008D0:  MOVLW  00
008D2:  ADDWFC xF8,W
008D4:  MOVWF  FEA
008D6:  SETF   FEF
008D8:  MOVLW  FF
008DA:  MOVFF  03,FEA
008DE:  MOVFF  01,FE9
008E2:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
008E4:  CLRF   xF9
008E6:  MOVF   xF9,W
008E8:  SUBLW  0E
008EA:  BNC   0946
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
008EC:  CLRF   xFA
008EE:  MOVF   xFA,W
008F0:  SUBLW  08
008F2:  BNC   0942
008F4:  CLRF   19
008F6:  BTFSC  FF2.7
008F8:  BSF    19.7
008FA:  BCF    FF2.7
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
008FC:  MOVLB  C
008FE:  CLRF   x29
00900:  MOVFF  BF9,C28
00904:  CLRF   x2B
00906:  MOVLW  0D
00908:  MOVWF  x2A
0090A:  MOVLB  0
0090C:  RCALL  0432
0090E:  BTFSC  19.7
00910:  BSF    FF2.7
00912:  MOVFF  02,BFC
00916:  MOVFF  01,BFB
0091A:  MOVLW  02
0091C:  MOVLB  B
0091E:  ADDWF  xFB,F
00920:  MOVLW  00
00922:  ADDWFC xFC,F
00924:  MOVF   xFA,W
00926:  ADDWF  xFB,W
00928:  MOVWF  01
0092A:  MOVLW  00
0092C:  ADDWFC xFC,W
0092E:  MOVWF  03
00930:  MOVF   01,W
00932:  ADDWF  xF7,W
00934:  MOVWF  FE9
00936:  MOVF   xF8,W
00938:  ADDWFC 03,W
0093A:  MOVWF  FEA
0093C:  CLRF   FEF
0093E:  INCF   xFA,F
00940:  BRA    08EE
....................         } 
00942:  INCF   xF9,F
00944:  BRA    08E6
....................     } 
00946:  MOVLB  0
00948:  RETURN 0
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
*
00BA2:  MOVLB  C
00BA4:  CLRF   x0F
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
00BA6:  CLRF   x0F
00BA8:  MOVF   x0F,W
00BAA:  SUBLW  08
00BAC:  BNC   0BDE
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
00BAE:  MOVLW  02
00BB0:  ADDWF  x0F,W
00BB2:  ADDWF  x0D,W
00BB4:  MOVWF  01
00BB6:  MOVLW  00
00BB8:  ADDWFC x0E,W
00BBA:  MOVWF  03
00BBC:  MOVLW  02
00BBE:  ADDWF  x0F,W
00BC0:  ADDWF  x0B,W
00BC2:  MOVWF  FE9
00BC4:  MOVLW  00
00BC6:  ADDWFC x0C,W
00BC8:  MOVWF  FEA
00BCA:  MOVFF  FEF,C12
00BCE:  MOVFF  03,FEA
00BD2:  MOVFF  01,FE9
00BD6:  MOVFF  C12,FEF
00BDA:  INCF   x0F,F
00BDC:  BRA    0BA8
....................     } 
00BDE:  MOVLB  0
00BE0:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
00BE2:  MOVLB  C
00BE4:  MOVF   x04,W
00BE6:  IORWF  x05,W
00BE8:  BNZ   0BEC
....................     { 
....................         return; 
00BEA:  BRA    0DAE
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
00BEC:  MOVLW  C3
00BEE:  ADDWF  x02,W
00BF0:  MOVWF  FE9
00BF2:  MOVLW  00
00BF4:  ADDWFC x03,W
00BF6:  MOVWF  FEA
00BF8:  MOVF   FEF,F
00BFA:  BNZ   0C0E
00BFC:  MOVLW  C4
00BFE:  ADDWF  x02,W
00C00:  MOVWF  FE9
00C02:  MOVLW  00
00C04:  ADDWFC x03,W
00C06:  MOVWF  FEA
00C08:  MOVF   FEF,W
00C0A:  SUBLW  0E
00C0C:  BZ    0C32
00C0E:  MOVLW  C4
00C10:  ADDWF  x02,W
00C12:  MOVWF  FE9
00C14:  MOVLW  00
00C16:  ADDWFC x03,W
00C18:  MOVWF  FEA
00C1A:  MOVFF  FEF,C06
00C1E:  MOVLW  C3
00C20:  ADDWF  x02,W
00C22:  MOVWF  FE9
00C24:  MOVLW  00
00C26:  ADDWFC x03,W
00C28:  MOVWF  FEA
00C2A:  MOVLW  01
00C2C:  SUBWF  FEF,W
00C2E:  SUBWF  x06,W
00C30:  BNZ   0C36
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
00C32:  BRA    0DAE
....................     }     
00C34:  BRA    0DAE
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
00C36:  MOVLW  C3
00C38:  ADDWF  x02,W
00C3A:  MOVWF  FE9
00C3C:  MOVLW  00
00C3E:  ADDWFC x03,W
00C40:  MOVWF  FEA
00C42:  MOVF   FEF,W
00C44:  SUBLW  FF
00C46:  BNZ   0CBE
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
00C48:  MOVLW  C3
00C4A:  ADDWF  x02,W
00C4C:  MOVWF  FE9
00C4E:  MOVLW  00
00C50:  ADDWFC x03,W
00C52:  MOVWF  FEA
00C54:  CLRF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
00C56:  MOVLW  C4
00C58:  ADDWF  x02,W
00C5A:  MOVWF  FE9
00C5C:  MOVLW  00
00C5E:  ADDWFC x03,W
00C60:  MOVWF  FEA
00C62:  CLRF   FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00C64:  MOVLW  C4
00C66:  ADDWF  x02,W
00C68:  MOVWF  FE9
00C6A:  MOVLW  00
00C6C:  ADDWFC x03,W
00C6E:  MOVWF  FEA
00C70:  CLRF   19
00C72:  BTFSC  FF2.7
00C74:  BSF    19.7
00C76:  BCF    FF2.7
00C78:  CLRF   x29
00C7A:  MOVFF  FEF,C28
00C7E:  CLRF   x2B
00C80:  MOVLW  0D
00C82:  MOVWF  x2A
00C84:  MOVLB  0
00C86:  CALL   0432
00C8A:  BTFSC  19.7
00C8C:  BSF    FF2.7
00C8E:  MOVFF  02,03
00C92:  MOVF   01,W
00C94:  MOVLB  C
00C96:  ADDWF  x02,W
00C98:  MOVWF  01
00C9A:  MOVF   x03,W
00C9C:  ADDWFC 03,F
00C9E:  MOVFF  01,C06
00CA2:  MOVFF  03,C07
00CA6:  MOVFF  C05,C0C
00CAA:  MOVFF  C04,C0B
00CAE:  MOVFF  03,C0E
00CB2:  MOVFF  01,C0D
00CB6:  MOVLB  0
00CB8:  RCALL  0BA2
....................     }  
00CBA:  BRA    0DAC
00CBC:  MOVLB  C
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
00CBE:  MOVLW  C4
00CC0:  ADDWF  x02,W
00CC2:  MOVWF  FE9
00CC4:  MOVLW  00
00CC6:  ADDWFC x03,W
00CC8:  MOVWF  FEA
00CCA:  MOVF   FEF,W
00CCC:  SUBLW  0E
00CCE:  BNZ   0D48
00CD0:  MOVLW  C3
00CD2:  ADDWF  x02,W
00CD4:  MOVWF  FE9
00CD6:  MOVLW  00
00CD8:  ADDWFC x03,W
00CDA:  MOVWF  FEA
00CDC:  MOVF   FEF,F
00CDE:  BZ    0D48
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
00CE0:  MOVLW  C4
00CE2:  ADDWF  x02,W
00CE4:  MOVWF  FE9
00CE6:  MOVLW  00
00CE8:  ADDWFC x03,W
00CEA:  MOVWF  FEA
00CEC:  CLRF   FEF
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00CEE:  MOVLW  C4
00CF0:  ADDWF  x02,W
00CF2:  MOVWF  FE9
00CF4:  MOVLW  00
00CF6:  ADDWFC x03,W
00CF8:  MOVWF  FEA
00CFA:  CLRF   19
00CFC:  BTFSC  FF2.7
00CFE:  BSF    19.7
00D00:  BCF    FF2.7
00D02:  CLRF   x29
00D04:  MOVFF  FEF,C28
00D08:  CLRF   x2B
00D0A:  MOVLW  0D
00D0C:  MOVWF  x2A
00D0E:  MOVLB  0
00D10:  CALL   0432
00D14:  BTFSC  19.7
00D16:  BSF    FF2.7
00D18:  MOVFF  02,03
00D1C:  MOVF   01,W
00D1E:  MOVLB  C
00D20:  ADDWF  x02,W
00D22:  MOVWF  01
00D24:  MOVF   x03,W
00D26:  ADDWFC 03,F
00D28:  MOVFF  01,C06
00D2C:  MOVFF  03,C07
00D30:  MOVFF  C05,C0C
00D34:  MOVFF  C04,C0B
00D38:  MOVFF  03,C0E
00D3C:  MOVFF  01,C0D
00D40:  MOVLB  0
00D42:  RCALL  0BA2
....................     }  
00D44:  BRA    0DAC
00D46:  MOVLB  C
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
00D48:  MOVLW  C4
00D4A:  ADDWF  x02,W
00D4C:  MOVWF  FE9
00D4E:  MOVLW  00
00D50:  ADDWFC x03,W
00D52:  MOVWF  FEA
00D54:  INCF   FEF,F
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00D56:  MOVLW  C4
00D58:  ADDWF  x02,W
00D5A:  MOVWF  FE9
00D5C:  MOVLW  00
00D5E:  ADDWFC x03,W
00D60:  MOVWF  FEA
00D62:  CLRF   19
00D64:  BTFSC  FF2.7
00D66:  BSF    19.7
00D68:  BCF    FF2.7
00D6A:  CLRF   x29
00D6C:  MOVFF  FEF,C28
00D70:  CLRF   x2B
00D72:  MOVLW  0D
00D74:  MOVWF  x2A
00D76:  MOVLB  0
00D78:  CALL   0432
00D7C:  BTFSC  19.7
00D7E:  BSF    FF2.7
00D80:  MOVFF  02,03
00D84:  MOVF   01,W
00D86:  MOVLB  C
00D88:  ADDWF  x02,W
00D8A:  MOVWF  01
00D8C:  MOVF   x03,W
00D8E:  ADDWFC 03,F
00D90:  MOVFF  01,C06
00D94:  MOVFF  03,C07
00D98:  MOVFF  C05,C0C
00D9C:  MOVFF  C04,C0B
00DA0:  MOVFF  03,C0E
00DA4:  MOVFF  01,C0D
00DA8:  MOVLB  0
00DAA:  RCALL  0BA2
00DAC:  MOVLB  C
....................     } 
00DAE:  MOVLB  0
00DB0:  RETURN 0
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
01118:  MOVLW  C3
0111A:  MOVLB  C
0111C:  ADDWF  x05,W
0111E:  MOVWF  FE9
01120:  MOVLW  00
01122:  ADDWFC x06,W
01124:  MOVWF  FEA
01126:  MOVF   FEF,W
01128:  SUBLW  FF
0112A:  BNZ   112E
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
0112C:  BRA    11F6
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
0112E:  MOVLW  C3
01130:  ADDWF  x05,W
01132:  MOVWF  FE9
01134:  MOVLW  00
01136:  ADDWFC x06,W
01138:  MOVWF  FEA
0113A:  CLRF   19
0113C:  BTFSC  FF2.7
0113E:  BSF    19.7
01140:  BCF    FF2.7
01142:  CLRF   x29
01144:  MOVFF  FEF,C28
01148:  CLRF   x2B
0114A:  MOVLW  0D
0114C:  MOVWF  x2A
0114E:  MOVLB  0
01150:  CALL   0432
01154:  BTFSC  19.7
01156:  BSF    FF2.7
01158:  MOVFF  02,03
0115C:  MOVF   01,W
0115E:  MOVLB  C
01160:  ADDWF  x05,W
01162:  MOVWF  01
01164:  MOVF   x06,W
01166:  ADDWFC 03,F
01168:  MOVFF  01,C09
0116C:  MOVFF  03,C0A
01170:  MOVFF  03,C0C
01174:  MOVFF  01,C0B
01178:  MOVFF  C08,C0E
0117C:  MOVFF  C07,C0D
01180:  MOVLB  0
01182:  RCALL  0BA2
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
01184:  MOVLW  C3
01186:  MOVLB  C
01188:  ADDWF  x05,W
0118A:  MOVWF  FE9
0118C:  MOVLW  00
0118E:  ADDWFC x06,W
01190:  MOVWF  FEA
01192:  MOVFF  FEF,C09
01196:  MOVLW  C4
01198:  ADDWF  x05,W
0119A:  MOVWF  FE9
0119C:  MOVLW  00
0119E:  ADDWFC x06,W
011A0:  MOVWF  FEA
011A2:  MOVF   FEF,W
011A4:  SUBWF  x09,W
011A6:  BNZ   11C6
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
011A8:  MOVLW  C3
011AA:  ADDWF  x05,W
011AC:  MOVWF  FE9
011AE:  MOVLW  00
011B0:  ADDWFC x06,W
011B2:  MOVWF  FEA
011B4:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
011B6:  MOVLW  C4
011B8:  ADDWF  x05,W
011BA:  MOVWF  FE9
011BC:  MOVLW  00
011BE:  ADDWFC x06,W
011C0:  MOVWF  FEA
011C2:  SETF   FEF
....................     }  
011C4:  BRA    11F6
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
011C6:  MOVLW  C3
011C8:  ADDWF  x05,W
011CA:  MOVWF  FE9
011CC:  MOVLW  00
011CE:  ADDWFC x06,W
011D0:  MOVWF  FEA
011D2:  MOVF   FEF,W
011D4:  SUBLW  0E
011D6:  BNZ   11E8
....................         pstIBUMSGQueue->m_i8Front = 0;  
011D8:  MOVLW  C3
011DA:  ADDWF  x05,W
011DC:  MOVWF  FE9
011DE:  MOVLW  00
011E0:  ADDWFC x06,W
011E2:  MOVWF  FEA
011E4:  CLRF   FEF
011E6:  BRA    11F6
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
011E8:  MOVLW  C3
011EA:  ADDWF  x05,W
011EC:  MOVWF  FE9
011EE:  MOVLW  00
011F0:  ADDWFC x06,W
011F2:  MOVWF  FEA
011F4:  INCF   FEF,F
....................    
....................     return; 
011F6:  MOVLB  0
011F8:  GOTO   1358 (RETURN)
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
015B0:  MOVLW  C3
015B2:  MOVLB  B
015B4:  ADDWF  xF8,W
015B6:  MOVWF  FE9
015B8:  MOVLW  00
015BA:  ADDWFC xF9,W
015BC:  MOVWF  FEA
015BE:  MOVF   FEF,W
015C0:  SUBLW  FF
015C2:  BNZ   15C6
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
015C4:  BRA    1622
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
015C6:  MOVLW  C3
015C8:  ADDWF  xF8,W
015CA:  MOVWF  FE9
015CC:  MOVLW  00
015CE:  ADDWFC xF9,W
015D0:  MOVWF  FEA
015D2:  CLRF   19
015D4:  BTFSC  FF2.7
015D6:  BSF    19.7
015D8:  BCF    FF2.7
015DA:  MOVLB  C
015DC:  CLRF   x29
015DE:  MOVFF  FEF,C28
015E2:  CLRF   x2B
015E4:  MOVLW  0D
015E6:  MOVWF  x2A
015E8:  MOVLB  0
015EA:  CALL   0432
015EE:  BTFSC  19.7
015F0:  BSF    FF2.7
015F2:  MOVFF  02,03
015F6:  MOVF   01,W
015F8:  MOVLB  B
015FA:  ADDWF  xF8,W
015FC:  MOVWF  01
015FE:  MOVF   xF9,W
01600:  ADDWFC 03,F
01602:  MOVFF  01,BFC
01606:  MOVFF  03,BFD
0160A:  MOVFF  03,C0C
0160E:  MOVFF  01,C0B
01612:  MOVFF  BFB,C0E
01616:  MOVFF  BFA,C0D
0161A:  MOVLB  0
0161C:  CALL   0BA2
01620:  MOVLB  B
01622:  MOVLB  0
01624:  GOTO   1682 (RETURN)
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
00A4A:  MOVLW  C3
00A4C:  MOVLB  B
00A4E:  ADDWF  xFC,W
00A50:  MOVWF  FE9
00A52:  MOVLW  00
00A54:  ADDWFC xFD,W
00A56:  MOVWF  FEA
00A58:  MOVF   FEF,W
00A5A:  SUBLW  FF
00A5C:  BNZ   0A60
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
00A5E:  BRA    0AD0
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
00A60:  MOVLW  C3
00A62:  ADDWF  xFC,W
00A64:  MOVWF  FE9
00A66:  MOVLW  00
00A68:  ADDWFC xFD,W
00A6A:  MOVWF  FEA
00A6C:  MOVFF  FEF,BFE
00A70:  MOVLW  C4
00A72:  ADDWF  xFC,W
00A74:  MOVWF  FE9
00A76:  MOVLW  00
00A78:  ADDWFC xFD,W
00A7A:  MOVWF  FEA
00A7C:  MOVF   FEF,W
00A7E:  SUBWF  xFE,W
00A80:  BNZ   0AA0
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
00A82:  MOVLW  C3
00A84:  ADDWF  xFC,W
00A86:  MOVWF  FE9
00A88:  MOVLW  00
00A8A:  ADDWFC xFD,W
00A8C:  MOVWF  FEA
00A8E:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
00A90:  MOVLW  C4
00A92:  ADDWF  xFC,W
00A94:  MOVWF  FE9
00A96:  MOVLW  00
00A98:  ADDWFC xFD,W
00A9A:  MOVWF  FEA
00A9C:  SETF   FEF
....................     }  
00A9E:  BRA    0AD0
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
00AA0:  MOVLW  C3
00AA2:  ADDWF  xFC,W
00AA4:  MOVWF  FE9
00AA6:  MOVLW  00
00AA8:  ADDWFC xFD,W
00AAA:  MOVWF  FEA
00AAC:  MOVF   FEF,W
00AAE:  SUBLW  0E
00AB0:  BNZ   0AC2
....................         pstIBUMSGQueue->m_i8Front = 0;  
00AB2:  MOVLW  C3
00AB4:  ADDWF  xFC,W
00AB6:  MOVWF  FE9
00AB8:  MOVLW  00
00ABA:  ADDWFC xFD,W
00ABC:  MOVWF  FEA
00ABE:  CLRF   FEF
00AC0:  BRA    0AD0
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
00AC2:  MOVLW  C3
00AC4:  ADDWF  xFC,W
00AC6:  MOVWF  FE9
00AC8:  MOVLW  00
00ACA:  ADDWFC xFD,W
00ACC:  MOVWF  FEA
00ACE:  INCF   FEF,F
00AD0:  MOVLB  0
00AD2:  RETURN 0
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
010F2:  MOVLB  B
010F4:  CLRF   xF9
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
010F6:  MOVLW  C3
010F8:  ADDWF  xF7,W
010FA:  MOVWF  FE9
010FC:  MOVLW  00
010FE:  ADDWFC xF8,W
01100:  MOVWF  FEA
01102:  MOVF   FEF,W
01104:  SUBLW  FF
01106:  BNZ   110C
....................     { 
....................         ui8RetVal = 0; 
01108:  CLRF   xF9
....................     } 
0110A:  BRA    1110
....................     else 
....................     { 
....................         ui8RetVal = 1; 
0110C:  MOVLW  01
0110E:  MOVWF  xF9
....................     } 
....................      
....................     return ui8RetVal; 
01110:  MOVFF  BF9,01
01114:  MOVLB  0
01116:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
*
01628:  MOVLB  B
0162A:  CLRF   xF7
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
0162C:  MOVLB  4
0162E:  MOVF   x47,W
01630:  SUBLW  09
01632:  BC    164E
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
01634:  CLRF   x47
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
01636:  MOVLW  02
01638:  MOVLB  B
0163A:  MOVWF  xFD
0163C:  MOVLW  9A
0163E:  MOVWF  xFC
01640:  MOVLB  0
01642:  CALL   0A4A
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
01646:  MOVLB  2
01648:  CLRF   x99
....................         return; 
0164A:  BRA    174E
0164C:  MOVLB  4
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
0164E:  INCF   x47,F
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01650:  MOVLB  B
01652:  CLRF   xF7
01654:  MOVF   xF7,W
01656:  SUBLW  08
01658:  BNC   166E
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
0165A:  CLRF   03
0165C:  MOVF   xF7,W
0165E:  ADDLW  06
01660:  MOVWF  FE9
01662:  MOVLW  02
01664:  ADDWFC 03,W
01666:  MOVWF  FEA
01668:  CLRF   FEF
0166A:  INCF   xF7,F
0166C:  BRA    1654
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0166E:  MOVLW  02
01670:  MOVWF  xF9
01672:  MOVLW  9A
01674:  MOVWF  xF8
01676:  MOVLW  02
01678:  MOVWF  xFB
0167A:  MOVLW  04
0167C:  MOVWF  xFA
0167E:  MOVLB  0
01680:  BRA    15B0
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
01682:  MOVLB  4
01684:  DECFSZ x47,W
01686:  BRA    1692
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
01688:  INCFSZ x37,W
0168A:  BRA    1690
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
0168C:  CLRF   x37
....................         } 
0168E:  BRA    1692
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
01690:  INCF   x37,F
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
01692:  MOVFF  437,204
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
01696:  MOVFF  437,438
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
0169A:  MOVLW  21
0169C:  MOVWF  x39
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
0169E:  MOVFF  206,43A
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
016A2:  MOVFF  207,43B
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
016A6:  MOVFF  208,43C
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
016AA:  MOVFF  209,43D
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
016AE:  MOVFF  20A,43E
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
016B2:  MOVFF  20B,43F
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
016B6:  MOVFF  20C,440
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
016BA:  MOVFF  20D,441
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
016BE:  MOVFF  20E,442
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
016C2:  MOVLW  04
016C4:  MOVLB  C
016C6:  MOVWF  x16
016C8:  MOVLW  38
016CA:  MOVWF  x15
016CC:  MOVLW  0B
016CE:  MOVWF  x17
016D0:  MOVLB  0
016D2:  CALL   0B0E
016D6:  MOVFF  02,446
016DA:  MOVFF  01,445
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
016DE:  MOVFF  446,BF9
016E2:  MOVFF  445,443
016E6:  MOVLB  4
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
016E8:  MOVFF  446,444
016EC:  MOVLB  4
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
016EE:  MOVLW  A5
016F0:  MOVLB  0
016F2:  CALL   0DB2
....................     fputc(STX, UART); 
016F6:  MOVLW  A5
016F8:  CALL   0DB2
....................     fputc(STX, UART); 
016FC:  MOVLW  A5
016FE:  CALL   0DB2
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
01702:  MOVLB  B
01704:  CLRF   xF7
01706:  MOVF   xF7,W
01708:  SUBLW  0C
0170A:  BNC   172C
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
0170C:  CLRF   03
0170E:  MOVF   xF7,W
01710:  ADDLW  38
01712:  MOVWF  FE9
01714:  MOVLW  04
01716:  ADDWFC 03,W
01718:  MOVWF  FEA
0171A:  MOVFF  FEF,BF8
0171E:  MOVF   xF8,W
01720:  MOVLB  0
01722:  CALL   0DB2
01726:  MOVLB  B
01728:  INCF   xF7,F
0172A:  BRA    1706
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
0172C:  MOVLW  B5
0172E:  MOVLB  0
01730:  CALL   0DB2
....................     fputc(ETX, UART); 
01734:  MOVLW  B5
01736:  CALL   0DB2
....................     delay_us(5); 
0173A:  CLRWDT
0173C:  MOVLW  07
0173E:  MOVWF  00
01740:  DECFSZ 00,F
01742:  BRA    1740
01744:  BRA    1746
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
01746:  MOVLW  01
01748:  MOVLB  4
0174A:  MOVWF  x27
0174C:  MOVLB  2
0174E:  MOVLB  0
01750:  GOTO   45EC (RETURN)
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
*
00AD4:  MOVLB  B
00AD6:  MOVF   xFB,W
00AD8:  MOVLB  4
00ADA:  SUBWF  x37,W
00ADC:  BNZ   0AFE
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
00ADE:  MOVLW  02
00AE0:  MOVLB  B
00AE2:  MOVWF  xFD
00AE4:  MOVLW  9A
00AE6:  MOVWF  xFC
00AE8:  MOVLB  0
00AEA:  RCALL  0A4A
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
00AEC:  MOVLB  4
00AEE:  CLRF   x47
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00AF0:  CLRF   x27
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00AF2:  CLRF   x29
00AF4:  CLRF   x28
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00AF6:  MOVLB  2
00AF8:  CLRF   x99
....................     } 
00AFA:  BRA    0B08
00AFC:  MOVLB  4
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00AFE:  CLRF   x27
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00B00:  CLRF   x29
00B02:  CLRF   x28
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00B04:  MOVLB  2
00B06:  CLRF   x99
....................     } 
00B08:  MOVLB  0
00B0A:  GOTO   1012 (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
*
00DBE:  MOVFF  1DB,BF7
00DC2:  MOVLB  B
00DC4:  CLRF   xF8
00DC6:  MOVFF  1DB,BF9
00DCA:  CLRF   xFA
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
00DCC:  MOVFF  1DB,4AE
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
00DD0:  MOVFF  1DC,4AF
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
00DD4:  MOVLB  4
00DD6:  CLRF   xB1
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
00DD8:  CLRF   xB0
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
00DDA:  MOVLB  1
00DDC:  MOVF   xDD,F
00DDE:  BZ    0E48
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00DE0:  MOVLW  01
00DE2:  ADDWF  xDB,W
00DE4:  MOVLB  B
00DE6:  MOVWF  xFC
00DE8:  CLRF   19
00DEA:  BTFSC  FF2.7
00DEC:  BSF    19.7
00DEE:  BCF    FF2.7
00DF0:  MOVFF  FE8,C2F
00DF4:  MOVLW  C8
00DF6:  MOVLB  C
00DF8:  MOVWF  x30
00DFA:  MOVLB  0
00DFC:  CALL   0182
00E00:  BTFSC  19.7
00E02:  BSF    FF2.7
00E04:  MOVFF  00,BF9
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
00E08:  CLRF   03
00E0A:  MOVLB  1
00E0C:  MOVF   xDB,W
00E0E:  ADDLW  13
00E10:  MOVWF  FE9
00E12:  MOVLW  01
00E14:  ADDWFC 03,W
00E16:  MOVWF  FEA
00E18:  MOVF   FEF,W
00E1A:  SUBLW  A5
00E1C:  BNZ   0E40
00E1E:  CLRF   03
00E20:  MOVLB  B
00E22:  MOVF   xF9,W
00E24:  ADDLW  13
00E26:  MOVWF  FE9
00E28:  MOVLW  01
00E2A:  ADDWFC 03,W
00E2C:  MOVWF  FEA
00E2E:  MOVF   FEF,W
00E30:  SUBLW  A5
00E32:  BTFSC  FD8.2
00E34:  BRA    0E3A
00E36:  MOVLB  1
00E38:  BRA    0E40
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
00E3A:  MOVLB  1
00E3C:  BRA    0E48
....................         } 
00E3E:  BRA    0E46
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
00E40:  MOVFF  BF9,1DB
....................             g_ui8ElementInQ--; 
00E44:  DECF   xDD,F
....................         } 
00E46:  BRA    0DDC
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
00E48:  MOVF   xDD,F
00E4A:  BNZ   0E4E
....................     { 
....................         // The message exhausted 
....................         return; 
00E4C:  BRA    10EC
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
00E4E:  MOVF   xDD,W
00E50:  SUBLW  0D
00E52:  BC    0EE4
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
00E54:  MOVLW  0E
00E56:  ADDWF  xDB,W
00E58:  MOVLB  B
00E5A:  MOVWF  xFC
00E5C:  CLRF   19
00E5E:  BTFSC  FF2.7
00E60:  BSF    19.7
00E62:  BCF    FF2.7
00E64:  MOVFF  FE8,C2F
00E68:  MOVLW  C8
00E6A:  MOVLB  C
00E6C:  MOVWF  x30
00E6E:  MOVLB  0
00E70:  CALL   0182
00E74:  BTFSC  19.7
00E76:  BSF    FF2.7
00E78:  MOVFF  00,BFA
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00E7C:  CLRF   03
00E7E:  MOVLB  1
00E80:  MOVF   xDB,W
00E82:  ADDLW  13
00E84:  MOVWF  FE9
00E86:  MOVLW  01
00E88:  ADDWFC 03,W
00E8A:  MOVWF  FEA
00E8C:  MOVF   FEF,W
00E8E:  SUBLW  A5
00E90:  BNZ   0EE0
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
00E92:  CLRF   03
00E94:  MOVLB  B
00E96:  MOVF   xFA,W
00E98:  ADDLW  13
00E9A:  MOVWF  FE9
00E9C:  MOVLW  01
00E9E:  ADDWFC 03,W
00EA0:  MOVWF  FEA
00EA2:  MOVF   FEF,W
00EA4:  SUBLW  B5
00EA6:  BNZ   0EB0
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
00EA8:  MOVLB  1
00EAA:  BRA    0EE4
....................             } 
00EAC:  BRA    0EDE
00EAE:  MOVLB  B
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00EB0:  MOVLW  01
00EB2:  MOVLB  1
00EB4:  ADDWF  xDB,W
00EB6:  MOVLB  B
00EB8:  MOVWF  xFC
00EBA:  CLRF   19
00EBC:  BTFSC  FF2.7
00EBE:  BSF    19.7
00EC0:  BCF    FF2.7
00EC2:  MOVFF  FE8,C2F
00EC6:  MOVLW  C8
00EC8:  MOVLB  C
00ECA:  MOVWF  x30
00ECC:  MOVLB  0
00ECE:  CALL   0182
00ED2:  BTFSC  19.7
00ED4:  BSF    FF2.7
00ED6:  MOVFF  00,1DB
....................                 g_ui8ElementInQ--; 
00EDA:  MOVLB  1
00EDC:  DECF   xDD,F
....................             } 
....................         } 
00EDE:  BRA    0EE2
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
00EE0:  BRA    10EC
....................         } 
00EE2:  BRA    0E4E
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00EE4:  MOVLW  01
00EE6:  ADDWF  xDB,W
00EE8:  MOVLB  B
00EEA:  MOVWF  xFC
00EEC:  CLRF   19
00EEE:  BTFSC  FF2.7
00EF0:  BSF    19.7
00EF2:  BCF    FF2.7
00EF4:  MOVFF  FE8,C2F
00EF8:  MOVLW  C8
00EFA:  MOVLB  C
00EFC:  MOVWF  x30
00EFE:  MOVLB  0
00F00:  CALL   0182
00F04:  BTFSC  19.7
00F06:  BSF    FF2.7
00F08:  MOVFF  00,1DB
....................     g_ui8ElementInQ--; 
00F0C:  MOVLB  1
00F0E:  DECF   xDD,F
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
00F10:  MOVLB  B
00F12:  CLRF   xF8
00F14:  MOVF   xF8,W
00F16:  SUBLW  0C
00F18:  BNC   0F80
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
00F1A:  CLRF   03
00F1C:  MOVF   xF8,W
00F1E:  ADDLW  2A
00F20:  MOVWF  01
00F22:  MOVLW  04
00F24:  ADDWFC 03,F
00F26:  MOVFF  03,BFC
00F2A:  CLRF   03
00F2C:  MOVLB  1
00F2E:  MOVF   xDB,W
00F30:  ADDLW  13
00F32:  MOVWF  FE9
00F34:  MOVLW  01
00F36:  ADDWFC 03,W
00F38:  MOVWF  FEA
00F3A:  MOVFF  FEF,BFD
00F3E:  MOVLB  B
00F40:  MOVFF  BFC,FEA
00F44:  MOVFF  01,FE9
00F48:  MOVFF  BFD,FEF
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F4C:  MOVLW  01
00F4E:  MOVLB  1
00F50:  ADDWF  xDB,W
00F52:  MOVLB  B
00F54:  MOVWF  xFC
00F56:  CLRF   19
00F58:  BTFSC  FF2.7
00F5A:  BSF    19.7
00F5C:  BCF    FF2.7
00F5E:  MOVFF  FE8,C2F
00F62:  MOVLW  C8
00F64:  MOVLB  C
00F66:  MOVWF  x30
00F68:  MOVLB  0
00F6A:  CALL   0182
00F6E:  BTFSC  19.7
00F70:  BSF    FF2.7
00F72:  MOVFF  00,1DB
....................         g_ui8ElementInQ--; 
00F76:  MOVLB  1
00F78:  DECF   xDD,F
00F7A:  MOVLB  B
00F7C:  INCF   xF8,F
00F7E:  BRA    0F14
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
00F80:  MOVLB  1
00F82:  MOVF   xDD,F
00F84:  BZ    0FCA
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00F86:  CLRF   03
00F88:  MOVF   xDB,W
00F8A:  ADDLW  13
00F8C:  MOVWF  FE9
00F8E:  MOVLW  01
00F90:  ADDWFC 03,W
00F92:  MOVWF  FEA
00F94:  MOVF   FEF,W
00F96:  SUBLW  A5
00F98:  BNZ   0F9C
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
00F9A:  BRA    0FCA
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F9C:  MOVLW  01
00F9E:  ADDWF  xDB,W
00FA0:  MOVLB  B
00FA2:  MOVWF  xFC
00FA4:  CLRF   19
00FA6:  BTFSC  FF2.7
00FA8:  BSF    19.7
00FAA:  BCF    FF2.7
00FAC:  MOVFF  FE8,C2F
00FB0:  MOVLW  C8
00FB2:  MOVLB  C
00FB4:  MOVWF  x30
00FB6:  MOVLB  0
00FB8:  CALL   0182
00FBC:  BTFSC  19.7
00FBE:  BSF    FF2.7
00FC0:  MOVFF  00,1DB
....................         g_ui8ElementInQ--; 
00FC4:  MOVLB  1
00FC6:  DECF   xDD,F
00FC8:  BRA    0F82
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
00FCA:  MOVLW  01
00FCC:  ADDWF  xDC,W
00FCE:  MOVLB  B
00FD0:  MOVWF  xFC
00FD2:  CLRF   19
00FD4:  BTFSC  FF2.7
00FD6:  BSF    19.7
00FD8:  BCF    FF2.7
00FDA:  MOVFF  FE8,C2F
00FDE:  MOVLW  C8
00FE0:  MOVLB  C
00FE2:  MOVWF  x30
00FE4:  MOVLB  0
00FE6:  CALL   0182
00FEA:  BTFSC  19.7
00FEC:  BSF    FF2.7
00FEE:  MOVFF  00,BF9
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
00FF2:  MOVLB  B
00FF4:  MOVF   xF9,W
00FF6:  MOVLB  1
00FF8:  SUBWF  xDB,W
00FFA:  BNZ   1002
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
00FFC:  SETF   xDC
00FFE:  MOVFF  1DC,1DB
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
01002:  MOVLB  4
01004:  MOVF   x2B,W
01006:  SUBLW  2C
01008:  BNZ   1018
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
0100A:  MOVFF  42A,BFB
0100E:  MOVLB  0
01010:  BRA    0AD4
....................         return; 
01012:  MOVLB  1
01014:  BRA    10EC
01016:  MOVLB  4
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
01018:  MOVF   x2B,W
0101A:  SUBLW  21
0101C:  BNZ   10EA
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
0101E:  MOVLW  04
01020:  MOVLB  C
01022:  MOVWF  x16
01024:  MOVLW  2A
01026:  MOVWF  x15
01028:  MOVLW  0B
0102A:  MOVWF  x17
0102C:  MOVLB  0
0102E:  RCALL  0B0E
01030:  MOVFF  02,446
01034:  MOVFF  01,445
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
01038:  MOVFF  446,BFB
0103C:  MOVLB  B
0103E:  CLRF   xFC
01040:  MOVLB  4
01042:  MOVF   x36,W
01044:  MOVLB  B
01046:  SUBWF  xFB,W
01048:  BNZ   10E8
0104A:  MOVF   xFC,F
0104C:  BNZ   10E8
0104E:  MOVFF  446,BFC
01052:  MOVFF  445,BFB
01056:  CLRF   xFC
01058:  MOVLB  4
0105A:  MOVF   x35,W
0105C:  MOVLB  B
0105E:  SUBWF  xFB,W
01060:  BNZ   10E8
01062:  MOVF   xFC,F
01064:  BNZ   10E8
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
01066:  MOVFF  42C,1F9
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
0106A:  MOVFF  42D,1FA
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
0106E:  MOVFF  42E,1FB
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
01072:  MOVFF  42F,1FC
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
01076:  MOVFF  430,1FD
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
0107A:  MOVFF  431,1FE
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
0107E:  MOVFF  432,1FF
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
01082:  MOVFF  433,200
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
01086:  MOVFF  434,201
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
0108A:  MOVLW  03
0108C:  MOVLB  C
0108E:  MOVWF  x03
01090:  MOVLW  5F
01092:  MOVWF  x02
01094:  MOVLW  01
01096:  MOVWF  x05
01098:  MOVLW  F7
0109A:  MOVWF  x04
0109C:  MOVLB  0
0109E:  RCALL  0BE2
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
010A0:  MOVLW  2C
010A2:  MOVLB  4
010A4:  MOVWF  x2B
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
010A6:  MOVLW  A5
010A8:  MOVLB  0
010AA:  RCALL  0DB2
....................             fputc(STX, UART); 
010AC:  MOVLW  A5
010AE:  RCALL  0DB2
....................             fputc(STX, UART); 
010B0:  MOVLW  A5
010B2:  RCALL  0DB2
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
010B4:  MOVLB  B
010B6:  CLRF   xF8
010B8:  MOVF   xF8,W
010BA:  SUBLW  0C
010BC:  BNC   10DC
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
010BE:  CLRF   03
010C0:  MOVF   xF8,W
010C2:  ADDLW  2A
010C4:  MOVWF  FE9
010C6:  MOVLW  04
010C8:  ADDWFC 03,W
010CA:  MOVWF  FEA
010CC:  MOVFF  FEF,BFB
010D0:  MOVF   xFB,W
010D2:  MOVLB  0
010D4:  RCALL  0DB2
010D6:  MOVLB  B
010D8:  INCF   xF8,F
010DA:  BRA    10B8
....................             } 
....................             fputc(ETX, UART); 
010DC:  MOVLW  B5
010DE:  MOVLB  0
010E0:  RCALL  0DB2
....................             fputc(ETX, UART); 
010E2:  MOVLW  B5
010E4:  RCALL  0DB2
010E6:  MOVLB  B
....................         } 
....................     } 
010E8:  MOVLB  4
010EA:  MOVLB  1
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
010EC:  MOVLB  0
010EE:  GOTO   45A8 (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
*
001CA:  MOVLB  0
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
001CC:  MOVLB  1
001CE:  MOVF   xDB,W
001D0:  SUBLW  FF
001D2:  BNZ   01D6
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
001D4:  CLRF   xDB
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
001D6:  MOVLW  01
001D8:  ADDWF  xDC,W
001DA:  MOVLB  C
001DC:  MOVWF  x2E
001DE:  MOVWF  x2F
001E0:  MOVLW  C8
001E2:  MOVWF  x30
001E4:  MOVLB  0
001E6:  RCALL  0182
001E8:  MOVFF  00,1DC
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
001EC:  CLRF   03
001EE:  MOVLB  1
001F0:  MOVF   xDC,W
001F2:  ADDLW  13
001F4:  MOVWF  FE9
001F6:  MOVLW  01
001F8:  ADDWFC 03,W
001FA:  MOVWF  FEA
001FC:  MOVFF  FEA,C30
00200:  MOVFF  FE9,C2F
00204:  MOVLB  0
00206:  BRA    01AE
00208:  MOVFF  C30,FEA
0020C:  MOVFF  C2F,FE9
00210:  MOVFF  01,FEF
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
00214:  MOVF   F98,W
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
00216:  MOVLB  E
00218:  BCF    x36.5
0021A:  MOVLB  0
0021C:  GOTO   0134
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED                   11 
.................... #define FLAG_DI_STATE_NOT_CHANGED               12 
....................  
.................... //#define CHECK_FOR_AT_RESPONSE                   15 
.................... //#define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... //#define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        10 // In Minutes. 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              40 // In Seconds. 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 // In Minutes. 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               18 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... #define  RESET_TIME_INTERVAL_COUNTING           20 
.................... #define  POWER_CUT_TIME_COUNTING                21 
.................... #define  NETWORK_RECONNECT_HALT_TIME_COUNTING   22 
.................... #define  MODEM_RESET_PROCESS_ON                 24 
.................... #define  MODEM_RESET_PROCESS_OFF                25 
.................... #define  PERIODIC_MODEM_RESET_TIMEOUT           30 // In minutes. 
....................  
.................... #define  TIME_STAMP_WRITE_INTERVAL_TIME         60 // In seconds. 
.................... #define  TIME_STAMP_SIGNAL_ON                   20 
.................... #define  TIME_STAMP_SIGNAL_COMPLETE             21 
....................  
.................... #define  KEEP_ALIVE_SEND_PROCESS_ON             33 
.................... #define  KEEP_ALIVE_SEND_PROCESS_OFF            44 
....................  
.................... #define  CHECK_FOR_QUERY_START                  45 
.................... #define  CHECK_FOR_QUERY_END                    46 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... unsigned int8  g_ui8TSWriteIntrvlCounter              = 0; 
.................... unsigned int8  g_fTSWriteToEEPROMSignal               = TIME_STAMP_SIGNAL_COMPLETE; 
.................... unsigned int8  g_ui8KeepAliveMonitoringCounter        = 180; 
.................... unsigned int8  g_fKeepAliveSendStatus                 = KEEP_ALIVE_SEND_PROCESS_OFF; 
.................... unsigned int8  g_fKeepAliveQueryCheck                 = CHECK_FOR_QUERY_END; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
*
005BE:  MOVLW  90
005C0:  MOVWF  FD5
005C2:  MOVLW  43
005C4:  MOVWF  FD6
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
005C6:  BTFSS  FD5.4
005C8:  BRA    05CE
005CA:  MOVLW  FD
005CC:  MOVWF  FD4
005CE:  MOVLW  8F
005D0:  MOVWF  FD3
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
005D2:  MOVLB  E
005D4:  BCF    x33.5
.................... 	enable_interrupts( INT_TIMER0 ); 
005D6:  BSF    x29.5
005D8:  MOVLB  0
005DA:  GOTO   4576 (RETURN)
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
*
00220:  MOVLB  0
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;   
00222:  MOVLB  5
00224:  INCF   x04,F
00226:  BTFSC  FD8.2
00228:  INCF   x05,F
....................      
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)   
0022A:  MOVF   x05,W
0022C:  SUBLW  02
0022E:  BC    0286
00230:  XORLW  FF
00232:  BNZ   023A
00234:  MOVF   x04,W
00236:  SUBLW  E7
00238:  BC    0286
....................     { 
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui32UnixTimeInSec++; 
0023A:  MOVLW  01
0023C:  MOVLB  0
0023E:  ADDWF  xC7,F
00240:  BTFSC  FD8.0
00242:  INCF   xC8,F
00244:  BTFSC  FD8.2
00246:  INCF   xC9,F
00248:  BTFSC  FD8.2
0024A:  INCF   xCA,F
....................  
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
0024C:  MOVLB  5
0024E:  CLRF   x05
00250:  CLRF   x04
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
00252:  INCF   x06,F
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
00254:  MOVF   x09,W
00256:  SUBLW  1A
00258:  BNZ   0260
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
0025A:  INCF   x0A,F
0025C:  BTFSC  FD8.2
0025E:  INCF   x0B,F
....................         } 
....................          
....................                  
....................         // Check for interval timeout to write time-stamp into EEPROM. 
....................         if(++g_ui8TSWriteIntrvlCounter >= TIME_STAMP_WRITE_INTERVAL_TIME) 
00260:  INCF   x0C,F
00262:  MOVF   x0C,W
00264:  SUBLW  3B
00266:  BC    027E
....................         { 
....................             // Reset counter. 
....................             g_ui8TSWriteIntrvlCounter = 0; 
00268:  CLRF   x0C
....................              
....................             // Hook current unix time. 
....................             g_ui32HookedUpTimeStampPerMinute = g_ui32UnixTimeInSec; 
0026A:  MOVFF  CA,98
0026E:  MOVFF  C9,97
00272:  MOVFF  C8,96
00276:  MOVFF  C7,95
....................              
....................             // Set flag to save current unix time to EEPROM. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_ON; 
0027A:  MOVLW  14
0027C:  MOVWF  x0D
....................         } 
....................          
....................         // Decrease keep alive monitoring counter at each second. 
....................         // and check if it meets zero level i.e. 180 seconds passed and no data in queue. 
....................         // Time to send Keep Alive to Server. 
....................         if(--g_ui8KeepAliveMonitoringCounter == 0) 
0027E:  DECFSZ x0E,F
00280:  BRA    0286
....................         { 
....................             // set flag to denote 180 seconds over. 
....................             // Time to send keep alive. 
....................             g_fKeepAliveSendStatus = KEEP_ALIVE_SEND_PROCESS_ON; 
00282:  MOVLW  21
00284:  MOVWF  x0F
....................         } 
....................     }    
....................      
....................      
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte)  
00286:  MOVF   3E,W
00288:  SUBLW  28
0028A:  BNZ   0290
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
0028C:  INCF   3F,F
....................     } 
0028E:  BRA    029C
....................     else if(MODBUS_IS_NOT_VALID_SLAVE_ID == g_fIsValidSlaveID) 
00290:  MOVLB  0
00292:  MOVF   x8A,W
00294:  SUBLW  0D
00296:  BNZ   029A
....................     { 
....................         // Increase counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter++; 
00298:  INCF   x8E,F
....................     } 
0029A:  MOVLB  5
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................       
....................     if(g_ui8UnexpectedSlaveIDIgnoreCounter >= ISR_TOTAL_8_BYTE_RECEIVE_TIME) 
0029C:  MOVLB  0
0029E:  MOVF   x8E,W
002A0:  SUBLW  02
002A2:  BC    02AE
....................     { 
....................         // Reset counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter = 0; 
002A4:  CLRF   x8E
....................          
....................         // Update flag status. 
....................         g_fIsValidSlaveID = MODBUS_IS_VALID_SLAVE_ID; 
002A6:  MOVLW  0C
002A8:  MOVWF  x8A
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002AA:  MOVLW  29
002AC:  MOVWF  3E
....................          
....................     }  
....................       
....................     if(g_ui8ISRReceiveByteTimeCounter > g_ui16ISRAllBytesExpectedRcvTime)  
002AE:  MOVF   x8C,F
002B0:  BNZ   02C2
002B2:  MOVF   3F,W
002B4:  SUBWF  x8B,W
002B6:  BC    02C2
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRReceivedByteStatus = ISR_RECEIVED_ALL_BYTES; 
002B8:  MOVLW  15
002BA:  MOVWF  x8D
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002BC:  MOVLW  29
002BE:  MOVWF  3E
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
002C0:  CLRF   3F
....................     }     
....................      
....................     // ############################### Non Critical ############################### 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay Start 
....................     //---------------------------------------------------- 
....................     if (IBU_WAIT_FOR_ACK_TIMEOUT_ON == g_fIBUMsgAckDelayStatus) 
002C2:  MOVLB  4
002C4:  DECFSZ x27,W
002C6:  BRA    02E4
....................     { 
....................         g_ui16IBUWaitForACKTikCount++; 
002C8:  INCF   x28,F
002CA:  BTFSC  FD8.2
002CC:  INCF   x29,F
....................         if (g_ui16IBUWaitForACKTikCount >= DELAY_IBU_MSG_ACK_NOT_RCV) 
002CE:  MOVF   x29,F
002D0:  BNZ   02D8
002D2:  MOVF   x28,W
002D4:  SUBLW  1D
002D6:  BC    02E4
....................         { 
....................             g_ui16IBUWaitForACKTikCount = 0; 
002D8:  CLRF   x29
002DA:  CLRF   x28
....................              
....................             // Reset flag denoting IBU is free now. 
....................             g_fIBUSendBusy = IBU_SENDING_FREE; 
002DC:  MOVLB  2
002DE:  CLRF   x99
....................              
....................             g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
002E0:  MOVLB  4
002E2:  CLRF   x27
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay End 
....................     //---------------------------------------------------- 
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
002E4:  MOVLB  5
002E6:  MOVF   x06,W
002E8:  SUBLW  3B
002EA:  BC    02EE
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
002EC:  CLRF   x06
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................     } 
....................      
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
002EE:  MOVLB  0
002F0:  MOVF   x92,F
002F2:  BZ    0326
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
002F4:  MOVLB  5
002F6:  INCF   x07,F
002F8:  BTFSC  FD8.2
002FA:  INCF   x08,F
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
002FC:  MOVLB  0
002FE:  MOVF   x91,W
00300:  MOVLB  5
00302:  SUBWF  x08,W
00304:  BNC   0328
00306:  BNZ   0312
00308:  MOVLB  0
0030A:  MOVF   x90,W
0030C:  MOVLB  5
0030E:  SUBWF  x07,W
00310:  BNC   0328
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
00312:  MOVLW  01
00314:  MOVLB  0
00316:  MOVWF  x8F
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
00318:  CLRF   x92
....................             g_ui16ShouldLookTimerCounter = 0; 
0031A:  MOVLB  5
0031C:  CLRF   x08
0031E:  CLRF   x07
....................             g_ui16TimeOutMilliseconds    = 0; 
00320:  MOVLB  0
00322:  CLRF   x91
00324:  CLRF   x90
00326:  MOVLB  5
....................         } 
....................     } 
....................          
....................     // Check if data send interval time reached timeout 
....................     if(g_ui16DataSendIntervalTime >= g_ui8DataSendingIntervalTime) 
00328:  MOVF   x0B,F
0032A:  BNZ   0336
0032C:  MOVLB  4
0032E:  MOVF   xEA,W
00330:  MOVLB  5
00332:  SUBWF  x0A,W
00334:  BNC   033E
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
00336:  MOVLW  19
00338:  MOVWF  x09
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
0033A:  CLRF   x0B
0033C:  CLRF   x0A
....................     } 
....................          
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
0033E:  BTFSS  FD5.4
00340:  BRA    0346
00342:  MOVLW  FD
00344:  MOVWF  FD4
00346:  MOVLW  8F
00348:  MOVWF  FD3
....................     clear_interrupt( INT_TIMER0 );	 
0034A:  MOVLB  E
0034C:  BCF    x33.5
0034E:  BCF    x33.5
00350:  MOVLB  0
00352:  GOTO   008A
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
.................... #include "vmIBCProcessM1.h" 
.................... /*  
....................  * File:   vmIBUProcessM1.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 11, 2018, 3:11 PM 
....................  */ 
....................  
.................... #ifndef VM_IBU_PROCESS_M1_H 
.................... #define	VM_IBU_PROCESS_M1_H 
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... //#include "vmSIM900_GPRSConfig.h" 
.................... //#include "vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
*
01DAE:  MOVF   FF2,W
01DB0:  MOVWF  00
01DB2:  BCF    FF2.7
01DB4:  MOVFF  C04,F75
01DB8:  MOVFF  C03,F74
01DBC:  MOVFF  C05,F76
01DC0:  BCF    F77.6
01DC2:  BCF    F77.7
01DC4:  BSF    F77.2
01DC6:  MOVLB  F
01DC8:  MOVLW  55
01DCA:  MOVWF  F78
01DCC:  MOVLW  AA
01DCE:  MOVWF  F78
01DD0:  BSF    F77.1
01DD2:  BTFSC  F77.1
01DD4:  BRA    1DD2
01DD6:  BCF    F77.2
01DD8:  BCF    F77.6
01DDA:  BSF    F77.7
01DDC:  MOVF   00,W
01DDE:  IORWF  FF2,F
01DE0:  MOVLB  0
01DE2:  RETURN 0
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
*
03B0C:  MOVLB  C
03B0E:  CLRF   x02
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
03B10:  MOVFF  C01,C02
....................     write_eeprom(uiAddress,uiTemp); 
03B14:  MOVF   FF2,W
03B16:  MOVWF  00
03B18:  BCF    FF2.7
03B1A:  MOVFF  BFF,F75
03B1E:  MOVFF  BFE,F74
03B22:  MOVFF  C02,F76
03B26:  BCF    F77.6
03B28:  BCF    F77.7
03B2A:  BSF    F77.2
03B2C:  MOVLB  F
03B2E:  MOVLW  55
03B30:  MOVWF  F78
03B32:  MOVLW  AA
03B34:  MOVWF  F78
03B36:  BSF    F77.1
03B38:  BTFSC  F77.1
03B3A:  BRA    3B38
03B3C:  BCF    F77.2
03B3E:  BCF    F77.6
03B40:  BSF    F77.7
03B42:  MOVF   00,W
03B44:  IORWF  FF2,F
....................     // Increment write address. 
....................     uiAddress++; 
03B46:  MOVLB  B
03B48:  INCF   xFE,F
03B4A:  BTFSC  FD8.2
03B4C:  INCF   xFF,F
....................     // Write second byte. 
....................     uiTemp = 0; 
03B4E:  MOVLB  C
03B50:  CLRF   x02
....................     uiTemp = uiValue & 0x00FF; 
03B52:  MOVFF  C00,C02
....................     write_eeprom(uiAddress,uiTemp); 
03B56:  MOVF   FF2,W
03B58:  MOVWF  00
03B5A:  BCF    FF2.7
03B5C:  MOVFF  BFF,F75
03B60:  MOVFF  BFE,F74
03B64:  MOVFF  C02,F76
03B68:  BCF    F77.6
03B6A:  BCF    F77.7
03B6C:  BSF    F77.2
03B6E:  MOVLB  F
03B70:  MOVLW  55
03B72:  MOVWF  F78
03B74:  MOVLW  AA
03B76:  MOVWF  F78
03B78:  BSF    F77.1
03B7A:  BTFSC  F77.1
03B7C:  BRA    3B7A
03B7E:  BCF    F77.2
03B80:  BCF    F77.6
03B82:  BSF    F77.7
03B84:  MOVF   00,W
03B86:  IORWF  FF2,F
03B88:  MOVLB  0
03B8A:  RETURN 0
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
*
00714:  MOVLB  B
00716:  CLRF   xFB
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
00718:  MOVFF  FF2,BFC
0071C:  BCF    FF2.7
0071E:  MOVFF  BFA,F75
00722:  MOVFF  BF9,F74
00726:  BCF    F77.6
00728:  BCF    F77.7
0072A:  BSF    F77.0
0072C:  MOVF   F76,W
0072E:  BCF    F77.6
00730:  BSF    F77.7
00732:  BTFSC  xFC.7
00734:  BSF    FF2.7
00736:  MOVWF  xFB
....................  
....................     return uiValue; 
00738:  MOVFF  BFB,01
0073C:  MOVLB  0
0073E:  RETURN 0
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
*
00790:  MOVLB  C
00792:  CLRF   x01
00794:  CLRF   x00
00796:  CLRF   x03
00798:  CLRF   x02
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
0079A:  MOVFF  FF2,C04
0079E:  BCF    FF2.7
007A0:  MOVFF  BFF,F75
007A4:  MOVFF  BFE,F74
007A8:  BCF    F77.6
007AA:  BCF    F77.7
007AC:  BSF    F77.0
007AE:  MOVF   F76,W
007B0:  BCF    F77.6
007B2:  BSF    F77.7
007B4:  BTFSC  x04.7
007B6:  BSF    FF2.7
007B8:  CLRF   x03
007BA:  MOVWF  x02
....................     uiValue = uiTemp << 8; 
007BC:  MOVFF  C02,C01
007C0:  CLRF   x00
....................     // Increment read address. 
....................     uiAddress++; 
007C2:  MOVLB  B
007C4:  INCF   xFE,F
007C6:  BTFSC  FD8.2
007C8:  INCF   xFF,F
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
007CA:  MOVFF  FF2,C04
007CE:  BCF    FF2.7
007D0:  MOVFF  BFF,F75
007D4:  MOVFF  BFE,F74
007D8:  BCF    F77.6
007DA:  BCF    F77.7
007DC:  BSF    F77.0
007DE:  MOVF   F76,W
007E0:  BCF    F77.6
007E2:  BSF    F77.7
007E4:  MOVLB  C
007E6:  BTFSC  x04.7
007E8:  BSF    FF2.7
007EA:  CLRF   x03
007EC:  MOVWF  x02
....................     uiValue = uiValue | uiTemp; 
007EE:  MOVF   x02,W
007F0:  IORWF  x00,F
007F2:  MOVF   x03,W
007F4:  IORWF  x01,F
....................  
....................     return uiValue; 
007F6:  MOVFF  C00,01
007FA:  MOVFF  C01,02
007FE:  MOVLB  0
00800:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
*
01DE4:  MOVLB  C
01DE6:  CLRF   x04
01DE8:  MOVLW  0A
01DEA:  MOVWF  x03
01DEC:  MOVFF  C02,C05
01DF0:  MOVLB  0
01DF2:  RCALL  1DAE
01DF4:  GOTO   374E (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
*
00740:  MOVLB  B
00742:  CLRF   xF8
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
00744:  CLRF   xFA
00746:  MOVLW  0A
00748:  MOVWF  xF9
0074A:  MOVLB  0
0074C:  RCALL  0714
0074E:  MOVFF  01,BF8
....................      
....................     return ui8MachineID; 
00752:  MOVLB  B
00754:  MOVFF  BF8,01
00758:  MOVLB  0
0075A:  GOTO   0766 (RETURN)
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
*
01DF8:  MOVLB  C
01DFA:  CLRF   x04
01DFC:  MOVLW  0C
01DFE:  MOVWF  x03
01E00:  MOVFF  C02,C05
01E04:  MOVLB  0
01E06:  RCALL  1DAE
01E08:  GOTO   374E (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
*
00772:  MOVLB  B
00774:  CLRF   xF7
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
00776:  CLRF   xFA
00778:  MOVLW  0C
0077A:  MOVWF  xF9
0077C:  MOVLB  0
0077E:  RCALL  0714
00780:  MOVFF  01,BF7
....................      
....................     return ui8DataSendInterval; 
00784:  MOVLB  B
00786:  MOVFF  BF7,01
0078A:  MOVLB  0
0078C:  GOTO   0958 (RETURN)
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
*
03B8C:  MOVLB  B
03B8E:  CLRF   xFC
03B90:  CLRF   xFB
03B92:  CLRF   xFD
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
03B94:  MOVLW  11
03B96:  MOVWF  xFD
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
03B98:  MOVFF  BFA,BFC
03B9C:  MOVFF  BF9,BFB
03BA0:  MOVLB  C
03BA2:  CLRF   03
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03BA4:  MOVLB  B
03BA6:  CLRF   xFF
03BA8:  MOVFF  BFD,BFE
03BAC:  MOVFF  BFC,C01
03BB0:  MOVFF  BFB,C00
03BB4:  MOVLB  0
03BB6:  RCALL  3B0C
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
03BB8:  MOVLW  02
03BBA:  MOVLB  B
03BBC:  ADDWF  xFD,F
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
03BBE:  MOVFF  BFA,C02
03BC2:  MOVFF  BF9,C01
03BC6:  MOVFF  BF8,BFC
03BCA:  MOVFF  BF7,BFB
03BCE:  MOVLB  C
03BD0:  CLRF   03
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03BD2:  MOVLB  B
03BD4:  CLRF   xFF
03BD6:  MOVFF  BFD,BFE
03BDA:  MOVFF  BFC,C01
03BDE:  MOVFF  BFB,C00
03BE2:  MOVLB  0
03BE4:  RCALL  3B0C
03BE6:  GOTO   4618 (RETURN)
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
*
00802:  MOVLB  B
00804:  CLRF   xFA
00806:  CLRF   xF9
00808:  CLRF   xF8
0080A:  CLRF   xF7
0080C:  CLRF   xFC
0080E:  CLRF   xFB
00810:  CLRF   xFD
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
00812:  MOVLW  11
00814:  MOVWF  xFD
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00816:  CLRF   xFF
00818:  MOVFF  BFD,BFE
0081C:  MOVLB  0
0081E:  RCALL  0790
00820:  MOVFF  02,BFC
00824:  MOVFF  01,BFB
....................     ui32StoredUnixTime = ui16Temp; 
00828:  MOVLB  B
0082A:  CLRF   xFA
0082C:  CLRF   xF9
0082E:  MOVFF  BFC,BF8
00832:  MOVFF  BFB,BF7
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
00836:  MOVFF  BF8,BFA
0083A:  MOVFF  BF7,BF9
0083E:  CLRF   xF7
00840:  CLRF   xF8
....................     ui8EEPROMAddress += 2; 
00842:  MOVLW  02
00844:  ADDWF  xFD,F
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00846:  CLRF   xFF
00848:  MOVFF  BFD,BFE
0084C:  MOVLB  0
0084E:  RCALL  0790
00850:  MOVFF  02,BFC
00854:  MOVFF  01,BFB
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
00858:  MOVLB  B
0085A:  CLRF   xFE
0085C:  CLRF   xFF
0085E:  MOVFF  BF9,BF9
00862:  MOVFF  BFA,BFA
00866:  MOVLB  B
00868:  MOVF   xFE,W
0086A:  IORWF  xFB,W
0086C:  MOVWF  xF7
0086E:  MOVF   xFF,W
00870:  IORWF  xFC,W
00872:  MOVWF  xF8
00874:  MOVLB  B
00876:  MOVLB  B
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
00878:  MOVLW  1E
0087A:  ADDWF  xF7,F
0087C:  MOVLW  00
0087E:  ADDWFC xF8,F
00880:  ADDWFC xF9,F
00882:  ADDWFC xFA,F
....................      
....................     return ui32StoredUnixTime;     
00884:  MOVFF  BF7,00
00888:  MOVFF  BF8,01
0088C:  MOVFF  BF9,02
00890:  MOVFF  BFA,03
00894:  MOVLB  0
00896:  GOTO   095E (RETURN)
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
*
01E0C:  MOVLB  C
01E0E:  CLRF   x04
01E10:  MOVLW  16
01E12:  MOVWF  x03
01E14:  MOVFF  C02,C05
01E18:  MOVLB  0
01E1A:  RCALL  1DAE
01E1C:  GOTO   374E (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
*
0089A:  MOVLB  B
0089C:  CLRF   xF7
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
0089E:  CLRF   xFA
008A0:  MOVLW  16
008A2:  MOVWF  xF9
008A4:  MOVLB  0
008A6:  RCALL  0714
008A8:  MOVFF  01,BF7
....................      
....................     return ui8SIMOperatorID;     
008AC:  MOVLB  B
008AE:  MOVFF  BF7,01
008B2:  MOVLB  0
008B4:  GOTO   0970 (RETURN)
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                15             
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_9          9 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int32             m_i32PipeWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... //ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
.................... } 
....................  
.................... //unsigned int8 CountDataSize(unsigned int32 ui32Data) 
.................... //{ 
.................... //    unsigned int8 ui8DataLen = 0; 
.................... //     
.................... //    if(ui32Data <= 9) 
.................... //    { 
.................... //        ui8DataLen = 1; 
.................... //    } 
.................... //    else if(ui32Data <= 99) 
.................... //    { 
.................... //        ui8DataLen = 2; 
.................... //    } 
.................... //    else if(ui32Data <= 999) 
.................... //    { 
.................... //        ui8DataLen = 3; 
.................... //    } 
.................... //    else if(ui32Data <= 9999) 
.................... //    { 
.................... //        ui8DataLen = 4; 
.................... //    } 
.................... //    else if(ui32Data <= 99999) 
.................... //    { 
.................... //        ui8DataLen = 5; 
.................... //    } 
.................... //    else if(ui32Data <= 999999) 
.................... //    { 
.................... //        ui8DataLen = 6; 
.................... //    } 
.................... //    else if(ui32Data <= 9999999) 
.................... //    { 
.................... //        ui8DataLen = 7; 
.................... //    } 
.................... //    else if(ui32Data <= 99999999) 
.................... //    { 
.................... //        ui8DataLen = 8; 
.................... //    } 
.................... //    else if(ui32Data <= 999999999) 
.................... //    { 
.................... //        ui8DataLen = 9; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8DataLen = 10; 
.................... //    } 
.................... // 
.................... //     
.................... //    return ui8DataLen; 
.................... //} 
....................  
.................... //void CheckURLInputByteLength(void) 
.................... //{ 
.................... //    unsigned int8 ui8DataByte = 0; 
.................... //     
.................... //    // Basic byte count is 75 bytes. 
.................... //    // Here the dynamic/ changing variables are considered to count byte length. 
.................... // 
.................... //    // Check for Machine ID. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui8MachineID); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 1. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16BasicMaterialStandard); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 2. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16PipeSpecification); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 3. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MaxWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //        // Check for header parameter - 4. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MinWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //     
.................... //     
.................... //    // Check for TimeStamp. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Sequence number. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Item weight. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Rejection status. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... // 
.................... //} 
....................  
....................  
.................... //void InitializeGPRSMsgQueue(void) 
.................... //{ 
.................... //    // Initialize front and rear of the queue 
.................... //    g_stGPRSMsgSendQueue.m_i8Front = -1; 
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = -1; 
.................... //     
.................... //    // Initialize each queue element 
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
.................... //    } 
....................  
.................... //} 
....................  
.................... //unsigned int8 IsGPRSMsgQueueEmpty(void) 
.................... //{ 
.................... //    unsigned int8 ui8QueueStatus = 0; 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        ui8QueueStatus = 1;  
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8QueueStatus = 0; 
.................... //    } 
.................... //    return ui8QueueStatus; 
.................... //} 
....................  
....................  
.................... //void InsertInGPRSMsgQueue() 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
.................... //    //g_stGPRSMsgSendQueue.m_ui8QArr[g_stGPRSMsgSendQueue.m_ui8Rear] = ui8Element; 
.................... //} 
....................  
.................... //void InsertInGPRSQueue(void) 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = 99; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = 999;     
.................... //} 
....................  
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................      
....................  
....................     // Fetch Machine ID from memory. 
....................     g_ui8MachineID = ReadMachineIDFromEEPROM();     
....................     //g_stGPRSMsgHeader.m_ui8MachineID = g_ui8MachineID;  // Delta 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... //unsigned int8 SetPDPContext(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt(); 
.................... //    // Set AT command for define PDP Context.     
.................... //    if(1 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"airtelgprs.com\"\r", GSM_M66);    // For Airtel SIM. 
.................... //    } 
.................... //    else if (2 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"internet\"\r", GSM_M66);          // For Idea SIM. 
.................... //    } 
.................... //    else if (3 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66);               // For Vodafone SIM. 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    }                                      
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 ActivatePDP(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to activate PDP context. 
.................... //    fputs("AT+CGACT=1,1\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(5); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Restart WDT. 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //}  
....................  
.................... //unsigned int8 ShowActivatedAddress(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound            = 1; 
.................... //    unsigned int8 ui8FirstCharSequenceFound     = 0; 
.................... //    unsigned int8 ui8FirstCharSeqIndex          = 0; 
.................... //    unsigned int8 ui8SecondCharSequenceFound    = 0; 
.................... //    unsigned int8 ui8DoubleQuoteCount           = 0; 
.................... //    
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to Show activated PDP address. 
.................... //    fputs("AT+CGPADDR=1\r",GSM_M66); 
.................... //    mz_delay_ms(2000); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Reset timeout flag. 
.................... //     g_fIsTimedOut = 0; 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Reset variables. 
.................... //        ui8FirstCharSequenceFound  = 0; 
.................... //        ui8FirstCharSeqIndex       = 0; 
.................... //        ui8SecondCharSequenceFound = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence has found. 
.................... //                    ui8FirstCharSequenceFound = 1; 
.................... //                    // Copy the first character sequence index. 
.................... //                    ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for second character sequence set. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
.................... //                { 
.................... //                    // Increment double quote count. 
.................... //                    ui8DoubleQuoteCount++; 
.................... //                    // Check double quote count. 
.................... //                    if(2 == ui8DoubleQuoteCount) 
.................... //                    { 
.................... //                        // Reset double quote count. 
.................... //                        ui8DoubleQuoteCount = 0; 
.................... //                        // loop through to check second quote count. 
.................... //                        for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
.................... //                        { 
.................... //                            // Check for stop count. 
.................... //                            if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
.................... //                            { 
.................... //                                // Increase stop. 
.................... //                                ui8DoubleQuoteCount++; 
.................... //                                // Check limiting stop count. 
.................... //                                if(3 == ui8DoubleQuoteCount) 
.................... //                                { 
.................... //                                    // Set flag denoting second character sequence has found. 
.................... //                                    ui8SecondCharSequenceFound = 1; 
.................... //                                    break; 
.................... //                                } 
.................... //                            }     
.................... //                        } 
.................... //                         
.................... //                         
.................... //                    } 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for OK. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsResponseFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //            } 
.................... //        } 
.................... //         
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //void SendGPRSConnectionQuery(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(3); 
.................... // 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnectionQueryResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //     
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSequenceFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //            { 
.................... //                // Set flag denoting first character sequence found. 
.................... //                ui8IsFirstCharSequenceFound = 1; 
.................... //                // Copy the index of the first character of the sequence. 
.................... //                ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //            } 
.................... //        } 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSequenceFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS not connected. 
.................... //                ui8IsResponseFound = 0; 
.................... //                break; 
.................... //            } 
.................... //            else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS connected. 
.................... //                ui8IsResponseFound = 1; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... //unsigned int8 SetHTTPURL(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsSetURLOk = 1; 
.................... //    unsigned int8 ui8IsConnectionDone = 0; 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 93; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Increment variables. 
.................... //    g_ui16Itm1SequenceNumber += 2; 
.................... //    g_ui16Itm2SequenceNumber += 2; 
.................... //    g_ui16ItemWeight++; 
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //            { 
.................... //                // Set flag denote connection is established. 
.................... //                ui8IsConnectionDone = 1; 
.................... //                break; 
.................... //            }        
.................... //        } 
.................... //         
.................... //        // set URL in buffer. 
.................... //        if(ui8IsConnectionDone) 
.................... //        { 
.................... //            // Set web service URL. 
.................... //            fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
.................... //            delay_ms(300); 
.................... //            // Check for "OK". 
.................... //            for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //                { 
.................... //                    // Set flag denoting Set URL successfully. 
.................... //                    ui8IsSetURLOk = 0; 
.................... //                    break; 
.................... //                } 
.................... //            }     
.................... //        } 
.................... //         
.................... //        
.................... //    } 
.................... //     
.................... //    return ui8IsSetURLOk; 
.................... //     
.................... //} 
....................  
.................... //void SetHTTPURLParameter(void) 
.................... //{ 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 75; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //     
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //     
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(2); 
.................... //} 
....................  
.................... //unsigned int8 SetHTTPURLL(void) 
.................... //{ 
.................... //    unsigned int8  ui8IsSetURLOk       = 1; 
.................... //    unsigned int8  ui8IsConnectionDone = 0; 
.................... //    unsigned int16 ui16ByteCount       = 0; 
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //        { 
.................... //            // Set flag denote connection is established. 
.................... //            ui8IsConnectionDone = 1; 
.................... //            break; 
.................... //        }        
.................... //    } 
.................... //     
.................... //    // set URL in buffer. 
.................... //    if(ui8IsConnectionDone) 
.................... //    { 
.................... // 
.................... //        // Set web service URL. 
.................... //        fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8MachineID, g_stGPRSMsgHeader.m_ui16BasicMaterialStandard, g_stGPRSMsgHeader.m_ui16PipeSpecification,g_stGPRSMsgHeader.m_ui16MaxWeight,g_stGPRSMsgHeader.m_ui16MinWeight, 
.................... //                                                                                                                                 g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... // 
.................... //         
.................... //        //delay_ms(300); 
.................... //        mz_delay_ms(300); 
.................... //        // Check for "OK". 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsSetURLOk = 0; 
.................... //                break; 
.................... //            } 
.................... //        }     
.................... //    } 
.................... // 
.................... //    return ui8IsSetURLOk; 
.................... //} 
....................  
.................... //void SendHTTPGetSessionRequest(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(10); 
.................... //} 
....................  
.................... //unsigned int8 CheckHTTPGETRequestResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    unsigned int8 ui8IsFirstCharSeqFound  = 0; 
.................... //    unsigned int8 ui8IsSecondCharSeqFound = 0; 
.................... //    unsigned int8 ui8CharSeqIndex         = 0; 
.................... //    unsigned int8 ui8CommaCount           = 0; 
.................... //     
.................... //    // Loop through entire receive buffer 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting that first character sequence is found. 
.................... //                ui8IsFirstCharSeqFound = 1; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
.................... //            { 
.................... //                // Set flag denoting that second character sequence has found. 
.................... //                ui8IsSecondCharSeqFound = 1; 
.................... //            }  
.................... // 
.................... //        } 
.................... // 
.................... //        // Check for third character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
.................... //            { 
.................... //                // Increase comma count 
.................... //                ui8CommaCount++; 
.................... //                // Check for comma count level 
.................... //                if(ui8CommaCount == 2) 
.................... //                { 
.................... //                    // Check for success message code. 
.................... //                    if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
.................... //                    { 
.................... //                        // Set flag denoting that success message code found. 
.................... //                        ui8IsOKFound = 0; 
.................... //                        break; 
.................... //                    } 
.................... //                } 
.................... //            }     
.................... //        } 
.................... // 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
*
005F6:  MOVLB  E
005F8:  MOVF   xDC,W
....................     enable_interrupts(INT_RDA5); 
005FA:  BSF    x2D.5
005FC:  MOVLB  0
005FE:  GOTO   4582 (RETURN)
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
*
0422A:  MOVLW  07
0422C:  MOVWF  FEA
0422E:  MOVLW  1F
04230:  MOVWF  FE9
04232:  CLRF   00
04234:  CLRF   02
04236:  MOVLW  14
04238:  MOVWF  01
0423A:  CALL   09CC
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
0423E:  MOVLB  7
04240:  CLRF   x33
04242:  MOVLB  0
04244:  GOTO   42B4 (RETURN)
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
*
0075E:  MOVLB  B
00760:  CLRF   xF7
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
00762:  MOVLB  0
00764:  BRA    0740
00766:  MOVFF  01,BF7
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
0076A:  MOVFF  BF7,99
0076E:  GOTO   0956 (RETURN)
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
*
00372:  MOVLB  0
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
00374:  CLRF   03
00376:  MOVLB  7
00378:  MOVF   x33,W
0037A:  ADDLW  1F
0037C:  MOVWF  FE9
0037E:  MOVLW  07
00380:  ADDWFC 03,W
00382:  MOVWF  FEA
00384:  MOVFF  FEA,C2A
00388:  MOVFF  FE9,C29
0038C:  MOVLB  0
0038E:  BRA    0356
00390:  MOVFF  C2A,FEA
00394:  MOVFF  C29,FE9
00398:  MOVFF  01,FEF
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
0039C:  MOVLB  7
0039E:  INCF   x33,F
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
003A0:  MOVF   x33,W
003A2:  SUBLW  13
003A4:  BC    03A8
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
003A6:  CLRF   x33
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
003A8:  MOVLB  E
003AA:  MOVF   xDC,W
003AC:  BCF    x37.5
003AE:  MOVLB  0
003B0:  GOTO   008A
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
*
00602:  MOVLB  B
00604:  SETF   x80
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
00606:  SETF   x81
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
00608:  CLRF   xF7
0060A:  MOVF   xF7,W
0060C:  SUBLW  63
0060E:  BTFSS  FD8.0
00610:  BRA    070E
00612:  CLRF   19
00614:  BTFSC  FF2.7
00616:  BSF    19.7
00618:  BCF    FF2.7
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
0061A:  MOVLB  C
0061C:  CLRF   x29
0061E:  MOVFF  BF7,C28
00622:  CLRF   x2B
00624:  MOVLW  0B
00626:  MOVWF  x2A
00628:  MOVLB  0
0062A:  RCALL  0432
0062C:  BTFSC  19.7
0062E:  BSF    FF2.7
00630:  MOVFF  01,BF8
00634:  MOVLW  06
00636:  MOVLB  B
00638:  ADDWF  01,W
0063A:  MOVWF  01
0063C:  MOVLW  00
0063E:  ADDWFC 02,W
00640:  MOVWF  03
00642:  MOVF   01,W
00644:  ADDLW  34
00646:  MOVWF  FE9
00648:  MOVLW  07
0064A:  ADDWFC 03,W
0064C:  MOVWF  FEA
0064E:  CLRF   FEF
00650:  CLRF   FEC
00652:  CLRF   FEC
00654:  CLRF   FEC
00656:  CLRF   19
00658:  BTFSC  FF2.7
0065A:  BSF    19.7
0065C:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
0065E:  MOVLB  C
00660:  CLRF   x29
00662:  MOVFF  BF7,C28
00666:  CLRF   x2B
00668:  MOVLW  0B
0066A:  MOVWF  x2A
0066C:  MOVLB  0
0066E:  RCALL  0432
00670:  BTFSC  19.7
00672:  BSF    FF2.7
00674:  MOVFF  01,BF8
00678:  MOVLW  04
0067A:  MOVLB  B
0067C:  ADDWF  01,W
0067E:  MOVWF  01
00680:  MOVLW  00
00682:  ADDWFC 02,W
00684:  MOVWF  03
00686:  MOVF   01,W
00688:  ADDLW  34
0068A:  MOVWF  FE9
0068C:  MOVLW  07
0068E:  ADDWFC 03,W
00690:  MOVWF  FEA
00692:  CLRF   FEC
00694:  MOVF   FED,F
00696:  CLRF   FEF
00698:  CLRF   19
0069A:  BTFSC  FF2.7
0069C:  BSF    19.7
0069E:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
006A0:  MOVLB  C
006A2:  CLRF   x29
006A4:  MOVFF  BF7,C28
006A8:  CLRF   x2B
006AA:  MOVLW  0B
006AC:  MOVWF  x2A
006AE:  MOVLB  0
006B0:  RCALL  0432
006B2:  BTFSC  19.7
006B4:  BSF    FF2.7
006B6:  MOVLW  34
006B8:  MOVLB  B
006BA:  ADDWF  01,W
006BC:  MOVWF  FE9
006BE:  MOVLW  07
006C0:  ADDWFC 02,W
006C2:  MOVWF  FEA
006C4:  CLRF   FEF
006C6:  CLRF   FEC
006C8:  CLRF   FEC
006CA:  CLRF   FEC
006CC:  CLRF   19
006CE:  BTFSC  FF2.7
006D0:  BSF    19.7
006D2:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
006D4:  MOVLB  C
006D6:  CLRF   x29
006D8:  MOVFF  BF7,C28
006DC:  CLRF   x2B
006DE:  MOVLW  0B
006E0:  MOVWF  x2A
006E2:  MOVLB  0
006E4:  RCALL  0432
006E6:  BTFSC  19.7
006E8:  BSF    FF2.7
006EA:  MOVFF  01,BF8
006EE:  MOVLW  0A
006F0:  MOVLB  B
006F2:  ADDWF  01,W
006F4:  MOVWF  01
006F6:  MOVLW  00
006F8:  ADDWFC 02,W
006FA:  MOVWF  03
006FC:  MOVF   01,W
006FE:  ADDLW  34
00700:  MOVWF  FE9
00702:  MOVLW  07
00704:  ADDWFC 03,W
00706:  MOVWF  FEA
00708:  CLRF   FEF
0070A:  INCF   xF7,F
0070C:  BRA    060A
....................     } 
0070E:  MOVLB  0
00710:  GOTO   0954 (RETURN)
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
*
03BEA:  MOVLB  B
03BEC:  CLRF   xF7
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
03BEE:  MOVF   x80,W
03BF0:  SUBLW  FF
03BF2:  BNZ   3BFA
....................     { 
....................         ui8QueueStatus = 1;  
03BF4:  MOVLW  01
03BF6:  MOVWF  xF7
....................     } 
03BF8:  BRA    3BFC
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
03BFA:  CLRF   xF7
....................     } 
....................     return ui8QueueStatus; 
03BFC:  MOVFF  BF7,01
03C00:  MOVLB  0
03C02:  GOTO   4636 (RETURN)
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
*
011FC:  MOVLB  B
011FE:  MOVF   x80,W
01200:  SUBLW  FF
01202:  BNZ   1206
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
01204:  CLRF   x80
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
01206:  MOVLW  01
01208:  ADDWF  x81,W
0120A:  MOVLB  C
0120C:  MOVWF  x06
0120E:  CLRF   19
01210:  BTFSC  FF2.7
01212:  BSF    19.7
01214:  BCF    FF2.7
01216:  MOVWF  x2F
01218:  MOVLW  64
0121A:  MOVWF  x30
0121C:  MOVLB  0
0121E:  CALL   0182
01222:  BTFSC  19.7
01224:  BSF    FF2.7
01226:  MOVFF  00,B81
0122A:  CLRF   19
0122C:  BTFSC  FF2.7
0122E:  BSF    19.7
01230:  BCF    FF2.7
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
01232:  MOVLB  C
01234:  CLRF   x29
01236:  MOVFF  B81,C28
0123A:  CLRF   x2B
0123C:  MOVLW  0B
0123E:  MOVWF  x2A
01240:  MOVLB  0
01242:  CALL   0432
01246:  BTFSC  19.7
01248:  BSF    FF2.7
0124A:  MOVFF  01,C05
0124E:  MOVLW  04
01250:  MOVLB  C
01252:  ADDWF  01,W
01254:  MOVWF  01
01256:  MOVLW  00
01258:  ADDWFC 02,W
0125A:  MOVWF  03
0125C:  MOVF   01,W
0125E:  ADDLW  34
01260:  MOVWF  FE9
01262:  MOVLW  07
01264:  ADDWFC 03,W
01266:  MOVWF  FEA
01268:  MOVFF  717,FEC
0126C:  MOVF   FED,F
0126E:  MOVFF  716,FEF
01272:  CLRF   19
01274:  BTFSC  FF2.7
01276:  BSF    19.7
01278:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
0127A:  CLRF   x29
0127C:  MOVFF  B81,C28
01280:  CLRF   x2B
01282:  MOVLW  0B
01284:  MOVWF  x2A
01286:  MOVLB  0
01288:  CALL   0432
0128C:  BTFSC  19.7
0128E:  BSF    FF2.7
01290:  MOVFF  01,C05
01294:  MOVLW  06
01296:  MOVLB  C
01298:  ADDWF  01,W
0129A:  MOVWF  01
0129C:  MOVLW  00
0129E:  ADDWFC 02,W
012A0:  MOVWF  03
012A2:  MOVF   01,W
012A4:  ADDLW  34
012A6:  MOVWF  FE9
012A8:  MOVLW  07
012AA:  ADDWFC 03,W
012AC:  MOVWF  FEA
012AE:  MOVFF  712,FEF
012B2:  MOVFF  713,FEC
012B6:  MOVFF  714,FEC
012BA:  MOVFF  715,FEC
012BE:  CLRF   19
012C0:  BTFSC  FF2.7
012C2:  BSF    19.7
012C4:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
012C6:  CLRF   x29
012C8:  MOVFF  B81,C28
012CC:  CLRF   x2B
012CE:  MOVLW  0B
012D0:  MOVWF  x2A
012D2:  MOVLB  0
012D4:  CALL   0432
012D8:  BTFSC  19.7
012DA:  BSF    FF2.7
012DC:  MOVFF  01,C05
012E0:  MOVLW  0A
012E2:  MOVLB  C
012E4:  ADDWF  01,W
012E6:  MOVWF  01
012E8:  MOVLW  00
012EA:  ADDWFC 02,W
012EC:  MOVWF  03
012EE:  MOVF   01,W
012F0:  ADDLW  34
012F2:  MOVWF  FE9
012F4:  MOVLW  07
012F6:  ADDWFC 03,W
012F8:  MOVWF  FEA
012FA:  MOVFF  718,FEF
012FE:  CLRF   19
01300:  BTFSC  FF2.7
01302:  BSF    19.7
01304:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
01306:  CLRF   x29
01308:  MOVFF  B81,C28
0130C:  CLRF   x2B
0130E:  MOVLW  0B
01310:  MOVWF  x2A
01312:  MOVLB  0
01314:  CALL   0432
01318:  BTFSC  19.7
0131A:  BSF    FF2.7
0131C:  MOVLW  34
0131E:  MOVLB  C
01320:  ADDWF  01,W
01322:  MOVWF  FE9
01324:  MOVLW  07
01326:  ADDWFC 02,W
01328:  MOVWF  FEA
0132A:  MOVFF  71A,FEF
0132E:  MOVFF  71B,FEC
01332:  MOVFF  71C,FEC
01336:  MOVFF  71D,FEC
0133A:  MOVLB  0
0133C:  GOTO   157C (RETURN)
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
*
03EE0:  CLRF   19
03EE2:  BTFSC  FF2.7
03EE4:  BSF    19.7
03EE6:  BCF    FF2.7
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/ipptv2/?a=%u&b=%Lu&c=%Lu&d=%u&e=%Lu&f=%u&g=%Lu&h=%Lu&i=%Lu&j=%Lu&k=%Lu&l=%Lu&m=%Lu&n=%Lu&o=%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16StandardSpecification,g_stLANDataHeader.m_ui8PressureRating,g_stLANDataHeader.m_ui16PipeOD,g_stLANDataHeader.m_ui8PipeLength,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight,g_stLANDataHeader.m_ui16Unused1,g_stLANDataHeader.m_ui16Unused2,g_stLANDataHeader.m_ui16Unused3, 
....................                                                                                                                           g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
03EE8:  MOVLB  C
03EEA:  CLRF   x29
03EEC:  MOVFF  B80,C28
03EF0:  CLRF   x2B
03EF2:  MOVLW  0B
03EF4:  MOVWF  x2A
03EF6:  MOVLB  0
03EF8:  CALL   0432
03EFC:  BTFSC  19.7
03EFE:  BSF    FF2.7
03F00:  MOVFF  02,C01
03F04:  MOVFF  01,C00
03F08:  MOVLW  34
03F0A:  MOVLB  C
03F0C:  ADDWF  01,W
03F0E:  MOVWF  FE9
03F10:  MOVLW  07
03F12:  ADDWFC 02,W
03F14:  MOVWF  FEA
03F16:  MOVFF  FEF,C02
03F1A:  MOVFF  FEC,C03
03F1E:  MOVFF  FEC,C04
03F22:  MOVFF  FEC,C05
03F26:  CLRF   19
03F28:  BTFSC  FF2.7
03F2A:  BSF    19.7
03F2C:  BCF    FF2.7
03F2E:  CLRF   x29
03F30:  MOVFF  B80,C28
03F34:  CLRF   x2B
03F36:  MOVLW  0B
03F38:  MOVWF  x2A
03F3A:  MOVLB  0
03F3C:  CALL   0432
03F40:  BTFSC  19.7
03F42:  BSF    FF2.7
03F44:  MOVFF  01,C06
03F48:  MOVLW  04
03F4A:  MOVLB  C
03F4C:  ADDWF  01,W
03F4E:  MOVWF  01
03F50:  MOVLW  00
03F52:  ADDWFC 02,W
03F54:  MOVWF  03
03F56:  MOVF   01,W
03F58:  ADDLW  34
03F5A:  MOVWF  FE9
03F5C:  MOVLW  07
03F5E:  ADDWFC 03,W
03F60:  MOVWF  FEA
03F62:  MOVFF  FEC,C07
03F66:  MOVF   FED,F
03F68:  MOVFF  FEF,C06
03F6C:  CLRF   19
03F6E:  BTFSC  FF2.7
03F70:  BSF    19.7
03F72:  BCF    FF2.7
03F74:  CLRF   x29
03F76:  MOVFF  B80,C28
03F7A:  CLRF   x2B
03F7C:  MOVLW  0B
03F7E:  MOVWF  x2A
03F80:  MOVLB  0
03F82:  CALL   0432
03F86:  BTFSC  19.7
03F88:  BSF    FF2.7
03F8A:  MOVFF  01,C08
03F8E:  MOVLW  06
03F90:  MOVLB  C
03F92:  ADDWF  01,W
03F94:  MOVWF  01
03F96:  MOVLW  00
03F98:  ADDWFC 02,W
03F9A:  MOVWF  03
03F9C:  MOVF   01,W
03F9E:  ADDLW  34
03FA0:  MOVWF  FE9
03FA2:  MOVLW  07
03FA4:  ADDWFC 03,W
03FA6:  MOVWF  FEA
03FA8:  MOVFF  FEF,C08
03FAC:  MOVFF  FEC,C09
03FB0:  MOVFF  FEC,C0A
03FB4:  MOVFF  FEC,C0B
03FB8:  CLRF   19
03FBA:  BTFSC  FF2.7
03FBC:  BSF    19.7
03FBE:  BCF    FF2.7
03FC0:  CLRF   x29
03FC2:  MOVFF  B80,C28
03FC6:  CLRF   x2B
03FC8:  MOVLW  0B
03FCA:  MOVWF  x2A
03FCC:  MOVLB  0
03FCE:  CALL   0432
03FD2:  BTFSC  19.7
03FD4:  BSF    FF2.7
03FD6:  MOVFF  01,C0C
03FDA:  MOVLW  0A
03FDC:  MOVLB  C
03FDE:  ADDWF  01,W
03FE0:  MOVWF  01
03FE2:  MOVLW  00
03FE4:  ADDWFC 02,W
03FE6:  MOVWF  03
03FE8:  MOVF   01,W
03FEA:  ADDLW  34
03FEC:  MOVWF  FE9
03FEE:  MOVLW  07
03FF0:  ADDWFC 03,W
03FF2:  MOVWF  FEA
03FF4:  MOVFF  FEF,C0C
03FF8:  MOVLW  B4
03FFA:  MOVWF  FF6
03FFC:  MOVLW  03
03FFE:  MOVWF  FF7
04000:  MOVLW  0F
04002:  MOVWF  x0D
04004:  MOVLB  0
04006:  RCALL  3C06
04008:  MOVFF  99,C0D
0400C:  MOVLW  1B
0400E:  MOVLB  C
04010:  MOVWF  x0E
04012:  MOVLB  0
04014:  RCALL  3C32
04016:  MOVLW  C5
04018:  MOVWF  FF6
0401A:  MOVLW  03
0401C:  MOVWF  FF7
0401E:  MOVLW  03
04020:  MOVLB  C
04022:  MOVWF  x0D
04024:  MOVLB  0
04026:  RCALL  3C06
04028:  MOVLW  10
0402A:  MOVWF  FE9
0402C:  MOVFF  9B,C0E
04030:  MOVFF  9A,C0D
04034:  RCALL  3CD4
04036:  MOVLW  CB
04038:  MOVWF  FF6
0403A:  MOVLW  03
0403C:  MOVWF  FF7
0403E:  MOVLW  03
04040:  MOVLB  C
04042:  MOVWF  x0D
04044:  MOVLB  0
04046:  RCALL  3C06
04048:  MOVLW  10
0404A:  MOVWF  FE9
0404C:  MOVFF  9D,C0E
04050:  MOVFF  9C,C0D
04054:  RCALL  3CD4
04056:  MOVLW  D1
04058:  MOVWF  FF6
0405A:  MOVLW  03
0405C:  MOVWF  FF7
0405E:  MOVLW  03
04060:  MOVLB  C
04062:  MOVWF  x0D
04064:  MOVLB  0
04066:  RCALL  3C06
04068:  MOVFF  9E,C0D
0406C:  MOVLW  1B
0406E:  MOVLB  C
04070:  MOVWF  x0E
04072:  MOVLB  0
04074:  RCALL  3C32
04076:  MOVLW  D6
04078:  MOVWF  FF6
0407A:  MOVLW  03
0407C:  MOVWF  FF7
0407E:  MOVLW  03
04080:  MOVLB  C
04082:  MOVWF  x0D
04084:  MOVLB  0
04086:  RCALL  3C06
04088:  MOVLW  10
0408A:  MOVWF  FE9
0408C:  MOVFF  A0,C0E
04090:  MOVFF  9F,C0D
04094:  RCALL  3CD4
04096:  MOVLW  DC
04098:  MOVWF  FF6
0409A:  MOVLW  03
0409C:  MOVWF  FF7
0409E:  MOVLW  03
040A0:  MOVLB  C
040A2:  MOVWF  x0D
040A4:  MOVLB  0
040A6:  RCALL  3C06
040A8:  MOVFF  A1,C0D
040AC:  MOVLW  1B
040AE:  MOVLB  C
040B0:  MOVWF  x0E
040B2:  MOVLB  0
040B4:  RCALL  3C32
040B6:  MOVLW  E1
040B8:  MOVWF  FF6
040BA:  MOVLW  03
040BC:  MOVWF  FF7
040BE:  MOVLW  03
040C0:  MOVLB  C
040C2:  MOVWF  x0D
040C4:  MOVLB  0
040C6:  RCALL  3C06
040C8:  MOVLW  41
040CA:  MOVWF  FE9
040CC:  MOVFF  A5,C10
040D0:  MOVFF  A4,C0F
040D4:  MOVFF  A3,C0E
040D8:  MOVFF  A2,C0D
040DC:  RCALL  3E20
040DE:  MOVLW  E7
040E0:  MOVWF  FF6
040E2:  MOVLW  03
040E4:  MOVWF  FF7
040E6:  MOVLW  03
040E8:  MOVLB  C
040EA:  MOVWF  x0D
040EC:  MOVLB  0
040EE:  RCALL  3C06
040F0:  MOVLW  41
040F2:  MOVWF  FE9
040F4:  MOVFF  A9,C10
040F8:  MOVFF  A8,C0F
040FC:  MOVFF  A7,C0E
04100:  MOVFF  A6,C0D
04104:  RCALL  3E20
04106:  MOVLW  ED
04108:  MOVWF  FF6
0410A:  MOVLW  03
0410C:  MOVWF  FF7
0410E:  MOVLW  03
04110:  MOVLB  C
04112:  MOVWF  x0D
04114:  MOVLB  0
04116:  RCALL  3C06
04118:  MOVLW  10
0411A:  MOVWF  FE9
0411C:  MOVFF  AB,C0E
04120:  MOVFF  AA,C0D
04124:  RCALL  3CD4
04126:  MOVLW  F3
04128:  MOVWF  FF6
0412A:  MOVLW  03
0412C:  MOVWF  FF7
0412E:  MOVLW  03
04130:  MOVLB  C
04132:  MOVWF  x0D
04134:  MOVLB  0
04136:  RCALL  3C06
04138:  MOVLW  10
0413A:  MOVWF  FE9
0413C:  MOVFF  AD,C0E
04140:  MOVFF  AC,C0D
04144:  RCALL  3CD4
04146:  MOVLW  F9
04148:  MOVWF  FF6
0414A:  MOVLW  03
0414C:  MOVWF  FF7
0414E:  MOVLW  03
04150:  MOVLB  C
04152:  MOVWF  x0D
04154:  MOVLB  0
04156:  RCALL  3C06
04158:  MOVLW  10
0415A:  MOVWF  FE9
0415C:  MOVFF  AF,C0E
04160:  MOVFF  AE,C0D
04164:  RCALL  3CD4
04166:  MOVLW  FF
04168:  MOVWF  FF6
0416A:  MOVLW  03
0416C:  MOVWF  FF7
0416E:  MOVLW  03
04170:  MOVLB  C
04172:  MOVWF  x0D
04174:  MOVLB  0
04176:  RCALL  3C06
04178:  MOVLW  41
0417A:  MOVWF  FE9
0417C:  MOVFF  C05,C10
04180:  MOVFF  C04,C0F
04184:  MOVFF  C03,C0E
04188:  MOVFF  C02,C0D
0418C:  RCALL  3E20
0418E:  MOVLW  05
04190:  MOVWF  FF6
04192:  MOVLW  04
04194:  MOVWF  FF7
04196:  MOVLW  03
04198:  MOVLB  C
0419A:  MOVWF  x0D
0419C:  MOVLB  0
0419E:  RCALL  3C06
041A0:  MOVLW  10
041A2:  MOVWF  FE9
041A4:  MOVFF  C07,C0E
041A8:  MOVFF  C06,C0D
041AC:  RCALL  3CD4
041AE:  MOVLW  0B
041B0:  MOVWF  FF6
041B2:  MOVLW  04
041B4:  MOVWF  FF7
041B6:  MOVLW  03
041B8:  MOVLB  C
041BA:  MOVWF  x0D
041BC:  MOVLB  0
041BE:  RCALL  3C06
041C0:  MOVLW  41
041C2:  MOVWF  FE9
041C4:  MOVFF  C0B,C10
041C8:  MOVFF  C0A,C0F
041CC:  MOVFF  C09,C0E
041D0:  MOVFF  C08,C0D
041D4:  RCALL  3E20
041D6:  MOVLW  11
041D8:  MOVWF  FF6
041DA:  MOVLW  04
041DC:  MOVWF  FF7
041DE:  MOVLW  03
041E0:  MOVLB  C
041E2:  MOVWF  x0D
041E4:  MOVLB  0
041E6:  RCALL  3C06
041E8:  MOVFF  C0C,C0D
041EC:  MOVLW  1B
041EE:  MOVLB  C
041F0:  MOVWF  x0E
041F2:  MOVLB  0
041F4:  RCALL  3C32
041F6:  GOTO   4656 (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
*
04248:  MOVLW  01
0424A:  MOVLB  B
0424C:  MOVWF  xF7
0424E:  CLRF   xF8
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
04250:  CLRF   xF8
04252:  MOVF   xF8,W
04254:  SUBLW  13
04256:  BNC   42BC
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
04258:  MOVLW  03
0425A:  SUBWF  xF8,W
0425C:  CLRF   03
0425E:  ADDLW  1F
04260:  MOVWF  FE9
04262:  MOVLW  07
04264:  ADDWFC 03,W
04266:  MOVWF  FEA
04268:  MOVF   FEF,W
0426A:  SUBLW  4F
0426C:  BNZ   42B8
0426E:  MOVLW  02
04270:  SUBWF  xF8,W
04272:  CLRF   03
04274:  ADDLW  1F
04276:  MOVWF  FE9
04278:  MOVLW  07
0427A:  ADDWFC 03,W
0427C:  MOVWF  FEA
0427E:  MOVF   FEF,W
04280:  SUBLW  6B
04282:  BNZ   42B8
04284:  MOVLW  01
04286:  SUBWF  xF8,W
04288:  CLRF   03
0428A:  ADDLW  1F
0428C:  MOVWF  FE9
0428E:  MOVLW  07
04290:  ADDWFC 03,W
04292:  MOVWF  FEA
04294:  MOVF   FEF,W
04296:  SUBLW  61
04298:  BNZ   42B8
0429A:  CLRF   03
0429C:  MOVF   xF8,W
0429E:  ADDLW  1F
042A0:  MOVWF  FE9
042A2:  MOVLW  07
042A4:  ADDWFC 03,W
042A6:  MOVWF  FEA
042A8:  MOVF   FEF,W
042AA:  SUBLW  79
042AC:  BNZ   42B8
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
042AE:  CLRF   xF7
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
042B0:  MOVLB  0
042B2:  BRA    422A
....................             break; 
042B4:  MOVLB  B
042B6:  BRA    42BC
....................         } 
042B8:  INCF   xF8,F
042BA:  BRA    4252
....................     } 
....................          
....................     return ui8RetVal; 
042BC:  MOVFF  BF7,01
042C0:  MOVLB  0
042C2:  GOTO   467E (RETURN)
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
....................  
.................... unsigned int16 g_ui16PrevItemCount = 0; 
.................... unsigned int16 g_ui16ItemCount     = 0; 
....................  
....................  // TESTING  
....................     unsigned int8 ui8Counter = 0; 
....................  
.................... // IBU Received message process proc 
.................... void ProcessIBUMsg() 
*
01340:  MOVLB  C
01342:  CLRF   x04
.................... {    
....................     ST_IBU_DATA_NODE stIBURcvNode; 
....................     unsigned int8  ui8LoopCount = 0; 
....................  
....................     // Get Node from IBU Receive Message Queue 
....................     DeleteIBUMsgQueue(&g_stIBURcvQueue, &stIBURcvNode); 
01344:  MOVLW  03
01346:  MOVWF  x06
01348:  MOVLW  5F
0134A:  MOVWF  x05
0134C:  MOVLW  0B
0134E:  MOVWF  x08
01350:  MOVLW  F7
01352:  MOVWF  x07
01354:  MOVLB  0
01356:  BRA    1118
....................      
....................     // Valid message present in IBU receive buffer 
....................     // So go for process the data 
....................     switch(stIBURcvNode.g_ui8ArrIBUData[0]) 
01358:  MOVLB  B
0135A:  MOVF   xF9,W
0135C:  XORLW  68
0135E:  MOVLB  0
01360:  BZ    13A0
01362:  XORLW  0E
01364:  BZ    1402
01366:  XORLW  0F
01368:  BZ    1406
0136A:  XORLW  EF
0136C:  BZ    140A
0136E:  XORLW  F6
01370:  BTFSC  FD8.2
01372:  BRA    145C
01374:  XORLW  01
01376:  BTFSC  FD8.2
01378:  BRA    1460
0137A:  XORLW  F2
0137C:  BTFSC  FD8.2
0137E:  BRA    1464
01380:  XORLW  04
01382:  BTFSC  FD8.2
01384:  BRA    1468
01386:  XORLW  03
01388:  BTFSC  FD8.2
0138A:  BRA    14BA
0138C:  XORLW  13
0138E:  BTFSC  FD8.2
01390:  BRA    158A
01392:  XORLW  0E
01394:  BTFSC  FD8.2
01396:  BRA    1594
01398:  XORLW  03
0139A:  BTFSC  FD8.2
0139C:  BRA    159E
0139E:  BRA    15A8
....................     { 
....................         case IBU_CMD_RESET_CALIB_DATA: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
013A0:  MOVLW  01
013A2:  MOVLB  C
013A4:  MOVWF  x04
013A6:  MOVF   x04,W
013A8:  SUBLW  08
013AA:  BNC   13E0
....................             { 
....................                 g_unIBUResetCalibData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
013AC:  MOVLW  01
013AE:  SUBWF  x04,W
013B0:  CLRF   03
013B2:  ADDLW  F3
013B4:  MOVWF  01
013B6:  MOVLW  00
013B8:  ADDWFC 03,F
013BA:  MOVFF  03,C06
013BE:  CLRF   03
013C0:  MOVF   x04,W
013C2:  ADDLW  F9
013C4:  MOVWF  FE9
013C6:  MOVLW  0B
013C8:  ADDWFC 03,W
013CA:  MOVWF  FEA
013CC:  MOVFF  FEF,C07
013D0:  MOVFF  C06,FEA
013D4:  MOVFF  01,FE9
013D8:  MOVFF  C07,FEF
013DC:  INCF   x04,F
013DE:  BRA    13A6
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32TareADCValueForCalibration    = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForTare; 
013E0:  MOVFF  F6,4C3
013E4:  MOVFF  F5,4C2
013E8:  MOVFF  F4,4C1
013EC:  MOVFF  F3,4C0
....................             g_ui32gWeightADCValueForCalibration = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForWeight; 
013F0:  MOVFF  FA,4C7
013F4:  MOVFF  F9,4C6
013F8:  MOVFF  F8,4C5
013FC:  MOVFF  F7,4C4
....................             break; 
01400:  BRA    15AA
....................         case IBU_CMD_START_CALIBRATION: 
....................             break; 
01402:  MOVLB  C
01404:  BRA    15AA
....................         case IBU_CMD_RESET_CALIB_POINT:             
....................             break; 
01406:  MOVLB  C
01408:  BRA    15AA
....................         case IBU_CMD_PROD_TARE_DATA: 
....................         { 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0140A:  MOVLW  01
0140C:  MOVLB  C
0140E:  MOVWF  x04
01410:  MOVF   x04,W
01412:  SUBLW  08
01414:  BNC   144A
....................             { 
....................                 g_unIBUProdModeTrData.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
01416:  MOVLW  01
01418:  SUBWF  x04,W
0141A:  CLRF   03
0141C:  ADDLW  DF
0141E:  MOVWF  01
01420:  MOVLW  00
01422:  ADDWFC 03,F
01424:  MOVFF  03,C06
01428:  CLRF   03
0142A:  MOVF   x04,W
0142C:  ADDLW  F9
0142E:  MOVWF  FE9
01430:  MOVLW  0B
01432:  ADDWFC 03,W
01434:  MOVWF  FEA
01436:  MOVFF  FEF,C07
0143A:  MOVFF  C06,FEA
0143E:  MOVFF  01,FE9
01442:  MOVFF  C07,FEF
01446:  INCF   x04,F
01448:  BRA    1410
....................             } 
....................             g_ui32RunningTareValue = (unsigned int16)(g_unIBUProdModeTrData.m_stTareData.m_i32TareData); 
0144A:  MOVLB  4
0144C:  CLRF   xD9
0144E:  CLRF   xD8
01450:  MOVFF  E4,4D7
01454:  MOVFF  E3,4D6
....................         } 
....................              
....................             break; 
01458:  MOVLB  C
0145A:  BRA    15AA
....................         case IBU_CMD_PRE_PROD_AVG_WEIGHT: 
....................             break; 
0145C:  MOVLB  C
0145E:  BRA    15AA
....................         case IBU_CMD_PRE_PROD_TOLERANCE: 
....................             break; 
01460:  MOVLB  C
01462:  BRA    15AA
....................         case IBU_CMD_START_PROD: 
....................             break; 
01464:  MOVLB  C
01466:  BRA    15AA
....................         case IBU_CMD_PROD_AVG_WT_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
01468:  MOVLW  01
0146A:  MOVLB  C
0146C:  MOVWF  x04
0146E:  MOVF   x04,W
01470:  SUBLW  08
01472:  BNC   14A8
....................                 { 
....................                     g_unIBUProdModeAvg.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
01474:  MOVLW  01
01476:  SUBWF  x04,W
01478:  CLRF   03
0147A:  ADDLW  FB
0147C:  MOVWF  01
0147E:  MOVLW  00
01480:  ADDWFC 03,F
01482:  MOVFF  03,C06
01486:  CLRF   03
01488:  MOVF   x04,W
0148A:  ADDLW  F9
0148C:  MOVWF  FE9
0148E:  MOVLW  0B
01490:  ADDWFC 03,W
01492:  MOVWF  FEA
01494:  MOVFF  FEF,C07
01498:  MOVFF  C06,FEA
0149C:  MOVFF  01,FE9
014A0:  MOVFF  C07,FEF
014A4:  INCF   x04,F
014A6:  BRA    146E
....................                 } 
....................                  
....................                 g_ui32RunningAvgWt = g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg; 
014A8:  MOVFF  FE,4D5
014AC:  MOVFF  FD,4D4
014B0:  MOVFF  FC,4D3
014B4:  MOVFF  FB,4D2
....................             } 
....................             break;             
014B8:  BRA    15AA
....................         case IBU_CMD_PROD_WEIGH_DATA: 
....................             { 
....................                  
....................                 // TESTING. 
....................                 //output_toggle(PIN_OUT_DO_00); 
....................  
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
014BA:  MOVLW  01
014BC:  MOVLB  C
014BE:  MOVWF  x04
014C0:  MOVF   x04,W
014C2:  SUBLW  08
014C4:  BNC   14FA
....................                 { 
....................                     g_unIBUProdModeWtStsData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
014C6:  MOVLW  01
014C8:  SUBWF  x04,W
014CA:  CLRF   03
014CC:  ADDLW  D7
014CE:  MOVWF  01
014D0:  MOVLW  00
014D2:  ADDWFC 03,F
014D4:  MOVFF  03,C06
014D8:  CLRF   03
014DA:  MOVF   x04,W
014DC:  ADDLW  F9
014DE:  MOVWF  FE9
014E0:  MOVLW  0B
014E2:  ADDWFC 03,W
014E4:  MOVWF  FEA
014E6:  MOVFF  FEF,C07
014EA:  MOVFF  C06,FEA
014EE:  MOVFF  01,FE9
014F2:  MOVFF  C07,FEF
014F6:  INCF   x04,F
014F8:  BRA    14C0
....................                 } 
....................                  
....................                 // Update current box weight in register. 
....................                 g_stProdModeCurrBoxData.m_i32PipeWeight = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_i32PipeWeight; 
014FA:  MOVFF  DA,715
014FE:  MOVFF  D9,714
01502:  MOVFF  D8,713
01506:  MOVFF  D7,712
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui32CurrentWt = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
0150A:  MOVFF  715,4CF
0150E:  MOVFF  714,4CE
01512:  MOVFF  713,4CD
01516:  MOVFF  712,4CC
....................                  
....................                 // Update Current box count in register. 
....................                 //g_ui16PipeCount = g_unIBUProdModeBoxCount.m_stBoxCount.m_ui16BoxCount; 
....................                 g_ui16PipeCount = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PipeCount; 
0151A:  MOVFF  DC,4C9
0151E:  MOVFF  DB,4C8
....................                 g_ui16ItemCount = g_ui16PipeCount; 
01522:  MOVFF  4C9,B85
01526:  MOVFF  4C8,B84
....................                  
....................                 // Update last box pass status. 
....................                 g_ui16CurrentPassStatus = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PassStatus; 
0152A:  MOVFF  DE,4D1
0152E:  MOVFF  DD,4D0
....................                  
....................                 // Update HMI Data Trigger Status. 
....................                 //g_ui8HMITriggerStatus = 1; 
....................  
....................                 if(g_ui16ItemCount > 0 && g_ui16PrevItemCount != g_ui16ItemCount) 
01532:  MOVLB  B
01534:  MOVF   x84,F
01536:  BNZ   153C
01538:  MOVF   x85,F
0153A:  BZ    1586
0153C:  MOVF   x84,W
0153E:  SUBWF  x82,W
01540:  BNZ   1548
01542:  MOVF   x85,W
01544:  SUBWF  x83,W
01546:  BZ    1586
....................                 { 
....................                     // Update production mode current box data. 
....................                     g_stProdModeCurrBoxData.m_ui16SequenceNo = g_ui16PipeCount; 
01548:  MOVFF  4C9,717
0154C:  MOVFF  4C8,716
....................                     g_stProdModeCurrBoxData.m_i32PipeWeight = g_ui32CurrentWt; 
01550:  MOVFF  4CF,715
01554:  MOVFF  4CE,714
01558:  MOVFF  4CD,713
0155C:  MOVFF  4CC,712
....................                     g_stProdModeCurrBoxData.m_ui16RejectionStatus = g_ui16CurrentPassStatus;  // TODO 
01560:  MOVFF  4D1,719
01564:  MOVFF  4D0,718
....................                     g_stProdModeCurrBoxData.m_ui32TimeStamp = g_ui32UnixTimeInSec; 
01568:  MOVFF  CA,71D
0156C:  MOVFF  C9,71C
01570:  MOVFF  C8,71B
01574:  MOVFF  C7,71A
....................                     // Insert current box data in GPRS send Message queue. 
....................                     InsertInPipeDataQueue(); 
01578:  MOVLB  0
0157A:  BRA    11FC
....................  
....................                     // update previous item count for next box reference. 
....................                     g_ui16PrevItemCount = g_ui16ItemCount; 
0157C:  MOVFF  B85,B83
01580:  MOVFF  B84,B82
01584:  MOVLB  B
....................                 } 
....................             } 
....................             break;             
01586:  MOVLB  C
01588:  BRA    15AA
....................         case IBU_CMD_PRE_PROD_TOL_STORE_ACK: 
....................             // No need to parse data. 
....................             // This is acknowledgement message. Transfer to HMI. 
....................             g_ui8ToleranceStoreAck = 1; 
0158A:  MOVLW  01
0158C:  MOVLB  4
0158E:  MOVWF  xE7
....................             break; 
01590:  MOVLB  C
01592:  BRA    15AA
....................         case IBU_CMD_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure below rated alarm occurred. 
....................             // Set flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 1; 
01594:  MOVLW  01
01596:  MOVLB  4
01598:  MOVWF  xF8
....................             break; 
0159A:  MOVLB  C
0159C:  BRA    15AA
....................         case IBU_CMD_RESET_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure recovers. 
....................             // Now it is above rated. 
....................             // Reset flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 0; 
0159E:  MOVLB  4
015A0:  CLRF   xF8
....................             break; 
015A2:  MOVLB  C
015A4:  BRA    15AA
015A6:  MOVLB  0
....................         default : 
....................             break; 
015A8:  MOVLB  C
....................     } 
015AA:  MOVLB  0
015AC:  GOTO   45C2 (RETURN)
.................... }    
....................  
....................  
....................  
.................... #endif	/* VM_IBU_PROCESS_M1_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
....................     enable_interrupts(INT_RDA5); 
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
....................     } 
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         ui8QueueStatus = 1;  
....................     } 
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
....................     } 
....................     return ui8QueueStatus; 
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/ipptv2/?a=%u&b=%Lu&c=%Lu&d=%u&e=%Lu&f=%u&g=%Lu&h=%Lu&i=%Lu&j=%Lu&k=%Lu&l=%Lu&m=%Lu&n=%Lu&o=%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16StandardSpecification,g_stLANDataHeader.m_ui8PressureRating,g_stLANDataHeader.m_ui16PipeOD,g_stLANDataHeader.m_ui8PipeLength,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight,g_stLANDataHeader.m_ui16Unused1,g_stLANDataHeader.m_ui16Unused2,g_stLANDataHeader.m_ui16Unused3, 
....................                                                                                                                           g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
....................             break; 
....................         } 
....................     } 
....................          
....................     return ui8RetVal; 
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
.................... #include "vmRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "../Common/vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
.................... 		{ 
.................... 			break; 
.................... 		} 
....................  
.................... 		uiByteCount++; 
.................... 		bShiftCount = 0; 
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
.................... 			{ 
.................... 				if (1 == uiByteCount) 
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
.................... 				} 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
....................  
.................... 			if (bShiftCount > 8) 
.................... 			{ 
.................... 				break; 
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
....................  
.................... 			uiCRC = uiCRC >> 1; 
....................  
.................... 			if (1 == bShiftCarry) 
.................... 			{ 
.................... 				continue; 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
.................... 			} 
.................... 		} 
.................... 	} 
....................  
.................... 	return uiCRC; 
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16StandardSpecification; 
....................     unsigned int8    m_ui8PressureRating; 
....................     unsigned int16   m_ui16PipeOD; 
....................     unsigned int8    m_ui8PipeLength; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................     unsigned int16   m_ui16Unused1;          
....................     unsigned int16   m_ui16Unused2; 
....................     unsigned int16   m_ui16Unused3;         // Last three parameters are unused for now; may use in future.  
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
....................      
....................     return ui8MachineID; 
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
....................      
....................     return ui8DataSendInterval; 
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ui16Temp; 
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
....................     ui8EEPROMAddress += 2; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
....................      
....................     return ui32StoredUnixTime;     
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
....................      
....................     return ui8SIMOperatorID;     
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
....................  
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                                        0x05 
.................... #define ADDRESS_FOR_SELECT_PRODUCTION_TYPE                  0x04 
.................... #define ADDRESS_FOR_SCRAP_ON_MODE                           0x99 
.................... #define ADRESS_FOR_HMI_TIMESTAMP                            0x47 
.................... #define ADDRESS_FOR_MACHINE_ID                              0x90 
....................  
....................  
.................... #define ADDRESS_FOR_SET_LOAD_CELL_FACTOR                    0x282 
.................... #define ADDRESS_FOR_CALIB_TARE_ADC_VALUE                    0x296 
.................... #define ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE                  0x298 
....................  
.................... #define ADDRESS_FOR_CURRENT_CALIBRATION_WT                  0x310 
.................... #define ADDRESS_FOR_START_CALIBRATION                       0x299 
.................... #define ADDRESS_FOR_RUNNING_VAR_PROD_DETAILS                0x420 
.................... #define ADDRESS_FOR_SELECTED_PRODUCT_INDEX                  0x540 
.................... #define ADDRESS_FOR_CURRENT_CBB_PRODUCT_INDEX               0x250  
....................  
.................... // use for production 
.................... #define ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION                 0x560 
.................... #define ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION                0x562 
.................... #define ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION            0x564 // SET 1 for accept 
.................... #define ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION            0x566 
.................... #define ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION                0x568 
.................... #define ADDRESS_FOR_WRITE_TARE_VALUE                        0x570 
.................... #define ADDRESS_FOR_HMI_DATA_UPDATE_TRIGGER                 0x760 
....................  
.................... // use for preproduction 
.................... #define ADDRESS_FOR_PRODUCTION_INDEX_PRE_PRODUCTION         0x500 
.................... #define ADDRESS_FOR_PRODUCTION_AVG_WT_PRE_PRODUCTION        0x550 
.................... #define ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION        0x552 
.................... #define ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION        0x554 
....................  
.................... #define ADDRESS_FOR_CALCULATED_MIN_MAX_WT                   0x50 
.................... #define ADDRESS_FOR_TOL_STORE_SEEKING_ACK                   0x88 
.................... #define ADDRESS_FOR_TOL_STORE_SETTING_ACK                   0x89 
.................... #define ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD         0x190 
.................... #define ADDRESS_FOR_PIPE_SPECIFICATION                      0x193 
.................... #define ADDRESS_FOR_PRE_PROD_MAX_MIN_WT                     0x52 
.................... #define ADDRESS_FOR_AT_OK_TIMER_SETTING                     0x53 
.................... #define ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING          0x54 
.................... #define ADDRESS_FOR_HTTP_GET_SESSION_TIMER_SETTING          0x55 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_TIMER_SETTING      0x56 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_NETWORK_RECONNECTION_HALT_TIME      0x57 
.................... #define ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME                0x58 
.................... #define ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME           0x59 
.................... #define ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME                0x60 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_INTERVAL_TIME      0x61 
.................... #define ADDRESS_FOR_SHIFT_NUMBER                            0x62 
.................... #define ADDRESS_FOR_SHIFT_DURATION                          0x63 
.................... #define ADDRESS_FOR_SELECT_SIM_OPERATOR                     0x64 
.................... #define ADDRESS_FOR_AIR_PRESSURE_ALARM                      0x65 
.................... #define ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY   0x66 
....................  
.................... // use for calibration type set 
.................... #define ADDRESS_FOR_CALIBRATION_TYPE                        0x710 
.................... #define ADDRESS_FOR_AUTO_CALIB_SAMPLE_COUNT                 0x711 
....................  
.................... // RS485 Communication related stuff 
.................... #define SIZE_RS485_RX_BUFF                                  50 
.................... #define SIZE_RS485_TX_BUFF                                  50 
.................... #define ISR_1ST_BYTE_RECEIVED                               0 
.................... #define ISR_1ST_BYTE_PROCESSED                              1 
.................... #define MODBUS_FNCODE_READ_COIL_STATUS                      1 
.................... #define MODBUS_FNCODE_READ_HOLDING_REGISTER                 3 
.................... #define MODBUS_FNCODE_WRITE_SINGLE_REGISTER                 6 
.................... #define MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER               16 
.................... #define MODBUS_SINGLE_REG_READ_WRITE_RX_BYTE_COUNT          8 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_READ                  9 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_WRITE                 10 
.................... #define MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL            0 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define STATUS_ON                                       10 
.................... #define STATUS_OFF                                      11 
....................  
....................  
.................... //#define RS485_RX_BUFF_SIZE 		50 
....................  
.................... //unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
....................  
.................... //ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... //unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
.................... unsigned int8 g_ui8RS485Rxbuffer[SIZE_RS485_RX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485Txbuffer[SIZE_RS485_TX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485RxByteCount                  = 0; 
.................... unsigned int8 g_fModbusMultiRegWriteTimeCountStats   = STATUS_OFF; 
.................... unsigned int8 g_fISRFirstBytesStatus                 = ISR_1ST_BYTE_PROCESSED; 
....................  
.................... unsigned int8 g_ui8Test                  = 0; 
.................... unsigned int16 g_ui16BitFillingTemp      = 0; 
.................... unsigned int32 g_ui32BitFillingTemp      = 0; 
....................  
....................  
.................... // Initialize RS485 receive interrupt. 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable interrupt.  
....................     clear_interrupt(INT_RDA3); 
*
005DE:  MOVLB  E
005E0:  MOVF   xEA,W
.................... 	enable_interrupts(INT_RDA3); 
005E2:  BSF    x2D.1
005E4:  MOVLB  0
005E6:  GOTO   457A (RETURN)
.................... } 
....................  
.................... void ResetRS485RXBuffer(void) 
.................... { 
....................     // clear buffer. 
....................     memset(g_ui8RS485Rxbuffer, 0, SIZE_RS485_RX_BUFF); 
*
01754:  MOVLW  0B
01756:  MOVWF  FEA
01758:  MOVLW  88
0175A:  MOVWF  FE9
0175C:  CLRF   00
0175E:  CLRF   02
01760:  MOVLW  32
01762:  MOVWF  01
01764:  CALL   09CC
....................     // Reset byte count. 
....................     g_ui8RS485RxByteCount = 0; 
01768:  MOVLB  B
0176A:  CLRF   xEC
0176C:  MOVLB  0
0176E:  RETURN 0
....................      
.................... } 
....................  
.................... #INT_RDA3 
.................... void RS485_RxByteReady_ISR3(void) 
*
0049A:  MOVLB  0
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte && g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
0049C:  MOVF   3E,W
0049E:  SUBLW  29
004A0:  BNZ   04E2
004A2:  MOVF   x8A,W
004A4:  SUBLW  0C
004A6:  BNZ   04E2
....................     { 
....................         ++g_ui8Test; 
004A8:  MOVLB  B
004AA:  INCF   xEF,F
....................         g_ui8TempByte = fgetc(RS485); 
004AC:  MOVLB  0
004AE:  RCALL  0418
004B0:  MOVFF  01,B87
....................          
....................         // Checking for is the request/response for valid slave..i.e. slaveID 
....................         if(SLAVE_ID == g_ui8TempByte) 
004B4:  MOVLB  B
004B6:  DECFSZ x87,W
004B8:  BRA    04D6
....................         { 
....................             g_fIsReadyToReceiveByte = ISR_IS_READY; 
004BA:  MOVLW  28
004BC:  MOVWF  3E
....................             g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
004BE:  CLRF   03
004C0:  MOVF   xEC,W
004C2:  ADDLW  88
004C4:  MOVWF  FE9
004C6:  MOVLW  0B
004C8:  ADDWFC 03,W
004CA:  MOVWF  FEA
004CC:  MOVFF  B87,FEF
....................             g_ui8RS485RxByteCount++; 
004D0:  INCF   xEC,F
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_RECEIVED;             
004D2:  CLRF   xEE
....................         } 
004D4:  BRA    04DE
....................         else 
....................         { 
....................             // change flag status if slave id does not match. 
....................             g_fIsValidSlaveID = MODBUS_IS_NOT_VALID_SLAVE_ID; 
004D6:  MOVLW  0D
004D8:  MOVLB  0
004DA:  MOVWF  x8A
004DC:  MOVLB  B
....................         } 
....................  
....................     } 
004DE:  BRA    05A4
004E0:  MOVLB  0
....................     else if(g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
004E2:  MOVF   x8A,W
004E4:  SUBLW  0C
004E6:  BNZ   05A6
....................     { 
....................         g_ui8TempByte = fgetc(RS485); 
004E8:  RCALL  0418
004EA:  MOVFF  01,B87
....................          
....................         // Checking for ISR 2nd received byte i.e. function code. 
....................         if(ISR_1ST_BYTE_RECEIVED == g_fISRFirstBytesStatus) 
004EE:  MOVLB  B
004F0:  MOVF   xEE,F
004F2:  BNZ   051A
....................         { 
....................             // change flag status. 
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_PROCESSED; 
004F4:  MOVLW  01
004F6:  MOVWF  xEE
....................              
....................             // Set ISR all byte expected receive timing. 
....................             if(g_ui8TempByte == MODBUS_FNCODE_READ_HOLDING_REGISTER || g_ui8TempByte == MODBUS_FNCODE_WRITE_SINGLE_REGISTER) 
004F8:  MOVF   x87,W
004FA:  SUBLW  03
004FC:  BZ    0504
004FE:  MOVF   x87,W
00500:  SUBLW  06
00502:  BNZ   0510
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_8_BYTE_RECEIVE_TIME; 
00504:  MOVLB  0
00506:  CLRF   x8C
00508:  MOVLW  03
0050A:  MOVWF  x8B
....................             } 
0050C:  BRA    051C
0050E:  MOVLB  B
....................             else if(g_ui8TempByte == MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER) 
00510:  MOVF   x87,W
00512:  SUBLW  10
00514:  BNZ   051A
....................             { 
....................                 // Set flag to calculate and  load receive time. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_ON; 
00516:  MOVLW  0A
00518:  MOVWF  xED
....................                  
....................                 // Load the time. 
....................                 //g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_19_BYTE_RECEIVE_TIME; 
....................             } 
0051A:  MOVLB  0
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................         } 
....................          
....................         // Check multi register receive time calculation status.(This will depend upon number of register requested for by master) 
....................         if(STATUS_ON == g_fModbusMultiRegWriteTimeCountStats) 
0051C:  MOVLB  B
0051E:  MOVF   xED,W
00520:  SUBLW  0A
00522:  BNZ   0588
....................         { 
....................             // Check byte count. 
....................             if(7 == g_ui8RS485RxByteCount) 
00524:  MOVF   xEC,W
00526:  SUBLW  07
00528:  BNZ   0588
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (RS485_9600_1_BYTE_RCV_TIME * (RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT + g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1])); 
0052A:  MOVLW  01
0052C:  SUBWF  xEC,W
0052E:  CLRF   03
00530:  ADDLW  88
00532:  MOVWF  FE9
00534:  MOVLW  0B
00536:  ADDWFC 03,W
00538:  MOVWF  FEA
0053A:  MOVF   FEF,W
0053C:  ADDLW  09
0053E:  MOVLB  C
00540:  MOVWF  x27
00542:  MOVLW  04
00544:  MOVWF  x29
00546:  MOVLW  10
00548:  MOVWF  x28
0054A:  CLRF   x2B
0054C:  MOVFF  C27,C2A
00550:  MOVLB  0
00552:  RCALL  0432
00554:  MOVFF  02,8C
00558:  MOVFF  01,8B
....................  
....................                 // Manipulate data. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (g_ui16ISRAllBytesExpectedRcvTime / 1000); 
0055C:  MOVFF  8C,C28
00560:  MOVFF  8B,C27
00564:  MOVLW  03
00566:  MOVLB  C
00568:  MOVWF  x2A
0056A:  MOVLW  E8
0056C:  MOVWF  x29
0056E:  MOVLB  0
00570:  RCALL  0454
00572:  MOVFF  02,8C
00576:  MOVFF  01,8B
....................                 g_ui16ISRAllBytesExpectedRcvTime = g_ui16ISRAllBytesExpectedRcvTime + 2; 
0057A:  MOVLW  02
0057C:  ADDWF  x8B,F
0057E:  MOVLW  00
00580:  ADDWFC x8C,F
....................  
....................                 // Reset flag status. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_OFF; 
00582:  MOVLW  0B
00584:  MOVLB  B
00586:  MOVWF  xED
....................             }             
....................         } 
....................          
....................         // Store the data byte in receive buffer. 
....................         g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
00588:  CLRF   03
0058A:  MOVF   xEC,W
0058C:  ADDLW  88
0058E:  MOVWF  FE9
00590:  MOVLW  0B
00592:  ADDWFC 03,W
00594:  MOVWF  FEA
00596:  MOVFF  B87,FEF
....................      
....................         // Increment receive byte count. 
....................         g_ui8RS485RxByteCount++; 
0059A:  INCF   xEC,F
....................          
....................         // Check received byte count with buffer size. 
....................         if(g_ui8RS485RxByteCount >= SIZE_RS485_RX_BUFF) 
0059C:  MOVF   xEC,W
0059E:  SUBLW  31
005A0:  BC    05A4
....................         { 
....................             // Reset byte count. 
....................             g_ui8RS485RxByteCount = 0; 
005A2:  CLRF   xEC
....................         } 
....................      
....................     } 
005A4:  MOVLB  0
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................      
....................     // TESTING 
....................     if(g_ui8RS485RxByteCount == 8) 
005A6:  MOVLB  B
005A8:  MOVF   xEC,W
005AA:  SUBLW  08
005AC:  BNZ   05B2
....................     { 
....................         g_ui8RS485RxByteCount = 8; 
005AE:  MOVLW  08
005B0:  MOVWF  xEC
....................     } 
....................      
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA3); 
005B2:  MOVLB  E
005B4:  MOVF   xEA,W
005B6:  BCF    x37.1
005B8:  MOVLB  0
005BA:  GOTO   008A
.................... } 
....................  
.................... void SetProductSpecificationForServer(void) 
.................... { 
....................      
....................     // Set LAN header messages or parameters. 
....................     // a. Basic Material. 
....................     g_stLANDataHeader.m_ui16BasicMaterialStandard = g_ui8BasicMaterialStandard; 
*
0296E:  CLRF   x9B
02970:  MOVFF  4FC,9A
....................      
....................     // b. Standard Type specification.. 
....................     g_stLANDataHeader.m_ui16StandardSpecification = g_ui8StandardSpecification; 
02974:  CLRF   x9D
02976:  MOVFF  4FD,9C
....................      
....................     // c. Pressure type specification. 
....................     g_stLANDataHeader.m_ui8PressureRating = g_ui8PressureRating; 
0297A:  MOVFF  4FE,9E
....................      
....................     // d. Pipe outer diameter. 
....................     g_stLANDataHeader.m_ui16PipeOD = g_ui8PipeOD; 
0297E:  CLRF   xA0
02980:  MOVFF  4FF,9F
....................      
....................     // e. Pipe length. 
....................     g_stLANDataHeader.m_ui8PipeLength = g_ui8PipeLength; 
02984:  MOVFF  500,A1
....................              
....................     // three unused parameters filled zero for now. 
....................     g_stLANDataHeader.m_ui16Unused1 = 0; 
02988:  CLRF   xAB
0298A:  CLRF   xAA
....................     g_stLANDataHeader.m_ui16Unused2 = 0; 
0298C:  CLRF   xAD
0298E:  CLRF   xAC
....................     g_stLANDataHeader.m_ui16Unused3 = 0; 
02990:  CLRF   xAF
02992:  CLRF   xAE
02994:  GOTO   3B02 (RETURN)
....................      
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void SendMulResponseToMaster(unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow) 
*
01A78:  MOVLB  C
01A7A:  CLRF   x07
01A7C:  CLRF   x08
01A7E:  CLRF   x0A
01A80:  CLRF   x09
.................... { 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................          
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
01A82:  CLRF   03
01A84:  MOVF   x08,W
01A86:  ADDLW  BA
01A88:  MOVWF  FE9
01A8A:  MOVLW  0B
01A8C:  ADDWFC 03,W
01A8E:  MOVWF  FEA
01A90:  MOVLW  01
01A92:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01A94:  INCF   x08,F
....................     // Stuff  the function code. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
01A96:  CLRF   03
01A98:  MOVF   x08,W
01A9A:  ADDLW  BA
01A9C:  MOVWF  FE9
01A9E:  MOVLW  0B
01AA0:  ADDWFC 03,W
01AA2:  MOVWF  FEA
01AA4:  MOVLW  03
01AA6:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AA8:  INCF   x08,F
....................     // Stuff number of data bytes to follow. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01AAA:  CLRF   03
01AAC:  MOVF   x08,W
01AAE:  ADDLW  BA
01AB0:  MOVWF  FE9
01AB2:  MOVLW  0B
01AB4:  ADDWFC 03,W
01AB6:  MOVWF  FEA
01AB8:  MOVFF  C06,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01ABC:  INCF   x08,F
....................  
....................     // For CBB Count. Register-> 560 & 561 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 8) & 0xFF); 
01ABE:  CLRF   03
01AC0:  MOVF   x08,W
01AC2:  ADDLW  BA
01AC4:  MOVWF  FE9
01AC6:  MOVLW  0B
01AC8:  ADDWFC 03,W
01ACA:  MOVWF  FEA
01ACC:  MOVFF  4C9,00
01AD0:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AD4:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 0) & 0xFF); 
01AD6:  CLRF   03
01AD8:  MOVF   x08,W
01ADA:  ADDLW  BA
01ADC:  MOVWF  FE9
01ADE:  MOVLW  0B
01AE0:  ADDWFC 03,W
01AE2:  MOVWF  FEA
01AE4:  MOVFF  4C9,C0E
01AE8:  MOVFF  4C8,00
01AEC:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AF0:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01AF2:  CLRF   03
01AF4:  MOVF   x08,W
01AF6:  ADDLW  BA
01AF8:  MOVWF  FE9
01AFA:  MOVLW  0B
01AFC:  ADDWFC 03,W
01AFE:  MOVWF  FEA
01B00:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B02:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01B04:  CLRF   03
01B06:  MOVF   x08,W
01B08:  ADDLW  BA
01B0A:  MOVWF  FE9
01B0C:  MOVLW  0B
01B0E:  ADDWFC 03,W
01B10:  MOVWF  FEA
01B12:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B14:  INCF   x08,F
....................      
....................     // For Current CBB Weight. Register-> 562 & 563 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32CurrentWt << 16) & 0xFFFF0000); 
01B16:  MOVFF  4CD,BF5
01B1A:  MOVFF  4CC,BF4
01B1E:  CLRF   00
01B20:  CLRF   01
01B22:  MOVFF  01,BF3
01B26:  MOVFF  00,BF2
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01B2A:  MOVFF  BF4,BF0
01B2E:  MOVFF  BF5,BF1
01B32:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01B34:  CLRF   03
01B36:  MOVF   x08,W
01B38:  ADDLW  BA
01B3A:  MOVWF  FE9
01B3C:  MOVLW  0B
01B3E:  ADDWFC 03,W
01B40:  MOVWF  FEA
01B42:  MOVFF  BF1,00
01B46:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B4A:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01B4C:  CLRF   03
01B4E:  MOVF   x08,W
01B50:  ADDLW  BA
01B52:  MOVWF  FE9
01B54:  MOVLW  0B
01B56:  ADDWFC 03,W
01B58:  MOVWF  FEA
01B5A:  MOVFF  BF1,C0E
01B5E:  MOVFF  BF0,00
01B62:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B66:  INCF   x08,F
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32CurrentWt >> 16) & 0xFFFF); 
01B68:  MOVFF  4CE,BF0
01B6C:  MOVFF  4CF,BF1
01B70:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01B72:  CLRF   03
01B74:  MOVF   x08,W
01B76:  ADDLW  BA
01B78:  MOVWF  FE9
01B7A:  MOVLW  0B
01B7C:  ADDWFC 03,W
01B7E:  MOVWF  FEA
01B80:  MOVFF  BF1,00
01B84:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B88:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01B8A:  CLRF   03
01B8C:  MOVF   x08,W
01B8E:  ADDLW  BA
01B90:  MOVWF  FE9
01B92:  MOVLW  0B
01B94:  ADDWFC 03,W
01B96:  MOVWF  FEA
01B98:  MOVFF  BF1,C0E
01B9C:  MOVFF  BF0,00
01BA0:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BA4:  INCF   x08,F
....................  
....................     // For Pass CBB Status. Register-> 564 & 565 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 8) & 0xFF); 
01BA6:  CLRF   03
01BA8:  MOVF   x08,W
01BAA:  ADDLW  BA
01BAC:  MOVWF  FE9
01BAE:  MOVLW  0B
01BB0:  ADDWFC 03,W
01BB2:  MOVWF  FEA
01BB4:  MOVFF  4D1,00
01BB8:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BBC:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 0) & 0xFF); 
01BBE:  CLRF   03
01BC0:  MOVF   x08,W
01BC2:  ADDLW  BA
01BC4:  MOVWF  FE9
01BC6:  MOVLW  0B
01BC8:  ADDWFC 03,W
01BCA:  MOVWF  FEA
01BCC:  MOVFF  4D1,C0E
01BD0:  MOVFF  4D0,00
01BD4:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BD8:  INCF   x08,F
....................      
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01BDA:  CLRF   03
01BDC:  MOVF   x08,W
01BDE:  ADDLW  BA
01BE0:  MOVWF  FE9
01BE2:  MOVLW  0B
01BE4:  ADDWFC 03,W
01BE6:  MOVWF  FEA
01BE8:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BEA:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01BEC:  CLRF   03
01BEE:  MOVF   x08,W
01BF0:  ADDLW  BA
01BF2:  MOVWF  FE9
01BF4:  MOVLW  0B
01BF6:  ADDWFC 03,W
01BF8:  MOVWF  FEA
01BFA:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01BFC:  INCF   x08,F
....................  
....................     // For Production Running Average. Register-> 566 & 567 
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningAvgWt << 16) & 0xFFFF0000); 
01BFE:  MOVFF  4D3,BF5
01C02:  MOVFF  4D2,BF4
01C06:  CLRF   00
01C08:  CLRF   01
01C0A:  MOVFF  01,BF3
01C0E:  MOVFF  00,BF2
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01C12:  MOVFF  BF4,BF0
01C16:  MOVFF  BF5,BF1
01C1A:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01C1C:  CLRF   03
01C1E:  MOVF   x08,W
01C20:  ADDLW  BA
01C22:  MOVWF  FE9
01C24:  MOVLW  0B
01C26:  ADDWFC 03,W
01C28:  MOVWF  FEA
01C2A:  MOVFF  BF1,00
01C2E:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C32:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01C34:  CLRF   03
01C36:  MOVF   x08,W
01C38:  ADDLW  BA
01C3A:  MOVWF  FE9
01C3C:  MOVLW  0B
01C3E:  ADDWFC 03,W
01C40:  MOVWF  FEA
01C42:  MOVFF  BF1,C0E
01C46:  MOVFF  BF0,00
01C4A:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C4E:  INCF   x08,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningAvgWt >> 16) & 0xFFFF); 
01C50:  MOVFF  4D4,BF0
01C54:  MOVFF  4D5,BF1
01C58:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01C5A:  CLRF   03
01C5C:  MOVF   x08,W
01C5E:  ADDLW  BA
01C60:  MOVWF  FE9
01C62:  MOVLW  0B
01C64:  ADDWFC 03,W
01C66:  MOVWF  FEA
01C68:  MOVFF  BF1,00
01C6C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C70:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01C72:  CLRF   03
01C74:  MOVF   x08,W
01C76:  ADDLW  BA
01C78:  MOVWF  FE9
01C7A:  MOVLW  0B
01C7C:  ADDWFC 03,W
01C7E:  MOVWF  FEA
01C80:  MOVFF  BF1,C0E
01C84:  MOVFF  BF0,00
01C88:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01C8C:  INCF   x08,F
....................      
....................     // For Running Tare Weight. Register-> 568 & 569 
....................     // Example: If the four bytes are like 1234 then it will be filled as 3412  
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningTareValue << 16) & 0xFFFF0000); 
01C8E:  MOVFF  4D7,BF5
01C92:  MOVFF  4D6,BF4
01C96:  CLRF   00
01C98:  CLRF   01
01C9A:  MOVFF  01,BF3
01C9E:  MOVFF  00,BF2
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01CA2:  MOVFF  BF4,BF0
01CA6:  MOVFF  BF5,BF1
01CAA:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01CAC:  CLRF   03
01CAE:  MOVF   x08,W
01CB0:  ADDLW  BA
01CB2:  MOVWF  FE9
01CB4:  MOVLW  0B
01CB6:  ADDWFC 03,W
01CB8:  MOVWF  FEA
01CBA:  MOVFF  BF1,00
01CBE:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01CC2:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01CC4:  CLRF   03
01CC6:  MOVF   x08,W
01CC8:  ADDLW  BA
01CCA:  MOVWF  FE9
01CCC:  MOVLW  0B
01CCE:  ADDWFC 03,W
01CD0:  MOVWF  FEA
01CD2:  MOVFF  BF1,C0E
01CD6:  MOVFF  BF0,00
01CDA:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01CDE:  INCF   x08,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningTareValue >> 16) & 0xFFFF); 
01CE0:  MOVFF  4D8,BF0
01CE4:  MOVFF  4D9,BF1
01CE8:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF);; 
01CEA:  CLRF   03
01CEC:  MOVF   x08,W
01CEE:  ADDLW  BA
01CF0:  MOVWF  FE9
01CF2:  MOVLW  0B
01CF4:  ADDWFC 03,W
01CF6:  MOVWF  FEA
01CF8:  MOVFF  BF1,00
01CFC:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D00:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF);; 
01D02:  CLRF   03
01D04:  MOVF   x08,W
01D06:  ADDLW  BA
01D08:  MOVWF  FE9
01D0A:  MOVLW  0B
01D0C:  ADDWFC 03,W
01D0E:  MOVWF  FEA
01D10:  MOVFF  BF1,C0E
01D14:  MOVFF  BF0,00
01D18:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D1C:  INCF   x08,F
....................      
....................     // CRC calculation. 
....................     ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
01D1E:  MOVLW  0B
01D20:  MOVWF  x16
01D22:  MOVLW  BA
01D24:  MOVWF  x15
01D26:  MOVFF  C08,C17
01D2A:  MOVLB  0
01D2C:  CALL   0B0E
01D30:  MOVFF  02,C0A
01D34:  MOVFF  01,C09
....................  
....................     // Stuff CRC 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
01D38:  CLRF   03
01D3A:  MOVLB  C
01D3C:  MOVF   x08,W
01D3E:  ADDLW  BA
01D40:  MOVWF  FE9
01D42:  MOVLW  0B
01D44:  ADDWFC 03,W
01D46:  MOVWF  FEA
01D48:  MOVFF  C09,00
01D4C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;                 
01D50:  INCF   x08,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01D52:  CLRF   03
01D54:  MOVF   x08,W
01D56:  ADDLW  BA
01D58:  MOVWF  FE9
01D5A:  MOVLW  0B
01D5C:  ADDWFC 03,W
01D5E:  MOVWF  FEA
01D60:  MOVFF  C0A,00
01D64:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01D68:  INCF   x08,F
....................      
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01D6A:  BSF    F7F.0
01D6C:  BCF    F87.0
....................     delay_ms(2); 
01D6E:  MOVLW  02
01D70:  MOVWF  x15
01D72:  MOVLB  0
01D74:  RCALL  1770
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01D76:  MOVLB  C
01D78:  CLRF   x07
01D7A:  MOVF   x08,W
01D7C:  SUBWF  x07,W
01D7E:  BC    1D9E
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01D80:  CLRF   03
01D82:  MOVF   x07,W
01D84:  ADDLW  BA
01D86:  MOVWF  FE9
01D88:  MOVLW  0B
01D8A:  ADDWFC 03,W
01D8C:  MOVWF  FEA
01D8E:  MOVFF  FEF,C0B
01D92:  MOVF   x0B,W
01D94:  MOVLB  0
01D96:  RCALL  17A0
01D98:  MOVLB  C
01D9A:  INCF   x07,F
01D9C:  BRA    1D7A
....................     } 
....................      
....................     delay_ms(3); 
01D9E:  MOVLW  03
01DA0:  MOVWF  x15
01DA2:  MOVLB  0
01DA4:  RCALL  1770
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0);     
01DA6:  BCF    F7F.0
01DA8:  BCF    F87.0
01DAA:  GOTO   2C0C (RETURN)
....................      
.................... } 
....................  
.................... void SendResponseToMaster(unsigned int8 ui8ResponseType, unsigned int8 ui8FuncCode, unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow, int32 ui32RegData) 
*
017AC:  MOVLB  C
017AE:  CLRF   x0E
017B0:  CLRF   x0D
017B2:  CLRF   x10
017B4:  CLRF   x0F
017B6:  CLRF   x11
017B8:  CLRF   x12
017BA:  CLRF   x14
017BC:  CLRF   x13
.................... { 
....................     unsigned int16 ui16NoOfRegisterToFollow = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16RegisterData         = 0; 
....................      
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
017BE:  CLRF   03
017C0:  MOVF   x12,W
017C2:  ADDLW  BA
017C4:  MOVWF  FE9
017C6:  MOVLW  0B
017C8:  ADDWFC 03,W
017CA:  MOVWF  FEA
017CC:  MOVLW  01
017CE:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
017D0:  INCF   x12,F
....................      
....................     // Step 1: Parse response type 
....................     if(MODBUS_RESPONSE_TO_MASTER_FOR_READ == ui8ResponseType) 
017D2:  MOVF   x04,W
017D4:  SUBLW  09
017D6:  BTFSS  FD8.2
017D8:  BRA    192E
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
017DA:  MOVF   x05,W
017DC:  XORLW  03
017DE:  MOVLB  0
017E0:  BZ    17E4
017E2:  BRA    192A
....................         { 
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Stuff  the function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
017E4:  CLRF   03
017E6:  MOVLB  C
017E8:  MOVF   x12,W
017EA:  ADDLW  BA
017EC:  MOVWF  FE9
017EE:  MOVLW  0B
017F0:  ADDWFC 03,W
017F2:  MOVWF  FEA
017F4:  MOVLW  03
017F6:  MOVWF  FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
017F8:  INCF   x12,F
....................                  
....................                 // Parse the no of registers to response 
....................                 if(2 == ui8DataBytesToFollow) // For WORD. 
017FA:  MOVF   x08,W
017FC:  SUBLW  02
017FE:  BNZ   184E
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01800:  CLRF   03
01802:  MOVF   x12,W
01804:  ADDLW  BA
01806:  MOVWF  FE9
01808:  MOVLW  0B
0180A:  ADDWFC 03,W
0180C:  MOVWF  FEA
0180E:  MOVFF  C08,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
01812:  INCF   x12,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData); 
01814:  MOVFF  C0A,C14
01818:  MOVFF  C09,C13
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
0181C:  CLRF   03
0181E:  MOVF   x12,W
01820:  ADDLW  BA
01822:  MOVWF  FE9
01824:  MOVLW  0B
01826:  ADDWFC 03,W
01828:  MOVWF  FEA
0182A:  MOVFF  C14,00
0182E:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
01832:  INCF   x12,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
01834:  CLRF   03
01836:  MOVF   x12,W
01838:  ADDLW  BA
0183A:  MOVWF  FE9
0183C:  MOVLW  0B
0183E:  ADDWFC 03,W
01840:  MOVWF  FEA
01842:  MOVFF  C13,00
01846:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
0184A:  INCF   x12,F
....................                 } 
0184C:  BRA    18DA
....................                 else if(4 == ui8DataBytesToFollow) // For DOUBLE WORD 
0184E:  MOVF   x08,W
01850:  SUBLW  04
01852:  BNZ   18DA
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01854:  CLRF   03
01856:  MOVF   x12,W
01858:  ADDLW  BA
0185A:  MOVWF  FE9
0185C:  MOVLW  0B
0185E:  ADDWFC 03,W
01860:  MOVWF  FEA
01862:  MOVFF  C08,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
01866:  INCF   x12,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData);  // 1st WORD of the DOUBLE WORD 
01868:  MOVFF  C0A,C14
0186C:  MOVFF  C09,C13
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
01870:  CLRF   03
01872:  MOVF   x12,W
01874:  ADDLW  BA
01876:  MOVWF  FE9
01878:  MOVLW  0B
0187A:  ADDWFC 03,W
0187C:  MOVWF  FEA
0187E:  MOVFF  C14,00
01882:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
01886:  INCF   x12,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
01888:  CLRF   03
0188A:  MOVF   x12,W
0188C:  ADDLW  BA
0188E:  MOVWF  FE9
01890:  MOVLW  0B
01892:  ADDWFC 03,W
01894:  MOVWF  FEA
01896:  MOVFF  C13,00
0189A:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;  
0189E:  INCF   x12,F
....................                     ui16RegisterData = (unsigned int16)(ui32RegData >> 16);  // 2nd WORD of the DOUBLE WORD 
018A0:  MOVFF  C0B,C13
018A4:  MOVFF  C0C,C14
018A8:  CLRF   03
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
018AA:  CLRF   03
018AC:  MOVF   x12,W
018AE:  ADDLW  BA
018B0:  MOVWF  FE9
018B2:  MOVLW  0B
018B4:  ADDWFC 03,W
018B6:  MOVWF  FEA
018B8:  MOVFF  C14,00
018BC:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
018C0:  INCF   x12,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
018C2:  CLRF   03
018C4:  MOVF   x12,W
018C6:  ADDLW  BA
018C8:  MOVWF  FE9
018CA:  MOVLW  0B
018CC:  ADDWFC 03,W
018CE:  MOVWF  FEA
018D0:  MOVFF  C13,00
018D4:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
018D8:  INCF   x12,F
....................                 } 
....................                 else 
....................                 { 
....................                     /* Do Nothing */ 
....................                 }  
....................                  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
018DA:  MOVLW  0B
018DC:  MOVWF  x16
018DE:  MOVLW  BA
018E0:  MOVWF  x15
018E2:  MOVFF  C12,C17
018E6:  MOVLB  0
018E8:  CALL   0B0E
018EC:  MOVFF  02,C10
018F0:  MOVFF  01,C0F
....................                  
....................                 // Stuff CRC value. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
018F4:  CLRF   03
018F6:  MOVLB  C
018F8:  MOVF   x12,W
018FA:  ADDLW  BA
018FC:  MOVWF  FE9
018FE:  MOVLW  0B
01900:  ADDWFC 03,W
01902:  MOVWF  FEA
01904:  MOVFF  C0F,00
01908:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0190C:  INCF   x12,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
0190E:  CLRF   03
01910:  MOVF   x12,W
01912:  ADDLW  BA
01914:  MOVWF  FE9
01916:  MOVLW  0B
01918:  ADDWFC 03,W
0191A:  MOVWF  FEA
0191C:  MOVFF  C10,00
01920:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01924:  INCF   x12,F
....................                 break; 
01926:  BRA    192C
01928:  MOVLB  0
....................             default: 
....................                 break; 
0192A:  MOVLB  C
....................         } 
....................     } 
0192C:  BRA    1A36
....................     else // Respond against write. 
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
0192E:  MOVF   x05,W
01930:  XORLW  06
01932:  MOVLB  0
01934:  BZ    193C
01936:  XORLW  16
01938:  BZ    1962
0193A:  BRA    1A32
....................         { 
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Stuff reply in RS485 transmit buffer. 
....................                 memcpy(g_ui8RS485Txbuffer, g_ui8RS485Rxbuffer, g_ui8RS485RxByteCount); 
0193C:  MOVLW  0B
0193E:  MOVWF  FEA
01940:  MOVLW  BA
01942:  MOVWF  FE9
01944:  MOVLW  0B
01946:  MOVWF  FE2
01948:  MOVLW  88
0194A:  MOVWF  FE1
0194C:  MOVLB  B
0194E:  MOVF   xEC,W
01950:  MOVWF  01
01952:  BZ    195C
01954:  MOVFF  FE6,FEE
01958:  DECFSZ 01,F
0195A:  BRA    1954
....................                 ui8DataBytesToSend = g_ui8RS485RxByteCount; 
0195C:  MOVFF  BEC,C12
....................                 break; 
01960:  BRA    1A34
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Stuff function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8FuncCode; 
01962:  CLRF   03
01964:  MOVLB  C
01966:  MOVF   x12,W
01968:  ADDLW  BA
0196A:  MOVWF  FE9
0196C:  MOVLW  0B
0196E:  ADDWFC 03,W
01970:  MOVWF  FEA
01972:  MOVFF  C05,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
01976:  INCF   x12,F
....................                  
....................                 // Stuff data address of the first register. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
01978:  CLRF   03
0197A:  MOVF   x12,W
0197C:  ADDLW  BA
0197E:  MOVWF  FE9
01980:  MOVLW  0B
01982:  ADDWFC 03,W
01984:  MOVWF  FEA
01986:  MOVFF  C07,00
0198A:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0198E:  INCF   x12,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); 
01990:  CLRF   03
01992:  MOVF   x12,W
01994:  ADDLW  BA
01996:  MOVWF  FE9
01998:  MOVLW  0B
0199A:  ADDWFC 03,W
0199C:  MOVWF  FEA
0199E:  MOVFF  C06,00
019A2:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019A6:  INCF   x12,F
....................  
....................                 // Stuff no of registers written. 
....................                 ui16NoOfRegisterToFollow = (unsigned int16)(ui8DataBytesToFollow / 2); 
019A8:  BCF    FD8.0
019AA:  RRCF   x08,W
019AC:  CLRF   x0E
019AE:  MOVWF  x0D
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 8) & 0xFF); 
019B0:  CLRF   03
019B2:  MOVF   x12,W
019B4:  ADDLW  BA
019B6:  MOVWF  FE9
019B8:  MOVLW  0B
019BA:  ADDWFC 03,W
019BC:  MOVWF  FEA
019BE:  MOVFF  C0E,00
019C2:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019C6:  INCF   x12,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 0) & 0xFF); 
019C8:  CLRF   03
019CA:  MOVF   x12,W
019CC:  ADDLW  BA
019CE:  MOVWF  FE9
019D0:  MOVLW  0B
019D2:  ADDWFC 03,W
019D4:  MOVWF  FEA
019D6:  MOVFF  C0D,00
019DA:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019DE:  INCF   x12,F
....................  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, 6); 
019E0:  MOVLW  0B
019E2:  MOVWF  x16
019E4:  MOVLW  BA
019E6:  MOVWF  x15
019E8:  MOVLW  06
019EA:  MOVWF  x17
019EC:  MOVLB  0
019EE:  CALL   0B0E
019F2:  MOVFF  02,C10
019F6:  MOVFF  01,C0F
....................                  
....................                 // Stuff CRC 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
019FA:  CLRF   03
019FC:  MOVLB  C
019FE:  MOVF   x12,W
01A00:  ADDLW  BA
01A02:  MOVWF  FE9
01A04:  MOVLW  0B
01A06:  ADDWFC 03,W
01A08:  MOVWF  FEA
01A0A:  MOVFF  C0F,00
01A0E:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A12:  INCF   x12,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01A14:  CLRF   03
01A16:  MOVF   x12,W
01A18:  ADDLW  BA
01A1A:  MOVWF  FE9
01A1C:  MOVLW  0B
01A1E:  ADDWFC 03,W
01A20:  MOVWF  FEA
01A22:  MOVFF  C10,00
01A26:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A2A:  INCF   x12,F
....................                  
....................                 break; 
01A2C:  MOVLB  B
01A2E:  BRA    1A34
01A30:  MOVLB  0
....................             default: 
....................                 break; 
01A32:  MOVLB  B
01A34:  MOVLB  C
....................         } 
....................     } 
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01A36:  BSF    F7F.0
01A38:  BCF    F87.0
....................     delay_ms(2); 
01A3A:  MOVLW  02
01A3C:  MOVWF  x15
01A3E:  MOVLB  0
01A40:  RCALL  1770
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01A42:  MOVLB  C
01A44:  CLRF   x11
01A46:  MOVF   x12,W
01A48:  SUBWF  x11,W
01A4A:  BC    1A6A
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01A4C:  CLRF   03
01A4E:  MOVF   x11,W
01A50:  ADDLW  BA
01A52:  MOVWF  FE9
01A54:  MOVLW  0B
01A56:  ADDWFC 03,W
01A58:  MOVWF  FEA
01A5A:  MOVFF  FEF,C15
01A5E:  MOVF   x15,W
01A60:  MOVLB  0
01A62:  RCALL  17A0
01A64:  MOVLB  C
01A66:  INCF   x11,F
01A68:  BRA    1A46
....................     } 
....................      
....................     delay_ms(3); 
01A6A:  MOVLW  03
01A6C:  MOVWF  x15
01A6E:  MOVLB  0
01A70:  RCALL  1770
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0); 
01A72:  BCF    F7F.0
01A74:  BCF    F87.0
01A76:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void ProcessUART2ReceivedData(void) 
*
02998:  MOVLB  B
0299A:  CLRF   xF8
0299C:  CLRF   xF7
0299E:  CLRF   xF9
029A0:  CLRF   xFB
029A2:  CLRF   xFA
029A4:  CLRF   xFD
029A6:  CLRF   xFC
029A8:  CLRF   xFE
029AA:  CLRF   xFF
029AC:  MOVLB  C
029AE:  CLRF   x00
029B0:  MOVLW  06
029B2:  MOVWF  x01
.................... { 
....................     unsigned int16 ui16ModbusCRCvalue       = 0; 
....................     unsigned int8  fIsValidCRC              = 0; 
....................     unsigned int16 ui16StartAddtess         = 0; 
....................     unsigned int16 ui16NoOfRegistersToRead  = 0; 
....................     unsigned int8  ui8LoopCount             = 0; 
....................     unsigned int8  ui8NoOfDataBytesToFollow = 0; 
....................     unsigned int8  ui8NoOfVariety           = 0; 
....................     unsigned int8  ui8WriteMulRegParseByteIndx = 6; 
....................      
....................  
....................     // Calculate CRC for data redundancy check. 
....................     // Calculate CRC with all bytes except last two. 
....................     ui16ModbusCRCvalue = calculateCrc(g_ui8RS485Rxbuffer, (g_ui8RS485RxByteCount - 2));     
029B4:  MOVLW  02
029B6:  MOVLB  B
029B8:  SUBWF  xEC,W
029BA:  MOVLB  C
029BC:  MOVWF  x02
029BE:  MOVLW  0B
029C0:  MOVWF  x16
029C2:  MOVLW  88
029C4:  MOVWF  x15
029C6:  MOVFF  C02,C17
029CA:  MOVLB  0
029CC:  CALL   0B0E
029D0:  MOVFF  02,BF8
029D4:  MOVFF  01,BF7
....................      
....................     // Validate CRC. 
....................     if(((ui16ModbusCRCvalue >> 8) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1] && 
....................        ((ui16ModbusCRCvalue >> 0) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 2]) 
029D8:  MOVFF  BF8,C02
029DC:  MOVLB  C
029DE:  CLRF   x03
029E0:  MOVLW  01
029E2:  MOVLB  B
029E4:  SUBWF  xEC,W
029E6:  CLRF   03
029E8:  ADDLW  88
029EA:  MOVWF  FE9
029EC:  MOVLW  0B
029EE:  ADDWFC 03,W
029F0:  MOVWF  FEA
029F2:  MOVF   FEF,W
029F4:  MOVLB  C
029F6:  SUBWF  x02,W
029F8:  BNZ   2A30
029FA:  MOVF   x03,F
029FC:  BNZ   2A30
029FE:  MOVFF  BF8,C03
02A02:  MOVFF  BF7,C02
02A06:  CLRF   x03
02A08:  MOVLW  02
02A0A:  MOVLB  B
02A0C:  SUBWF  xEC,W
02A0E:  CLRF   03
02A10:  ADDLW  88
02A12:  MOVWF  FE9
02A14:  MOVLW  0B
02A16:  ADDWFC 03,W
02A18:  MOVWF  FEA
02A1A:  MOVF   FEF,W
02A1C:  MOVLB  C
02A1E:  SUBWF  x02,W
02A20:  BNZ   2A30
02A22:  MOVF   x03,F
02A24:  BNZ   2A30
....................     { 
....................         // Set flag denoting received byte string CRC validation successful. 
....................         fIsValidCRC = 1; 
02A26:  MOVLW  01
02A28:  MOVLB  B
02A2A:  MOVWF  xF9
....................     } 
02A2C:  BRA    2A38
02A2E:  MOVLB  C
....................     else 
....................     { 
....................         // Error occured in received data bytes 
....................         ResetRS485RXBuffer(); 
02A30:  MOVLB  0
02A32:  CALL   1754
02A36:  MOVLB  B
....................     } 
....................      
....................     // If CRC validation turns out to true. 
....................     if(fIsValidCRC) 
02A38:  MOVF   xF9,F
02A3A:  BTFSC  FD8.2
02A3C:  GOTO   3B06
....................     { 
....................         // Parse function code and process accordingly. 
....................         switch(g_ui8RS485Rxbuffer[1]) 
02A40:  MOVF   x89,W
02A42:  XORLW  01
02A44:  MOVLB  0
02A46:  BZ    2A5E
02A48:  XORLW  02
02A4A:  BZ    2A62
02A4C:  XORLW  05
02A4E:  BTFSC  FD8.2
02A50:  BRA    2E48
02A52:  XORLW  16
02A54:  BTFSC  FD8.2
02A56:  GOTO   3750
02A5A:  GOTO   3B04
....................         { 
....................             case MODBUS_FNCODE_READ_COIL_STATUS: 
....................                  
....................                 break; 
02A5E:  GOTO   3B04
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02A62:  MOVLB  B
02A64:  CLRF   xFB
02A66:  MOVFF  B8A,BFA
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02A6A:  MOVFF  BFA,BFB
02A6E:  MOVLB  B
02A70:  CLRF   xFA
02A72:  MOVLB  B
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02A74:  MOVF   x8B,W
02A76:  IORWF  xFA,F
....................  
....................                 // Process the data at that address. 
....................                 switch(ui16StartAddtess) 
02A78:  MOVF   xFA,W
02A7A:  MOVWF  00
02A7C:  MOVF   xFB,W
02A7E:  MOVWF  03
02A80:  MOVLW  02
02A82:  SUBWF  03,W
02A84:  BNZ   2A90
02A86:  MOVLW  96
02A88:  SUBWF  00,W
02A8A:  MOVLB  0
02A8C:  BZ    2B1E
02A8E:  MOVLB  B
02A90:  MOVLW  02
02A92:  SUBWF  03,W
02A94:  BNZ   2AA2
02A96:  MOVLW  98
02A98:  SUBWF  00,W
02A9A:  MOVLB  0
02A9C:  BTFSC  FD8.2
02A9E:  BRA    2B74
02AA0:  MOVLB  B
02AA2:  MOVLW  05
02AA4:  SUBWF  03,W
02AA6:  BNZ   2AB4
02AA8:  MOVLW  60
02AAA:  SUBWF  00,W
02AAC:  MOVLB  0
02AAE:  BTFSC  FD8.2
02AB0:  BRA    2BCA
02AB2:  MOVLB  B
02AB4:  MOVLW  05
02AB6:  SUBWF  03,W
02AB8:  BNZ   2AC6
02ABA:  MOVLW  62
02ABC:  SUBWF  00,W
02ABE:  MOVLB  0
02AC0:  BTFSC  FD8.2
02AC2:  BRA    2C4C
02AC4:  MOVLB  B
02AC6:  MOVLW  05
02AC8:  SUBWF  03,W
02ACA:  BNZ   2AD8
02ACC:  MOVLW  66
02ACE:  SUBWF  00,W
02AD0:  MOVLB  0
02AD2:  BTFSC  FD8.2
02AD4:  BRA    2CA2
02AD6:  MOVLB  B
02AD8:  MOVLW  05
02ADA:  SUBWF  03,W
02ADC:  BNZ   2AEA
02ADE:  MOVLW  68
02AE0:  SUBWF  00,W
02AE2:  MOVLB  0
02AE4:  BTFSC  FD8.2
02AE6:  BRA    2CF8
02AE8:  MOVLB  B
02AEA:  MOVLW  05
02AEC:  SUBWF  03,W
02AEE:  BNZ   2AFC
02AF0:  MOVLW  64
02AF2:  SUBWF  00,W
02AF4:  MOVLB  0
02AF6:  BTFSC  FD8.2
02AF8:  BRA    2D4E
02AFA:  MOVLB  B
02AFC:  MOVF   03,W
02AFE:  BNZ   2B0C
02B00:  MOVLW  88
02B02:  SUBWF  00,W
02B04:  MOVLB  0
02B06:  BTFSC  FD8.2
02B08:  BRA    2DA0
02B0A:  MOVLB  B
02B0C:  MOVF   03,W
02B0E:  BNZ   2B1C
02B10:  MOVLW  65
02B12:  SUBWF  00,W
02B14:  MOVLB  0
02B16:  BTFSC  FD8.2
02B18:  BRA    2DF0
02B1A:  MOVLB  B
02B1C:  BRA    2E42
....................                 { 
....................                     case ADDRESS_FOR_CALIB_TARE_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02B1E:  MOVLB  B
02B20:  CLRF   xFD
02B22:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02B26:  MOVFF  BFC,BFD
02B2A:  MOVLB  B
02B2C:  CLRF   xFC
02B2E:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);   
02B30:  MOVF   x8D,W
02B32:  IORWF  xFC,F
....................  
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32TareADCValueForCalibration); 
02B34:  BCF    FD8.0
02B36:  RLCF   xFC,W
02B38:  MOVLB  C
02B3A:  MOVWF  x02
02B3C:  MOVLB  B
02B3E:  RLCF   xFD,W
02B40:  MOVLB  C
02B42:  MOVWF  x03
02B44:  MOVLW  09
02B46:  MOVWF  x04
02B48:  MOVLW  03
02B4A:  MOVWF  x05
02B4C:  MOVFF  BFB,C07
02B50:  MOVFF  BFA,C06
02B54:  MOVFF  C02,C08
02B58:  MOVFF  4C3,C0C
02B5C:  MOVFF  4C2,C0B
02B60:  MOVFF  4C1,C0A
02B64:  MOVFF  4C0,C09
02B68:  MOVLB  0
02B6A:  CALL   17AC
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02B6E:  CALL   1754
....................                          
....................                         break; 
02B72:  BRA    2E44
....................                     case ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02B74:  MOVLB  B
02B76:  CLRF   xFD
02B78:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02B7C:  MOVFF  BFC,BFD
02B80:  MOVLB  B
02B82:  CLRF   xFC
02B84:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02B86:  MOVF   x8D,W
02B88:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32gWeightADCValueForCalibration);                         
02B8A:  BCF    FD8.0
02B8C:  RLCF   xFC,W
02B8E:  MOVLB  C
02B90:  MOVWF  x02
02B92:  MOVLB  B
02B94:  RLCF   xFD,W
02B96:  MOVLB  C
02B98:  MOVWF  x03
02B9A:  MOVLW  09
02B9C:  MOVWF  x04
02B9E:  MOVLW  03
02BA0:  MOVWF  x05
02BA2:  MOVFF  BFB,C07
02BA6:  MOVFF  BFA,C06
02BAA:  MOVFF  C02,C08
02BAE:  MOVFF  4C7,C0C
02BB2:  MOVFF  4C6,C0B
02BB6:  MOVFF  4C5,C0A
02BBA:  MOVFF  4C4,C09
02BBE:  MOVLB  0
02BC0:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02BC4:  CALL   1754
....................                          
....................                         break; 
02BC8:  BRA    2E44
....................                     case ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02BCA:  MOVLB  B
02BCC:  CLRF   xFD
02BCE:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02BD2:  MOVFF  BFC,BFD
02BD6:  MOVLB  B
02BD8:  CLRF   xFC
02BDA:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02BDC:  MOVF   x8D,W
02BDE:  IORWF  xFC,F
....................  
....................                         // Check for number of registers requested for. 
....................                         if(ui16NoOfRegistersToRead > 1) 
02BE0:  MOVF   xFD,F
02BE2:  BNZ   2BEA
02BE4:  MOVF   xFC,W
02BE6:  SUBLW  01
02BE8:  BC    2C10
....................                         { 
....................                             // Step 2: Send response to master with requested data. 
....................                             SendMulResponseToMaster(ui16StartAddtess, (ui16NoOfRegistersToRead * 2)); 
02BEA:  BCF    FD8.0
02BEC:  RLCF   xFC,W
02BEE:  MOVLB  C
02BF0:  MOVWF  x02
02BF2:  MOVLB  B
02BF4:  RLCF   xFD,W
02BF6:  MOVLB  C
02BF8:  MOVWF  x03
02BFA:  MOVFF  BFB,C05
02BFE:  MOVFF  BFA,C04
02C02:  MOVFF  C02,C06
02C06:  MOVLB  0
02C08:  GOTO   1A78
....................                         } 
02C0C:  BRA    2C46
02C0E:  MOVLB  B
....................                         else 
....................                         {                         
....................                             // Step 2: Send response to master with requested data. 
....................                             SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16PipeCount);                                                 
02C10:  BCF    FD8.0
02C12:  RLCF   xFC,W
02C14:  MOVLB  C
02C16:  MOVWF  x02
02C18:  MOVLB  B
02C1A:  RLCF   xFD,W
02C1C:  MOVLB  C
02C1E:  MOVWF  x03
02C20:  MOVLW  09
02C22:  MOVWF  x04
02C24:  MOVLW  03
02C26:  MOVWF  x05
02C28:  MOVFF  BFB,C07
02C2C:  MOVFF  BFA,C06
02C30:  MOVFF  C02,C08
02C34:  CLRF   x0C
02C36:  CLRF   x0B
02C38:  MOVFF  4C9,C0A
02C3C:  MOVFF  4C8,C09
02C40:  MOVLB  0
02C42:  CALL   17AC
....................                         } 
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02C46:  CALL   1754
....................                          
....................                         break; 
02C4A:  BRA    2E44
....................                     case ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02C4C:  MOVLB  B
02C4E:  CLRF   xFD
02C50:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02C54:  MOVFF  BFC,BFD
02C58:  MOVLB  B
02C5A:  CLRF   xFC
02C5C:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02C5E:  MOVF   x8D,W
02C60:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32CurrentWt);                                                                         
02C62:  BCF    FD8.0
02C64:  RLCF   xFC,W
02C66:  MOVLB  C
02C68:  MOVWF  x02
02C6A:  MOVLB  B
02C6C:  RLCF   xFD,W
02C6E:  MOVLB  C
02C70:  MOVWF  x03
02C72:  MOVLW  09
02C74:  MOVWF  x04
02C76:  MOVLW  03
02C78:  MOVWF  x05
02C7A:  MOVFF  BFB,C07
02C7E:  MOVFF  BFA,C06
02C82:  MOVFF  C02,C08
02C86:  MOVFF  4CF,C0C
02C8A:  MOVFF  4CE,C0B
02C8E:  MOVFF  4CD,C0A
02C92:  MOVFF  4CC,C09
02C96:  MOVLB  0
02C98:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02C9C:  CALL   1754
....................                          
....................                         break; 
02CA0:  BRA    2E44
....................                     case ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02CA2:  MOVLB  B
02CA4:  CLRF   xFD
02CA6:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02CAA:  MOVFF  BFC,BFD
02CAE:  MOVLB  B
02CB0:  CLRF   xFC
02CB2:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02CB4:  MOVF   x8D,W
02CB6:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningAvgWt);                                                                         
02CB8:  BCF    FD8.0
02CBA:  RLCF   xFC,W
02CBC:  MOVLB  C
02CBE:  MOVWF  x02
02CC0:  MOVLB  B
02CC2:  RLCF   xFD,W
02CC4:  MOVLB  C
02CC6:  MOVWF  x03
02CC8:  MOVLW  09
02CCA:  MOVWF  x04
02CCC:  MOVLW  03
02CCE:  MOVWF  x05
02CD0:  MOVFF  BFB,C07
02CD4:  MOVFF  BFA,C06
02CD8:  MOVFF  C02,C08
02CDC:  MOVFF  4D5,C0C
02CE0:  MOVFF  4D4,C0B
02CE4:  MOVFF  4D3,C0A
02CE8:  MOVFF  4D2,C09
02CEC:  MOVLB  0
02CEE:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02CF2:  CALL   1754
....................                          
....................                         break; 
02CF6:  BRA    2E44
....................                     case ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02CF8:  MOVLB  B
02CFA:  CLRF   xFD
02CFC:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D00:  MOVFF  BFC,BFD
02D04:  MOVLB  B
02D06:  CLRF   xFC
02D08:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02D0A:  MOVF   x8D,W
02D0C:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningTareValue);                                                                         
02D0E:  BCF    FD8.0
02D10:  RLCF   xFC,W
02D12:  MOVLB  C
02D14:  MOVWF  x02
02D16:  MOVLB  B
02D18:  RLCF   xFD,W
02D1A:  MOVLB  C
02D1C:  MOVWF  x03
02D1E:  MOVLW  09
02D20:  MOVWF  x04
02D22:  MOVLW  03
02D24:  MOVWF  x05
02D26:  MOVFF  BFB,C07
02D2A:  MOVFF  BFA,C06
02D2E:  MOVFF  C02,C08
02D32:  MOVFF  4D9,C0C
02D36:  MOVFF  4D8,C0B
02D3A:  MOVFF  4D7,C0A
02D3E:  MOVFF  4D6,C09
02D42:  MOVLB  0
02D44:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02D48:  CALL   1754
....................                          
....................                         break; 
02D4C:  BRA    2E44
....................                     case ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02D4E:  MOVLB  B
02D50:  CLRF   xFD
02D52:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D56:  MOVFF  BFC,BFD
02D5A:  MOVLB  B
02D5C:  CLRF   xFC
02D5E:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02D60:  MOVF   x8D,W
02D62:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16CurrentPassStatus);                                                                         
02D64:  BCF    FD8.0
02D66:  RLCF   xFC,W
02D68:  MOVLB  C
02D6A:  MOVWF  x02
02D6C:  MOVLB  B
02D6E:  RLCF   xFD,W
02D70:  MOVLB  C
02D72:  MOVWF  x03
02D74:  MOVLW  09
02D76:  MOVWF  x04
02D78:  MOVLW  03
02D7A:  MOVWF  x05
02D7C:  MOVFF  BFB,C07
02D80:  MOVFF  BFA,C06
02D84:  MOVFF  C02,C08
02D88:  CLRF   x0C
02D8A:  CLRF   x0B
02D8C:  MOVFF  4D1,C0A
02D90:  MOVFF  4D0,C09
02D94:  MOVLB  0
02D96:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
02D9A:  CALL   1754
....................                         break; 
02D9E:  BRA    2E44
....................                     case ADDRESS_FOR_TOL_STORE_SEEKING_ACK: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02DA0:  MOVLB  B
02DA2:  CLRF   xFD
02DA4:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02DA8:  MOVFF  BFC,BFD
02DAC:  MOVLB  B
02DAE:  CLRF   xFC
02DB0:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);                         
02DB2:  MOVF   x8D,W
02DB4:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8ToleranceStoreAck); 
02DB6:  BCF    FD8.0
02DB8:  RLCF   xFC,W
02DBA:  MOVLB  C
02DBC:  MOVWF  x02
02DBE:  MOVLB  B
02DC0:  RLCF   xFD,W
02DC2:  MOVLB  C
02DC4:  MOVWF  x03
02DC6:  MOVLW  09
02DC8:  MOVWF  x04
02DCA:  MOVLW  03
02DCC:  MOVWF  x05
02DCE:  MOVFF  BFB,C07
02DD2:  MOVFF  BFA,C06
02DD6:  MOVFF  C02,C08
02DDA:  CLRF   x0C
02DDC:  CLRF   x0B
02DDE:  CLRF   x0A
02DE0:  MOVFF  4E7,C09
02DE4:  MOVLB  0
02DE6:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                          
02DEA:  CALL   1754
....................                         break; 
02DEE:  BRA    2E44
....................                     case ADDRESS_FOR_AIR_PRESSURE_ALARM: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02DF0:  MOVLB  B
02DF2:  CLRF   xFD
02DF4:  MOVFF  B8C,BFC
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02DF8:  MOVFF  BFC,BFD
02DFC:  MOVLB  B
02DFE:  CLRF   xFC
02E00:  MOVLB  B
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02E02:  MOVF   x8D,W
02E04:  IORWF  xFC,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8AirPressureAlarm); 
02E06:  BCF    FD8.0
02E08:  RLCF   xFC,W
02E0A:  MOVLB  C
02E0C:  MOVWF  x02
02E0E:  MOVLB  B
02E10:  RLCF   xFD,W
02E12:  MOVLB  C
02E14:  MOVWF  x03
02E16:  MOVLW  09
02E18:  MOVWF  x04
02E1A:  MOVLW  03
02E1C:  MOVWF  x05
02E1E:  MOVFF  BFB,C07
02E22:  MOVFF  BFA,C06
02E26:  MOVFF  C02,C08
02E2A:  CLRF   x0C
02E2C:  CLRF   x0B
02E2E:  CLRF   x0A
02E30:  MOVFF  4F8,C09
02E34:  MOVLB  0
02E36:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E3A:  CALL   1754
....................                         break;                         
02E3E:  BRA    2E44
02E40:  MOVLB  B
....................                     default: 
....................                         break; 
02E42:  MOVLB  0
....................                 } 
....................                 break; 
02E44:  GOTO   3B04
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02E48:  MOVLB  B
02E4A:  CLRF   xFB
02E4C:  MOVFF  B8A,BFA
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02E50:  MOVFF  BFA,BFB
02E54:  MOVLB  B
02E56:  CLRF   xFA
02E58:  MOVLB  B
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02E5A:  MOVF   x8B,W
02E5C:  IORWF  xFA,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
02E5E:  MOVF   xFA,W
02E60:  MOVWF  00
02E62:  MOVF   xFB,W
02E64:  MOVWF  03
02E66:  MOVLW  02
02E68:  SUBWF  03,W
02E6A:  BNZ   2E78
02E6C:  MOVLW  82
02E6E:  SUBWF  00,W
02E70:  MOVLB  0
02E72:  BTFSC  FD8.2
02E74:  BRA    2F72
02E76:  MOVLB  B
02E78:  MOVF   03,W
02E7A:  BNZ   2E88
02E7C:  MOVLW  05
02E7E:  SUBWF  00,W
02E80:  MOVLB  0
02E82:  BTFSC  FD8.2
02E84:  BRA    3026
02E86:  MOVLB  B
02E88:  MOVLW  02
02E8A:  SUBWF  03,W
02E8C:  BNZ   2E9A
02E8E:  MOVLW  99
02E90:  SUBWF  00,W
02E92:  MOVLB  0
02E94:  BTFSC  FD8.2
02E96:  BRA    3148
02E98:  MOVLB  B
02E9A:  MOVLW  05
02E9C:  SUBWF  03,W
02E9E:  BNZ   2EAC
02EA0:  MOVLW  52
02EA2:  SUBWF  00,W
02EA4:  MOVLB  0
02EA6:  BTFSC  FD8.2
02EA8:  BRA    31D4
02EAA:  MOVLB  B
02EAC:  MOVLW  05
02EAE:  SUBWF  03,W
02EB0:  BNZ   2EBE
02EB2:  MOVLW  54
02EB4:  SUBWF  00,W
02EB6:  MOVLB  0
02EB8:  BTFSC  FD8.2
02EBA:  BRA    3222
02EBC:  MOVLB  B
02EBE:  MOVF   03,W
02EC0:  BNZ   2ECE
02EC2:  MOVLW  99
02EC4:  SUBWF  00,W
02EC6:  MOVLB  0
02EC8:  BTFSC  FD8.2
02ECA:  BRA    32D6
02ECC:  MOVLB  B
02ECE:  MOVF   03,W
02ED0:  BNZ   2EDE
02ED2:  MOVLW  89
02ED4:  SUBWF  00,W
02ED6:  MOVLB  0
02ED8:  BTFSC  FD8.2
02EDA:  BRA    333C
02EDC:  MOVLB  B
02EDE:  MOVF   03,W
02EE0:  BNZ   2EEE
02EE2:  MOVLW  90
02EE4:  SUBWF  00,W
02EE6:  MOVLB  0
02EE8:  BTFSC  FD8.2
02EEA:  BRA    3368
02EEC:  MOVLB  B
02EEE:  MOVF   03,W
02EF0:  BNZ   2EFE
02EF2:  MOVLW  54
02EF4:  SUBWF  00,W
02EF6:  MOVLB  0
02EF8:  BTFSC  FD8.2
02EFA:  BRA    33A0
02EFC:  MOVLB  B
02EFE:  MOVF   03,W
02F00:  BNZ   2F0E
02F02:  MOVLW  58
02F04:  SUBWF  00,W
02F06:  MOVLB  0
02F08:  BTFSC  FD8.2
02F0A:  BRA    33D4
02F0C:  MOVLB  B
02F0E:  MOVF   03,W
02F10:  BNZ   2F1E
02F12:  MOVLW  59
02F14:  SUBWF  00,W
02F16:  MOVLB  0
02F18:  BTFSC  FD8.2
02F1A:  BRA    3488
02F1C:  MOVLB  B
02F1E:  MOVF   03,W
02F20:  BNZ   2F2E
02F22:  MOVLW  60
02F24:  SUBWF  00,W
02F26:  MOVLB  0
02F28:  BTFSC  FD8.2
02F2A:  BRA    353E
02F2C:  MOVLB  B
02F2E:  MOVF   03,W
02F30:  BNZ   2F3E
02F32:  MOVLW  62
02F34:  SUBWF  00,W
02F36:  MOVLB  0
02F38:  BTFSC  FD8.2
02F3A:  BRA    35F4
02F3C:  MOVLB  B
02F3E:  MOVF   03,W
02F40:  BNZ   2F4E
02F42:  MOVLW  63
02F44:  SUBWF  00,W
02F46:  MOVLB  0
02F48:  BTFSC  FD8.2
02F4A:  BRA    3620
02F4C:  MOVLB  B
02F4E:  MOVF   03,W
02F50:  BNZ   2F5E
02F52:  MOVLW  64
02F54:  SUBWF  00,W
02F56:  MOVLB  0
02F58:  BTFSC  FD8.2
02F5A:  BRA    3662
02F5C:  MOVLB  B
02F5E:  MOVF   03,W
02F60:  BNZ   2F6E
02F62:  MOVLW  66
02F64:  SUBWF  00,W
02F66:  MOVLB  0
02F68:  BTFSC  FD8.2
02F6A:  BRA    3696
02F6C:  MOVLB  B
02F6E:  GOTO   374C
....................                 { 
....................                     case ADDRESS_FOR_SET_LOAD_CELL_FACTOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrLoadCellFactor = g_ui8RS485Rxbuffer[4]; 
02F72:  MOVLB  4
02F74:  CLRF   xE4
02F76:  MOVFF  B8C,4E3
....................                         g_ui16CurrLoadCellFactor = ((g_ui16CurrLoadCellFactor << 8) & 0xFF00); 
02F7A:  MOVFF  4E3,4E4
02F7E:  MOVLB  4
02F80:  CLRF   xE3
02F82:  MOVLB  4
....................                         g_ui16CurrLoadCellFactor = (g_ui16CurrLoadCellFactor | g_ui8RS485Rxbuffer[5]); 
02F84:  MOVLB  B
02F86:  MOVF   x8D,W
02F88:  MOVLB  4
02F8A:  IORWF  xE3,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
02F8C:  MOVLW  0A
02F8E:  MOVLB  C
02F90:  MOVWF  x04
02F92:  MOVLW  06
02F94:  MOVWF  x05
02F96:  MOVFF  BFB,C07
02F9A:  MOVFF  BFA,C06
02F9E:  CLRF   x08
02FA0:  CLRF   x0C
02FA2:  CLRF   x0B
02FA4:  CLRF   x0A
02FA6:  CLRF   x09
02FA8:  MOVLB  0
02FAA:  CALL   17AC
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02FAE:  CALL   1754
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_SET_LOAD_CELL_FACTOR; 
02FB2:  MOVLW  6C
02FB4:  MOVLB  2
02FB6:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor = g_ui16CurrLoadCellFactor; 
02FB8:  MOVFF  4E4,104
02FBC:  MOVFF  4E3,103
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16Padding = 0; 
02FC0:  MOVLB  1
02FC2:  CLRF   x06
02FC4:  CLRF   x05
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
02FC6:  MOVLW  01
02FC8:  MOVLB  B
02FCA:  MOVWF  xFE
02FCC:  MOVF   xFE,W
02FCE:  SUBLW  08
02FD0:  BNC   300C
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUCurrLoadCellFactor.m_ui8Arr[ui8LoopCount-1]; 
02FD2:  CLRF   03
02FD4:  MOVF   xFE,W
02FD6:  ADDLW  06
02FD8:  MOVWF  01
02FDA:  MOVLW  02
02FDC:  ADDWFC 03,F
02FDE:  MOVFF  03,C03
02FE2:  MOVLW  01
02FE4:  MOVLB  B
02FE6:  SUBWF  xFE,W
02FE8:  CLRF   03
02FEA:  ADDLW  03
02FEC:  MOVWF  FE9
02FEE:  MOVLW  01
02FF0:  ADDWFC 03,W
02FF2:  MOVWF  FEA
02FF4:  MOVFF  FEF,C04
02FF8:  MOVLB  C
02FFA:  MOVFF  C03,FEA
02FFE:  MOVFF  01,FE9
03002:  MOVFF  C04,FEF
03006:  MOVLB  B
03008:  INCF   xFE,F
0300A:  BRA    2FCC
....................                         } 
....................      
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
0300C:  MOVLW  02
0300E:  MOVLB  C
03010:  MOVWF  x03
03012:  MOVLW  9A
03014:  MOVWF  x02
03016:  MOVLW  02
03018:  MOVWF  x05
0301A:  MOVLW  04
0301C:  MOVWF  x04
0301E:  MOVLB  0
03020:  CALL   0BE2
....................                         break; 
03024:  BRA    374E
....................                     case MODE_ADDRESS: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrentMode = g_ui8RS485Rxbuffer[4]; 
03026:  MOVLB  4
03028:  CLRF   xE1
0302A:  MOVFF  B8C,4E0
....................                         g_ui16CurrentMode = ((g_ui16CurrentMode << 8) & 0xFF00); 
0302E:  MOVFF  4E0,4E1
03032:  MOVLB  4
03034:  CLRF   xE0
03036:  MOVLB  4
....................                         g_ui16CurrentMode = (g_ui16CurrentMode | g_ui8RS485Rxbuffer[5]);  
03038:  MOVLB  B
0303A:  MOVF   x8D,W
0303C:  MOVLB  4
0303E:  IORWF  xE0,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                         
03040:  MOVLW  0A
03042:  MOVLB  C
03044:  MOVWF  x04
03046:  MOVLW  06
03048:  MOVWF  x05
0304A:  MOVFF  BFB,C07
0304E:  MOVFF  BFA,C06
03052:  CLRF   x08
03054:  CLRF   x0C
03056:  CLRF   x0B
03058:  CLRF   x0A
0305A:  CLRF   x09
0305C:  MOVLB  0
0305E:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03062:  CALL   1754
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node.                         
....................                         switch(g_ui16CurrentMode) 
03066:  MOVLB  4
03068:  MOVF   xE0,W
0306A:  MOVWF  00
0306C:  MOVF   xE1,W
0306E:  MOVWF  03
03070:  MOVF   03,W
03072:  BNZ   307C
03074:  MOVF   00,F
03076:  MOVLB  0
03078:  BZ    30D2
0307A:  MOVLB  4
0307C:  MOVF   03,W
0307E:  BNZ   308A
03080:  MOVLW  01
03082:  SUBWF  00,W
03084:  MOVLB  0
03086:  BZ    30DA
03088:  MOVLB  4
0308A:  MOVF   03,W
0308C:  BNZ   3098
0308E:  MOVLW  02
03090:  SUBWF  00,W
03092:  MOVLB  0
03094:  BZ    30E2
03096:  MOVLB  4
03098:  MOVF   03,W
0309A:  BNZ   30A6
0309C:  MOVLW  03
0309E:  SUBWF  00,W
030A0:  MOVLB  0
030A2:  BZ    30EA
030A4:  MOVLB  4
030A6:  MOVF   03,W
030A8:  BNZ   30B4
030AA:  MOVLW  06
030AC:  SUBWF  00,W
030AE:  MOVLB  0
030B0:  BZ    30F2
030B2:  MOVLB  4
030B4:  MOVF   03,W
030B6:  BNZ   30C2
030B8:  MOVLW  05
030BA:  SUBWF  00,W
030BC:  MOVLB  0
030BE:  BZ    30FA
030C0:  MOVLB  4
030C2:  MOVF   03,W
030C4:  BNZ   30D0
030C6:  MOVLW  04
030C8:  SUBWF  00,W
030CA:  MOVLB  0
030CC:  BZ    3102
030CE:  MOVLB  4
030D0:  BRA    310C
....................                         { 
....................                             case BOARD_MODE_TYPE_NOTHING: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
030D2:  MOVLW  64
030D4:  MOVLB  2
030D6:  MOVWF  x06
....................                                  
....................                                 break; 
030D8:  BRA    310E
....................                             case BOARD_MODE_TYPE_HOME: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
030DA:  MOVLW  64
030DC:  MOVLB  2
030DE:  MOVWF  x06
....................                                          
....................                                 break; 
030E0:  BRA    310E
....................                             case BOARD_MODE_TYPE_PRE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PRE_PROD; 
030E2:  MOVLW  6F
030E4:  MOVLB  2
030E6:  MOVWF  x06
....................                                  
....................                                 break; 
030E8:  BRA    310E
....................                             case BOARD_MODE_TYPE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PROD; 
030EA:  MOVLW  82
030EC:  MOVLB  2
030EE:  MOVWF  x06
....................                                  
....................                                 break; 
030F0:  BRA    310E
....................                             case BOARD_MODE_TYPE_POST_PROD: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_POST_PROD; 
030F2:  MOVLW  96
030F4:  MOVLB  2
030F6:  MOVWF  x06
....................                                  
....................                                 break; 
030F8:  BRA    310E
....................                             case BOARD_MODE_TYPE_CALIBRATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CALIB; 
030FA:  MOVLW  65
030FC:  MOVLB  2
030FE:  MOVWF  x06
....................                                  
....................                                 break; 
03100:  BRA    310E
....................                             case BOARD_MODE_TYPE_CONFIGURATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CONFIG; 
03102:  MOVLW  8D
03104:  MOVLB  2
03106:  MOVWF  x06
....................                                  
....................                                 break; 
03108:  BRA    310E
0310A:  MOVLB  4
....................                             default: 
....................                                 break; 
0310C:  MOVLB  2
....................                         } 
....................                          
....................                         // Stuff remaining padding bytes. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0310E:  MOVLW  01
03110:  MOVLB  B
03112:  MOVWF  xFE
03114:  MOVF   xFE,W
03116:  SUBLW  08
03118:  BNC   312E
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
0311A:  CLRF   03
0311C:  MOVF   xFE,W
0311E:  ADDLW  06
03120:  MOVWF  FE9
03122:  MOVLW  02
03124:  ADDWFC 03,W
03126:  MOVWF  FEA
03128:  CLRF   FEF
0312A:  INCF   xFE,F
0312C:  BRA    3114
....................                         } 
....................                          
....................                         // Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0312E:  MOVLW  02
03130:  MOVLB  C
03132:  MOVWF  x03
03134:  MOVLW  9A
03136:  MOVWF  x02
03138:  MOVLW  02
0313A:  MOVWF  x05
0313C:  MOVLW  04
0313E:  MOVWF  x04
03140:  MOVLB  0
03142:  CALL   0BE2
....................                         break; 
03146:  BRA    374E
....................                     case  ADDRESS_FOR_START_CALIBRATION: 
....................                         // Step 1: accumulate data. 
....................                         g_fStartCalibration = g_ui8RS485Rxbuffer[4]; 
03148:  MOVFF  B8C,4E2
....................                         g_fStartCalibration = ((g_fStartCalibration << 8) & 0xFF00); 
0314C:  MOVLW  00
0314E:  MOVLB  4
03150:  CLRF   xE2
....................                         g_fStartCalibration = (g_fStartCalibration | g_ui8RS485Rxbuffer[5]);                          
03152:  MOVLB  B
03154:  MOVF   x8D,W
03156:  MOVLB  4
03158:  IORWF  xE2,F
....................                                  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
0315A:  MOVLW  0A
0315C:  MOVLB  C
0315E:  MOVWF  x04
03160:  MOVLW  06
03162:  MOVWF  x05
03164:  MOVFF  BFB,C07
03168:  MOVFF  BFA,C06
0316C:  CLRF   x08
0316E:  CLRF   x0C
03170:  CLRF   x0B
03172:  CLRF   x0A
03174:  CLRF   x09
03176:  MOVLB  0
03178:  CALL   17AC
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0317C:  CALL   1754
....................                                  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_START_CALIBRATION; 
03180:  MOVLW  66
03182:  MOVLB  2
03184:  MOVWF  x06
....................  
....................                         // b. Stuff data. 
....................                         // No data need to stuff 
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Remaining all bytes are padding bytes; need to stuff. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03186:  MOVLW  01
03188:  MOVLB  B
0318A:  MOVWF  xFE
0318C:  MOVF   xFE,W
0318E:  SUBLW  08
03190:  BNC   31A6
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
03192:  CLRF   03
03194:  MOVF   xFE,W
03196:  ADDLW  06
03198:  MOVWF  FE9
0319A:  MOVLW  02
0319C:  ADDWFC 03,W
0319E:  MOVWF  FEA
031A0:  CLRF   FEF
031A2:  INCF   xFE,F
031A4:  BRA    318C
....................                         }                         
....................  
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
031A6:  MOVLW  02
031A8:  MOVLB  C
031AA:  MOVWF  x03
031AC:  MOVLW  9A
031AE:  MOVWF  x02
031B0:  MOVLW  02
031B2:  MOVWF  x05
031B4:  MOVLW  04
031B6:  MOVWF  x04
031B8:  MOVLB  0
031BA:  CALL   0BE2
....................                          
....................                         // Reset Calibration point values; i.e. Tare ADC & Weight ADC values. 
....................                         g_ui32TareADCValueForCalibration = 0; 
031BE:  MOVLB  4
031C0:  CLRF   xC3
031C2:  CLRF   xC2
031C4:  CLRF   xC1
031C6:  CLRF   xC0
....................                         g_ui32gWeightADCValueForCalibration = 0; 
031C8:  CLRF   xC7
031CA:  CLRF   xC6
031CC:  CLRF   xC5
031CE:  CLRF   xC4
....................                         break; 
031D0:  MOVLB  0
031D2:  BRA    374E
....................                     case ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdPvTol = g_ui8RS485Rxbuffer[4]; 
031D4:  MOVLB  4
031D6:  CLRF   xDD
031D8:  MOVFF  B8C,4DC
....................                         g_ui16CurrProdPvTol = ((g_ui16CurrProdPvTol << 8) & 0xFF00); 
031DC:  MOVFF  4DC,4DD
031E0:  MOVLB  4
031E2:  CLRF   xDC
031E4:  MOVLB  4
....................                         g_ui16CurrProdPvTol = (g_ui16CurrProdPvTol | g_ui8RS485Rxbuffer[5]);                          
031E6:  MOVLB  B
031E8:  MOVF   x8D,W
031EA:  MOVLB  4
031EC:  IORWF  xDC,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);   
031EE:  MOVLW  0A
031F0:  MOVLB  C
031F2:  MOVWF  x04
031F4:  MOVLW  06
031F6:  MOVWF  x05
031F8:  MOVFF  BFB,C07
031FC:  MOVFF  BFA,C06
03200:  CLRF   x08
03202:  CLRF   x0C
03204:  CLRF   x0B
03206:  CLRF   x0A
03208:  CLRF   x09
0320A:  MOVLB  0
0320C:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03210:  CALL   1754
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         //g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (int16)g_ui16CurrProdPvTol; 
03214:  CLRF   xEA
03216:  CLRF   xE9
03218:  MOVFF  4DD,E8
0321C:  MOVFF  4DC,E7
....................                          
....................                         // ##################################################### 
....................                         // Positive tolerance will be sent to MCU0 after negative 
....................                         // tolerance will arrive so that can be sent accumulately. 
....................                         // ##################################################### 
....................                          
.................... //                        // c. Stuff padding bytes; if needed. 
.................... //                        g_unIBUAvgNode.m_stIBUAvgNode.m_i16Padding = 0; 
.................... //                        for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
.................... //                        { 
.................... //                            g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUAvgNode.m_ui8Arr[ui8LoopCount - 1]; 
.................... //                        }                         
.................... //                         
.................... //                        // d. Insert in IBU sent message queue. 
.................... //                        InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
....................                         break; 
03220:  BRA    374E
....................                     case ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdNvTol = g_ui8RS485Rxbuffer[4]; 
03222:  MOVLB  4
03224:  CLRF   xDF
03226:  MOVFF  B8C,4DE
....................                         g_ui16CurrProdNvTol = ((g_ui16CurrProdNvTol << 8) & 0xFF00); 
0322A:  MOVFF  4DE,4DF
0322E:  MOVLB  4
03230:  CLRF   xDE
03232:  MOVLB  4
....................                         g_ui16CurrProdNvTol = (g_ui16CurrProdNvTol | g_ui8RS485Rxbuffer[5]);  
03234:  MOVLB  B
03236:  MOVF   x8D,W
03238:  MOVLB  4
0323A:  IORWF  xDE,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
0323C:  MOVLW  0A
0323E:  MOVLB  C
03240:  MOVWF  x04
03242:  MOVLW  06
03244:  MOVWF  x05
03246:  MOVFF  BFB,C07
0324A:  MOVFF  BFA,C06
0324E:  CLRF   x08
03250:  CLRF   x0C
03252:  CLRF   x0B
03254:  CLRF   x0A
03256:  CLRF   x09
03258:  MOVLB  0
0325A:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0325E:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE;   
03262:  MOVLW  71
03264:  MOVLB  2
03266:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (int16)g_ui16CurrProdNvTol; 
03268:  MOVLB  0
0326A:  CLRF   xEE
0326C:  CLRF   xED
0326E:  MOVFF  4DF,EC
03272:  MOVFF  4DE,EB
....................                          
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Not Needed. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03276:  MOVLW  01
03278:  MOVLB  B
0327A:  MOVWF  xFE
0327C:  MOVF   xFE,W
0327E:  SUBLW  08
03280:  BNC   32BC
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
03282:  CLRF   03
03284:  MOVF   xFE,W
03286:  ADDLW  06
03288:  MOVWF  01
0328A:  MOVLW  02
0328C:  ADDWFC 03,F
0328E:  MOVFF  03,C03
03292:  MOVLW  01
03294:  MOVLB  B
03296:  SUBWF  xFE,W
03298:  CLRF   03
0329A:  ADDLW  E7
0329C:  MOVWF  FE9
0329E:  MOVLW  00
032A0:  ADDWFC 03,W
032A2:  MOVWF  FEA
032A4:  MOVFF  FEF,C04
032A8:  MOVLB  C
032AA:  MOVFF  C03,FEA
032AE:  MOVFF  01,FE9
032B2:  MOVFF  C04,FEF
032B6:  MOVLB  B
032B8:  INCF   xFE,F
032BA:  BRA    327C
....................                         }  
....................                          
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
032BC:  MOVLW  02
032BE:  MOVLB  C
032C0:  MOVWF  x03
032C2:  MOVLW  9A
032C4:  MOVWF  x02
032C6:  MOVLW  02
032C8:  MOVWF  x05
032CA:  MOVLW  04
032CC:  MOVWF  x04
032CE:  MOVLB  0
032D0:  CALL   0BE2
....................                         break; 
032D4:  BRA    374E
....................                     case ADDRESS_FOR_SCRAP_ON_MODE: 
....................                         // Step 1: No data to parse..just send the mode to MCU0 for mode setting. 
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
032D6:  MOVLW  0A
032D8:  MOVLB  C
032DA:  MOVWF  x04
032DC:  MOVLW  06
032DE:  MOVWF  x05
032E0:  MOVFF  BFB,C07
032E4:  MOVFF  BFA,C06
032E8:  CLRF   x08
032EA:  CLRF   x0C
032EC:  CLRF   x0B
032EE:  CLRF   x0A
032F0:  CLRF   x09
032F2:  MOVLB  0
032F4:  CALL   17AC
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
032F8:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_SCRAP_MODE; 
032FC:  MOVLW  76
032FE:  MOVLB  2
03300:  MOVWF  x06
....................                          
....................                         // b. Stuff padding data. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03302:  MOVLW  01
03304:  MOVLB  B
03306:  MOVWF  xFE
03308:  MOVF   xFE,W
0330A:  SUBLW  08
0330C:  BNC   3322
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
0330E:  CLRF   03
03310:  MOVF   xFE,W
03312:  ADDLW  06
03314:  MOVWF  FE9
03316:  MOVLW  02
03318:  ADDWFC 03,W
0331A:  MOVWF  FEA
0331C:  CLRF   FEF
0331E:  INCF   xFE,F
03320:  BRA    3308
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03322:  MOVLW  02
03324:  MOVLB  C
03326:  MOVWF  x03
03328:  MOVLW  9A
0332A:  MOVWF  x02
0332C:  MOVLW  02
0332E:  MOVWF  x05
03330:  MOVLW  04
03332:  MOVWF  x04
03334:  MOVLB  0
03336:  CALL   0BE2
....................                         break; 
0333A:  BRA    374E
....................                     case ADDRESS_FOR_TOL_STORE_SETTING_ACK: 
....................                         // No data to parse. 
....................                         // Ack confirmation message. 
....................                         // Reset ack register. 
....................                         g_ui8ToleranceStoreAck = 0; 
0333C:  MOVLB  4
0333E:  CLRF   xE7
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
03340:  MOVLW  0A
03342:  MOVLB  C
03344:  MOVWF  x04
03346:  MOVLW  06
03348:  MOVWF  x05
0334A:  MOVFF  BFB,C07
0334E:  MOVFF  BFA,C06
03352:  CLRF   x08
03354:  CLRF   x0C
03356:  CLRF   x0B
03358:  CLRF   x0A
0335A:  CLRF   x09
0335C:  MOVLB  0
0335E:  CALL   17AC
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
03362:  CALL   1754
....................                         break; 
03366:  BRA    374E
....................                     case ADDRESS_FOR_MACHINE_ID: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8MachineID = g_ui8RS485Rxbuffer[5]; 
03368:  MOVFF  B8D,4E8
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);    
0336C:  MOVLW  0A
0336E:  MOVLB  C
03370:  MOVWF  x04
03372:  MOVLW  06
03374:  MOVWF  x05
03376:  MOVFF  BFB,C07
0337A:  MOVFF  BFA,C06
0337E:  CLRF   x08
03380:  CLRF   x0C
03382:  CLRF   x0B
03384:  CLRF   x0A
03386:  CLRF   x09
03388:  MOVLB  0
0338A:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0338E:  CALL   1754
....................                          
....................                         // Step 4: Set data. 
....................                         g_stLANDataHeader.m_ui8MachineID = g_ui8MachineID; 
03392:  MOVFF  4E8,99
....................                         
....................                         // Step 5: Store data in EEPROM. 
....................                         WriteMachineIDToEEPROM(g_ui8MachineID);                         
03396:  MOVFF  4E8,C02
0339A:  GOTO   1DE4
....................                         break; 
0339E:  BRA    374E
....................                     case ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8DataSendingIntervalTime = g_ui8RS485Rxbuffer[5]; 
033A0:  MOVFF  B8D,4EA
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
033A4:  MOVLW  0A
033A6:  MOVLB  C
033A8:  MOVWF  x04
033AA:  MOVLW  06
033AC:  MOVWF  x05
033AE:  MOVFF  BFB,C07
033B2:  MOVFF  BFA,C06
033B6:  CLRF   x08
033B8:  CLRF   x0C
033BA:  CLRF   x0B
033BC:  CLRF   x0A
033BE:  CLRF   x09
033C0:  MOVLB  0
033C2:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
033C6:  CALL   1754
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteIntervalToEEPROM(g_ui8DataSendingIntervalTime); 
033CA:  MOVFF  4EA,C02
033CE:  GOTO   1DF8
....................                         break;                                 
033D2:  BRA    374E
....................                     case ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipePresenceDelayTime = g_ui8RS485Rxbuffer[4]; 
033D4:  MOVLB  4
033D6:  CLRF   xEF
033D8:  MOVFF  B8C,4EE
....................                         g_ui16PipePresenceDelayTime = ((g_ui16PipePresenceDelayTime << 8) & 0xFF00); 
033DC:  MOVFF  4EE,4EF
033E0:  MOVLB  4
033E2:  CLRF   xEE
033E4:  MOVLB  4
....................                         g_ui16PipePresenceDelayTime = (g_ui16PipePresenceDelayTime | g_ui8RS485Rxbuffer[5]); 
033E6:  MOVLB  B
033E8:  MOVF   x8D,W
033EA:  MOVLB  4
033EC:  IORWF  xEE,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
033EE:  MOVLW  0A
033F0:  MOVLB  C
033F2:  MOVWF  x04
033F4:  MOVLW  06
033F6:  MOVWF  x05
033F8:  MOVFF  BFB,C07
033FC:  MOVFF  BFA,C06
03400:  CLRF   x08
03402:  CLRF   x0C
03404:  CLRF   x0B
03406:  CLRF   x0A
03408:  CLRF   x09
0340A:  MOVLB  0
0340C:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03410:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
03414:  MOVLW  98
03416:  MOVLB  2
03418:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipePresenceDelayTime; 
0341A:  MOVFF  4EF,10D
0341E:  MOVFF  4EE,10C
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_PRESENCE_DELAY; // Means pipe presence delay time. 
03422:  MOVLW  01
03424:  MOVLB  1
03426:  MOVWF  x0B
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
03428:  CLRF   x0E
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0342A:  MOVLB  B
0342C:  MOVWF  xFE
0342E:  MOVF   xFE,W
03430:  SUBLW  08
03432:  BNC   346E
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
03434:  CLRF   03
03436:  MOVF   xFE,W
03438:  ADDLW  06
0343A:  MOVWF  01
0343C:  MOVLW  02
0343E:  ADDWFC 03,F
03440:  MOVFF  03,C03
03444:  MOVLW  01
03446:  MOVLB  B
03448:  SUBWF  xFE,W
0344A:  CLRF   03
0344C:  ADDLW  0B
0344E:  MOVWF  FE9
03450:  MOVLW  01
03452:  ADDWFC 03,W
03454:  MOVWF  FEA
03456:  MOVFF  FEF,C04
0345A:  MOVLB  C
0345C:  MOVFF  C03,FEA
03460:  MOVFF  01,FE9
03464:  MOVFF  C04,FEF
03468:  MOVLB  B
0346A:  INCF   xFE,F
0346C:  BRA    342E
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0346E:  MOVLW  02
03470:  MOVLB  C
03472:  MOVWF  x03
03474:  MOVLW  9A
03476:  MOVWF  x02
03478:  MOVLW  02
0347A:  MOVWF  x05
0347C:  MOVLW  04
0347E:  MOVWF  x04
03480:  MOVLB  0
03482:  CALL   0BE2
....................                         break; 
03486:  BRA    374E
....................                     case ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeStabilizationDelayTime = g_ui8RS485Rxbuffer[4]; 
03488:  MOVLB  4
0348A:  CLRF   xF1
0348C:  MOVFF  B8C,4F0
....................                         g_ui16PipeStabilizationDelayTime = ((g_ui16PipeStabilizationDelayTime << 8) & 0xFF00); 
03490:  MOVFF  4F0,4F1
03494:  MOVLB  4
03496:  CLRF   xF0
03498:  MOVLB  4
....................                         g_ui16PipeStabilizationDelayTime = (g_ui16PipeStabilizationDelayTime | g_ui8RS485Rxbuffer[5]); 
0349A:  MOVLB  B
0349C:  MOVF   x8D,W
0349E:  MOVLB  4
034A0:  IORWF  xF0,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
034A2:  MOVLW  0A
034A4:  MOVLB  C
034A6:  MOVWF  x04
034A8:  MOVLW  06
034AA:  MOVWF  x05
034AC:  MOVFF  BFB,C07
034B0:  MOVFF  BFA,C06
034B4:  CLRF   x08
034B6:  CLRF   x0C
034B8:  CLRF   x0B
034BA:  CLRF   x0A
034BC:  CLRF   x09
034BE:  MOVLB  0
034C0:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
034C4:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
034C8:  MOVLW  98
034CA:  MOVLB  2
034CC:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeStabilizationDelayTime; 
034CE:  MOVFF  4F1,10D
034D2:  MOVFF  4F0,10C
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_STABILIZATION_DELAY; // Means pipe stabilization delay time. 
034D6:  MOVLW  02
034D8:  MOVLB  1
034DA:  MOVWF  x0B
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
034DC:  CLRF   x0E
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
034DE:  MOVLW  01
034E0:  MOVLB  B
034E2:  MOVWF  xFE
034E4:  MOVF   xFE,W
034E6:  SUBLW  08
034E8:  BNC   3524
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
034EA:  CLRF   03
034EC:  MOVF   xFE,W
034EE:  ADDLW  06
034F0:  MOVWF  01
034F2:  MOVLW  02
034F4:  ADDWFC 03,F
034F6:  MOVFF  03,C03
034FA:  MOVLW  01
034FC:  MOVLB  B
034FE:  SUBWF  xFE,W
03500:  CLRF   03
03502:  ADDLW  0B
03504:  MOVWF  FE9
03506:  MOVLW  01
03508:  ADDWFC 03,W
0350A:  MOVWF  FEA
0350C:  MOVFF  FEF,C04
03510:  MOVLB  C
03512:  MOVFF  C03,FEA
03516:  MOVFF  01,FE9
0351A:  MOVFF  C04,FEF
0351E:  MOVLB  B
03520:  INCF   xFE,F
03522:  BRA    34E4
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03524:  MOVLW  02
03526:  MOVLB  C
03528:  MOVWF  x03
0352A:  MOVLW  9A
0352C:  MOVWF  x02
0352E:  MOVLW  02
03530:  MOVWF  x05
03532:  MOVLW  04
03534:  MOVWF  x04
03536:  MOVLB  0
03538:  CALL   0BE2
....................                         break; 
0353C:  BRA    374E
....................                     case ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeTransferDelayTime = g_ui8RS485Rxbuffer[4]; 
0353E:  MOVLB  4
03540:  CLRF   xF3
03542:  MOVFF  B8C,4F2
....................                         g_ui16PipeTransferDelayTime = ((g_ui16PipeTransferDelayTime << 8) & 0xFF00); 
03546:  MOVFF  4F2,4F3
0354A:  MOVLB  4
0354C:  CLRF   xF2
0354E:  MOVLB  4
....................                         g_ui16PipeTransferDelayTime = (g_ui16PipeTransferDelayTime | g_ui8RS485Rxbuffer[5]); 
03550:  MOVLB  B
03552:  MOVF   x8D,W
03554:  MOVLB  4
03556:  IORWF  xF2,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03558:  MOVLW  0A
0355A:  MOVLB  C
0355C:  MOVWF  x04
0355E:  MOVLW  06
03560:  MOVWF  x05
03562:  MOVFF  BFB,C07
03566:  MOVFF  BFA,C06
0356A:  CLRF   x08
0356C:  CLRF   x0C
0356E:  CLRF   x0B
03570:  CLRF   x0A
03572:  CLRF   x09
03574:  MOVLB  0
03576:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0357A:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
0357E:  MOVLW  98
03580:  MOVLB  2
03582:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeTransferDelayTime; 
03584:  MOVFF  4F3,10D
03588:  MOVFF  4F2,10C
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_TRANSFER_DELAY; // Means pipe transfer delay time. 
0358C:  MOVLW  03
0358E:  MOVLB  1
03590:  MOVWF  x0B
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
03592:  CLRF   x0E
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03594:  MOVLW  01
03596:  MOVLB  B
03598:  MOVWF  xFE
0359A:  MOVF   xFE,W
0359C:  SUBLW  08
0359E:  BNC   35DA
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
035A0:  CLRF   03
035A2:  MOVF   xFE,W
035A4:  ADDLW  06
035A6:  MOVWF  01
035A8:  MOVLW  02
035AA:  ADDWFC 03,F
035AC:  MOVFF  03,C03
035B0:  MOVLW  01
035B2:  MOVLB  B
035B4:  SUBWF  xFE,W
035B6:  CLRF   03
035B8:  ADDLW  0B
035BA:  MOVWF  FE9
035BC:  MOVLW  01
035BE:  ADDWFC 03,W
035C0:  MOVWF  FEA
035C2:  MOVFF  FEF,C04
035C6:  MOVLB  C
035C8:  MOVFF  C03,FEA
035CC:  MOVFF  01,FE9
035D0:  MOVFF  C04,FEF
035D4:  MOVLB  B
035D6:  INCF   xFE,F
035D8:  BRA    359A
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
035DA:  MOVLW  02
035DC:  MOVLB  C
035DE:  MOVWF  x03
035E0:  MOVLW  9A
035E2:  MOVWF  x02
035E4:  MOVLW  02
035E6:  MOVWF  x05
035E8:  MOVLW  04
035EA:  MOVWF  x04
035EC:  MOVLB  0
035EE:  CALL   0BE2
....................                         break; 
035F2:  BRA    374E
....................                     case ADDRESS_FOR_SHIFT_NUMBER: 
....................                         // Step 1: accumulate data.                         
....................                         g_ui8ShiftNumber = g_ui8RS485Rxbuffer[5]; 
035F4:  MOVFF  B8D,4F5
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
035F8:  MOVLW  0A
035FA:  MOVLB  C
035FC:  MOVWF  x04
035FE:  MOVLW  06
03600:  MOVWF  x05
03602:  MOVFF  BFB,C07
03606:  MOVFF  BFA,C06
0360A:  CLRF   x08
0360C:  CLRF   x0C
0360E:  CLRF   x0B
03610:  CLRF   x0A
03612:  CLRF   x09
03614:  MOVLB  0
03616:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
0361A:  CALL   1754
....................                         break; 
0361E:  BRA    374E
....................                     case ADDRESS_FOR_SHIFT_DURATION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16TotalMachineUpTime = g_ui8RS485Rxbuffer[4]; 
03620:  MOVLB  4
03622:  CLRF   xF7
03624:  MOVFF  B8C,4F6
....................                         g_ui16TotalMachineUpTime = ((g_ui16TotalMachineUpTime << 8) & 0xFF00); 
03628:  MOVFF  4F6,4F7
0362C:  MOVLB  4
0362E:  CLRF   xF6
03630:  MOVLB  4
....................                         g_ui16TotalMachineUpTime = (g_ui16TotalMachineUpTime | g_ui8RS485Rxbuffer[5]); 
03632:  MOVLB  B
03634:  MOVF   x8D,W
03636:  MOVLB  4
03638:  IORWF  xF6,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0363A:  MOVLW  0A
0363C:  MOVLB  C
0363E:  MOVWF  x04
03640:  MOVLW  06
03642:  MOVWF  x05
03644:  MOVFF  BFB,C07
03648:  MOVFF  BFA,C06
0364C:  CLRF   x08
0364E:  CLRF   x0C
03650:  CLRF   x0B
03652:  CLRF   x0A
03654:  CLRF   x09
03656:  MOVLB  0
03658:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0365C:  CALL   1754
....................                          
....................                         // Send the shift related data to server for report generation. 
....................                         // Insert data in GPRS message queue. 
....................                         //InsertInGPRSQueue(); 
....................                         break; 
03660:  BRA    374E
....................                     case ADDRESS_FOR_SELECT_SIM_OPERATOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8SIMOperatorID = g_ui8RS485Rxbuffer[5]; 
03662:  MOVFF  B8D,4F9
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03666:  MOVLW  0A
03668:  MOVLB  C
0366A:  MOVWF  x04
0366C:  MOVLW  06
0366E:  MOVWF  x05
03670:  MOVFF  BFB,C07
03674:  MOVFF  BFA,C06
03678:  CLRF   x08
0367A:  CLRF   x0C
0367C:  CLRF   x0B
0367E:  CLRF   x0A
03680:  CLRF   x09
03682:  MOVLB  0
03684:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03688:  CALL   1754
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteSIMOperatorIDToEEPROM(g_ui8SIMOperatorID);                         
0368C:  MOVFF  4F9,C02
03690:  GOTO   1E0C
....................                         break;  
03694:  BRA    374E
....................                     case ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16WeighingCylinderUpActivationDelay = g_ui8RS485Rxbuffer[4]; 
03696:  MOVLB  4
03698:  CLRF   xFB
0369A:  MOVFF  B8C,4FA
....................                         g_ui16WeighingCylinderUpActivationDelay = ((g_ui16WeighingCylinderUpActivationDelay << 8) & 0xFF00); 
0369E:  MOVFF  4FA,4FB
036A2:  MOVLB  4
036A4:  CLRF   xFA
036A6:  MOVLB  4
....................                         g_ui16WeighingCylinderUpActivationDelay = (g_ui16WeighingCylinderUpActivationDelay | g_ui8RS485Rxbuffer[5]); 
036A8:  MOVLB  B
036AA:  MOVF   x8D,W
036AC:  MOVLB  4
036AE:  IORWF  xFA,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
036B0:  MOVLW  0A
036B2:  MOVLB  C
036B4:  MOVWF  x04
036B6:  MOVLW  06
036B8:  MOVWF  x05
036BA:  MOVFF  BFB,C07
036BE:  MOVFF  BFA,C06
036C2:  CLRF   x08
036C4:  CLRF   x0C
036C6:  CLRF   x0B
036C8:  CLRF   x0A
036CA:  CLRF   x09
036CC:  MOVLB  0
036CE:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
036D2:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY; 
036D6:  MOVLW  9B
036D8:  MOVLB  2
036DA:  MOVWF  x06
....................                          
....................                         // b. Stuff data. 
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16DelayTime = g_ui16WeighingCylinderUpActivationDelay; 
036DC:  MOVFF  4FB,110
036E0:  MOVFF  4FA,10F
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16Spare = 0; 
036E4:  MOVLB  1
036E6:  CLRF   x12
036E8:  CLRF   x11
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
036EA:  MOVLW  01
036EC:  MOVLB  B
036EE:  MOVWF  xFE
036F0:  MOVF   xFE,W
036F2:  SUBLW  08
036F4:  BNC   3730
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unWeighingCylinderUpActivationDelay.m_ui8Arr[ui8LoopCount - 1]; 
036F6:  CLRF   03
036F8:  MOVF   xFE,W
036FA:  ADDLW  06
036FC:  MOVWF  01
036FE:  MOVLW  02
03700:  ADDWFC 03,F
03702:  MOVFF  03,C03
03706:  MOVLW  01
03708:  MOVLB  B
0370A:  SUBWF  xFE,W
0370C:  CLRF   03
0370E:  ADDLW  0F
03710:  MOVWF  FE9
03712:  MOVLW  01
03714:  ADDWFC 03,W
03716:  MOVWF  FEA
03718:  MOVFF  FEF,C04
0371C:  MOVLB  C
0371E:  MOVFF  C03,FEA
03722:  MOVFF  01,FE9
03726:  MOVFF  C04,FEF
0372A:  MOVLB  B
0372C:  INCF   xFE,F
0372E:  BRA    36F0
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
03730:  MOVLW  02
03732:  MOVLB  C
03734:  MOVWF  x03
03736:  MOVLW  9A
03738:  MOVWF  x02
0373A:  MOVLW  02
0373C:  MOVWF  x05
0373E:  MOVLW  04
03740:  MOVWF  x04
03742:  MOVLB  0
03744:  CALL   0BE2
....................                         break;                         
03748:  BRA    374E
0374A:  MOVLB  B
....................                     default: 
....................                         break; 
0374C:  MOVLB  0
....................    
....................                 } 
....................  
....................                 break; 
0374E:  BRA    3B04
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Accumulate first register address to start write. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
03750:  MOVLB  B
03752:  CLRF   xFB
03754:  MOVFF  B8A,BFA
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
03758:  MOVFF  BFA,BFB
0375C:  MOVLB  B
0375E:  CLRF   xFA
03760:  MOVLB  B
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
03762:  MOVF   x8B,W
03764:  IORWF  xFA,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
03766:  MOVF   xFA,W
03768:  MOVWF  00
0376A:  MOVF   xFB,W
0376C:  MOVWF  03
0376E:  MOVF   03,W
03770:  BNZ   377C
03772:  MOVLW  47
03774:  SUBWF  00,W
03776:  MOVLB  0
03778:  BZ    37C0
0377A:  MOVLB  B
0377C:  MOVF   03,W
0377E:  BNZ   378A
03780:  MOVLW  50
03782:  SUBWF  00,W
03784:  MOVLB  0
03786:  BZ    3858
03788:  MOVLB  B
0378A:  MOVF   03,W
0378C:  BNZ   379A
0378E:  MOVLW  52
03790:  SUBWF  00,W
03792:  MOVLB  0
03794:  BTFSC  FD8.2
03796:  BRA    39A2
03798:  MOVLB  B
0379A:  MOVLW  01
0379C:  SUBWF  03,W
0379E:  BNZ   37AC
037A0:  MOVLW  90
037A2:  SUBWF  00,W
037A4:  MOVLB  0
037A6:  BTFSC  FD8.2
037A8:  BRA    3A88
037AA:  MOVLB  B
037AC:  MOVLW  01
037AE:  SUBWF  03,W
037B0:  BNZ   37BE
037B2:  MOVLW  93
037B4:  SUBWF  00,W
037B6:  MOVLB  0
037B8:  BTFSC  FD8.2
037BA:  BRA    3AC2
037BC:  MOVLB  B
037BE:  BRA    3B00
....................                 { 
....................                     case ADRESS_FOR_HMI_TIMESTAMP: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];                         
037C0:  MOVFF  B8E,BFF
....................  
....................                         // Year 
....................                         g_stHMITime.tm_year = g_ui8RS485Rxbuffer[7]; 
037C4:  CLRF   xB7
037C6:  MOVFF  B8F,B6
....................                         g_stHMITime.tm_year = ((g_stHMITime.tm_year << 8) & 0xFF00); 
037CA:  MOVFF  B6,B7
037CE:  MOVLB  0
037D0:  CLRF   xB6
037D2:  MOVLB  0
....................                         g_stHMITime.tm_year = (g_stHMITime.tm_year | g_ui8RS485Rxbuffer[8]); 
037D4:  MOVLB  B
037D6:  MOVF   x90,W
037D8:  MOVLB  0
037DA:  IORWF  xB6,F
....................                         // Month 
....................                         g_stHMITime.tm_mon = g_ui8RS485Rxbuffer[10] - 1; 
037DC:  MOVLW  01
037DE:  MOVLB  B
037E0:  SUBWF  x92,W
037E2:  MOVLB  0
037E4:  MOVWF  xB5
....................                         // Day 
....................                         g_stHMITime.tm_mday = g_ui8RS485Rxbuffer[12]; 
037E6:  MOVFF  B94,B4
....................                         // Week Day 
....................                         g_stHMITime.tm_wday = g_ui8RS485Rxbuffer[14]; 
037EA:  MOVFF  B96,B8
....................                         // Hour 
....................                         g_stHMITime.tm_hour = g_ui8RS485Rxbuffer[16]; 
037EE:  MOVFF  B98,B3
....................                         // Minute 
....................                         g_stHMITime.tm_min = g_ui8RS485Rxbuffer[18]; 
037F2:  MOVFF  B9A,B2
....................                         // Second 
....................                         g_stHMITime.tm_sec = g_ui8RS485Rxbuffer[20]; 
037F6:  MOVFF  B9C,B1
....................                          
....................                         // Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
037FA:  MOVLW  0A
037FC:  MOVLB  C
037FE:  MOVWF  x04
03800:  MOVLW  10
03802:  MOVWF  x05
03804:  MOVFF  BFB,C07
03808:  MOVFF  BFA,C06
0380C:  MOVFF  BFF,C08
03810:  CLRF   x0C
03812:  CLRF   x0B
03814:  CLRF   x0A
03816:  CLRF   x09
03818:  MOVLB  0
0381A:  CALL   17AC
....................  
....................                         g_ui32UnixTimeInSec = mktime(&g_stHMITime); 
0381E:  MOVLB  C
03820:  CLRF   x03
03822:  MOVLW  B1
03824:  MOVWF  x02
03826:  MOVLB  0
03828:  GOTO   2074
0382C:  MOVFF  03,CA
03830:  MOVFF  02,C9
03834:  MOVFF  01,C8
03838:  MOVFF  00,C7
....................                          
....................                         g_pstHMITimeTemp = localtime(&g_ui32UnixTimeInSec); 
0383C:  MOVLB  C
0383E:  CLRF   x03
03840:  MOVLW  C7
03842:  MOVWF  x02
03844:  MOVLB  0
03846:  GOTO   2570
0384A:  MOVFF  02,C6
0384E:  MOVFF  01,C5
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03852:  CALL   1754
....................                         break; 
03856:  BRA    3B02
....................                     case ADDRESS_FOR_CALCULATED_MIN_MAX_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
03858:  MOVFF  B8E,BFF
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
0385C:  CLRF   xEA
0385E:  CLRF   xE9
03860:  CLRF   xE8
03862:  MOVFF  B91,E7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03866:  MOVFF  E9,EA
0386A:  MOVFF  E8,E9
0386E:  MOVFF  E7,E8
03872:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
03874:  MOVLB  B
03876:  MOVF   x92,W
03878:  MOVLB  0
0387A:  IORWF  xE7,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
0387C:  MOVFF  E9,EA
03880:  MOVFF  E8,E9
03884:  MOVFF  E7,E8
03888:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
0388A:  MOVLB  B
0388C:  MOVF   x8F,W
0388E:  MOVLB  0
03890:  IORWF  xE7,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03892:  MOVFF  E9,EA
03896:  MOVFF  E8,E9
0389A:  MOVFF  E7,E8
0389E:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
038A0:  MOVLB  B
038A2:  MOVF   x90,W
038A4:  MOVLB  0
038A6:  IORWF  xE7,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
038A8:  CLRF   xEE
038AA:  CLRF   xED
038AC:  CLRF   xEC
038AE:  MOVFF  B95,EB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
038B2:  MOVFF  ED,EE
038B6:  MOVFF  EC,ED
038BA:  MOVFF  EB,EC
038BE:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
038C0:  MOVLB  B
038C2:  MOVF   x96,W
038C4:  MOVLB  0
038C6:  IORWF  xEB,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
038C8:  MOVFF  ED,EE
038CC:  MOVFF  EC,ED
038D0:  MOVFF  EB,EC
038D4:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
038D6:  MOVLB  B
038D8:  MOVF   x93,W
038DA:  MOVLB  0
038DC:  IORWF  xEB,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
038DE:  MOVFF  ED,EE
038E2:  MOVFF  EC,ED
038E6:  MOVFF  EB,EC
038EA:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
038EC:  MOVLB  B
038EE:  MOVF   x94,W
038F0:  MOVLB  0
038F2:  IORWF  xEB,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
038F4:  MOVLW  0A
038F6:  MOVLB  C
038F8:  MOVWF  x04
038FA:  MOVLW  10
038FC:  MOVWF  x05
038FE:  MOVFF  BFB,C07
03902:  MOVFF  BFA,C06
03906:  MOVFF  BFF,C08
0390A:  CLRF   x0C
0390C:  CLRF   x0B
0390E:  CLRF   x0A
03910:  CLRF   x09
03912:  MOVLB  0
03914:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03918:  CALL   1754
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU data node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
0391C:  MOVLW  71
0391E:  MOVLB  2
03920:  MOVWF  x06
....................                          
....................                         // b. stuff data in node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03922:  MOVLW  01
03924:  MOVLB  B
03926:  MOVWF  xFE
03928:  MOVF   xFE,W
0392A:  SUBLW  08
0392C:  BNC   3968
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
0392E:  CLRF   03
03930:  MOVF   xFE,W
03932:  ADDLW  06
03934:  MOVWF  01
03936:  MOVLW  02
03938:  ADDWFC 03,F
0393A:  MOVFF  03,C03
0393E:  MOVLW  01
03940:  MOVLB  B
03942:  SUBWF  xFE,W
03944:  CLRF   03
03946:  ADDLW  E7
03948:  MOVWF  FE9
0394A:  MOVLW  00
0394C:  ADDWFC 03,W
0394E:  MOVWF  FEA
03950:  MOVFF  FEF,C04
03954:  MOVLB  C
03956:  MOVFF  C03,FEA
0395A:  MOVFF  01,FE9
0395E:  MOVFF  C04,FEF
03962:  MOVLB  B
03964:  INCF   xFE,F
03966:  BRA    3928
....................                         } 
....................  
....................                         // c. Insert in IBU message send queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03968:  MOVLW  02
0396A:  MOVLB  C
0396C:  MOVWF  x03
0396E:  MOVLW  9A
03970:  MOVWF  x02
03972:  MOVLW  02
03974:  MOVWF  x05
03976:  MOVLW  04
03978:  MOVWF  x04
0397A:  MOVLB  0
0397C:  CALL   0BE2
....................  
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03980:  MOVFF  EA,A5
03984:  MOVFF  E9,A4
03988:  MOVFF  E8,A3
0398C:  MOVFF  E7,A2
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt; 
03990:  MOVFF  EE,A9
03994:  MOVFF  ED,A8
03998:  MOVFF  EC,A7
0399C:  MOVFF  EB,A6
....................                         break; 
039A0:  BRA    3B02
....................                     case ADDRESS_FOR_PRE_PROD_MAX_MIN_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
039A2:  MOVFF  B8E,BFF
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
039A6:  CLRF   xEA
039A8:  CLRF   xE9
039AA:  CLRF   xE8
039AC:  MOVFF  B91,E7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039B0:  MOVFF  E9,EA
039B4:  MOVFF  E8,E9
039B8:  MOVFF  E7,E8
039BC:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
039BE:  MOVLB  B
039C0:  MOVF   x92,W
039C2:  MOVLB  0
039C4:  IORWF  xE7,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039C6:  MOVFF  E9,EA
039CA:  MOVFF  E8,E9
039CE:  MOVFF  E7,E8
039D2:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
039D4:  MOVLB  B
039D6:  MOVF   x8F,W
039D8:  MOVLB  0
039DA:  IORWF  xE7,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039DC:  MOVFF  E9,EA
039E0:  MOVFF  E8,E9
039E4:  MOVFF  E7,E8
039E8:  CLRF   xE7
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
039EA:  MOVLB  B
039EC:  MOVF   x90,W
039EE:  MOVLB  0
039F0:  IORWF  xE7,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
039F2:  CLRF   xEE
039F4:  CLRF   xED
039F6:  CLRF   xEC
039F8:  MOVFF  B95,EB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
039FC:  MOVFF  ED,EE
03A00:  MOVFF  EC,ED
03A04:  MOVFF  EB,EC
03A08:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
03A0A:  MOVLB  B
03A0C:  MOVF   x96,W
03A0E:  MOVLB  0
03A10:  IORWF  xEB,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A12:  MOVFF  ED,EE
03A16:  MOVFF  EC,ED
03A1A:  MOVFF  EB,EC
03A1E:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
03A20:  MOVLB  B
03A22:  MOVF   x93,W
03A24:  MOVLB  0
03A26:  IORWF  xEB,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A28:  MOVFF  ED,EE
03A2C:  MOVFF  EC,ED
03A30:  MOVFF  EB,EC
03A34:  CLRF   xEB
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
03A36:  MOVLB  B
03A38:  MOVF   x94,W
03A3A:  MOVLB  0
03A3C:  IORWF  xEB,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03A3E:  MOVLW  0A
03A40:  MOVLB  C
03A42:  MOVWF  x04
03A44:  MOVLW  10
03A46:  MOVWF  x05
03A48:  MOVFF  BFB,C07
03A4C:  MOVFF  BFA,C06
03A50:  MOVFF  BFF,C08
03A54:  CLRF   x0C
03A56:  CLRF   x0B
03A58:  CLRF   x0A
03A5A:  CLRF   x09
03A5C:  MOVLB  0
03A5E:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();  
03A62:  CALL   1754
....................                          
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03A66:  MOVFF  EA,A5
03A6A:  MOVFF  E9,A4
03A6E:  MOVFF  E8,A3
03A72:  MOVFF  E7,A2
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt;                         
03A76:  MOVFF  EE,A9
03A7A:  MOVFF  ED,A8
03A7E:  MOVFF  EC,A7
03A82:  MOVFF  EB,A6
....................                         break; 
03A86:  BRA    3B02
....................                     case ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03A88:  MOVFF  B8E,BFF
....................                          
....................                         // Basic material and standard Specification and pressure rating of pipe has arrived. 
....................                         // 1. First register(2 bytes) contains basic material and standard 
....................                         // 2. Second register(2 bytes) contains standard specification. 
....................                         // 3. Third register (2 bytes) contains pressure rating / type classification. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8BasicMaterialStandard = g_ui8RS485Rxbuffer[8]; 
03A8C:  MOVFF  B90,4FC
....................                         g_ui8StandardSpecification = g_ui8RS485Rxbuffer[10]; 
03A90:  MOVFF  B92,4FD
....................                         g_ui8PressureRating        = g_ui8RS485Rxbuffer[12]; 
03A94:  MOVFF  B94,4FE
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03A98:  MOVLW  0A
03A9A:  MOVLB  C
03A9C:  MOVWF  x04
03A9E:  MOVLW  10
03AA0:  MOVWF  x05
03AA2:  MOVFF  BFB,C07
03AA6:  MOVFF  BFA,C06
03AAA:  MOVFF  BFF,C08
03AAE:  CLRF   x0C
03AB0:  CLRF   x0B
03AB2:  CLRF   x0A
03AB4:  CLRF   x09
03AB6:  MOVLB  0
03AB8:  CALL   17AC
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
03ABC:  CALL   1754
....................                         break; 
03AC0:  BRA    3B02
....................                     case ADDRESS_FOR_PIPE_SPECIFICATION: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03AC2:  MOVFF  B8E,BFF
....................  
....................                         // Pipe specification has arrived. 
....................                         // 1. First register(2 bytes) contains pipe's outer diameter(OD). 
....................                         // 2. Second register(2 bytes) contains pipe's length. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8PipeOD = g_ui8RS485Rxbuffer[8]; 
03AC6:  MOVFF  B90,4FF
....................                         g_ui8PipeLength = g_ui8RS485Rxbuffer[10]; 
03ACA:  MOVFF  B92,500
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03ACE:  MOVLW  0A
03AD0:  MOVLB  C
03AD2:  MOVWF  x04
03AD4:  MOVLW  10
03AD6:  MOVWF  x05
03AD8:  MOVFF  BFB,C07
03ADC:  MOVFF  BFA,C06
03AE0:  MOVFF  BFF,C08
03AE4:  CLRF   x0C
03AE6:  CLRF   x0B
03AE8:  CLRF   x0A
03AEA:  CLRF   x09
03AEC:  MOVLB  0
03AEE:  CALL   17AC
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03AF2:  CALL   1754
....................  
....................                         // Set all product specification in GPRS message header. 
....................                         SetProductSpecificationForServer(); 
03AF6:  GOTO   296E
....................                         break; 
03AFA:  MOVLB  0
03AFC:  BRA    3B02
03AFE:  MOVLB  B
....................                     default: 
....................                         break; 
03B00:  MOVLB  0
....................                 } 
....................                 break; 
03B02:  BRA    3B04
....................  
....................             default: 
....................                 break; 
03B04:  MOVLB  B
....................                  
....................         } 
....................     } 
03B06:  MOVLB  0
03B08:  GOTO   45F6 (RETURN)
.................... } 
....................  
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... void Initialize(void) 
.................... { 
....................      
....................     // Set RS485 Transmit Inactive. 
....................     output_bit(PIN_RS485_RTS,0); 
*
0094A:  BCF    F7F.0
0094C:  BCF    F87.0
....................  
....................      
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL); 
0094E:  MOVLW  C0
00950:  IORWF  FF2,F
....................      
....................  
....................     // Initialize for GPRS message queue. 
....................     InitializePipeDataQueue(); 
00952:  BRA    0602
....................     InitializeLANMsgHeader(); 
00954:  BRA    075E
....................  
....................      
....................     // Read set of Timer values from EEPROM.  
....................     g_ui8DataSendingIntervalTime = ReadIntervalFromEEPROM(); 
00956:  BRA    0772
00958:  MOVFF  01,4EA
....................     g_ui32UnixTimeInSec = ReadStoredUnixTimeFromEEPROM(); 
0095C:  BRA    0802
0095E:  MOVFF  03,CA
00962:  MOVFF  02,C9
00966:  MOVFF  01,C8
0096A:  MOVFF  00,C7
....................     g_ui8SIMOperatorID  = ReadSIMOPeratorIDFromEEPROM(); 
0096E:  BRA    089A
00970:  MOVFF  01,4F9
....................      
....................     // Initialize the sending queue to M0 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBURcvQueue);  
00974:  MOVLW  03
00976:  MOVLB  B
00978:  MOVWF  xF8
0097A:  MOVLW  5F
0097C:  MOVWF  xF7
0097E:  MOVLB  0
00980:  RCALL  08B8
....................     InitializeDataQueue(&g_stIBUSendQueue); 
00982:  MOVLW  02
00984:  MOVLB  B
00986:  MOVWF  xF8
00988:  MOVLW  9A
0098A:  MOVWF  xF7
0098C:  MOVLB  0
0098E:  RCALL  08B8
....................      
....................     // Initialize global variables for RS485 communication.     
....................     g_ui16PipeCount =  0; 
00990:  MOVLB  4
00992:  CLRF   xC9
00994:  CLRF   xC8
....................     g_ui16PipeCountPrev = 0; 
00996:  CLRF   xCB
00998:  CLRF   xCA
....................     g_ui32CurrentWt = 0; 
0099A:  CLRF   xCF
0099C:  CLRF   xCE
0099E:  CLRF   xCD
009A0:  CLRF   xCC
....................     g_ui16CurrentPassStatus = 0; 
009A2:  CLRF   xD1
009A4:  CLRF   xD0
....................     g_ui32RunningAvgWt = 0; 
009A6:  CLRF   xD5
009A8:  CLRF   xD4
009AA:  CLRF   xD3
009AC:  CLRF   xD2
....................     g_ui32RunningTareValue = 0; 
009AE:  CLRF   xD9
009B0:  CLRF   xD8
009B2:  CLRF   xD7
009B4:  CLRF   xD6
....................     //g_ui16ServerStatus = 0; 
....................     g_ui16CurrentMode = 0; 
009B6:  CLRF   xE1
009B8:  CLRF   xE0
....................          
....................     g_stIBURcvData.g_ui8ArrIBUData[0] = 0; 
009BA:  MOVLB  1
009BC:  CLRF   xF9
....................     g_stIBURcvData.g_ui8ArrIBUData[1] = 0; 
009BE:  CLRF   xFA
....................     g_stIBURcvData.g_ui8ArrIBUData[2] = 0; 
009C0:  CLRF   xFB
....................     g_stIBURcvData.g_ui8ArrIBUData[3] = 0; 
009C2:  CLRF   xFC
....................     g_stIBURcvData.g_ui8ArrIBUData[4] = 0; 
009C4:  CLRF   xFD
009C6:  MOVLB  0
009C8:  GOTO   4586 (RETURN)
....................      
....................      
.................... }	 
....................  
.................... void main() 
*
042C6:  BSF    F77.7
042C8:  BCF    F77.6
042CA:  CLRF   FF8
042CC:  MOVLB  E
042CE:  BCF    x1F.5
042D0:  BSF    x22.5
042D2:  BCF    x23.1
042D4:  BCF    x23.5
042D6:  BSF    FF2.5
042D8:  BSF    07.7
042DA:  MOVLW  55
042DC:  MOVLB  D
042DE:  MOVWF  xEF
042E0:  MOVLW  AA
042E2:  MOVWF  xEF
042E4:  BCF    xEF.0
042E6:  MOVLW  17
042E8:  MOVLB  E
042EA:  MOVWF  x0F
042EC:  MOVLW  21
042EE:  MOVWF  x13
042F0:  MOVLW  23
042F2:  MOVWF  x17
042F4:  MOVLW  0C
042F6:  MOVWF  x68
042F8:  MOVLW  10
042FA:  MOVWF  x72
042FC:  MOVLW  14
042FE:  MOVWF  x74
04300:  MOVLW  55
04302:  MOVLB  D
04304:  MOVWF  xEF
04306:  MOVLW  AA
04308:  MOVWF  xEF
0430A:  BSF    xEF.0
0430C:  CLRF   2F
0430E:  MOVLB  E
04310:  BSF    xF0.3
04312:  MOVLW  81
04314:  MOVWF  xEC
04316:  MOVLW  00
04318:  MOVWF  xED
0431A:  MOVLW  A6
0431C:  MOVWF  xEF
0431E:  MOVLW  90
04320:  MOVWF  xEE
04322:  BCF    F9E.3
04324:  MOVLW  40
04326:  MOVWF  F9A
04328:  MOVLW  A6
0432A:  MOVWF  F9D
0432C:  MOVLW  90
0432E:  MOVWF  F9C
04330:  BSF    xE2.3
04332:  MOVLW  2A
04334:  MOVWF  xDE
04336:  MOVLW  00
04338:  MOVWF  xDF
0433A:  MOVLW  A6
0433C:  MOVWF  xE1
0433E:  MOVLW  90
04340:  MOVWF  xE0
04342:  CLRF   33
04344:  CLRF   32
04346:  MOVLW  29
04348:  MOVWF  3E
0434A:  CLRF   3F
0434C:  MOVLW  16
0434E:  MOVWF  40
04350:  MOVLB  0
04352:  CLRF   x87
04354:  CLRF   x88
04356:  MOVLW  03
04358:  MOVWF  x89
0435A:  MOVLW  0C
0435C:  MOVWF  x8A
0435E:  CLRF   x8C
04360:  MOVLW  FA
04362:  MOVWF  x8B
04364:  MOVLW  16
04366:  MOVWF  x8D
04368:  CLRF   x8E
0436A:  CLRF   x8F
0436C:  CLRF   x91
0436E:  CLRF   x90
04370:  CLRF   x92
04372:  CLRF   x93
04374:  CLRF   x94
04376:  CLRF   x98
04378:  CLRF   x97
0437A:  CLRF   x96
0437C:  CLRF   x95
0437E:  CLRF   xB0
04380:  CLRF   xC6
04382:  MOVLW  BB
04384:  MOVWF  xC5
04386:  CLRF   xCA
04388:  CLRF   xC9
0438A:  CLRF   xC8
0438C:  CLRF   xC7
0438E:  CLRF   xD4
04390:  CLRF   xD5
04392:  CLRF   xD6
04394:  MOVLB  1
04396:  CLRF   xDD
04398:  CLRF   xF2
0439A:  CLRF   xF3
0439C:  CLRF   xF4
0439E:  MOVLW  A5
043A0:  MOVWF  xF5
043A2:  CLRF   xF6
043A4:  MOVLB  2
043A6:  CLRF   x98
043A8:  CLRF   x99
043AA:  MOVLW  01
043AC:  MOVLB  4
043AE:  MOVWF  x24
043B0:  CLRF   x25
043B2:  CLRF   x26
043B4:  CLRF   x27
043B6:  CLRF   x29
043B8:  CLRF   x28
043BA:  CLRF   x37
043BC:  CLRF   x46
043BE:  CLRF   x45
043C0:  CLRF   x47
043C2:  CLRF   xAE
043C4:  CLRF   xAF
043C6:  CLRF   xB0
043C8:  CLRF   xB1
043CA:  MOVWF  xBF
043CC:  CLRF   xC3
043CE:  CLRF   xC2
043D0:  CLRF   xC1
043D2:  CLRF   xC0
043D4:  CLRF   xC7
043D6:  CLRF   xC6
043D8:  CLRF   xC5
043DA:  CLRF   xC4
043DC:  CLRF   xC9
043DE:  CLRF   xC8
043E0:  CLRF   xCF
043E2:  CLRF   xCE
043E4:  CLRF   xCD
043E6:  CLRF   xCC
043E8:  CLRF   xD1
043EA:  CLRF   xD0
043EC:  CLRF   xD5
043EE:  CLRF   xD4
043F0:  CLRF   xD3
043F2:  CLRF   xD2
043F4:  CLRF   xD9
043F6:  CLRF   xD8
043F8:  CLRF   xD7
043FA:  CLRF   xD6
043FC:  CLRF   xDB
043FE:  CLRF   xDA
04400:  CLRF   xDD
04402:  CLRF   xDC
04404:  CLRF   xDF
04406:  CLRF   xDE
04408:  CLRF   xE1
0440A:  CLRF   xE0
0440C:  CLRF   xE2
0440E:  CLRF   xE4
04410:  CLRF   xE3
04412:  CLRF   xE6
04414:  CLRF   xE5
04416:  CLRF   xE7
04418:  CLRF   xE8
0441A:  CLRF   xE9
0441C:  CLRF   xEA
0441E:  CLRF   xEB
04420:  CLRF   xEC
04422:  CLRF   xED
04424:  CLRF   xEF
04426:  CLRF   xEE
04428:  CLRF   xF1
0442A:  CLRF   xF0
0442C:  CLRF   xF3
0442E:  CLRF   xF2
04430:  CLRF   xF4
04432:  CLRF   xF5
04434:  CLRF   xF7
04436:  CLRF   xF6
04438:  CLRF   xF8
0443A:  CLRF   xF9
0443C:  CLRF   xFB
0443E:  CLRF   xFA
04440:  CLRF   xFC
04442:  CLRF   xFD
04444:  CLRF   xFE
04446:  CLRF   xFF
04448:  MOVLB  5
0444A:  CLRF   x00
0444C:  CLRF   x02
0444E:  CLRF   x01
04450:  MOVLW  0C
04452:  MOVWF  x03
04454:  CLRF   x05
04456:  CLRF   x04
04458:  CLRF   x06
0445A:  CLRF   x08
0445C:  CLRF   x07
0445E:  MOVLW  1A
04460:  MOVWF  x09
04462:  CLRF   x0B
04464:  CLRF   x0A
04466:  CLRF   x0C
04468:  MOVLW  15
0446A:  MOVWF  x0D
0446C:  MOVLW  B4
0446E:  MOVWF  x0E
04470:  MOVLW  2C
04472:  MOVWF  x0F
04474:  MOVLW  2E
04476:  MOVWF  x10
04478:  MOVLB  7
0447A:  CLRF   x06
0447C:  CLRF   x05
0447E:  CLRF   x07
04480:  CLRF   x08
04482:  CLRF   x0A
04484:  MOVLW  01
04486:  MOVWF  x09
04488:  CLRF   x0C
0448A:  MOVLW  02
0448C:  MOVWF  x0B
0448E:  MOVLW  07
04490:  MOVWF  x0E
04492:  MOVLW  CF
04494:  MOVWF  x0D
04496:  CLRF   x0F
04498:  CLRF   x10
0449A:  CLRF   x11
0449C:  CLRF   x1E
0449E:  CLRF   x33
044A0:  MOVLB  B
044A2:  CLRF   x83
044A4:  CLRF   x82
044A6:  CLRF   x85
044A8:  CLRF   x84
044AA:  CLRF   x86
044AC:  CLRF   x87
044AE:  CLRF   xEC
044B0:  MOVLW  0B
044B2:  MOVWF  xED
044B4:  MOVLW  01
044B6:  MOVWF  xEE
044B8:  CLRF   xEF
044BA:  CLRF   xF1
044BC:  CLRF   xF0
044BE:  CLRF   xF5
044C0:  CLRF   xF4
044C2:  CLRF   xF3
044C4:  CLRF   xF2
044C6:  MOVLB  E
044C8:  CLRF   x92
044CA:  CLRF   x9A
044CC:  CLRF   xA7
044CE:  CLRF   xAF
044D0:  CLRF   xB4
044D2:  CLRF   xBC
044D4:  CLRF   xD2
044D6:  CLRF   xD3
044D8:  CLRF   xD1
044DA:  CLRF   xD0
044DC:  MOVLW  0C
044DE:  MOVWF  31
044E0:  MOVLW  32
044E2:  MOVWF  30
044E4:  MOVLW  01
044E6:  MOVLB  C
044E8:  MOVWF  x33
044EA:  MOVLW  B4
044EC:  MOVWF  x32
044EE:  CLRF   x35
044F0:  CLRF   x34
044F2:  MOVLB  0
044F4:  BRA    451E
044F6:  DATA 46,40
044F8:  DATA 41,00
044FA:  DATA 14,41
044FC:  DATA DE,00
044FE:  DATA 87,42
04500:  DATA 11,00
04502:  DATA 0D,44
04504:  DATA 38,00
04506:  DATA 66,44
04508:  DATA 48,00
0450A:  DATA 0D,44
0450C:  DATA B2,00
0450E:  DATA FF,45
04510:  DATA 11,00
04512:  DATA F5,C0
04514:  DATA 00,14
04516:  DATA 47,1F
04518:  DATA 00,64
0451A:  DATA 4B,88
0451C:  DATA 00,00
0451E:  MOVLW  00
04520:  MOVWF  FF8
04522:  MOVLW  44
04524:  MOVWF  FF7
04526:  MOVLW  F6
04528:  MOVWF  FF6
0452A:  TBLRD*+
0452C:  MOVF   FF5,W
0452E:  MOVWF  00
04530:  XORLW  00
04532:  BZ    455A
04534:  TBLRD*+
04536:  MOVF   FF5,W
04538:  MOVWF  01
0453A:  BTFSC  FE8.7
0453C:  BRA    4548
0453E:  ANDLW  3F
04540:  MOVWF  FEA
04542:  TBLRD*+
04544:  MOVF   FF5,W
04546:  MOVWF  FE9
04548:  BTFSC  01.6
0454A:  TBLRD*+
0454C:  BTFSS  01.6
0454E:  TBLRD*+
04550:  MOVF   FF5,W
04552:  MOVWF  FEE
04554:  DCFSNZ 00,F
04556:  BRA    452A
04558:  BRA    454C
0455A:  CLRF   FF8
0455C:  MOVLB  B
0455E:  CLRF   xF6
.................... { 
....................     unsigned int8 ui8RetVal                         = 0; 
....................     g_fDataSendingSequence                          = LAN_DATA_SENDING_SEQUENCE_1; 
04560:  MOVLW  01
04562:  MOVLB  7
04564:  MOVWF  x1E
....................      
.................... 	// Set Watch Dog Timer ON. 
....................     setup_wdt(WDT_4S | WDT_WINDOW_100_PERCENT); 
04566:  MOVLW  07
04568:  MOVLB  E
0456A:  MOVWF  x3E
0456C:  MOVLW  19
0456E:  MOVWF  x3D
....................      
.................... 	//Initialize 1 millisecond timer. 
.................... 	Init1MSTimer(); 
04570:  MOVLB  0
04572:  GOTO   05BE
....................     	 
.................... 	//Initialize RS485 Receive interrupt. 
.................... 	InitRS485RxInterrupt(); 
04576:  GOTO   05DE
.................... 	 
.................... 	//Initialize UART2UART Receive interrupt. 
....................     InitIBURxInterrupt(); 
0457A:  GOTO   05EA
....................      
....................     // Initialize GPRS Module;EC20 Receive interrupt. 
....................     //InitM66RxInterrupt(); 
....................      
....................     // Initialize LAN Module; USR_K3 receive interrupt. 
....................     InitLANCommRxInterrupt(); 
0457E:  GOTO   05F6
....................  
.................... 	// Initialize Main Global variables  
.................... 	Initialize(); 
04582:  GOTO   094A
....................      
....................     // Initialize Receive Queue 
....................     InitializeRcvQ(); 
04586:  GOTO   09E6
....................      
....................     // Set GSM modem ready 
....................     //delay_ms(3000); 
....................      
....................  
.................... 	// Reset WDT. 
.................... 	restart_wdt(); 
0458A:  MOVLB  E
0458C:  MOVF   x3D,W
0458E:  CLRWDT
....................  
.................... 	for(;;) 
.................... 	{  
....................         // step 1: Check if there is any message received in IBU through UART 
....................         g_ui8ElementInQ = ElementsInQ(); 
04590:  MOVLB  0
04592:  GOTO   0A04
04596:  MOVFF  01,1DD
....................         if (g_ui8ElementInQ >= SIZE_IBU_COMPLETE_SEND_MSG) 
0459A:  MOVLB  1
0459C:  MOVF   xDD,W
0459E:  SUBLW  11
045A0:  BC    45AA
....................         { 
....................             // Hopefully a Complete Message Received 
....................             CheckIBUReceiveQ(); 
045A2:  MOVLB  0
045A4:  GOTO   0DBE
045A8:  MOVLB  1
....................         } 
....................  
....................         // step 2: Check if there is any message in IBC Receive Queue 
....................         if (IsMSGInIBUQueue(&g_stIBURcvQueue)) 
045AA:  MOVLW  03
045AC:  MOVLB  B
045AE:  MOVWF  xF8
045B0:  MOVLW  5F
045B2:  MOVWF  xF7
045B4:  MOVLB  0
045B6:  CALL   10F2
045BA:  MOVF   01,F
045BC:  BZ    45C2
....................         { 
....................             // Process IBC  
....................             ProcessIBUMsg(); 
045BE:  GOTO   1340
....................         }  
....................          
....................         // Step 3: check if there is any message in IBU send queue. 
....................         // If available then process to send to UART. 
....................         if(IsMSGInIBUQueue(&g_stIBUSendQueue) &&  
....................           (IBU_SENDING_FREE == g_fIBUSendBusy)) 
045C2:  MOVLW  02
045C4:  MOVLB  B
045C6:  MOVWF  xF8
045C8:  MOVLW  9A
045CA:  MOVWF  xF7
045CC:  MOVLB  0
045CE:  CALL   10F2
045D2:  MOVF   01,F
045D4:  BZ    45EC
045D6:  MOVLB  2
045D8:  MOVF   x99,F
045DA:  BTFSC  FD8.2
045DC:  BRA    45E2
045DE:  MOVLB  0
045E0:  BRA    45EC
....................         { 
....................             // Set flag to denote IBU is busy in sending data. 
....................             g_fIBUSendBusy = IBU_SENDING_BUSY; 
045E2:  MOVLW  01
045E4:  MOVWF  x99
....................              
....................             // Send data from queue. 
....................             SendIBUMSGFromQ(); 
045E6:  MOVLB  0
045E8:  GOTO   1628
....................         }         
....................   
....................         // Step 5: Check if a byte received in Modbus..then process data. 
....................         if(ISR_RECEIVED_ALL_BYTES == g_fISRReceivedByteStatus) 
045EC:  MOVF   x8D,W
045EE:  SUBLW  15
045F0:  BNZ   45FA
....................         {  
....................             // Process received data. 
....................             ProcessUART2ReceivedData(); 
045F2:  GOTO   2998
....................  
....................             // Reset flag. 
....................             g_fISRReceivedByteStatus = ISR_PROCESSED_ALL_BYTES; 
045F6:  MOVLW  16
045F8:  MOVWF  x8D
....................         } 
....................          
....................         // Step 6: Check for unix time write to EEPROM signal. 
....................         if(TIME_STAMP_SIGNAL_ON == g_fTSWriteToEEPROMSignal) 
045FA:  MOVLB  5
045FC:  MOVF   x0D,W
045FE:  SUBLW  14
04600:  BNZ   461E
....................         { 
....................             // Write data to EEPROM. 
....................             WriteCurrentUnixTimeToEEPROM(g_ui32HookedUpTimeStampPerMinute); 
04602:  MOVFF  98,BFA
04606:  MOVFF  97,BF9
0460A:  MOVFF  96,BF8
0460E:  MOVFF  95,BF7
04612:  MOVLB  0
04614:  GOTO   3B8C
....................              
....................             // Reset flag state. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_COMPLETE; 
04618:  MOVLW  15
0461A:  MOVLB  5
0461C:  MOVWF  x0D
....................         } 
....................          
....................          
....................         // Here, pipe current weight or pipe data will be sent through LAN. 
....................         // By modular data sending process we can uninterruptedly run peripheral 
....................         // process along with data sending in parallel. 
....................          
....................  // ################ Below steps are for GPRS modular data sending ###################### 
....................          
....................         // Step 1: Check modular data sending time interval & data sending sequence 
....................         //         are allowing to initiate data sending process. 
....................         if(SHOULD_SEND_DATA == g_fShouldSendData && 
....................            LAN_DATA_SENDING_SEQUENCE_1 == g_fDataSendingSequence) 
0461E:  MOVF   x09,W
04620:  SUBLW  19
04622:  BNZ   464A
04624:  MOVLB  7
04626:  DECFSZ x1E,W
04628:  BRA    462C
0462A:  BRA    4630
0462C:  MOVLB  5
0462E:  BRA    464A
....................         { 
....................             // Check if new data available in data queue. 
....................             ui8RetVal = IsPipeDataQueueEmpty(); 
04630:  MOVLB  0
04632:  GOTO   3BEA
04636:  MOVFF  01,BF6
....................              
....................             if(0 == ui8RetVal)  // Queue is not empty. 
0463A:  MOVLB  B
0463C:  MOVF   xF6,F
0463E:  BNZ   4648
....................             { 
....................                 // Update sequence flag of sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_2; 
04640:  MOVLW  02
04642:  MOVLB  7
04644:  MOVWF  x1E
....................             } 
04646:  MOVLB  B
....................             else    // Queue is empty. 
....................             { 
....................                 /* Do Nothing; Wait until new data available */ 
....................             } 
....................         } 
04648:  BRA    4720
....................          
....................         // Step 2: If data present in queue then fetch according to queue front 
....................         //         and send. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_2 == g_fDataSendingSequence) 
0464A:  MOVLB  7
0464C:  MOVF   x1E,W
0464E:  SUBLW  02
04650:  BNZ   466A
....................         { 
....................             // Send data from queue. 
....................             SendDataFromQ(); 
04652:  MOVLB  0
04654:  BRA    3EE0
....................              
....................             // Set a timeout to receive success code. 
....................             g_fIsTimedOut = 0; 
04656:  CLRF   x8F
....................             SetTimeout(SERVER_RESPONSE_RECEIVE_TIMEOUT); 
04658:  MOVLW  03
0465A:  MOVLB  B
0465C:  MOVWF  xF7
0465E:  MOVLB  0
04660:  RCALL  41FA
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_3; 
04662:  MOVLW  03
04664:  MOVLB  7
04666:  MOVWF  x1E
....................         } 
04668:  BRA    471E
....................          
....................         // Step 3: check for return code from server upto set time. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 0) 
0466A:  MOVF   x1E,W
0466C:  SUBLW  03
0466E:  BNZ   4694
04670:  MOVLB  0
04672:  MOVF   x8F,F
04674:  BTFSC  FD8.2
04676:  BRA    467C
04678:  MOVLB  7
0467A:  BRA    4694
....................         { 
....................             // Check for server response. 
....................             ui8RetVal = CheckServerResponse(); 
0467C:  BRA    4248
0467E:  MOVFF  01,BF6
....................             //ui8RetVal = 0; 
....................              
....................             // Check return value. 
....................             if(ui8RetVal == 0)  // Server response received. 
04682:  MOVLB  B
04684:  MOVF   xF6,F
04686:  BNZ   4690
....................             { 
....................                 // Update sequence flag for data sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_4; 
04688:  MOVLW  04
0468A:  MOVLB  7
0468C:  MOVWF  x1E
....................             } 
0468E:  MOVLB  B
....................             else  // No response received after parsing. 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................                 
....................         }  
04690:  BRA    4720
04692:  MOVLB  7
....................          
....................         // Step 4: check if set timeout for arriving server response; is over. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 1) 
04694:  MOVF   x1E,W
04696:  SUBLW  03
04698:  BNZ   46BA
0469A:  MOVLB  0
0469C:  DECFSZ x8F,W
0469E:  BRA    46A2
046A0:  BRA    46A6
046A2:  MOVLB  7
046A4:  BRA    46BA
....................         { 
....................             // No response received during set time interval for expected arrival. 
....................             // Set a time interval to wait & try Once. 
....................             g_fIsTimedOut = 0; 
046A6:  CLRF   x8F
....................             SetTimeout(DATA_RESEND_INTERVAL_TIMEOUT); 
046A8:  MOVLW  0A
046AA:  MOVLB  B
046AC:  MOVWF  xF7
046AE:  MOVLB  0
046B0:  RCALL  41FA
....................  
....................             // Update sequence flag. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_5; 
046B2:  MOVLW  05
046B4:  MOVLB  7
046B6:  MOVWF  x1E
....................         } 
046B8:  BRA    471E
....................          
....................         // Step 5: If server response code received & parsed successfully. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_4 == g_fDataSendingSequence) 
046BA:  MOVF   x1E,W
046BC:  SUBLW  04
046BE:  BNZ   4706
....................         { 
....................             // Data from queue successfully sent to server and server response 
....................             // is also received.  
....................             // Update flags upon successful data send. 
....................              
....................             // Update data sending interval flag for next interval counting start. 
....................             g_fShouldSendData = SHOULD_NOT_SEND_DATA; 
046C0:  MOVLW  1A
046C2:  MOVLB  5
046C4:  MOVWF  x09
....................              
....................             // Handle queue front. 
....................             if (g_stPipeDataSendQueue.m_i8Front == g_stPipeDataSendQueue.m_i8Rear) 
046C6:  MOVLB  B
046C8:  MOVF   x81,W
046CA:  SUBWF  x80,W
046CC:  BNZ   46D6
....................             { 
....................                 // Queue is empty 
....................                 g_stPipeDataSendQueue.m_i8Front = g_stPipeDataSendQueue.m_i8Rear = -1; 
046CE:  SETF   x81
046D0:  MOVFF  B81,B80
....................             } 
046D4:  BRA    46FE
....................             else // Queue is not empty 
....................             { 
....................                 g_stPipeDataSendQueue.m_i8Front = (g_stPipeDataSendQueue.m_i8Front + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
046D6:  MOVLW  01
046D8:  ADDWF  x80,W
046DA:  MOVWF  xF8
046DC:  CLRF   19
046DE:  BTFSC  FF2.7
046E0:  BSF    19.7
046E2:  BCF    FF2.7
046E4:  MOVFF  FE8,C2F
046E8:  MOVLW  64
046EA:  MOVLB  C
046EC:  MOVWF  x30
046EE:  MOVLB  0
046F0:  CALL   0182
046F4:  BTFSC  19.7
046F6:  BSF    FF2.7
046F8:  MOVFF  00,B80
046FC:  MOVLB  B
....................             }  
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
046FE:  MOVLW  01
04700:  MOVLB  7
04702:  MOVWF  x1E
....................         } 
04704:  BRA    471E
....................          
....................         // Step 6: If proper response is not received; after waiting for some time 
....................         //          resend data. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_5 == g_fDataSendingSequence && 
....................                 1 == g_fIsTimedOut) 
04706:  MOVF   x1E,W
04708:  SUBLW  05
0470A:  BNZ   471E
0470C:  MOVLB  0
0470E:  DECFSZ x8F,W
04710:  BRA    4714
04712:  BRA    4718
04714:  MOVLB  7
04716:  BRA    471E
....................         { 
....................             // Update sequence flag to resend data. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
04718:  MOVLW  01
0471A:  MOVLB  7
0471C:  MOVWF  x1E
....................         } 
0471E:  MOVLB  B
....................         else 
....................         { 
....................             /* Do Nothing */ 
....................         } 
....................              
.................... 		// Reset WDT. 
....................         restart_wdt();                 
04720:  MOVLB  E
04722:  MOVF   x3D,W
04724:  CLRWDT
04726:  BRA    4590
.................... 	}	 
.................... } 
....................     	 
04728:  BRA    4728
....................  
....................  
....................  
....................  
....................  
.................... 	 

Configuration Fuses:
   Word  1: DFFF   ECH RSTOSC_EXT NOCLKOUT CKS NOFCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV24 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 01 02 03 04                                        ....
