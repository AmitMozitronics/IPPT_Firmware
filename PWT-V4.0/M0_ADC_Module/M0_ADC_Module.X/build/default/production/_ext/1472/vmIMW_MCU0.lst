CCS PCH C Compiler, Version 5.083, 13314               02-Mar-21 17:47

               Filename:   D:\Work\Projects\PWT\01_Code\PWT-V4.0\M0_ADC_Module\M0_ADC_Module.X\build\default\production\_ext\1472\vmIMW_MCU0.lst

               ROM used:   12706 bytes (19%)
                           Largest free fragment is 52826
               RAM used:   2675 (75%) at main() level
                           2734 (77%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   2B74
*
00008:  GOTO   00CE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  MOVLB  E
00066:  BTFSS  x29.5
00068:  GOTO   0072
0006C:  BTFSC  x33.5
0006E:  GOTO   0290
00072:  BTFSS  x2D.3
00074:  GOTO   007E
00078:  BTFSC  x37.3
0007A:  GOTO   0196
0007E:  MOVFF  0E,00
00082:  MOVFF  0F,01
00086:  MOVFF  10,02
0008A:  MOVFF  11,03
0008E:  MOVFF  0C,FE9
00092:  MOVFF  07,FEA
00096:  BSF    07.7
00098:  MOVFF  08,FE1
0009C:  MOVFF  09,FE2
000A0:  MOVFF  0A,FD9
000A4:  MOVFF  0B,FDA
000A8:  MOVFF  12,FF3
000AC:  MOVFF  13,FF4
000B0:  MOVFF  14,FFA
000B4:  MOVFF  15,FF5
000B8:  MOVFF  16,FF6
000BC:  MOVFF  17,FF7
000C0:  MOVF   04,W
000C2:  MOVFF  06,FE0
000C6:  MOVFF  05,FD8
000CA:  RETFIE 0
000CC:  MOVLB  0
000CE:  MOVWF  1A
000D0:  MOVFF  FD8,1B
000D4:  MOVFF  FE0,1C
000D8:  MOVLB  0
000DA:  MOVFF  FE9,22
000DE:  MOVFF  FEA,1D
000E2:  MOVFF  FE1,1E
000E6:  MOVFF  FE2,1F
000EA:  MOVFF  FD9,20
000EE:  MOVFF  FDA,21
000F2:  MOVFF  FF3,28
000F6:  MOVFF  FF4,29
000FA:  MOVFF  FFA,2A
000FE:  MOVFF  FF5,2B
00102:  MOVFF  FF6,2C
00106:  MOVFF  FF7,2D
0010A:  MOVFF  00,24
0010E:  MOVFF  01,25
00112:  MOVFF  02,26
00116:  MOVFF  03,27
0011A:  MOVLB  E
0011C:  BTFSS  x2C.5
0011E:  GOTO   0128
00122:  BTFSC  x36.5
00124:  GOTO   0232
00128:  MOVFF  24,00
0012C:  MOVFF  25,01
00130:  MOVFF  26,02
00134:  MOVFF  27,03
00138:  MOVFF  22,FE9
0013C:  MOVFF  1D,FEA
00140:  BSF    1D.7
00142:  MOVFF  1E,FE1
00146:  MOVFF  1F,FE2
0014A:  MOVFF  20,FD9
0014E:  MOVFF  21,FDA
00152:  MOVFF  28,FF3
00156:  MOVFF  29,FF4
0015A:  MOVFF  2A,FFA
0015E:  MOVFF  2B,FF5
00162:  MOVFF  2C,FF6
00166:  MOVFF  2D,FF7
0016A:  MOVF   1A,W
0016C:  MOVFF  1C,FE0
00170:  MOVFF  1B,FD8
00174:  RETFIE 0
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... //#include "18F46K80.h" 
.................... #include "18F66k40.h" 
.................... //////////// Standard Header file for the PIC18F66K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F66K40 
*
001DE:  MOVLB  A
001E0:  MOVF   xAC,W
001E2:  CLRF   01
001E4:  SUBWF  xAB,W
001E6:  BTFSC  FD8.0
001E8:  GOTO   01F4
001EC:  MOVFF  AAB,00
001F0:  GOTO   020E
001F4:  CLRF   00
001F6:  MOVLW  08
001F8:  MOVWF  xAD
001FA:  RLCF   xAB,F
001FC:  RLCF   00,F
001FE:  MOVF   xAC,W
00200:  SUBWF  00,W
00202:  BTFSC  FD8.0
00204:  MOVWF  00
00206:  RLCF   01,F
00208:  DECFSZ xAD,F
0020A:  GOTO   01FA
0020E:  MOVLB  0
00210:  RETURN 0
*
0053C:  MOVLB  A
0053E:  MOVF   x9C,W
00540:  MULWF  x9E
00542:  MOVFF  FF3,01
00546:  MOVFF  FF4,00
0054A:  MULWF  x9F
0054C:  MOVF   FF3,W
0054E:  ADDWF  00,F
00550:  MOVF   x9D,W
00552:  MULWF  x9E
00554:  MOVF   FF3,W
00556:  ADDWFC 00,W
00558:  MOVWF  02
0055A:  MOVLB  0
0055C:  RETURN 0
*
00784:  MOVLW  8E
00786:  MOVWF  00
00788:  MOVFF  A82,01
0078C:  MOVFF  A81,02
00790:  CLRF   03
00792:  MOVF   01,F
00794:  BTFSS  FD8.2
00796:  GOTO   07B2
0079A:  MOVFF  02,01
0079E:  CLRF   02
007A0:  MOVLW  08
007A2:  SUBWF  00,F
007A4:  MOVF   01,F
007A6:  BTFSS  FD8.2
007A8:  GOTO   07B2
007AC:  CLRF   00
007AE:  GOTO   07C6
007B2:  BCF    FD8.0
007B4:  BTFSC  01.7
007B6:  GOTO   07C4
007BA:  RLCF   02,F
007BC:  RLCF   01,F
007BE:  DECF   00,F
007C0:  GOTO   07B2
007C4:  BCF    01.7
007C6:  RETURN 0
007C8:  MOVLB  A
007CA:  MOVF   x85,W
007CC:  BTFSC  FD8.2
007CE:  GOTO   09B2
007D2:  MOVWF  x91
007D4:  MOVF   x89,W
007D6:  BTFSC  FD8.2
007D8:  GOTO   09B2
007DC:  SUBWF  x91,F
007DE:  BTFSS  FD8.0
007E0:  GOTO   07F2
007E4:  MOVLW  7F
007E6:  ADDWF  x91,F
007E8:  BTFSC  FD8.0
007EA:  GOTO   09B2
007EE:  GOTO   0802
007F2:  MOVLW  81
007F4:  SUBWF  x91,F
007F6:  BTFSS  FD8.0
007F8:  GOTO   09B2
007FC:  BTFSC  FD8.2
007FE:  GOTO   09B2
00802:  MOVFF  A91,00
00806:  CLRF   01
00808:  CLRF   02
0080A:  CLRF   03
0080C:  CLRF   x90
0080E:  MOVFF  A86,A8F
00812:  BSF    x8F.7
00814:  MOVFF  A87,A8E
00818:  MOVFF  A88,A8D
0081C:  MOVLW  19
0081E:  MOVWF  x91
00820:  MOVF   x8C,W
00822:  SUBWF  x8D,F
00824:  BTFSC  FD8.0
00826:  GOTO   0852
0082A:  MOVLW  01
0082C:  SUBWF  x8E,F
0082E:  BTFSC  FD8.0
00830:  GOTO   0852
00834:  SUBWF  x8F,F
00836:  BTFSC  FD8.0
00838:  GOTO   0852
0083C:  SUBWF  x90,F
0083E:  BTFSC  FD8.0
00840:  GOTO   0852
00844:  INCF   x90,F
00846:  INCF   x8F,F
00848:  INCF   x8E,F
0084A:  MOVF   x8C,W
0084C:  ADDWF  x8D,F
0084E:  GOTO   08CE
00852:  MOVF   x8B,W
00854:  SUBWF  x8E,F
00856:  BTFSC  FD8.0
00858:  GOTO   0896
0085C:  MOVLW  01
0085E:  SUBWF  x8F,F
00860:  BTFSC  FD8.0
00862:  GOTO   0896
00866:  SUBWF  x90,F
00868:  BTFSC  FD8.0
0086A:  GOTO   0896
0086E:  INCF   x90,F
00870:  INCF   x8F,F
00872:  MOVF   x8B,W
00874:  ADDWF  x8E,F
00876:  MOVF   x8C,W
00878:  ADDWF  x8D,F
0087A:  BTFSS  FD8.0
0087C:  GOTO   08CE
00880:  INCF   x8E,F
00882:  BTFSS  FD8.2
00884:  GOTO   08CE
00888:  INCF   x8F,F
0088A:  BTFSS  FD8.2
0088C:  GOTO   08CE
00890:  INCF   x90,F
00892:  GOTO   08CE
00896:  MOVF   x8A,W
00898:  IORLW  80
0089A:  SUBWF  x8F,F
0089C:  BTFSC  FD8.0
0089E:  GOTO   08CC
008A2:  MOVLW  01
008A4:  SUBWF  x90,F
008A6:  BTFSC  FD8.0
008A8:  GOTO   08CC
008AC:  INCF   x90,F
008AE:  MOVF   x8A,W
008B0:  IORLW  80
008B2:  ADDWF  x8F,F
008B4:  MOVF   x8B,W
008B6:  ADDWF  x8E,F
008B8:  BTFSS  FD8.0
008BA:  GOTO   0876
008BE:  INCF   x8F,F
008C0:  BTFSS  FD8.2
008C2:  GOTO   0876
008C6:  INCF   x90,F
008C8:  GOTO   0876
008CC:  BSF    03.0
008CE:  DECFSZ x91,F
008D0:  GOTO   08D8
008D4:  GOTO   08F0
008D8:  BCF    FD8.0
008DA:  RLCF   x8D,F
008DC:  RLCF   x8E,F
008DE:  RLCF   x8F,F
008E0:  RLCF   x90,F
008E2:  BCF    FD8.0
008E4:  RLCF   03,F
008E6:  RLCF   02,F
008E8:  RLCF   01,F
008EA:  RLCF   x92,F
008EC:  GOTO   0820
008F0:  BTFSS  x92.0
008F2:  GOTO   0904
008F6:  BCF    FD8.0
008F8:  RRCF   01,F
008FA:  RRCF   02,F
008FC:  RRCF   03,F
008FE:  RRCF   x92,F
00900:  GOTO   090C
00904:  DECF   00,F
00906:  BTFSC  FD8.2
00908:  GOTO   09B2
0090C:  BTFSC  x92.7
0090E:  GOTO   0972
00912:  BCF    FD8.0
00914:  RLCF   x8D,F
00916:  RLCF   x8E,F
00918:  RLCF   x8F,F
0091A:  RLCF   x90,F
0091C:  MOVF   x8C,W
0091E:  SUBWF  x8D,F
00920:  BTFSC  FD8.0
00922:  GOTO   0940
00926:  MOVLW  01
00928:  SUBWF  x8E,F
0092A:  BTFSC  FD8.0
0092C:  GOTO   0940
00930:  SUBWF  x8F,F
00932:  BTFSC  FD8.0
00934:  GOTO   0940
00938:  SUBWF  x90,F
0093A:  BTFSS  FD8.0
0093C:  GOTO   0998
00940:  MOVF   x8B,W
00942:  SUBWF  x8E,F
00944:  BTFSC  FD8.0
00946:  GOTO   095C
0094A:  MOVLW  01
0094C:  SUBWF  x8F,F
0094E:  BTFSC  FD8.0
00950:  GOTO   095C
00954:  SUBWF  x90,F
00956:  BTFSS  FD8.0
00958:  GOTO   0998
0095C:  MOVF   x8A,W
0095E:  IORLW  80
00960:  SUBWF  x8F,F
00962:  BTFSC  FD8.0
00964:  GOTO   0972
00968:  MOVLW  01
0096A:  SUBWF  x90,F
0096C:  BTFSS  FD8.0
0096E:  GOTO   0998
00972:  INCF   03,F
00974:  BTFSS  FD8.2
00976:  GOTO   0998
0097A:  INCF   02,F
0097C:  BTFSS  FD8.2
0097E:  GOTO   0998
00982:  INCF   01,F
00984:  BTFSS  FD8.2
00986:  GOTO   0998
0098A:  INCF   00,F
0098C:  BTFSC  FD8.2
0098E:  GOTO   09B2
00992:  RRCF   01,F
00994:  RRCF   02,F
00996:  RRCF   03,F
00998:  MOVFF  A86,A91
0099C:  MOVF   x8A,W
0099E:  XORWF  x91,F
009A0:  BTFSS  x91.7
009A2:  GOTO   09AC
009A6:  BSF    01.7
009A8:  GOTO   09BA
009AC:  BCF    01.7
009AE:  GOTO   09BA
009B2:  CLRF   00
009B4:  CLRF   01
009B6:  CLRF   02
009B8:  CLRF   03
009BA:  MOVLB  0
009BC:  RETURN 0
*
00CBC:  TSTFSZ 01
00CBE:  GOTO   0CCC
00CC2:  TSTFSZ 02
00CC4:  GOTO   0CCE
00CC8:  GOTO   0CDE
00CCC:  INCF   02,F
00CCE:  MOVFF  00,FEE
00CD2:  DECFSZ 01,F
00CD4:  GOTO   0CCE
00CD8:  DECFSZ 02,F
00CDA:  GOTO   0CCE
00CDE:  GOTO   0CF4 (RETURN)
*
01E02:  BTFSC  FD8.1
01E04:  GOTO   1E10
01E08:  MOVLW  0A
01E0A:  MOVWF  FEA
01E0C:  MOVLW  9F
01E0E:  MOVWF  FE9
01E10:  CLRF   00
01E12:  CLRF   01
01E14:  CLRF   02
01E16:  CLRF   03
01E18:  MOVLB  A
01E1A:  CLRF   x9F
01E1C:  CLRF   xA0
01E1E:  CLRF   xA1
01E20:  CLRF   xA2
01E22:  MOVF   x9E,W
01E24:  IORWF  x9D,W
01E26:  IORWF  x9C,W
01E28:  IORWF  x9B,W
01E2A:  BTFSC  FD8.2
01E2C:  GOTO   1E9A
01E30:  MOVLW  20
01E32:  MOVWF  xA3
01E34:  BCF    FD8.0
01E36:  RLCF   x97,F
01E38:  RLCF   x98,F
01E3A:  RLCF   x99,F
01E3C:  RLCF   x9A,F
01E3E:  RLCF   x9F,F
01E40:  RLCF   xA0,F
01E42:  RLCF   xA1,F
01E44:  RLCF   xA2,F
01E46:  MOVF   x9E,W
01E48:  SUBWF  xA2,W
01E4A:  BTFSS  FD8.2
01E4C:  GOTO   1E68
01E50:  MOVF   x9D,W
01E52:  SUBWF  xA1,W
01E54:  BTFSS  FD8.2
01E56:  GOTO   1E68
01E5A:  MOVF   x9C,W
01E5C:  SUBWF  xA0,W
01E5E:  BTFSS  FD8.2
01E60:  GOTO   1E68
01E64:  MOVF   x9B,W
01E66:  SUBWF  x9F,W
01E68:  BTFSS  FD8.0
01E6A:  GOTO   1E8C
01E6E:  MOVF   x9B,W
01E70:  SUBWF  x9F,F
01E72:  MOVF   x9C,W
01E74:  BTFSS  FD8.0
01E76:  INCFSZ x9C,W
01E78:  SUBWF  xA0,F
01E7A:  MOVF   x9D,W
01E7C:  BTFSS  FD8.0
01E7E:  INCFSZ x9D,W
01E80:  SUBWF  xA1,F
01E82:  MOVF   x9E,W
01E84:  BTFSS  FD8.0
01E86:  INCFSZ x9E,W
01E88:  SUBWF  xA2,F
01E8A:  BSF    FD8.0
01E8C:  RLCF   00,F
01E8E:  RLCF   01,F
01E90:  RLCF   02,F
01E92:  RLCF   03,F
01E94:  DECFSZ xA3,F
01E96:  GOTO   1E34
01E9A:  MOVFF  A9F,FEF
01E9E:  MOVFF  AA0,FEC
01EA2:  MOVFF  AA1,FEC
01EA6:  MOVFF  AA2,FEC
01EAA:  MOVLB  0
01EAC:  RETURN 0
01EAE:  MOVLW  B6
01EB0:  MOVWF  00
01EB2:  CLRF   03
01EB4:  CLRF   02
01EB6:  CLRF   01
01EB8:  MOVLB  A
01EBA:  MOVF   x83,W
01EBC:  IORWF  x84,W
01EBE:  IORWF  x85,W
01EC0:  IORWF  x86,W
01EC2:  BTFSS  FD8.2
01EC4:  GOTO   1ECE
01EC8:  CLRF   00
01ECA:  GOTO   1EEC
01ECE:  BCF    FD8.0
01ED0:  BTFSC  01.7
01ED2:  GOTO   1EEA
01ED6:  RLCF   x83,F
01ED8:  RLCF   x84,F
01EDA:  RLCF   x85,F
01EDC:  RLCF   x86,F
01EDE:  RLCF   03,F
01EE0:  RLCF   02,F
01EE2:  RLCF   01,F
01EE4:  DECFSZ 00,F
01EE6:  GOTO   1ECE
01EEA:  BCF    01.7
01EEC:  MOVLB  0
01EEE:  GOTO   208A (RETURN)
01EF2:  MOVLB  A
01EF4:  MOVF   x87,W
01EF6:  BTFSC  FD8.2
01EF8:  GOTO   2004
01EFC:  MOVWF  00
01EFE:  MOVF   x8B,W
01F00:  BTFSC  FD8.2
01F02:  GOTO   2004
01F06:  ADDWF  00,F
01F08:  BTFSS  FD8.0
01F0A:  GOTO   1F1C
01F0E:  MOVLW  81
01F10:  ADDWF  00,F
01F12:  BTFSC  FD8.0
01F14:  GOTO   2004
01F18:  GOTO   1F2C
01F1C:  MOVLW  7F
01F1E:  SUBWF  00,F
01F20:  BTFSS  FD8.0
01F22:  GOTO   2004
01F26:  BTFSC  FD8.2
01F28:  GOTO   2004
01F2C:  MOVFF  A88,A8F
01F30:  MOVF   x8C,W
01F32:  XORWF  x8F,F
01F34:  BSF    x88.7
01F36:  BSF    x8C.7
01F38:  MOVF   x8A,W
01F3A:  MULWF  x8E
01F3C:  MOVFF  FF4,A91
01F40:  MOVF   x89,W
01F42:  MULWF  x8D
01F44:  MOVFF  FF4,03
01F48:  MOVFF  FF3,A90
01F4C:  MULWF  x8E
01F4E:  MOVF   FF3,W
01F50:  ADDWF  x91,F
01F52:  MOVF   FF4,W
01F54:  ADDWFC x90,F
01F56:  MOVLW  00
01F58:  ADDWFC 03,F
01F5A:  MOVF   x8A,W
01F5C:  MULWF  x8D
01F5E:  MOVF   FF3,W
01F60:  ADDWF  x91,F
01F62:  MOVF   FF4,W
01F64:  ADDWFC x90,F
01F66:  MOVLW  00
01F68:  CLRF   02
01F6A:  ADDWFC 03,F
01F6C:  ADDWFC 02,F
01F6E:  MOVF   x88,W
01F70:  MULWF  x8E
01F72:  MOVF   FF3,W
01F74:  ADDWF  x90,F
01F76:  MOVF   FF4,W
01F78:  ADDWFC 03,F
01F7A:  MOVLW  00
01F7C:  ADDWFC 02,F
01F7E:  MOVF   x88,W
01F80:  MULWF  x8D
01F82:  MOVF   FF3,W
01F84:  ADDWF  03,F
01F86:  MOVF   FF4,W
01F88:  ADDWFC 02,F
01F8A:  MOVLW  00
01F8C:  CLRF   01
01F8E:  ADDWFC 01,F
01F90:  MOVF   x8A,W
01F92:  MULWF  x8C
01F94:  MOVF   FF3,W
01F96:  ADDWF  x90,F
01F98:  MOVF   FF4,W
01F9A:  ADDWFC 03,F
01F9C:  MOVLW  00
01F9E:  ADDWFC 02,F
01FA0:  ADDWFC 01,F
01FA2:  MOVF   x89,W
01FA4:  MULWF  x8C
01FA6:  MOVF   FF3,W
01FA8:  ADDWF  03,F
01FAA:  MOVF   FF4,W
01FAC:  ADDWFC 02,F
01FAE:  MOVLW  00
01FB0:  ADDWFC 01,F
01FB2:  MOVF   x88,W
01FB4:  MULWF  x8C
01FB6:  MOVF   FF3,W
01FB8:  ADDWF  02,F
01FBA:  MOVF   FF4,W
01FBC:  ADDWFC 01,F
01FBE:  INCF   00,F
01FC0:  BTFSC  01.7
01FC2:  GOTO   1FD0
01FC6:  RLCF   x90,F
01FC8:  RLCF   03,F
01FCA:  RLCF   02,F
01FCC:  RLCF   01,F
01FCE:  DECF   00,F
01FD0:  MOVLW  00
01FD2:  BTFSS  x90.7
01FD4:  GOTO   1FF8
01FD8:  INCF   03,F
01FDA:  ADDWFC 02,F
01FDC:  ADDWFC 01,F
01FDE:  MOVF   01,W
01FE0:  BTFSS  FD8.2
01FE2:  GOTO   1FF8
01FE6:  MOVF   02,W
01FE8:  BTFSS  FD8.2
01FEA:  GOTO   1FF8
01FEE:  MOVF   03,W
01FF0:  BTFSS  FD8.2
01FF2:  GOTO   1FF8
01FF6:  INCF   00,F
01FF8:  BTFSC  x8F.7
01FFA:  BSF    01.7
01FFC:  BTFSS  x8F.7
01FFE:  BCF    01.7
02000:  GOTO   200C
02004:  CLRF   00
02006:  CLRF   01
02008:  CLRF   02
0200A:  CLRF   03
0200C:  MOVLB  0
0200E:  GOTO   20BE (RETURN)
02012:  MOVLB  A
02014:  MOVF   x83,W
02016:  SUBLW  B6
02018:  MOVWF  x83
0201A:  CLRF   03
0201C:  MOVFF  A84,A87
02020:  BSF    x84.7
02022:  BCF    FD8.0
02024:  RRCF   x84,F
02026:  RRCF   x85,F
02028:  RRCF   x86,F
0202A:  RRCF   03,F
0202C:  RRCF   02,F
0202E:  RRCF   01,F
02030:  RRCF   00,F
02032:  DECFSZ x83,F
02034:  GOTO   2022
02038:  BTFSS  x87.7
0203A:  GOTO   2054
0203E:  COMF   00,F
02040:  COMF   01,F
02042:  COMF   02,F
02044:  COMF   03,F
02046:  INCF   00,F
02048:  BTFSC  FD8.2
0204A:  INCF   01,F
0204C:  BTFSC  FD8.2
0204E:  INCF   02,F
02050:  BTFSC  FD8.2
02052:  INCF   03,F
02054:  MOVLB  0
02056:  GOTO   20E2 (RETURN)
*
0317C:  ADDWF  FE8,W
0317E:  CLRF   FF7
03180:  RLCF   FF7,F
03182:  ADDLW  97
03184:  MOVWF  FF6
03186:  MOVLW  31
03188:  ADDWFC FF7,F
0318A:  TBLRD*-
0318C:  MOVF   FF5,W
0318E:  MOVWF  FFA
03190:  TBLRD*
03192:  MOVF   FF5,W
03194:  MOVWF  FF9
03196:  DATA 3E,31
03198:  DATA 44,31
0319A:  DATA 50,31
0319C:  DATA 6E,31
0319E:  DATA 50,31
031A0:  DATA 6E,31
031A2:  DATA 34,31
031A4:  DATA 4A,31
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VI_PIN_CONFIG_H_ 
.................... #define _VI_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // DI PIN Mapping. 
.................... #define PIN_IN_DI_00               PIN_B1   // Pipe presense sensor left. 
.................... #define PIN_IN_DI_01               PIN_B2   // Pipe presense sensor right. 
.................... #define PIN_IN_DI_02               PIN_B3   // Pressure switch indication. 
.................... #define PIN_IN_DI_03               PIN_G6   // Left Weighing Cylinder Actuated Up. 
.................... #define PIN_IN_DI_04               PIN_G7   // Right Weighing Cylinder Actuated Up. 
.................... #define PIN_IN_DI_05               PIN_F0    
.................... #define PIN_IN_DI_06               PIN_F1 
.................... #define PIN_IN_DI_07               PIN_F2 
....................  
.................... // D0 PIN Mapping. 
.................... #define PIN_OUT_DO_00              PIN_H2  // Weighing Module activated solenoid. 
.................... #define PIN_OUT_DO_01              PIN_H3  // Weighing completed; pipe reject solenoid. 
.................... #define PIN_OUT_DO_02              PIN_D1   
.................... #define PIN_OUT_DO_03              PIN_D2  // Tower Light Blue; Indicates Pipe OverWeight. 
.................... #define PIN_OUT_DO_04              PIN_D3  // Tower Light Green; Indicates Pipe Underweight. 
.................... #define PIN_OUT_DO_05              PIN_D4 
....................  
.................... // LAN Communication Pin Mapping. 
.................... #define PIN_LAN_COMM_XMIT          PIN_E0 
.................... #define PIN_LAN_COMM_RCV    	   PIN_E1 
....................  
.................... // Camera Communication PIN Mapping. 
.................... #define PIN_CAM_COMM_XMIT          PIN_C0 
.................... #define PIN_CAM_COMM_RCV           PIN_C1 
....................  
.................... // ADC Communication PIN Mapping. 
.................... #define PIN_ADC_SPARE             PIN_G4 
.................... #define PIN_ADC_PDWN              PIN_F7 
.................... #define PIN_ADC_SCLK              PIN_D6 
.................... #define PIN_ADC_DOUT_DRDY         PIN_D5 
.................... #define PIN_ADC_TEMP              PIN_G4 
.................... // PGA -> Programmable Gain Amplifier. 
.................... #define PIN_ADC_GAIN_1            PIN_F4 
.................... #define PIN_ADC_GAIN_0            PIN_F3 
....................  
.................... // UART -><- UART(IBU) Communication PIN Mapping. 
.................... #define PIN_IBU_XMIT              PIN_C6 
.................... #define PIN_IBU_RCV               PIN_C7 
....................  
....................  
.................... #endif /* _VI_PIN_CONFIG_H_ */ 
....................  
....................  
.................... //#ifndef _VI_PIN_CONFIG_H_ 
.................... //#define _VI_PIN_CONFIG_H_ 
.................... // 
.................... ////#include "18F46K80.h" 
.................... // 
.................... //// DI PIN Mapping. 
.................... //#define PIN_IN_DI_00               PIN_D4  
.................... //#define PIN_IN_DI_01               PIN_B0  
.................... //#define PIN_IN_DI_02               PIN_B1  
.................... //#define PIN_IN_DI_03               PIN_B2  
.................... //#define PIN_IN_DI_04               PIN_B4    
.................... //#define PIN_IN_DI_05               PIN_B5  
.................... //#define PIN_IN_DI_06               PIN_A0  
.................... //#define PIN_IN_DI_07               PIN_A1  
.................... // 
.................... //// D0 PIN Mapping. 
.................... //#define PIN_OUT_DO_00              PIN_E0  
.................... //#define PIN_OUT_DO_01              PIN_E1  
.................... //#define PIN_OUT_DO_02              PIN_E2  
.................... //#define PIN_OUT_DO_03              PIN_C0  
.................... //#define PIN_OUT_DO_04              PIN_C1  
.................... //#define PIN_OUT_DO_05              PIN_D0 
.................... //#define PIN_OUT_DO_06              PIN_D1 
.................... //#define PIN_OUT_DO_07              PIN_D2 
.................... // 
.................... // 
.................... //// LAN Communication Pin Mapping. 
.................... //#define PIN_LAN_COMM_XMIT          PIN_C6 
.................... //#define PIN_LAN_COMM_RCV    	   PIN_C7 
.................... // 
.................... //// ADC Communication PIN Mapping; IC -> ADS1131(18-bit ADC). 
.................... //#define PIN_ADC_DOUT_DRDY           PIN_C4 
.................... //#define PIN_ADC_SCLK                PIN_C3 
.................... //#define PIN_ADC_PDWN                PIN_C2 
.................... // 
.................... // 
.................... //// IBC Communication PIN Mapping. 
.................... //#define PIN_IBC_RCV                 PIN_B3 
.................... //#define PIN_IBC_XMIT                PIN_D5 
.................... // 
.................... //// UART To UART Communication PIN Mapping. 
.................... //#define PIN_UART2_COMM_XMIT         PIN_D6 
.................... //#define PIN_UART2_COMM_RCV          PIN_D7 
.................... // 
.................... // 
.................... //#endif /* _VI_PIN_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
00C64:  MOVLW  0A
00C66:  MOVWF  FEA
00C68:  MOVLW  73
00C6A:  MOVWF  FE9
00C6C:  MOVF   FEF,W
00C6E:  BTFSC  FD8.2
00C70:  GOTO   0C96
00C74:  MOVLW  06
00C76:  MOVWF  01
00C78:  MOVLW  BF
00C7A:  MOVWF  00
00C7C:  CLRWDT
00C7E:  DECFSZ 00,F
00C80:  BRA    0C7C
00C82:  DECFSZ 01,F
00C84:  BRA    0C78
00C86:  MOVLW  7A
00C88:  MOVWF  00
00C8A:  DECFSZ 00,F
00C8C:  BRA    0C8A
00C8E:  BRA    0C90
00C90:  CLRWDT
00C92:  DECFSZ FEF,F
00C94:  BRA    0C74
00C96:  GOTO   2FFC (RETURN)
....................  
.................... //******** Serial Interface ************ 
.................... ////#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... //#pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ********** Serial Interface ************************************** 
....................  
.................... // ################ Using UART2 -> Configure for Camera ######################## 
.................... #PIN_SELECT U4RX=PIN_C1 
.................... #PIN_SELECT U4TX=PIN_C0 
.................... #use rs232(baud=9600,UART4,stream=CAMERA,ERRORS) 
*
00176:  MOVLB  E
00178:  BTFSS  x37.3
0017A:  GOTO   0178
0017E:  MOVFF  EE7,2F
00182:  MOVFF  EE3,01
00186:  BTFSS  2F.1
00188:  GOTO   0190
0018C:  BCF    xE7.4
0018E:  BSF    xE7.4
00190:  MOVLB  0
00192:  GOTO   01B6 (RETURN)
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
*
00212:  MOVLB  E
00214:  BTFSS  x36.5
00216:  GOTO   0214
0021A:  MOVFF  F9C,2F
0021E:  MOVFF  F98,01
00222:  BTFSS  2F.1
00224:  GOTO   022C
00228:  BCF    F9C.4
0022A:  BSF    F9C.4
0022C:  MOVLB  0
0022E:  GOTO   0278 (RETURN)
*
00F34:  MOVLB  E
00F36:  BTFSS  x36.4
00F38:  GOTO   0F36
00F3C:  MOVWF  F99
00F3E:  MOVLB  0
00F40:  RETURN 0
....................  
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for high–order byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for low–order byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
*
00E7E:  MOVLB  A
00E80:  CLRF   x7B
00E82:  CLRF   x7A
00E84:  SETF   x7D
00E86:  SETF   x7C
00E88:  MOVLW  A0
00E8A:  MOVWF  x7F
00E8C:  MOVLW  01
00E8E:  MOVWF  x7E
00E90:  CLRF   x80
00E92:  CLRF   x81
00E94:  CLRF   x82
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
00E96:  MOVF   x79,W
00E98:  SUBWF  x80,W
00E9A:  BTFSS  FD8.2
00E9C:  GOTO   0EA4
.................... 		{ 
.................... 			break; 
00EA0:  GOTO   0F28
.................... 		} 
....................  
.................... 		uiByteCount++; 
00EA4:  INCF   x80,F
.................... 		bShiftCount = 0; 
00EA6:  CLRF   x81
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
00EA8:  MOVF   x81,F
00EAA:  BTFSS  FD8.2
00EAC:  GOTO   0EE8
.................... 			{ 
.................... 				if (1 == uiByteCount) 
00EB0:  DECFSZ x80,W
00EB2:  GOTO   0ED2
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
00EB6:  MOVLW  01
00EB8:  SUBWF  x80,W
00EBA:  ADDWF  x77,W
00EBC:  MOVWF  FE9
00EBE:  MOVLW  00
00EC0:  ADDWFC x78,W
00EC2:  MOVWF  FEA
00EC4:  MOVF   FEF,W
00EC6:  XORWF  x7C,W
00EC8:  MOVWF  x7A
00ECA:  MOVFF  A7D,A7B
.................... 				} 
00ECE:  GOTO   0EE4
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
00ED2:  MOVLW  01
00ED4:  SUBWF  x80,W
00ED6:  ADDWF  x77,W
00ED8:  MOVWF  FE9
00EDA:  MOVLW  00
00EDC:  ADDWFC x78,W
00EDE:  MOVWF  FEA
00EE0:  MOVF   FEF,W
00EE2:  XORWF  x7A,F
.................... 				} 
.................... 			} 
00EE4:  GOTO   0EF0
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
00EE8:  MOVF   x7E,W
00EEA:  XORWF  x7A,F
00EEC:  MOVF   x7F,W
00EEE:  XORWF  x7B,F
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
00EF0:  MOVLB  A
00EF2:  INCF   x81,F
....................  
.................... 			if (bShiftCount > 8) 
00EF4:  MOVF   x81,W
00EF6:  SUBLW  08
00EF8:  BTFSC  FD8.0
00EFA:  GOTO   0F02
.................... 			{ 
.................... 				break; 
00EFE:  GOTO   0F24
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
00F02:  MOVF   x7A,W
00F04:  ANDLW  01
00F06:  MOVWF  x82
....................  
.................... 			uiCRC = uiCRC >> 1; 
00F08:  BCF    FD8.0
00F0A:  RRCF   x7B,F
00F0C:  RRCF   x7A,F
....................  
.................... 			if (1 == bShiftCarry) 
00F0E:  DECFSZ x82,W
00F10:  GOTO   0F1C
.................... 			{ 
.................... 				continue; 
00F14:  GOTO   0EA8
.................... 			} 
00F18:  GOTO   0F20
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
00F1C:  GOTO   0EF0
.................... 			} 
00F20:  GOTO   0EA8
.................... 		} 
00F24:  GOTO   0E96
.................... 	} 
....................  
.................... 	return uiCRC; 
00F28:  MOVFF  A7A,01
00F2C:  MOVFF  A7B,02
00F30:  MOVLB  0
00F32:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
.................... #include "vmCircularQ.h" 
.................... /*  
....................  * File:   vmCircularQ.h 
....................  * Author: AmitDP 
....................  * 
....................  * Created on February 26, 2020, 2:17 PM 
....................  */ 
....................  
.................... #ifndef VM_CIRCULAR_Q_H 
.................... #define	VM_CIRCULAR_Q_H 
....................  
....................  
.................... #define SIZE_RCV_QUEUE 200 
....................  
.................... typedef struct _ST_RCV_QUEUE 
.................... { 
....................     int8 m_ui8QArr[SIZE_RCV_QUEUE]; 
....................     int8 m_ui8Front; 
....................     int8 m_ui8Rear; 
.................... } ST_RCV_QUEUE; 
....................  
.................... ST_RCV_QUEUE g_stRcvQueue; 
.................... unsigned int8 g_ui8ElementInQ = 0; 
....................  
.................... void InitializeRcvQ() 
.................... { 
....................     memset(g_stRcvQueue.m_ui8QArr, SIZE_RCV_QUEUE, 0); 
*
00CE2:  CLRF   FEA
00CE4:  MOVLW  78
00CE6:  MOVWF  FE9
00CE8:  MOVLW  C8
00CEA:  MOVWF  00
00CEC:  CLRF   02
00CEE:  CLRF   01
00CF0:  GOTO   0CBC
....................     g_stRcvQueue.m_ui8Front = -1; 
00CF4:  MOVLB  1
00CF6:  SETF   x40
....................     g_stRcvQueue.m_ui8Rear  = -1; 
00CF8:  SETF   x41
00CFA:  MOVLB  0
00CFC:  GOTO   3004 (RETURN)
.................... } 
....................  
.................... //int isFull() 
.................... //{ 
.................... //    if( (front == rear + 1) || (front == 0 && rear == SIZE_RCV_QUEUE-1)) return 1; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... //int8 items[SIZE_RCV_QUEUE]; 
.................... //int front = -1, rear =-1; 
.................... unsigned int8 ElementsInQ(void) 
*
01082:  MOVLW  0A
01084:  MOVLB  A
01086:  MOVWF  x73
.................... { 
....................     unsigned int8 ui8Retval = 10; 
....................      
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
01088:  MOVLB  1
0108A:  MOVF   x40,W
0108C:  SUBLW  FF
0108E:  BTFSS  FD8.2
01090:  GOTO   10A2
....................     { 
....................         //return = 0; 
....................         ui8Retval = 0; 
01094:  MOVLB  A
01096:  CLRF   x73
....................         return ui8Retval; 
01098:  MOVFF  A73,01
0109C:  GOTO   10CE
010A0:  MOVLB  1
....................     } 
....................      
....................      
....................     if (g_stRcvQueue.m_ui8Front > g_stRcvQueue.m_ui8Rear) 
010A2:  MOVF   x40,W
010A4:  SUBWF  x41,W
010A6:  BTFSC  FD8.0
010A8:  GOTO   10C0
....................     { 
....................         //return = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
....................         ui8Retval = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
010AC:  MOVLW  C8
010AE:  BSF    FD8.0
010B0:  SUBFWB x40,W
010B2:  ADDWF  x41,W
010B4:  ADDLW  01
010B6:  MOVLB  A
010B8:  MOVWF  x73
....................     } 
010BA:  GOTO   10CA
010BE:  MOVLB  1
....................     else 
....................     { 
....................         //return = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
....................         ui8Retval = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
010C0:  MOVF   x40,W
010C2:  SUBWF  x41,W
010C4:  ADDLW  01
010C6:  MOVLB  A
010C8:  MOVWF  x73
....................     } 
....................      
....................     return ui8Retval; 
010CA:  MOVFF  A73,01
010CE:  MOVLB  0
010D0:  GOTO   3054 (RETURN)
.................... } 
....................  
.................... unsigned int8 IsQFull(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if( (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear + 1) || 
....................         (g_stRcvQueue.m_ui8Front == 0 && g_stRcvQueue.m_ui8Rear == SIZE_RCV_QUEUE - 1)) 
....................     { 
....................         // Queue is Full 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     }    
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int isEmpty() 
.................... //{ 
.................... //    if(front == -1) return 1; 
.................... //    return 0; 
.................... //} 
....................  
.................... unsigned int8 IsQEmpty(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if(g_stRcvQueue.m_ui8Front == -1) 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     return ui8RetVal; 
.................... } 
....................  
.................... //void enQueue(int element) 
.................... //{ 
.................... //    if(isFull()) printf("\n Queue is full!! \n"); 
.................... //    else 
.................... //    { 
.................... //        if(front == -1) front = 0; 
.................... //        rear = (rear + 1) % SIZE_RCV_QUEUE; 
.................... //        items[rear] = element; 
.................... //        printf("\n Inserted -> %d", element); 
.................... //    } 
.................... //} 
....................  
.................... void EnQueue(unsigned int8 ui8Element) 
.................... { 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = ui8Element; 
.................... } 
....................  
.................... unsigned int8 DeQueue(void) 
.................... { 
....................     unsigned int8 ui8Element = 0; 
....................     unsigned int8 ui8RetVal  = 0; 
....................      
....................     ui8RetVal = IsQEmpty(); 
....................     if(ui8RetVal) 
....................     { 
....................         ui8RetVal = 0; 
....................         //return 0; //?? 
....................     } 
....................     else 
....................     { 
....................         ui8Element = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         if (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear) 
....................         { 
....................             g_stRcvQueue.m_ui8Front = -1; 
....................             g_stRcvQueue.m_ui8Rear  = -1; 
....................         } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
....................         else 
....................         { 
....................             g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         } 
....................         //printf("\n Deleted element -> %d \n", ui8Element); 
....................         ui8RetVal = ui8Element; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int deQueue() 
.................... //{ 
.................... //    int element; 
.................... //    if(isEmpty()) { 
.................... //        printf("\n Queue is empty !! \n"); 
.................... //        return(-1); 
.................... //    } else { 
.................... //        element = items[front]; 
.................... //        if (front == rear){ 
.................... //            front = -1; 
.................... //            rear = -1; 
.................... //        } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
.................... //        else { 
.................... //            front = (front + 1) % SIZE_RCV_QUEUE; 
.................... //             
.................... //        } 
.................... //        printf("\n Deleted element -> %d \n", element); 
.................... //        return(element); 
.................... //    } 
.................... //} 
....................  
....................  
.................... #endif	/* VM_CIRCULAR_Q_H */ 
....................  
....................  
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
*
00C38:  MOVF   F98,W
.................... 	enable_interrupts(INT_RDA); 
00C3A:  MOVLB  E
00C3C:  BSF    x2C.5
00C3E:  MOVLB  0
00C40:  GOTO   0C5C (RETURN)
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
00C44:  MOVLB  E
00C46:  MOVF   xE3,W
.................... 	enable_interrupts(INT_RDA4);     
00C48:  BSF    x2D.3
00C4A:  MOVLB  0
00C4C:  GOTO   0C60 (RETURN)
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
*
00196:  MOVLB  0
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
00198:  CLRF   03
0019A:  MOVLB  1
0019C:  MOVF   x57,W
0019E:  ADDLW  43
001A0:  MOVWF  FE9
001A2:  MOVLW  01
001A4:  ADDWFC 03,W
001A6:  MOVWF  FEA
001A8:  MOVFF  FEA,AA8
001AC:  MOVFF  FE9,AA7
001B0:  MOVLB  0
001B2:  GOTO   0176
001B6:  MOVFF  AA8,FEA
001BA:  MOVFF  AA7,FE9
001BE:  MOVFF  01,FEF
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
001C2:  MOVLB  1
001C4:  INCF   x57,F
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
001C6:  MOVF   x57,W
001C8:  SUBLW  13
001CA:  BTFSC  FD8.0
001CC:  GOTO   01D2
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
001D0:  CLRF   x57
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
001D2:  MOVLB  E
001D4:  MOVF   xE3,W
.................... } 
....................  
001D6:  BCF    x37.3
001D8:  MOVLB  0
001DA:  GOTO   007E
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
0055E:  MOVLB  A
00560:  CLRF   x76
00562:  CLRF   x77
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
00564:  MOVLW  C3
00566:  ADDWF  x74,W
00568:  MOVWF  01
0056A:  MOVLW  00
0056C:  ADDWFC x75,W
0056E:  MOVWF  03
00570:  MOVLW  C4
00572:  ADDWF  x74,W
00574:  MOVWF  FE9
00576:  MOVLW  00
00578:  ADDWFC x75,W
0057A:  MOVWF  FEA
0057C:  SETF   FEF
0057E:  MOVLW  FF
00580:  MOVFF  03,FEA
00584:  MOVFF  01,FE9
00588:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
0058A:  CLRF   x76
0058C:  MOVF   x76,W
0058E:  SUBLW  0E
00590:  BTFSS  FD8.0
00592:  GOTO   05EC
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
00596:  CLRF   x77
00598:  MOVF   x77,W
0059A:  SUBLW  08
0059C:  BTFSS  FD8.0
0059E:  GOTO   05E6
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
005A2:  CLRF   x9D
005A4:  MOVFF  A76,A9C
005A8:  CLRF   x9F
005AA:  MOVLW  0D
005AC:  MOVWF  x9E
005AE:  MOVLB  0
005B0:  CALL   053C
005B4:  MOVFF  02,A79
005B8:  MOVFF  01,A78
005BC:  MOVLW  02
005BE:  MOVLB  A
005C0:  ADDWF  x78,F
005C2:  MOVLW  00
005C4:  ADDWFC x79,F
005C6:  MOVF   x77,W
005C8:  ADDWF  x78,W
005CA:  MOVWF  01
005CC:  MOVLW  00
005CE:  ADDWFC x79,W
005D0:  MOVWF  03
005D2:  MOVF   01,W
005D4:  ADDWF  x74,W
005D6:  MOVWF  FE9
005D8:  MOVF   x75,W
005DA:  ADDWFC 03,W
005DC:  MOVWF  FEA
005DE:  CLRF   FEF
005E0:  INCF   x77,F
005E2:  GOTO   0598
....................         } 
005E6:  INCF   x76,F
005E8:  GOTO   058C
....................     } 
005EC:  MOVLB  0
005EE:  RETURN 0
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
*
00DC8:  MOVLB  A
00DCA:  CLRF   xA1
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
00DCC:  CLRF   xA1
00DCE:  MOVF   xA1,W
00DD0:  SUBLW  08
00DD2:  BTFSS  FD8.0
00DD4:  GOTO   0E0A
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
00DD8:  MOVLW  02
00DDA:  ADDWF  xA1,W
00DDC:  ADDWF  x9F,W
00DDE:  MOVWF  01
00DE0:  MOVLW  00
00DE2:  ADDWFC xA0,W
00DE4:  MOVWF  03
00DE6:  MOVLW  02
00DE8:  ADDWF  xA1,W
00DEA:  ADDWF  x9D,W
00DEC:  MOVWF  FE9
00DEE:  MOVLW  00
00DF0:  ADDWFC x9E,W
00DF2:  MOVWF  FEA
00DF4:  MOVFF  FEF,AA4
00DF8:  MOVFF  03,FEA
00DFC:  MOVFF  01,FE9
00E00:  MOVFF  AA4,FEF
00E04:  INCF   xA1,F
00E06:  GOTO   0DCE
....................     } 
00E0A:  MOVLB  0
00E0C:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
*
01114:  MOVLB  A
01116:  MOVF   x99,W
01118:  IORWF  x9A,W
0111A:  BTFSS  FD8.2
0111C:  GOTO   1124
....................     { 
....................         return; 
01120:  GOTO   12E8
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
01124:  MOVLW  C3
01126:  ADDWF  x97,W
01128:  MOVWF  FE9
0112A:  MOVLW  00
0112C:  ADDWFC x98,W
0112E:  MOVWF  FEA
01130:  MOVF   FEF,F
01132:  BTFSS  FD8.2
01134:  GOTO   114E
01138:  MOVLW  C4
0113A:  ADDWF  x97,W
0113C:  MOVWF  FE9
0113E:  MOVLW  00
01140:  ADDWFC x98,W
01142:  MOVWF  FEA
01144:  MOVF   FEF,W
01146:  SUBLW  0E
01148:  BTFSC  FD8.2
0114A:  GOTO   1176
0114E:  MOVLW  C4
01150:  ADDWF  x97,W
01152:  MOVWF  FE9
01154:  MOVLW  00
01156:  ADDWFC x98,W
01158:  MOVWF  FEA
0115A:  MOVFF  FEF,A9B
0115E:  MOVLW  C3
01160:  ADDWF  x97,W
01162:  MOVWF  FE9
01164:  MOVLW  00
01166:  ADDWFC x98,W
01168:  MOVWF  FEA
0116A:  MOVLW  01
0116C:  SUBWF  FEF,W
0116E:  SUBWF  x9B,W
01170:  BTFSS  FD8.2
01172:  GOTO   117E
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
01176:  GOTO   12E8
....................     }     
0117A:  GOTO   12E8
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
0117E:  MOVLW  C3
01180:  ADDWF  x97,W
01182:  MOVWF  FE9
01184:  MOVLW  00
01186:  ADDWFC x98,W
01188:  MOVWF  FEA
0118A:  MOVF   FEF,W
0118C:  SUBLW  FF
0118E:  BTFSS  FD8.2
01190:  GOTO   1202
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
01194:  MOVLW  C3
01196:  ADDWF  x97,W
01198:  MOVWF  FE9
0119A:  MOVLW  00
0119C:  ADDWFC x98,W
0119E:  MOVWF  FEA
011A0:  CLRF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
011A2:  MOVLW  C4
011A4:  ADDWF  x97,W
011A6:  MOVWF  FE9
011A8:  MOVLW  00
011AA:  ADDWFC x98,W
011AC:  MOVWF  FEA
011AE:  CLRF   FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
011B0:  MOVLW  C4
011B2:  ADDWF  x97,W
011B4:  MOVWF  FE9
011B6:  MOVLW  00
011B8:  ADDWFC x98,W
011BA:  MOVWF  FEA
011BC:  CLRF   x9D
011BE:  MOVFF  FEF,A9C
011C2:  CLRF   x9F
011C4:  MOVLW  0D
011C6:  MOVWF  x9E
011C8:  MOVLB  0
011CA:  CALL   053C
011CE:  MOVFF  02,03
011D2:  MOVF   01,W
011D4:  MOVLB  A
011D6:  ADDWF  x97,W
011D8:  MOVWF  01
011DA:  MOVF   x98,W
011DC:  ADDWFC 03,F
011DE:  MOVFF  01,A9B
011E2:  MOVFF  03,A9C
011E6:  MOVFF  A9A,A9E
011EA:  MOVFF  A99,A9D
011EE:  MOVFF  03,AA0
011F2:  MOVFF  01,A9F
011F6:  MOVLB  0
011F8:  CALL   0DC8
....................     }  
011FC:  GOTO   12E6
01200:  MOVLB  A
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
01202:  MOVLW  C4
01204:  ADDWF  x97,W
01206:  MOVWF  FE9
01208:  MOVLW  00
0120A:  ADDWFC x98,W
0120C:  MOVWF  FEA
0120E:  MOVF   FEF,W
01210:  SUBLW  0E
01212:  BTFSS  FD8.2
01214:  GOTO   128C
01218:  MOVLW  C3
0121A:  ADDWF  x97,W
0121C:  MOVWF  FE9
0121E:  MOVLW  00
01220:  ADDWFC x98,W
01222:  MOVWF  FEA
01224:  MOVF   FEF,F
01226:  BTFSC  FD8.2
01228:  GOTO   128C
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
0122C:  MOVLW  C4
0122E:  ADDWF  x97,W
01230:  MOVWF  FE9
01232:  MOVLW  00
01234:  ADDWFC x98,W
01236:  MOVWF  FEA
01238:  CLRF   FEF
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
0123A:  MOVLW  C4
0123C:  ADDWF  x97,W
0123E:  MOVWF  FE9
01240:  MOVLW  00
01242:  ADDWFC x98,W
01244:  MOVWF  FEA
01246:  CLRF   x9D
01248:  MOVFF  FEF,A9C
0124C:  CLRF   x9F
0124E:  MOVLW  0D
01250:  MOVWF  x9E
01252:  MOVLB  0
01254:  CALL   053C
01258:  MOVFF  02,03
0125C:  MOVF   01,W
0125E:  MOVLB  A
01260:  ADDWF  x97,W
01262:  MOVWF  01
01264:  MOVF   x98,W
01266:  ADDWFC 03,F
01268:  MOVFF  01,A9B
0126C:  MOVFF  03,A9C
01270:  MOVFF  A9A,A9E
01274:  MOVFF  A99,A9D
01278:  MOVFF  03,AA0
0127C:  MOVFF  01,A9F
01280:  MOVLB  0
01282:  CALL   0DC8
....................     }  
01286:  GOTO   12E6
0128A:  MOVLB  A
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
0128C:  MOVLW  C4
0128E:  ADDWF  x97,W
01290:  MOVWF  FE9
01292:  MOVLW  00
01294:  ADDWFC x98,W
01296:  MOVWF  FEA
01298:  INCF   FEF,F
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
0129A:  MOVLW  C4
0129C:  ADDWF  x97,W
0129E:  MOVWF  FE9
012A0:  MOVLW  00
012A2:  ADDWFC x98,W
012A4:  MOVWF  FEA
012A6:  CLRF   x9D
012A8:  MOVFF  FEF,A9C
012AC:  CLRF   x9F
012AE:  MOVLW  0D
012B0:  MOVWF  x9E
012B2:  MOVLB  0
012B4:  CALL   053C
012B8:  MOVFF  02,03
012BC:  MOVF   01,W
012BE:  MOVLB  A
012C0:  ADDWF  x97,W
012C2:  MOVWF  01
012C4:  MOVF   x98,W
012C6:  ADDWFC 03,F
012C8:  MOVFF  01,A9B
012CC:  MOVFF  03,A9C
012D0:  MOVFF  A9A,A9E
012D4:  MOVFF  A99,A9D
012D8:  MOVFF  03,AA0
012DC:  MOVFF  01,A9F
012E0:  MOVLB  0
012E2:  CALL   0DC8
012E6:  MOVLB  A
....................     } 
012E8:  MOVLB  0
012EA:  RETURN 0
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
0167A:  MOVLW  C3
0167C:  MOVLB  A
0167E:  ADDWF  x81,W
01680:  MOVWF  FE9
01682:  MOVLW  00
01684:  ADDWFC x82,W
01686:  MOVWF  FEA
01688:  MOVF   FEF,W
0168A:  SUBLW  FF
0168C:  BTFSS  FD8.2
0168E:  GOTO   1696
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
01692:  GOTO   1760
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
01696:  MOVLW  C3
01698:  ADDWF  x81,W
0169A:  MOVWF  FE9
0169C:  MOVLW  00
0169E:  ADDWFC x82,W
016A0:  MOVWF  FEA
016A2:  CLRF   x9D
016A4:  MOVFF  FEF,A9C
016A8:  CLRF   x9F
016AA:  MOVLW  0D
016AC:  MOVWF  x9E
016AE:  MOVLB  0
016B0:  CALL   053C
016B4:  MOVFF  02,03
016B8:  MOVF   01,W
016BA:  MOVLB  A
016BC:  ADDWF  x81,W
016BE:  MOVWF  01
016C0:  MOVF   x82,W
016C2:  ADDWFC 03,F
016C4:  MOVFF  01,A85
016C8:  MOVFF  03,A86
016CC:  MOVFF  03,A9E
016D0:  MOVFF  01,A9D
016D4:  MOVFF  A84,AA0
016D8:  MOVFF  A83,A9F
016DC:  MOVLB  0
016DE:  CALL   0DC8
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
016E2:  MOVLW  C3
016E4:  MOVLB  A
016E6:  ADDWF  x81,W
016E8:  MOVWF  FE9
016EA:  MOVLW  00
016EC:  ADDWFC x82,W
016EE:  MOVWF  FEA
016F0:  MOVFF  FEF,A85
016F4:  MOVLW  C4
016F6:  ADDWF  x81,W
016F8:  MOVWF  FE9
016FA:  MOVLW  00
016FC:  ADDWFC x82,W
016FE:  MOVWF  FEA
01700:  MOVF   FEF,W
01702:  SUBWF  x85,W
01704:  BTFSS  FD8.2
01706:  GOTO   172A
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
0170A:  MOVLW  C3
0170C:  ADDWF  x81,W
0170E:  MOVWF  FE9
01710:  MOVLW  00
01712:  ADDWFC x82,W
01714:  MOVWF  FEA
01716:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
01718:  MOVLW  C4
0171A:  ADDWF  x81,W
0171C:  MOVWF  FE9
0171E:  MOVLW  00
01720:  ADDWFC x82,W
01722:  MOVWF  FEA
01724:  SETF   FEF
....................     }  
01726:  GOTO   1760
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
0172A:  MOVLW  C3
0172C:  ADDWF  x81,W
0172E:  MOVWF  FE9
01730:  MOVLW  00
01732:  ADDWFC x82,W
01734:  MOVWF  FEA
01736:  MOVF   FEF,W
01738:  SUBLW  0E
0173A:  BTFSS  FD8.2
0173C:  GOTO   1752
....................         pstIBUMSGQueue->m_i8Front = 0;  
01740:  MOVLW  C3
01742:  ADDWF  x81,W
01744:  MOVWF  FE9
01746:  MOVLW  00
01748:  ADDWFC x82,W
0174A:  MOVWF  FEA
0174C:  CLRF   FEF
0174E:  GOTO   1760
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
01752:  MOVLW  C3
01754:  ADDWF  x81,W
01756:  MOVWF  FE9
01758:  MOVLW  00
0175A:  ADDWFC x82,W
0175C:  MOVWF  FEA
0175E:  INCF   FEF,F
....................    
....................     return; 
01760:  MOVLB  0
01762:  GOTO   1958 (RETURN)
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
00E0E:  MOVLW  C3
00E10:  MOVLB  A
00E12:  ADDWF  x74,W
00E14:  MOVWF  FE9
00E16:  MOVLW  00
00E18:  ADDWFC x75,W
00E1A:  MOVWF  FEA
00E1C:  MOVF   FEF,W
00E1E:  SUBLW  FF
00E20:  BTFSS  FD8.2
00E22:  GOTO   0E2A
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
00E26:  GOTO   0E78
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
00E2A:  MOVLW  C3
00E2C:  ADDWF  x74,W
00E2E:  MOVWF  FE9
00E30:  MOVLW  00
00E32:  ADDWFC x75,W
00E34:  MOVWF  FEA
00E36:  CLRF   x9D
00E38:  MOVFF  FEF,A9C
00E3C:  CLRF   x9F
00E3E:  MOVLW  0D
00E40:  MOVWF  x9E
00E42:  MOVLB  0
00E44:  CALL   053C
00E48:  MOVFF  02,03
00E4C:  MOVF   01,W
00E4E:  MOVLB  A
00E50:  ADDWF  x74,W
00E52:  MOVWF  01
00E54:  MOVF   x75,W
00E56:  ADDWFC 03,F
00E58:  MOVFF  01,A78
00E5C:  MOVFF  03,A79
00E60:  MOVFF  03,A9E
00E64:  MOVFF  01,A9D
00E68:  MOVFF  A77,AA0
00E6C:  MOVFF  A76,A9F
00E70:  MOVLB  0
00E72:  CALL   0DC8
00E76:  MOVLB  A
00E78:  MOVLB  0
00E7A:  GOTO   0FA4 (RETURN)
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
00D2C:  MOVLW  C3
00D2E:  MOVLB  A
00D30:  ADDWF  x78,W
00D32:  MOVWF  FE9
00D34:  MOVLW  00
00D36:  ADDWFC x79,W
00D38:  MOVWF  FEA
00D3A:  MOVF   FEF,W
00D3C:  SUBLW  FF
00D3E:  BTFSS  FD8.2
00D40:  GOTO   0D48
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
00D44:  GOTO   0DC4
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
00D48:  MOVLW  C3
00D4A:  ADDWF  x78,W
00D4C:  MOVWF  FE9
00D4E:  MOVLW  00
00D50:  ADDWFC x79,W
00D52:  MOVWF  FEA
00D54:  MOVFF  FEF,A7A
00D58:  MOVLW  C4
00D5A:  ADDWF  x78,W
00D5C:  MOVWF  FE9
00D5E:  MOVLW  00
00D60:  ADDWFC x79,W
00D62:  MOVWF  FEA
00D64:  MOVF   FEF,W
00D66:  SUBWF  x7A,W
00D68:  BTFSS  FD8.2
00D6A:  GOTO   0D8E
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
00D6E:  MOVLW  C3
00D70:  ADDWF  x78,W
00D72:  MOVWF  FE9
00D74:  MOVLW  00
00D76:  ADDWFC x79,W
00D78:  MOVWF  FEA
00D7A:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
00D7C:  MOVLW  C4
00D7E:  ADDWF  x78,W
00D80:  MOVWF  FE9
00D82:  MOVLW  00
00D84:  ADDWFC x79,W
00D86:  MOVWF  FEA
00D88:  SETF   FEF
....................     }  
00D8A:  GOTO   0DC4
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
00D8E:  MOVLW  C3
00D90:  ADDWF  x78,W
00D92:  MOVWF  FE9
00D94:  MOVLW  00
00D96:  ADDWFC x79,W
00D98:  MOVWF  FEA
00D9A:  MOVF   FEF,W
00D9C:  SUBLW  0E
00D9E:  BTFSS  FD8.2
00DA0:  GOTO   0DB6
....................         pstIBUMSGQueue->m_i8Front = 0;  
00DA4:  MOVLW  C3
00DA6:  ADDWF  x78,W
00DA8:  MOVWF  FE9
00DAA:  MOVLW  00
00DAC:  ADDWFC x79,W
00DAE:  MOVWF  FEA
00DB0:  CLRF   FEF
00DB2:  GOTO   0DC4
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
00DB6:  MOVLW  C3
00DB8:  ADDWF  x78,W
00DBA:  MOVWF  FE9
00DBC:  MOVLW  00
00DBE:  ADDWFC x79,W
00DC0:  MOVWF  FEA
00DC2:  INCF   FEF,F
00DC4:  MOVLB  0
00DC6:  RETURN 0
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
00D00:  MOVLB  A
00D02:  CLRF   x75
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
00D04:  MOVLW  C3
00D06:  ADDWF  x73,W
00D08:  MOVWF  FE9
00D0A:  MOVLW  00
00D0C:  ADDWFC x74,W
00D0E:  MOVWF  FEA
00D10:  MOVF   FEF,W
00D12:  SUBLW  FF
00D14:  BTFSS  FD8.2
00D16:  GOTO   0D20
....................     { 
....................         ui8RetVal = 0; 
00D1A:  CLRF   x75
....................     } 
00D1C:  GOTO   0D24
....................     else 
....................     { 
....................         ui8RetVal = 1; 
00D20:  MOVLW  01
00D22:  MOVWF  x75
....................     } 
....................      
....................     return ui8RetVal; 
00D24:  MOVFF  A75,01
00D28:  MOVLB  0
00D2A:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
*
00F42:  MOVLB  A
00F44:  CLRF   x73
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
00F46:  MOVLB  3
00F48:  MOVF   xAC,W
00F4A:  SUBLW  09
00F4C:  BTFSC  FD8.0
00F4E:  GOTO   0F6C
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
00F52:  CLRF   xAC
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
00F54:  MOVLW  01
00F56:  MOVLB  A
00F58:  MOVWF  x79
00F5A:  SETF   x78
00F5C:  MOVLB  0
00F5E:  CALL   0D2C
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00F62:  MOVLB  1
00F64:  CLRF   xFE
....................         return; 
00F66:  GOTO   107C
00F6A:  MOVLB  3
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
00F6C:  INCF   xAC,F
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
00F6E:  MOVLB  A
00F70:  CLRF   x73
00F72:  MOVF   x73,W
00F74:  SUBLW  08
00F76:  BTFSS  FD8.0
00F78:  GOTO   0F92
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
00F7C:  CLRF   03
00F7E:  MOVF   x73,W
00F80:  ADDLW  6B
00F82:  MOVWF  FE9
00F84:  MOVLW  01
00F86:  ADDWFC 03,W
00F88:  MOVWF  FEA
00F8A:  CLRF   FEF
00F8C:  INCF   x73,F
00F8E:  GOTO   0F72
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
00F92:  MOVLW  01
00F94:  MOVWF  x75
00F96:  SETF   x74
00F98:  MOVWF  x77
00F9A:  MOVLW  69
00F9C:  MOVWF  x76
00F9E:  MOVLB  0
00FA0:  GOTO   0E0E
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
00FA4:  MOVLB  3
00FA6:  DECFSZ xAC,W
00FA8:  GOTO   0FBA
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
00FAC:  INCFSZ x9C,W
00FAE:  GOTO   0FB8
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
00FB2:  CLRF   x9C
....................         } 
00FB4:  GOTO   0FBA
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
00FB8:  INCF   x9C,F
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
00FBA:  MOVFF  39C,169
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
00FBE:  MOVFF  39C,39D
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
00FC2:  MOVLW  21
00FC4:  MOVWF  x9E
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
00FC6:  MOVFF  16B,39F
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
00FCA:  MOVFF  16C,3A0
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
00FCE:  MOVFF  16D,3A1
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
00FD2:  MOVFF  16E,3A2
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
00FD6:  MOVFF  16F,3A3
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
00FDA:  MOVFF  170,3A4
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
00FDE:  MOVFF  171,3A5
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
00FE2:  MOVFF  172,3A6
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
00FE6:  MOVFF  173,3A7
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
00FEA:  MOVLW  03
00FEC:  MOVLB  A
00FEE:  MOVWF  x78
00FF0:  MOVLW  9D
00FF2:  MOVWF  x77
00FF4:  MOVLW  0B
00FF6:  MOVWF  x79
00FF8:  MOVLB  0
00FFA:  CALL   0E7E
00FFE:  MOVFF  02,3AB
01002:  MOVFF  01,3AA
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
01006:  MOVFF  3AB,A75
0100A:  MOVFF  3AA,3A8
0100E:  MOVLB  3
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
01010:  MOVFF  3AB,3A9
01014:  MOVLB  3
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
01016:  MOVLW  A5
01018:  MOVLB  0
0101A:  CALL   0F34
....................     fputc(STX, UART); 
0101E:  MOVLW  A5
01020:  CALL   0F34
....................     fputc(STX, UART); 
01024:  MOVLW  A5
01026:  CALL   0F34
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
0102A:  MOVLB  A
0102C:  CLRF   x73
0102E:  MOVF   x73,W
01030:  SUBLW  0C
01032:  BTFSS  FD8.0
01034:  GOTO   105A
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
01038:  CLRF   03
0103A:  MOVF   x73,W
0103C:  ADDLW  9D
0103E:  MOVWF  FE9
01040:  MOVLW  03
01042:  ADDWFC 03,W
01044:  MOVWF  FEA
01046:  MOVFF  FEF,A74
0104A:  MOVF   x74,W
0104C:  MOVLB  0
0104E:  CALL   0F34
01052:  MOVLB  A
01054:  INCF   x73,F
01056:  GOTO   102E
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
0105A:  MOVLW  B5
0105C:  MOVLB  0
0105E:  CALL   0F34
....................     fputc(ETX, UART); 
01062:  MOVLW  B5
01064:  CALL   0F34
....................     delay_us(5); 
01068:  CLRWDT
0106A:  MOVLW  07
0106C:  MOVWF  00
0106E:  DECFSZ 00,F
01070:  BRA    106E
01072:  BRA    1074
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
01074:  MOVLW  01
01076:  MOVLB  3
01078:  MOVWF  x8C
0107A:  MOVLB  1
0107C:  MOVLB  0
0107E:  GOTO   304C (RETURN)
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
*
010D4:  MOVLB  A
010D6:  MOVF   x77,W
010D8:  MOVLB  3
010DA:  SUBWF  x9C,W
010DC:  BTFSS  FD8.2
010DE:  GOTO   1104
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
010E2:  MOVLW  01
010E4:  MOVLB  A
010E6:  MOVWF  x79
010E8:  SETF   x78
010EA:  MOVLB  0
010EC:  CALL   0D2C
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
010F0:  MOVLB  3
010F2:  CLRF   xAC
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
010F4:  CLRF   x8C
....................         g_ui16IBUWaitForACKTikCount  = 0; 
010F6:  CLRF   x8E
010F8:  CLRF   x8D
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
010FA:  MOVLB  1
010FC:  CLRF   xFE
....................     } 
010FE:  GOTO   110E
01102:  MOVLB  3
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
01104:  CLRF   x8C
....................         g_ui16IBUWaitForACKTikCount  = 0; 
01106:  CLRF   x8E
01108:  CLRF   x8D
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
0110A:  MOVLB  1
0110C:  CLRF   xFE
....................     } 
0110E:  MOVLB  0
01110:  GOTO   156C (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
*
012EC:  MOVFF  140,A73
012F0:  MOVLB  A
012F2:  CLRF   x74
012F4:  MOVFF  140,A75
012F8:  CLRF   x76
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
012FA:  MOVFF  140,413
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
012FE:  MOVFF  141,414
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
01302:  MOVLB  4
01304:  CLRF   x16
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
01306:  CLRF   x15
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
01308:  MOVLB  1
0130A:  MOVF   x42,F
0130C:  BTFSC  FD8.2
0130E:  GOTO   1382
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
01312:  MOVLW  01
01314:  ADDWF  x40,W
01316:  MOVLB  A
01318:  MOVWF  x78
0131A:  CLRF   19
0131C:  BTFSC  FF2.7
0131E:  BSF    19.7
01320:  BCF    FF2.7
01322:  MOVWF  xAB
01324:  MOVLW  C8
01326:  MOVWF  xAC
01328:  MOVLB  0
0132A:  CALL   01DE
0132E:  BTFSC  19.7
01330:  BSF    FF2.7
01332:  MOVFF  00,A75
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
01336:  CLRF   03
01338:  MOVLB  1
0133A:  MOVF   x40,W
0133C:  ADDLW  78
0133E:  MOVWF  FE9
01340:  MOVLW  00
01342:  ADDWFC 03,W
01344:  MOVWF  FEA
01346:  MOVF   FEF,W
01348:  SUBLW  A5
0134A:  BTFSS  FD8.2
0134C:  GOTO   1378
01350:  CLRF   03
01352:  MOVLB  A
01354:  MOVF   x75,W
01356:  ADDLW  78
01358:  MOVWF  FE9
0135A:  MOVLW  00
0135C:  ADDWFC 03,W
0135E:  MOVWF  FEA
01360:  MOVF   FEF,W
01362:  SUBLW  A5
01364:  BTFSC  FD8.2
01366:  BRA    136E
01368:  MOVLB  1
0136A:  GOTO   1378
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
0136E:  MOVLB  1
01370:  GOTO   1382
....................         } 
01374:  GOTO   137E
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
01378:  MOVFF  A75,140
....................             g_ui8ElementInQ--; 
0137C:  DECF   x42,F
....................         } 
0137E:  GOTO   130A
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
01382:  MOVF   x42,F
01384:  BTFSS  FD8.2
01386:  GOTO   138E
....................     { 
....................         // The message exhausted 
....................         return; 
0138A:  GOTO   1674
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
0138E:  MOVF   x42,W
01390:  SUBLW  0D
01392:  BTFSC  FD8.0
01394:  GOTO   1432
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
01398:  MOVLW  0E
0139A:  ADDWF  x40,W
0139C:  MOVLB  A
0139E:  MOVWF  x78
013A0:  CLRF   19
013A2:  BTFSC  FF2.7
013A4:  BSF    19.7
013A6:  BCF    FF2.7
013A8:  MOVWF  xAB
013AA:  MOVLW  C8
013AC:  MOVWF  xAC
013AE:  MOVLB  0
013B0:  CALL   01DE
013B4:  BTFSC  19.7
013B6:  BSF    FF2.7
013B8:  MOVFF  00,A76
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
013BC:  CLRF   03
013BE:  MOVLB  1
013C0:  MOVF   x40,W
013C2:  ADDLW  78
013C4:  MOVWF  FE9
013C6:  MOVLW  00
013C8:  ADDWFC 03,W
013CA:  MOVWF  FEA
013CC:  MOVF   FEF,W
013CE:  SUBLW  A5
013D0:  BTFSS  FD8.2
013D2:  GOTO   142A
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
013D6:  CLRF   03
013D8:  MOVLB  A
013DA:  MOVF   x76,W
013DC:  ADDLW  78
013DE:  MOVWF  FE9
013E0:  MOVLW  00
013E2:  ADDWFC 03,W
013E4:  MOVWF  FEA
013E6:  MOVF   FEF,W
013E8:  SUBLW  B5
013EA:  BTFSS  FD8.2
013EC:  GOTO   13FC
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
013F0:  MOVLB  1
013F2:  GOTO   1432
....................             } 
013F6:  GOTO   1426
013FA:  MOVLB  A
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
013FC:  MOVLW  01
013FE:  MOVLB  1
01400:  ADDWF  x40,W
01402:  MOVLB  A
01404:  MOVWF  x78
01406:  CLRF   19
01408:  BTFSC  FF2.7
0140A:  BSF    19.7
0140C:  BCF    FF2.7
0140E:  MOVWF  xAB
01410:  MOVLW  C8
01412:  MOVWF  xAC
01414:  MOVLB  0
01416:  CALL   01DE
0141A:  BTFSC  19.7
0141C:  BSF    FF2.7
0141E:  MOVFF  00,140
....................                 g_ui8ElementInQ--; 
01422:  MOVLB  1
01424:  DECF   x42,F
....................             } 
....................         } 
01426:  GOTO   142E
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
0142A:  GOTO   1674
....................         } 
0142E:  GOTO   138E
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
01432:  MOVLW  01
01434:  ADDWF  x40,W
01436:  MOVLB  A
01438:  MOVWF  x78
0143A:  CLRF   19
0143C:  BTFSC  FF2.7
0143E:  BSF    19.7
01440:  BCF    FF2.7
01442:  MOVWF  xAB
01444:  MOVLW  C8
01446:  MOVWF  xAC
01448:  MOVLB  0
0144A:  CALL   01DE
0144E:  BTFSC  19.7
01450:  BSF    FF2.7
01452:  MOVFF  00,140
....................     g_ui8ElementInQ--; 
01456:  MOVLB  1
01458:  DECF   x42,F
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
0145A:  MOVLB  A
0145C:  CLRF   x74
0145E:  MOVF   x74,W
01460:  SUBLW  0C
01462:  BTFSS  FD8.0
01464:  GOTO   14CC
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
01468:  CLRF   03
0146A:  MOVF   x74,W
0146C:  ADDLW  8F
0146E:  MOVWF  01
01470:  MOVLW  03
01472:  ADDWFC 03,F
01474:  MOVFF  03,A78
01478:  CLRF   03
0147A:  MOVLB  1
0147C:  MOVF   x40,W
0147E:  ADDLW  78
01480:  MOVWF  FE9
01482:  MOVLW  00
01484:  ADDWFC 03,W
01486:  MOVWF  FEA
01488:  MOVFF  FEF,A79
0148C:  MOVLB  A
0148E:  MOVFF  A78,FEA
01492:  MOVFF  01,FE9
01496:  MOVFF  A79,FEF
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
0149A:  MOVLW  01
0149C:  MOVLB  1
0149E:  ADDWF  x40,W
014A0:  MOVLB  A
014A2:  MOVWF  x78
014A4:  CLRF   19
014A6:  BTFSC  FF2.7
014A8:  BSF    19.7
014AA:  BCF    FF2.7
014AC:  MOVWF  xAB
014AE:  MOVLW  C8
014B0:  MOVWF  xAC
014B2:  MOVLB  0
014B4:  CALL   01DE
014B8:  BTFSC  19.7
014BA:  BSF    FF2.7
014BC:  MOVFF  00,140
....................         g_ui8ElementInQ--; 
014C0:  MOVLB  1
014C2:  DECF   x42,F
014C4:  MOVLB  A
014C6:  INCF   x74,F
014C8:  GOTO   145E
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
014CC:  MOVLB  1
014CE:  MOVF   x42,F
014D0:  BTFSC  FD8.2
014D2:  GOTO   151E
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
014D6:  CLRF   03
014D8:  MOVF   x40,W
014DA:  ADDLW  78
014DC:  MOVWF  FE9
014DE:  MOVLW  00
014E0:  ADDWFC 03,W
014E2:  MOVWF  FEA
014E4:  MOVF   FEF,W
014E6:  SUBLW  A5
014E8:  BTFSS  FD8.2
014EA:  GOTO   14F2
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
014EE:  GOTO   151E
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
014F2:  MOVLW  01
014F4:  ADDWF  x40,W
014F6:  MOVLB  A
014F8:  MOVWF  x78
014FA:  CLRF   19
014FC:  BTFSC  FF2.7
014FE:  BSF    19.7
01500:  BCF    FF2.7
01502:  MOVWF  xAB
01504:  MOVLW  C8
01506:  MOVWF  xAC
01508:  MOVLB  0
0150A:  CALL   01DE
0150E:  BTFSC  19.7
01510:  BSF    FF2.7
01512:  MOVFF  00,140
....................         g_ui8ElementInQ--; 
01516:  MOVLB  1
01518:  DECF   x42,F
0151A:  GOTO   14CE
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
0151E:  MOVLW  01
01520:  ADDWF  x41,W
01522:  MOVLB  A
01524:  MOVWF  x78
01526:  CLRF   19
01528:  BTFSC  FF2.7
0152A:  BSF    19.7
0152C:  BCF    FF2.7
0152E:  MOVWF  xAB
01530:  MOVLW  C8
01532:  MOVWF  xAC
01534:  MOVLB  0
01536:  CALL   01DE
0153A:  BTFSC  19.7
0153C:  BSF    FF2.7
0153E:  MOVFF  00,A75
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
01542:  MOVLB  A
01544:  MOVF   x75,W
01546:  MOVLB  1
01548:  SUBWF  x40,W
0154A:  BTFSS  FD8.2
0154C:  GOTO   1556
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
01550:  SETF   x41
01552:  MOVFF  141,140
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
01556:  MOVLB  3
01558:  MOVF   x90,W
0155A:  SUBLW  2C
0155C:  BTFSS  FD8.2
0155E:  GOTO   1574
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
01562:  MOVFF  38F,A77
01566:  MOVLB  0
01568:  GOTO   10D4
....................         return; 
0156C:  MOVLB  1
0156E:  GOTO   1674
01572:  MOVLB  3
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
01574:  MOVF   x90,W
01576:  SUBLW  21
01578:  BTFSS  FD8.2
0157A:  GOTO   1672
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
0157E:  MOVLW  03
01580:  MOVLB  A
01582:  MOVWF  x78
01584:  MOVLW  8F
01586:  MOVWF  x77
01588:  MOVLW  0B
0158A:  MOVWF  x79
0158C:  MOVLB  0
0158E:  CALL   0E7E
01592:  MOVFF  02,3AB
01596:  MOVFF  01,3AA
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
0159A:  MOVFF  3AB,A77
0159E:  MOVLB  A
015A0:  CLRF   x78
015A2:  MOVLB  3
015A4:  MOVF   x9B,W
015A6:  MOVLB  A
015A8:  SUBWF  x77,W
015AA:  BTFSS  FD8.2
015AC:  GOTO   166C
015B0:  MOVF   x78,F
015B2:  BTFSS  FD8.2
015B4:  GOTO   166C
015B8:  MOVFF  3AB,A78
015BC:  MOVFF  3AA,A77
015C0:  CLRF   x78
015C2:  MOVLB  3
015C4:  MOVF   x9A,W
015C6:  MOVLB  A
015C8:  SUBWF  x77,W
015CA:  BTFSS  FD8.2
015CC:  GOTO   166C
015D0:  MOVF   x78,F
015D2:  BTFSS  FD8.2
015D4:  GOTO   166C
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
015D8:  MOVFF  391,15E
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
015DC:  MOVFF  392,15F
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
015E0:  MOVFF  393,160
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
015E4:  MOVFF  394,161
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
015E8:  MOVFF  395,162
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
015EC:  MOVFF  396,163
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
015F0:  MOVFF  397,164
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
015F4:  MOVFF  398,165
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
015F8:  MOVFF  399,166
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
015FC:  MOVLW  02
015FE:  MOVWF  x98
01600:  MOVLW  C4
01602:  MOVWF  x97
01604:  MOVLW  01
01606:  MOVWF  x9A
01608:  MOVLW  5C
0160A:  MOVWF  x99
0160C:  MOVLB  0
0160E:  CALL   1114
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
01612:  MOVLW  2C
01614:  MOVLB  3
01616:  MOVWF  x90
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
01618:  MOVLW  A5
0161A:  MOVLB  0
0161C:  CALL   0F34
....................             fputc(STX, UART); 
01620:  MOVLW  A5
01622:  CALL   0F34
....................             fputc(STX, UART); 
01626:  MOVLW  A5
01628:  CALL   0F34
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
0162C:  MOVLB  A
0162E:  CLRF   x74
01630:  MOVF   x74,W
01632:  SUBLW  0C
01634:  BTFSS  FD8.0
01636:  GOTO   165C
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
0163A:  CLRF   03
0163C:  MOVF   x74,W
0163E:  ADDLW  8F
01640:  MOVWF  FE9
01642:  MOVLW  03
01644:  ADDWFC 03,W
01646:  MOVWF  FEA
01648:  MOVFF  FEF,A77
0164C:  MOVF   x77,W
0164E:  MOVLB  0
01650:  CALL   0F34
01654:  MOVLB  A
01656:  INCF   x74,F
01658:  GOTO   1630
....................             } 
....................             fputc(ETX, UART); 
0165C:  MOVLW  B5
0165E:  MOVLB  0
01660:  CALL   0F34
....................             fputc(ETX, UART); 
01664:  MOVLW  B5
01666:  CALL   0F34
0166A:  MOVLB  A
....................         } 
....................     } 
0166C:  GOTO   1670
01670:  MOVLB  3
01672:  MOVLB  1
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
01674:  MOVLB  0
01676:  GOTO   306A (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
*
00232:  MOVLB  0
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
00234:  MOVLB  1
00236:  MOVF   x40,W
00238:  SUBLW  FF
0023A:  BTFSS  FD8.2
0023C:  GOTO   0242
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
00240:  CLRF   x40
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
00242:  MOVLW  01
00244:  ADDWF  x41,W
00246:  MOVLB  A
00248:  MOVWF  xAA
0024A:  MOVWF  xAB
0024C:  MOVLW  C8
0024E:  MOVWF  xAC
00250:  MOVLB  0
00252:  CALL   01DE
00256:  MOVFF  00,141
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
0025A:  CLRF   03
0025C:  MOVLB  1
0025E:  MOVF   x41,W
00260:  ADDLW  78
00262:  MOVWF  FE9
00264:  MOVLW  00
00266:  ADDWFC 03,W
00268:  MOVWF  FEA
0026A:  MOVFF  FEA,AAC
0026E:  MOVFF  FE9,AAB
00272:  MOVLB  0
00274:  GOTO   0212
00278:  MOVFF  AAC,FEA
0027C:  MOVFF  AAB,FE9
00280:  MOVFF  01,FEF
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
00284:  MOVF   F98,W
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
.................... #include "../Common/vmADS1232.h" 
.................... /*  
....................  * File:   vmADS1232.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on October 10, 2019, 12:50 PM 
....................  */ 
....................  
.................... #ifndef VM_ADS1232_H 
.................... #define	VM_ADS1232_H 
....................  
.................... #define ADS1232_ADC_BITS                    19 
00286:  MOVLB  E
00288:  BCF    x36.5
0028A:  MOVLB  0
0028C:  GOTO   0128
.................... #define ADS1232_ADC_EXCLUSION_BITS          3 
....................  
.................... //unsigned int32 read_adc(void) 
.................... //{ 
.................... //    unsigned int32 dataa  = 0; 
.................... //    unsigned int8 i       = 0; 
.................... //     
.................... //    // Delay required as per ADC1232 data-sheet; after data ready pin goes down 
.................... //    // data is ready but after a certain time i.e. data uploading time which is  
.................... //    // 39us minimum when read-back is not allowed.[Page No. 18] 
.................... //    delay_us(50); 
.................... //     
.................... //    // Retrieve data from DOUT/DRDY pin over SPI.  
.................... //    // Here 24-bit ADC is used. But we retrieve 20-bit as it gives upto 19.2  
.................... //    // resolution. 
.................... //    for(i = 0; i<20; i++) 
.................... //    {          
.................... //        output_high(PIN_ADC_SCLK); 
.................... //        delay_us(1); 
.................... //        shift_left(&dataa,3,input_state(PIN_ADC_DOUT_DRDY)); 
.................... //        output_low(PIN_ADC_SCLK); 
.................... //        delay_us(1); 
.................... //    } 
.................... //     
.................... //   // Apply last clock pulse to make DOUT PIN high i.e.data retrieve done. 
.................... //   delay_us(1); 
.................... //   output_high(PIN_ADC_SCLK); 
.................... //   delay_us(1); 
.................... //   output_low(PIN_ADC_SCLK);     
.................... //     
.................... //   return dataa; 
.................... //} 
....................  
.................... unsigned int32 read(void) 
*
01CF8:  MOVLB  A
01CFA:  CLRF   x76
01CFC:  CLRF   x75
01CFE:  CLRF   x74
01D00:  CLRF   x73
01D02:  CLRF   x77
.................... { 
....................     unsigned int32 RawADC  = 0;  
....................     unsigned int8 i       = 0; 
....................  
....................     // Delay required as per ADC1232 data-sheet; after data ready pin goes down 
....................     // data is ready but after a certain time i.e. data uploading time which is  
....................     // 39us minimum when read-back is not allowed.[Page No. 18] 
....................     delay_us(50); 
01D04:  CLRWDT
01D06:  MOVLW  52
01D08:  MOVWF  00
01D0A:  DECFSZ 00,F
01D0C:  BRA    1D0A
01D0E:  BRA    1D10
....................      
....................     // Retrieve data from DOUT/DRDY pin over SPI.  
....................     // Here 24-bit ADC is used. But we retrieve 24-bit as it gives upto 19.2  
....................     // resolution. 
....................      
.................... //    // Option 1: Taking all 24-bits for high resolution. 
....................     for(i = 0; i<24; i++) 
01D10:  CLRF   x77
01D12:  MOVF   x77,W
01D14:  SUBLW  17
01D16:  BTFSS  FD8.0
01D18:  GOTO   1D4C
....................     { 
....................  
....................         output_high(PIN_ADC_SCLK); 
01D1C:  BCF    F84.6
01D1E:  BSF    F7C.6
....................         delay_us(1); 
01D20:  CLRWDT
01D22:  BRA    1D24
01D24:  BRA    1D26
....................         shift_left(&RawADC,3,input(PIN_ADC_DOUT_DRDY)); 
01D26:  BSF    F84.5
01D28:  BTFSC  F8C.5
01D2A:  GOTO   1D34
01D2E:  BCF    FD8.0
01D30:  GOTO   1D36
01D34:  BSF    FD8.0
01D36:  RLCF   x73,F
01D38:  RLCF   x74,F
01D3A:  RLCF   x75,F
....................         output_low(PIN_ADC_SCLK); 
01D3C:  BCF    F84.6
01D3E:  BCF    F7C.6
....................         delay_us(1); 
01D40:  CLRWDT
01D42:  BRA    1D44
01D44:  BRA    1D46
01D46:  INCF   x77,F
01D48:  GOTO   1D12
....................     }  
....................      
....................     // TESTING. 
....................     // To reduce the noise-full or erroneous bits. 
....................     RawADC = (RawADC & 0xFFFFFFF0); 
01D4C:  MOVLW  F0
01D4E:  ANDWF  x73,F
....................     //RawADC >>= 4; 
....................      
....................     // Option 2: Taking 21-bits to minimize data-size overhead by discarding  
....................     //           3-bits from MSB of ADC output. 
.................... //    for(i = 0; i<24; i++) 
.................... //    { 
.................... //        // Unacceptable. 
.................... //        if(i < ADS1232_ADC_EXCLUSION_BITS) 
.................... //        { 
.................... //            output_high(PIN_ADC_SCLK); 
.................... //            delay_us(1);   
.................... //            output_low(PIN_ADC_SCLK); 
.................... //            delay_us(1);             
.................... //        } 
.................... //         
.................... //        // Acceptable. 
.................... //        else 
.................... //        { 
.................... //            output_high(PIN_ADC_SCLK); 
.................... //            delay_us(1); 
.................... //            shift_left(&RawADC,3,input(PIN_ADC_DOUT_DRDY)); 
.................... //            output_low(PIN_ADC_SCLK); 
.................... //            delay_us(1);             
.................... //        } 
.................... //         
.................... //    } 
....................      
....................     // Apply additional clock pulse to make DOUT/DRDY PIN high i.e.data retrieve done. 
....................     delay_us(1); 
01D50:  CLRWDT
01D52:  BRA    1D54
01D54:  BRA    1D56
....................     output_high(PIN_ADC_SCLK); 
01D56:  BCF    F84.6
01D58:  BSF    F7C.6
....................     delay_us(1); 
01D5A:  CLRWDT
01D5C:  BRA    1D5E
01D5E:  BRA    1D60
....................     output_low(PIN_ADC_SCLK);     
01D60:  BCF    F84.6
01D62:  BCF    F7C.6
....................       
....................     return RawADC; 
01D64:  MOVFF  A73,00
01D68:  MOVFF  A74,01
01D6C:  MOVFF  A75,02
01D70:  MOVFF  A76,03
01D74:  MOVLB  0
01D76:  GOTO   3094 (RETURN)
.................... } 
....................  
....................  
.................... #endif	/* VM_ADS1232_H */ 
....................  
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
*
01766:  MOVLB  A
01768:  CLRF   x8D
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
0176A:  MOVFF  A8C,A8D
....................     write_eeprom(uiAddress,uiTemp); 
0176E:  MOVF   FF2,W
01770:  MOVWF  00
01772:  BCF    FF2.7
01774:  MOVFF  A8A,F75
01778:  MOVFF  A89,F74
0177C:  MOVFF  A8D,F76
01780:  BCF    F77.6
01782:  BCF    F77.7
01784:  BSF    F77.2
01786:  MOVLB  F
01788:  MOVLW  55
0178A:  MOVWF  F78
0178C:  MOVLW  AA
0178E:  MOVWF  F78
01790:  BSF    F77.1
01792:  BTFSC  F77.1
01794:  GOTO   1792
01798:  BCF    F77.2
0179A:  BCF    F77.6
0179C:  BSF    F77.7
0179E:  MOVF   00,W
017A0:  IORWF  FF2,F
....................     // Increment write address. 
....................     uiAddress++; 
017A2:  MOVLB  A
017A4:  INCF   x89,F
017A6:  BTFSC  FD8.2
017A8:  INCF   x8A,F
....................     // Write second byte. 
....................     uiTemp = 0; 
017AA:  CLRF   x8D
....................     uiTemp = uiValue & 0x00FF; 
017AC:  MOVFF  A8B,A8D
....................     write_eeprom(uiAddress,uiTemp); 
017B0:  MOVF   FF2,W
017B2:  MOVWF  00
017B4:  BCF    FF2.7
017B6:  MOVFF  A8A,F75
017BA:  MOVFF  A89,F74
017BE:  MOVFF  A8D,F76
017C2:  BCF    F77.6
017C4:  BCF    F77.7
017C6:  BSF    F77.2
017C8:  MOVLB  F
017CA:  MOVLW  55
017CC:  MOVWF  F78
017CE:  MOVLW  AA
017D0:  MOVWF  F78
017D2:  BSF    F77.1
017D4:  BTFSC  F77.1
017D6:  GOTO   17D4
017DA:  BCF    F77.2
017DC:  BCF    F77.6
017DE:  BSF    F77.7
017E0:  MOVF   00,W
017E2:  IORWF  FF2,F
017E4:  MOVLB  0
017E6:  RETURN 0
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
....................  
....................     return uiValue; 
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
*
00644:  MOVLB  A
00646:  CLRF   x7F
00648:  CLRF   x7E
0064A:  CLRF   x81
0064C:  CLRF   x80
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
0064E:  MOVFF  FF2,A82
00652:  BCF    FF2.7
00654:  MOVFF  A7D,F75
00658:  MOVFF  A7C,F74
0065C:  BCF    F77.6
0065E:  BCF    F77.7
00660:  BSF    F77.0
00662:  MOVF   F76,W
00664:  BCF    F77.6
00666:  BSF    F77.7
00668:  BTFSC  x82.7
0066A:  BSF    FF2.7
0066C:  CLRF   x81
0066E:  MOVWF  x80
....................     uiValue = uiTemp << 8; 
00670:  MOVFF  A80,A7F
00674:  CLRF   x7E
....................     // Increment read address. 
....................     uiAddress++; 
00676:  INCF   x7C,F
00678:  BTFSC  FD8.2
0067A:  INCF   x7D,F
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
0067C:  MOVFF  FF2,A82
00680:  BCF    FF2.7
00682:  MOVFF  A7D,F75
00686:  MOVFF  A7C,F74
0068A:  BCF    F77.6
0068C:  BCF    F77.7
0068E:  BSF    F77.0
00690:  MOVF   F76,W
00692:  BCF    F77.6
00694:  BSF    F77.7
00696:  BTFSC  x82.7
00698:  BSF    FF2.7
0069A:  CLRF   x81
0069C:  MOVWF  x80
....................     uiValue = uiValue | uiTemp; 
0069E:  MOVF   x80,W
006A0:  IORWF  x7E,F
006A2:  MOVF   x81,W
006A4:  IORWF  x7F,F
....................  
....................     return uiValue; 
006A6:  MOVFF  A7E,01
006AA:  MOVFF  A7F,02
006AE:  MOVLB  0
006B0:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmStateMachine.h" 
.................... #ifndef _VI_STATE_MACHINE_H_ 
.................... #define _VI_STATE_MACHINE_H_ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... #ifndef _VM_DIGITAL_IO_CONFIG_H_ 
.................... #define _VM_DIGITAL_IO_CONFIG_H_ 
....................  
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
.................... typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8       m_bArr[4]; 
....................     unsigned int32      m_ui32AllDIs; 
....................     ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8       m_bArr[2]; 
....................     unsigned int16      m_ui16AllDOs; 
....................     ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8              m_bArr[2]; 
....................     unsigned int16             m_ui16AllCounters; 
....................     ST_ALL_COUNTER_STATE_BIT   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Digital Input Output *************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
.................... UN_ALL_DIS      g_unDIState; 
.................... UN_ALL_DOS      g_unDOState; 
.................... UN_ALL_COUNTERS g_unAllCounters; 
.................... UN_ALL_DIS      g_unDIStateFilter; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
....................  
.................... #endif /* _VI_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... //typedef struct _ST_ALL_DI_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDICn15: 1; 
.................... //    unsigned int8 m_ui1HWDICn14: 1; 
.................... //    unsigned int8 m_ui1HWDICn13: 1; 
.................... //    unsigned int8 m_ui1HWDICn12: 1; 
.................... //    unsigned int8 m_ui1HWDICn11: 1; 
.................... //    unsigned int8 m_ui1HWDICn10: 1; 
.................... //    unsigned int8 m_ui1HWDICn09: 1; 
.................... //    unsigned int8 m_ui1HWDICn08: 1; 
.................... // 
.................... //    unsigned int8 m_ui1HWDICn07: 1; 
.................... //    unsigned int8 m_ui1HWDICn06: 1; 
.................... //    unsigned int8 m_ui1HWDICn05: 1; 
.................... //    unsigned int8 m_ui1HWDICn04: 1; 
.................... //    unsigned int8 m_ui1HWDICn03: 1; 
.................... //    unsigned int8 m_ui1HWDICn02: 1; 
.................... //    unsigned int8 m_ui1HWDICn01: 1; 
.................... //    unsigned int8 m_ui1HWDICn00: 1; 
.................... //}ST_ALL_DI_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DIS 
.................... //{ 
.................... //	unsigned int8       m_bArr[2]; 
.................... //    unsigned int16      m_ui16AllDIs; 
.................... //    ST_ALL_DI_STATE_BIT m_stAllDIBits; 
.................... //} UN_ALL_DIS; 
.................... // 
.................... //typedef struct _ST_ALL_DO_STATE_BIT 
.................... //{ 
.................... //    unsigned int8 m_ui1HWDOCn07: 1; 
.................... //    unsigned int8 m_ui1HWDOCn06: 1; 
.................... //    unsigned int8 m_ui1HWDOCn05: 1; 
.................... //    unsigned int8 m_ui1HWDOCn04: 1; 
.................... //    unsigned int8 m_ui1HWDOCn03: 1; 
.................... //    unsigned int8 m_ui1HWDOCn02: 1; 
.................... //    unsigned int8 m_ui1HWDOCn01: 1; 
.................... //    unsigned int8 m_ui1HWDOCn00: 1; 
.................... // 
.................... //}ST_ALL_DO_STATE_BIT; 
.................... // 
.................... //typedef union _UN_ALL_DOS 
.................... //{ 
.................... //    unsigned int8     m_ui8AllDOs; 
.................... //    ST_ALL_DO_STATE_BIT m_stAllDOBits; 
.................... //} UN_ALL_DOS; 
.................... // 
.................... ////***************************************************************************** 
.................... //// Above -> Data Structure for Digital Input Output *************************** 
.................... ////***************************************************************************** 
.................... // 
.................... // 
.................... ////***************************************************************************** 
.................... //// Below -> Global Variable Declaration *************************************** 
.................... ////***************************************************************************** 
.................... //UN_ALL_DIS      g_unDICurrState; 
.................... //UN_ALL_DOS      g_unDOCurrState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIPrevState; 
.................... //UN_ALL_DOS      g_unDOPrevState; 
.................... // 
.................... //UN_ALL_DIS      g_unDIStateFilter; 
.................... ////***************************************************************************** 
.................... //// Above -> Global Variable Declaration *************************************** 
.................... ////*****************************************************************************  
....................  
.................... //#endif /* _VM_DIGITAL_IO_CONFIG_H_ */ 
....................  
.................... /*************************** Inclusion files **********************************/ 
....................  
.................... #define FLAG_STATE_CHANGED           1 
.................... #define FLAG_STATE_NOT_CHANGED       0 
.................... #define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... #define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... #define MAX_NUMBER_OF_STATE          10 
.................... #define MAX_NO_OF_EXP_NXT_STATES     4 
....................  
.................... #define STATE_MACHINE_0              0 
.................... #define STATE_MACHINE_1              1 
.................... #define STATE_MACHINE_2              2 
.................... #define STATE_MACHINE_3              3 
.................... #define STATE_MACHINE_4              4 
....................  
.................... //#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... //#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... //#define COUNTER_SUCTION_WAIT         300 
....................  
.................... // Return codes 
.................... #define VI_RETN_SUCCESS               0 
....................  
.................... #define STATE_NOTHING 0 
.................... #define STATE_01 1 
.................... #define STATE_02 2 
.................... #define STATE_03 3 
.................... #define STATE_04 4 
.................... #define STATE_05 5 
.................... #define STATE_06 6 
.................... #define STATE_07 7 
.................... #define STATE_08 8 
.................... #define STATE_09 9 
.................... #define STATE_10 10 
.................... #define STATE_11 11 
.................... #define STATE_12 12 
.................... #define STATE_13 13 
.................... #define STATE_14 14 
.................... #define STATE_15 15 
.................... #define STATE_16 16 
.................... #define STATE_17 17 
.................... #define STATE_18 18 
.................... #define STATE_19 19 
....................  
.................... #define STATE_CONTINUE_OFF 0 
.................... #define STATE_CONTINUE_ON  1 
....................  
.................... /*typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
....................  
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef ST_ALL_DI_STATE_BIT ST_ALL_DIS; 
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8      m_bArr[4]; 
....................     unsigned int32     m_ui32AllDIs; 
....................     ST_ALL_DIS         m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef ST_ALL_DO_STATE_BIT ST_ALL_DOS; 
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllDOs; 
....................     ST_ALL_DOS        m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef ST_ALL_COUNTER_STATE_BIT ST_ALL_COUNTERS; 
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllCounters; 
....................     ST_ALL_COUNTERS   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
.................... */ 
....................  
.................... int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
....................  
....................  
....................  
.................... typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... { 
....................     int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... } ST_STATE_INDEX_TABLE_NODE; 
....................  
....................  
.................... typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
....................  
.................... typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... { 
....................     int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
....................     int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
....................     PTR_STATE_FUNCTION pFunStateFunction; 
....................      
.................... } ST_STATE_LOOKUP_TABLE_NODE; 
....................  
....................  
.................... typedef struct _ST_STATE_MACHINE 
.................... { 
....................     unsigned int32               m_ui32StateDIFilter; 
....................     unsigned int16               m_ui16StateDOFilter; 
....................     unsigned int16               m_uiStateCounterFilter; 
....................     ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
....................     ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
....................     // Temporary Values 
....................     unsigned int32               m_ui32LastDIState; 
....................     unsigned int16               m_ui16LastDOState; 
....................  
....................     //int8                       m_iExpNxtStates; 
....................     int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
....................     int8                         m_i8PrevState; 
....................     int8                         m_fContinue; 
.................... } ST_STATE_MACHINE; 
....................  
....................  
.................... //================= All Variable Declarations Start ==========================// 
.................... //UN_ALL_DIS      g_unAllDIs; 
.................... //UN_ALL_DOS      g_unDOState; 
.................... //UN_ALL_COUNTERS g_unAllCounters; 
....................  
.................... unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
....................  
.................... unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fSuctionWait = 0;  
.................... unsigned int16 g_ui16TimerCount = 0;  
.................... //================= All Variable Declarations End ============================// 
....................  
.................... // Timer Function for DI Polling 
.................... /*void PollingInterrupt() 
.................... { 
....................     // Step 1 : Poll all DIs 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
....................     unsigned int8 ui8Test =  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
....................  
....................     // Step 2: Check for any state change 
....................     // Check ALL DI States Changes and all DO State Changes 
....................     if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
....................         g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
....................     { 
....................         g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
....................     } 
....................     else 
....................     { 
....................         g_uiStateChange = FLAG_STATE_CHANGED; 
....................         g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
....................         g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
....................     } 
....................  
....................  
....................     if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
....................     { 
....................         g_ui16TimerCount++; 
....................     } 
....................  
.................... }*/ 
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
....................     delay_us(10); 
....................     //output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
....................     //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
....................     //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
....................     //output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
....................     //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
....................     //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................      
.................... int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... { 
....................     int8 iStateIdx = 1; 
....................     // Check for all the states and find suitable state 
....................     for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
....................     { 
....................          
....................     }     
....................     return 0; 
.................... } 
....................  
....................  
.................... int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... { 
....................     unsigned int32 ui32DIState   = 0; 
....................     unsigned int16 ui16DOState   = 0; 
....................     int8           i8ExpNxtState = 0; 
....................     int8           i8TempState   = 0; 
....................     ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
....................     unsigned int8 ui8ExpNextState = 0; 
....................      
....................     // Step 1: Apply DI and DO Filter 
....................     ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
....................     //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
....................     
....................     // Step 2: Check with DO State Filter 
....................     // If Any change not found then Return 
....................     if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
....................     { 
....................         // No Change 
....................         // So Return 0 
....................         return 0; 
....................     } 
....................     // Step 3: IF Change found then do the following: 
....................     //     a. Update last state value 
....................     //     b. Check if the State is matching with the expected next state 
....................     //     c. If YES then call State function 
....................     //     d. If the State is not matching then perform Error Handling 
....................      
....................     // Stape 3a: Update last state value 
....................     //pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................  
....................     // Step 3b: Check if the State is matching with the expected next states 
....................     for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
....................     {        
....................         //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
....................         //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
....................         //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
....................         ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
....................         if (ui8ExpNextState == STATE_NOTHING) 
....................         { 
....................             // No State Matched, this is an Error 
....................             // Handle Error 
....................             return HandleStateError(pstStateMachine); 
....................         }     
....................          
....................         if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
....................         {    
....................             // State Is matching 
....................             // Call State Function 
....................             pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
....................              
....................             pstStateMachine->m_i8PrevState = ui8ExpNextState; 
....................              
....................             //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
....................             //{ 
....................             //    output_bit(PIN_OUT_DO_07, 0); 
....................             //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
....................             //}     
....................             // Stape 3a: Update last state value 
....................             pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................              
....................             break; 
....................              
....................         } 
....................         else 
....................         { 
....................             // Next State is not matching 
....................             // ERROR 
....................         } 
....................     } 
....................  
....................  
....................     // If Expected State does not match 
....................     if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
....................     { 
....................         // Handle Error 
....................         return HandleStateError(pstStateMachine); 
....................     } 
....................  
....................     return VI_RETN_SUCCESS; 
.................... } 
....................  
.................... void InitilizeStates() 
.................... { 
....................     g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... } 
....................      
....................  
.................... #endif /* _VI_STATE_MACHINE_H_ */ 
....................  
....................  
....................  
....................  
.................... //#ifndef _VM_STATE_MACHINE_H_ 
.................... //#define _VM_STATE_MACHINE_H_ 
.................... // 
.................... //#include "vmDigitalIOConfig.h" 
.................... ///*************************** Inclusion files **********************************/ 
.................... // 
.................... //#define FLAG_STATE_CHANGED           1 
.................... //#define FLAG_STATE_NOT_CHANGED       0 
.................... //#define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... //#define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... //#define MAX_NUMBER_OF_STATE          8 
.................... //#define MAX_NO_OF_EXP_NXT_STATES     4 
.................... // 
.................... //#define STATE_MACHINE_0   0 
.................... //#define STATE_MACHINE_1   1 
.................... //#define STATE_MACHINE_2   2 
.................... //#define STATE_MACHINE_3   3 
.................... //#define STATE_MACHINE_4   4 
.................... // 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... ////#define COUNTER_SUCTION_WAIT         300 
.................... // 
.................... //// Return codes 
.................... //#define VI_RETN_SUCCESS               0 
.................... // 
.................... //#define STATE_NOTHING 0 
.................... //#define STATE_01 1 
.................... //#define STATE_02 2 
.................... //#define STATE_03 3 
.................... //#define STATE_04 4 
.................... //#define STATE_05 5 
.................... //#define STATE_06 6 
.................... //#define STATE_07 7 
.................... //#define STATE_08 8 
.................... //#define STATE_09 9 
.................... //#define STATE_10 10 
.................... //#define STATE_11 11 
.................... //#define STATE_12 12 
.................... //#define STATE_13 13 
.................... //#define STATE_14 14 
.................... //#define STATE_15 15 
.................... //#define STATE_16 16 
.................... //#define STATE_17 17 
.................... //#define STATE_18 18 
.................... //#define STATE_19 19 
.................... // 
.................... //#define STATE_CONTINUE_OFF 0 
.................... //#define STATE_CONTINUE_ON  1 
.................... // 
.................... // 
.................... //int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
.................... // 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... //{ 
.................... //    int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //} ST_STATE_INDEX_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... ////typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
.................... // 
.................... //typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... //{ 
.................... //    int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //    int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
.................... //    PTR_STATE_FUNCTION pFunStateFunction; 
.................... //     
.................... //} ST_STATE_LOOKUP_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_MACHINE 
.................... //{ 
.................... //    unsigned int32               m_ui32StateDIFilter; 
.................... //    unsigned int16               m_ui16StateDOFilter; 
.................... //    unsigned int16               m_uiStateCounterFilter; 
.................... //    ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
.................... //    // Temporary Values 
.................... //    unsigned int32               m_ui32LastDIState; 
.................... //    unsigned int16               m_ui16LastDOState; 
.................... // 
.................... //    //int8                       m_iExpNxtStates; 
.................... //    int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
.................... //    int8                         m_i8PrevState; 
.................... //    int8                         m_fContinue; 
.................... //} ST_STATE_MACHINE; 
.................... // 
.................... // 
.................... ////================= All Variable Declarations Start ==========================// 
.................... ////UN_ALL_DIS      g_unAllDIs; 
.................... ////UN_ALL_DOS      g_unDOState; 
.................... ////UN_ALL_COUNTERS g_unAllCounters; 
.................... // 
.................... //unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
.................... // 
.................... //unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //unsigned int8  g_fSuctionWait = 0;  
.................... //unsigned int16 g_ui16TimerCount = 0;  
.................... ////================= All Variable Declarations End ============================// 
.................... // 
.................... //// Timer Function for DI Polling 
.................... ///*void PollingInterrupt() 
.................... //{ 
.................... //    // Step 1 : Poll all DIs 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
.................... //    unsigned int8 ui8Test =  
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
.................... // 
.................... //    // Step 2: Check for any state change 
.................... //    // Check ALL DI States Changes and all DO State Changes 
.................... //    if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
.................... //        g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_CHANGED; 
.................... //        g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
.................... //        g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
.................... //    } 
.................... // 
.................... // 
.................... //    if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
.................... //    { 
.................... //        g_ui16TimerCount++; 
.................... //    } 
.................... // 
.................... //}*/ 
.................... // 
.................... //void ExecuteALLDOs(void) 
.................... //{ 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
.................... //    output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
.................... //    output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
.................... //    output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... //} 
.................... //     
.................... //int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... //{ 
.................... //    int8 iStateIdx = 1; 
.................... //    // Check for all the states and find suitable state 
.................... //    for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
.................... //    { 
.................... //         
.................... //    }     
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... //{ 
.................... //    unsigned int32 ui32DIState   = 0; 
.................... //    unsigned int16 ui16DOState   = 0; 
.................... //    int8           i8ExpNxtState = 0; 
.................... //    int8           i8TempState   = 0; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
.................... //    unsigned int8 ui8ExpNextState = 0; 
.................... //     
.................... //    // Step 1: Apply DI and DO Filter 
.................... //    //ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
.................... //    //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
.................... //    
.................... //    // Step 2: Check with DO State Filter 
.................... //    // If Any change not found then Return 
.................... //    if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
.................... //    { 
.................... //        // No Change 
.................... //        // So Return 0 
.................... //        return 0; 
.................... //    } 
.................... //    // Step 3: IF Change found then do the following: 
.................... //    //     a. Update last state value 
.................... //    //     b. Check if the State is matching with the expected next state 
.................... //    //     c. If YES then call State function 
.................... //    //     d. If the State is not matching then perform Error Handling 
.................... //     
.................... //    // Stape 3a: Update last state value 
.................... //    //pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... // 
.................... //    // Step 3b: Check if the State is matching with the expected next states 
.................... //    for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
.................... //    {        
.................... //        //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
.................... //        //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
.................... //        //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
.................... //        ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
.................... //        if (ui8ExpNextState == STATE_NOTHING) 
.................... //        { 
.................... //            // No State Matched, this is an Error 
.................... //            // Handle Error 
.................... //            return HandleStateError(pstStateMachine); 
.................... //        }     
.................... //         
.................... //        if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
.................... //        {    
.................... //            // State Is matching 
.................... //            // Call State Function 
.................... //            pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
.................... //             
.................... //            pstStateMachine->m_i8PrevState = ui8ExpNextState; 
.................... //             
.................... //            //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
.................... //            //{ 
.................... //            //    output_bit(PIN_OUT_DO_07, 0); 
.................... //            //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
.................... //            //}     
.................... //            // Stape 3a: Update last state value 
.................... //            pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... //             
.................... //            break; 
.................... //             
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            // Next State is not matching 
.................... //            // ERROR 
.................... //        } 
.................... //    } 
.................... // 
.................... // 
.................... //    // If Expected State does not match 
.................... //    if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
.................... //    { 
.................... //        // Handle Error 
.................... //        return HandleStateError(pstStateMachine); 
.................... //    } 
.................... // 
.................... //    return VI_RETN_SUCCESS; 
.................... //} 
.................... // 
.................... //void InitilizeStates() 
.................... //{ 
.................... //   // g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... //     
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_H_ */ 
.................... // 
.................... // 
....................  
....................  
.................... #include "vmTimerConfig.h" 
....................  
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... //#include "18F46K80.h" 
.................... #include "18F66k40.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
.................... //******** Serial Interface ************ 
.................... ////#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... //#pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ********** Serial Interface ************************************** 
....................  
.................... // ################ Using UART2 -> Configure for Camera ######################## 
.................... #PIN_SELECT U4RX=PIN_C1 
.................... #PIN_SELECT U4TX=PIN_C0 
.................... #use rs232(baud=9600,UART4,stream=CAMERA,ERRORS) 
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
....................  
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmStateMachineForIMW_M0.h" 
.................... #ifndef _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
.................... #define _VM_STATE_MACHINE_FOR_IMW_M0_H_ 
....................  
.................... #include "vmSystemConfig.h" 
....................  
.................... #ifndef _VI_SYSTEM_CONFIG_H_ 
.................... #define _VI_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... //#include "18F46K80.h" 
.................... #include "18F66k40.h" 
.................... #include "vmPINConfig.h" 
....................  
.................... //****************** Component Configuration ******************** 
....................  
.................... //optimization level. 
.................... #pragma opt 8 
....................   
.................... //********* CPU Settings ******************************************* 
....................  
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
....................  
.................... //******** Serial Interface ************ 
.................... ////#pragma use rs232(stream=RS485, xmit=PIN_RS485_XMIT, rcv=PIN_RS485_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
.................... //#pragma use rs232(stream=ARD_RS232, xmit=PIN_LAN_COMM_XMIT, rcv=PIN_LAN_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ********** Serial Interface ************************************** 
....................  
.................... // ################ Using UART2 -> Configure for Camera ######################## 
.................... #PIN_SELECT U4RX=PIN_C1 
.................... #PIN_SELECT U4TX=PIN_C0 
.................... #use rs232(baud=9600,UART4,stream=CAMERA,ERRORS) 
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
....................  
....................  
.................... //#define unsigned int8 BYTE 
.................... #ifndef M0_ADC_MODULE 
.................... #define M0_ADC_MODULE 1 
.................... #endif 
....................  
.................... #endif /* _VI_SYSTEM_CONFIG_H_ */ 
....................  
.................... //#include "vmStateMachine.h" 
.................... #include "../Common/vmStateMachine.h" 
.................... #ifndef _VI_STATE_MACHINE_H_ 
.................... #define _VI_STATE_MACHINE_H_ 
....................  
.................... #include "vmDigitalIOConfig.h" 
.................... /*************************** Inclusion files **********************************/ 
....................  
.................... #define FLAG_STATE_CHANGED           1 
.................... #define FLAG_STATE_NOT_CHANGED       0 
.................... #define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... #define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... #define MAX_NUMBER_OF_STATE          10 
.................... #define MAX_NO_OF_EXP_NXT_STATES     4 
....................  
.................... #define STATE_MACHINE_0              0 
.................... #define STATE_MACHINE_1              1 
.................... #define STATE_MACHINE_2              2 
.................... #define STATE_MACHINE_3              3 
.................... #define STATE_MACHINE_4              4 
....................  
.................... //#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... //#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... //#define COUNTER_SUCTION_WAIT         300 
....................  
.................... // Return codes 
.................... #define VI_RETN_SUCCESS               0 
....................  
.................... #define STATE_NOTHING 0 
.................... #define STATE_01 1 
.................... #define STATE_02 2 
.................... #define STATE_03 3 
.................... #define STATE_04 4 
.................... #define STATE_05 5 
.................... #define STATE_06 6 
.................... #define STATE_07 7 
.................... #define STATE_08 8 
.................... #define STATE_09 9 
.................... #define STATE_10 10 
.................... #define STATE_11 11 
.................... #define STATE_12 12 
.................... #define STATE_13 13 
.................... #define STATE_14 14 
.................... #define STATE_15 15 
.................... #define STATE_16 16 
.................... #define STATE_17 17 
.................... #define STATE_18 18 
.................... #define STATE_19 19 
....................  
.................... #define STATE_CONTINUE_OFF 0 
.................... #define STATE_CONTINUE_ON  1 
....................  
.................... /*typedef struct _ST_ALL_DI_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SWDICn07: 1; 
....................     unsigned int8 m_ui1SWDICn06: 1; 
....................     unsigned int8 m_ui1SWDICn05: 1; 
....................     unsigned int8 m_ui1SWDICn04: 1; 
....................     unsigned int8 m_ui1SWDICn03: 1; 
....................     unsigned int8 m_ui1SWDICn02: 1; 
....................     unsigned int8 m_ui1SWDICn01: 1; 
....................     unsigned int8 m_ui1SWDICn00: 1; 
....................  
....................     unsigned int8 m_ui1GDICn05: 1; 
....................     unsigned int8 m_ui1GDICn04: 1; 
....................     unsigned int8 m_ui1GDICn03: 1; 
....................     unsigned int8 m_ui1GDICn02: 1; 
....................     unsigned int8 m_ui1GDICn01: 1; 
....................     unsigned int8 m_ui1GDICn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDICn17: 1; 
....................     unsigned int8 m_ui1HWDICn16: 1; 
....................     unsigned int8 m_ui1HWDICn15: 1; 
....................     unsigned int8 m_ui1HWDICn14: 1; 
....................     unsigned int8 m_ui1HWDICn13: 1; 
....................     unsigned int8 m_ui1HWDICn12: 1; 
....................     unsigned int8 m_ui1HWDICn11: 1; 
....................     unsigned int8 m_ui1HWDICn10: 1; 
....................     unsigned int8 m_ui1HWDICn09: 1; 
....................     unsigned int8 m_ui1HWDICn08: 1; 
....................     unsigned int8 m_ui1HWDICn07: 1; 
....................     unsigned int8 m_ui1HWDICn06: 1; 
....................     unsigned int8 m_ui1HWDICn05: 1; 
....................     unsigned int8 m_ui1HWDICn04: 1; 
....................     unsigned int8 m_ui1HWDICn03: 1; 
....................     unsigned int8 m_ui1HWDICn02: 1; 
....................     unsigned int8 m_ui1HWDICn01: 1; 
....................     unsigned int8 m_ui1HWDICn00: 1; 
....................  
.................... } ST_ALL_DI_STATE_BIT; 
....................  
.................... typedef ST_ALL_DI_STATE_BIT ST_ALL_DIS; 
.................... typedef union _UN_ALL_DIS 
.................... { 
.................... 	unsigned int8      m_bArr[4]; 
....................     unsigned int32     m_ui32AllDIs; 
....................     ST_ALL_DIS         m_stAllDIBits; 
.................... } UN_ALL_DIS; 
....................  
.................... typedef struct _ST_ALL_DO_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui1SRDOCn07: 1; 
....................     unsigned int8 m_ui1SRDOCn06: 1; 
....................     unsigned int8 m_ui1SRDOCn05: 1; 
....................     unsigned int8 m_ui1SRDOCn04: 1; 
....................     unsigned int8 m_ui1SRDOCn03: 1; 
....................     unsigned int8 m_ui1SRDOCn02: 1; 
....................     unsigned int8 m_ui1SRDOCn01: 1; 
....................     unsigned int8 m_ui1SRDOCn00: 1; 
....................  
....................     unsigned int8 m_ui1HWDOCn07: 1; 
....................     unsigned int8 m_ui1HWDOCn06: 1; 
....................     unsigned int8 m_ui1HWDOCn05: 1; 
....................     unsigned int8 m_ui1HWDOCn04: 1; 
....................     unsigned int8 m_ui1HWDOCn03: 1; 
....................     unsigned int8 m_ui1HWDOCn02: 1; 
....................     unsigned int8 m_ui1HWDOCn01: 1; 
....................     unsigned int8 m_ui1HWDOCn00: 1; 
.................... } ST_ALL_DO_STATE_BIT; 
....................  
.................... typedef ST_ALL_DO_STATE_BIT ST_ALL_DOS; 
.................... typedef union _UN_ALL_DOS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllDOs; 
....................     ST_ALL_DOS        m_stAllDOBits; 
.................... } UN_ALL_DOS; 
....................  
.................... typedef struct _ST_ALL_COUNTER_STATE_BIT 
.................... { 
....................     unsigned int8 m_ui3Counter0: 3; 
....................     unsigned int8 m_ui3Counter1: 3; 
....................     unsigned int8 m_ui2Counter2: 2; 
....................  
....................     unsigned int8 m_ui2Counter3: 2; 
....................     unsigned int8 m_ui2Counter4: 2; 
....................     unsigned int8 m_ui2Counter5: 2; 
....................     unsigned int8 m_ui2Counter6: 2; 
.................... } ST_ALL_COUNTER_STATE_BIT; 
....................  
.................... typedef ST_ALL_COUNTER_STATE_BIT ST_ALL_COUNTERS; 
.................... typedef union _UN_ALL_COUNTERS 
.................... { 
....................     unsigned int8     m_bArr[2]; 
....................     unsigned int16    m_ui16AllCounters; 
....................     ST_ALL_COUNTERS   m_stAllCounterBits; 
.................... } UN_ALL_COUNTERS; 
.................... */ 
....................  
.................... int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
....................  
....................  
....................  
.................... typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... { 
....................     int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... } ST_STATE_INDEX_TABLE_NODE; 
....................  
....................  
.................... typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
....................  
.................... typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... { 
....................     int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
....................     int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
....................     int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
....................     PTR_STATE_FUNCTION pFunStateFunction; 
....................      
.................... } ST_STATE_LOOKUP_TABLE_NODE; 
....................  
....................  
.................... typedef struct _ST_STATE_MACHINE 
.................... { 
....................     unsigned int32               m_ui32StateDIFilter; 
....................     unsigned int16               m_ui16StateDOFilter; 
....................     unsigned int16               m_uiStateCounterFilter; 
....................     ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
....................     ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
....................     // Temporary Values 
....................     unsigned int32               m_ui32LastDIState; 
....................     unsigned int16               m_ui16LastDOState; 
....................  
....................     //int8                       m_iExpNxtStates; 
....................     int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
....................     int8                         m_i8PrevState; 
....................     int8                         m_fContinue; 
.................... } ST_STATE_MACHINE; 
....................  
....................  
.................... //================= All Variable Declarations Start ==========================// 
.................... //UN_ALL_DIS      g_unAllDIs; 
.................... //UN_ALL_DOS      g_unDOState; 
.................... //UN_ALL_COUNTERS g_unAllCounters; 
....................  
.................... unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
....................  
.................... unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fSuctionWait = 0;  
.................... unsigned int16 g_ui16TimerCount = 0;  
.................... //================= All Variable Declarations End ============================// 
....................  
.................... // Timer Function for DI Polling 
.................... /*void PollingInterrupt() 
.................... { 
....................     // Step 1 : Poll all DIs 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
....................     unsigned int8 ui8Test =  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
....................  
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
....................     g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
....................  
....................     // Step 2: Check for any state change 
....................     // Check ALL DI States Changes and all DO State Changes 
....................     if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
....................         g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
....................     { 
....................         g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
....................     } 
....................     else 
....................     { 
....................         g_uiStateChange = FLAG_STATE_CHANGED; 
....................         g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
....................         g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
....................     } 
....................  
....................  
....................     if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
....................     { 
....................         g_ui16TimerCount++; 
....................     } 
....................  
.................... }*/ 
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
....................     delay_us(10); 
....................     //output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
....................     //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
....................     //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
....................     //output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
....................     //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
....................     //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................      
.................... int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... { 
....................     int8 iStateIdx = 1; 
....................     // Check for all the states and find suitable state 
....................     for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
....................     { 
....................          
....................     }     
....................     return 0; 
.................... } 
....................  
....................  
.................... int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... { 
....................     unsigned int32 ui32DIState   = 0; 
....................     unsigned int16 ui16DOState   = 0; 
....................     int8           i8ExpNxtState = 0; 
....................     int8           i8TempState   = 0; 
....................     ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
....................     unsigned int8 ui8ExpNextState = 0; 
....................      
....................     // Step 1: Apply DI and DO Filter 
....................     ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
....................     //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
....................     
....................     // Step 2: Check with DO State Filter 
....................     // If Any change not found then Return 
....................     if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
....................     { 
....................         // No Change 
....................         // So Return 0 
....................         return 0; 
....................     } 
....................     // Step 3: IF Change found then do the following: 
....................     //     a. Update last state value 
....................     //     b. Check if the State is matching with the expected next state 
....................     //     c. If YES then call State function 
....................     //     d. If the State is not matching then perform Error Handling 
....................      
....................     // Stape 3a: Update last state value 
....................     //pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................  
....................     // Step 3b: Check if the State is matching with the expected next states 
....................     for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
....................     {        
....................         //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
....................         //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
....................         //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
....................         ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
....................         if (ui8ExpNextState == STATE_NOTHING) 
....................         { 
....................             // No State Matched, this is an Error 
....................             // Handle Error 
....................             return HandleStateError(pstStateMachine); 
....................         }     
....................          
....................         if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
....................         {    
....................             // State Is matching 
....................             // Call State Function 
....................             pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
....................              
....................             pstStateMachine->m_i8PrevState = ui8ExpNextState; 
....................              
....................             //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
....................             //{ 
....................             //    output_bit(PIN_OUT_DO_07, 0); 
....................             //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
....................             //}     
....................             // Stape 3a: Update last state value 
....................             pstStateMachine->m_ui32LastDIState = ui32DIState; 
....................              
....................             break; 
....................              
....................         } 
....................         else 
....................         { 
....................             // Next State is not matching 
....................             // ERROR 
....................         } 
....................     } 
....................  
....................  
....................     // If Expected State does not match 
....................     if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
....................     { 
....................         // Handle Error 
....................         return HandleStateError(pstStateMachine); 
....................     } 
....................  
....................     return VI_RETN_SUCCESS; 
.................... } 
....................  
.................... void InitilizeStates() 
.................... { 
....................     g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... } 
....................      
....................  
.................... #endif /* _VI_STATE_MACHINE_H_ */ 
....................  
....................  
....................  
....................  
.................... //#ifndef _VM_STATE_MACHINE_H_ 
.................... //#define _VM_STATE_MACHINE_H_ 
.................... // 
.................... //#include "vmDigitalIOConfig.h" 
.................... ///*************************** Inclusion files **********************************/ 
.................... // 
.................... //#define FLAG_STATE_CHANGED           1 
.................... //#define FLAG_STATE_NOT_CHANGED       0 
.................... //#define MAX_NUMBER_OF_STATE_MACHINES 5 
.................... //#define MIN_NUMBER_OF_STATE_MACHINES 1 
.................... //#define MAX_NUMBER_OF_STATE          8 
.................... //#define MAX_NO_OF_EXP_NXT_STATES     4 
.................... // 
.................... //#define STATE_MACHINE_0   0 
.................... //#define STATE_MACHINE_1   1 
.................... //#define STATE_MACHINE_2   2 
.................... //#define STATE_MACHINE_3   3 
.................... //#define STATE_MACHINE_4   4 
.................... // 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_ON   1 
.................... ////#define TIMER_FLAG_SUCTION_WAIT_OFF  0 
.................... ////#define COUNTER_SUCTION_WAIT         300 
.................... // 
.................... //// Return codes 
.................... //#define VI_RETN_SUCCESS               0 
.................... // 
.................... //#define STATE_NOTHING 0 
.................... //#define STATE_01 1 
.................... //#define STATE_02 2 
.................... //#define STATE_03 3 
.................... //#define STATE_04 4 
.................... //#define STATE_05 5 
.................... //#define STATE_06 6 
.................... //#define STATE_07 7 
.................... //#define STATE_08 8 
.................... //#define STATE_09 9 
.................... //#define STATE_10 10 
.................... //#define STATE_11 11 
.................... //#define STATE_12 12 
.................... //#define STATE_13 13 
.................... //#define STATE_14 14 
.................... //#define STATE_15 15 
.................... //#define STATE_16 16 
.................... //#define STATE_17 17 
.................... //#define STATE_18 18 
.................... //#define STATE_19 19 
.................... // 
.................... //#define STATE_CONTINUE_OFF 0 
.................... //#define STATE_CONTINUE_ON  1 
.................... // 
.................... // 
.................... //int8 g_ui8NumberOfActiveMachines; //= MIN_NUMBER_OF_STATE_MACHINES; 
.................... // 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_INDEX_TABLE_NODE 
.................... //{ 
.................... //    int32 m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16 m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //} ST_STATE_INDEX_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef unsigned int8(*PTR_STATE_FUNCTION)(int8, int8); 
.................... ////typedef unsigned int8(*PTR_STATE_FUNCTION)(void); 
.................... // 
.................... //typedef struct _ST_STATE_LOOKUP_TABLE_NODE 
.................... //{ 
.................... //    int32              m_ui32DIState;      // Populate the DI State after applying the State DI Filter 
.................... //    int16              m_ui16DOState;      // Populate the DO State after applying the State DO Filter 
.................... //    int8               m_i8ArrExpNextState[MAX_NO_OF_EXP_NXT_STATES]; 
.................... //    PTR_STATE_FUNCTION pFunStateFunction; 
.................... //     
.................... //} ST_STATE_LOOKUP_TABLE_NODE; 
.................... // 
.................... // 
.................... //typedef struct _ST_STATE_MACHINE 
.................... //{ 
.................... //    unsigned int32               m_ui32StateDIFilter; 
.................... //    unsigned int16               m_ui16StateDOFilter; 
.................... //    unsigned int16               m_uiStateCounterFilter; 
.................... //    ST_STATE_INDEX_TABLE_NODE    m_stArrStateIndexTable[MAX_NUMBER_OF_STATE]; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE   m_stArrStateLookupTable[MAX_NUMBER_OF_STATE]; 
.................... //    // Temporary Values 
.................... //    unsigned int32               m_ui32LastDIState; 
.................... //    unsigned int16               m_ui16LastDOState; 
.................... // 
.................... //    //int8                       m_iExpNxtStates; 
.................... //    int8                         m_i8ArrCurExpNextState[MAX_NO_OF_EXP_NXT_STATES];    // Expected Next States 
.................... //    int8                         m_i8PrevState; 
.................... //    int8                         m_fContinue; 
.................... //} ST_STATE_MACHINE; 
.................... // 
.................... // 
.................... ////================= All Variable Declarations Start ==========================// 
.................... ////UN_ALL_DIS      g_unAllDIs; 
.................... ////UN_ALL_DOS      g_unDOState; 
.................... ////UN_ALL_COUNTERS g_unAllCounters; 
.................... // 
.................... //unsigned int32 g_ui32AllDIsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsCurrentState       = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllDOsPreviousState      = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersCurrentState  = 0;      //TODO This should be overwrite by Board Initialization 
.................... //unsigned int16 g_ui32AllCountersPreviousState = 0;      //TODO This should be overwrite by Board Initialization 
.................... // 
.................... //unsigned int8  g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //unsigned int8  g_fSuctionWait = 0;  
.................... //unsigned int16 g_ui16TimerCount = 0;  
.................... ////================= All Variable Declarations End ============================// 
.................... // 
.................... //// Timer Function for DI Polling 
.................... ///*void PollingInterrupt() 
.................... //{ 
.................... //    // Step 1 : Poll all DIs 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn00 = input(PIN_IN_DI_00); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn01 = input(PIN_IN_DI_01); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn02 = input(PIN_IN_DI_02); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn03 = input(PIN_IN_DI_03); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn04 = input(PIN_IN_DI_04); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn05 = input(PIN_IN_DI_05); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn06 = input(PIN_IN_DI_06); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn07 = input(PIN_IN_DI_07); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn08 = input(PIN_IN_DI_08); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn09 = input(PIN_IN_DI_09); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn10 = input(PIN_IN_DI_10); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn11 = input(PIN_IN_DI_11); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn12 = input(PIN_IN_DI_12); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn13 = input(PIN_IN_DI_13); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn14 = input(PIN_IN_DI_14); 
.................... //    unsigned int8 ui8Test =  
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn15 = input(PIN_IN_DI_15); 
.................... // 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn16 = input(PIN_IN_DI_16); 
.................... //    g_unAllDIs.m_stAllDIBits.m_ui1HWDICn17 = input(PIN_IN_DI_17); 
.................... // 
.................... //    // Step 2: Check for any state change 
.................... //    // Check ALL DI States Changes and all DO State Changes 
.................... //    if (g_unAllDIs.m_ui32AllDIs == g_ui32AllDIsPreviousState && 
.................... //        g_unDOState.m_ui16AllDOs == g_ui32AllDOsPreviousState) 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_NOT_CHANGED; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        g_uiStateChange = FLAG_STATE_CHANGED; 
.................... //        g_ui32AllDIsPreviousState = g_unAllDIs.m_ui32AllDIs; 
.................... //        g_ui32AllDOsPreviousState = g_unDOState.m_ui16AllDOs; 
.................... //    } 
.................... // 
.................... // 
.................... //    if (g_fSuctionWait == TIMER_FLAG_SUCTION_WAIT_ON) 
.................... //    { 
.................... //        g_ui16TimerCount++; 
.................... //    } 
.................... // 
.................... //}*/ 
.................... // 
.................... //void ExecuteALLDOs(void) 
.................... //{ 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); 
.................... //    output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); 
.................... //    output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); 
.................... //    output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... //} 
.................... //     
.................... //int8 HandleStateError(ST_STATE_MACHINE *pstStateMachine) 
.................... //{ 
.................... //    int8 iStateIdx = 1; 
.................... //    // Check for all the states and find suitable state 
.................... //    for (iStateIdx = 1; iStateIdx < MAX_NUMBER_OF_STATE; iStateIdx++) 
.................... //    { 
.................... //         
.................... //    }     
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //int8 CheckState(ST_STATE_MACHINE *pstStateMachine, int8 i8StMacIndex) 
.................... //{ 
.................... //    unsigned int32 ui32DIState   = 0; 
.................... //    unsigned int16 ui16DOState   = 0; 
.................... //    int8           i8ExpNxtState = 0; 
.................... //    int8           i8TempState   = 0; 
.................... //    ST_STATE_LOOKUP_TABLE_NODE* pStLookUptableNode = 0; 
.................... //    unsigned int8 ui8ExpNextState = 0; 
.................... //     
.................... //    // Step 1: Apply DI and DO Filter 
.................... //    //ui32DIState = g_unDIState.m_ui32AllDIs & pstStateMachine->m_ui32StateDIFilter; 
.................... //    //ui16DOState = g_unDOState.m_ui16AllDOs & pstStateMachine->m_ui16StateDOFilter; 
.................... //    
.................... //    // Step 2: Check with DO State Filter 
.................... //    // If Any change not found then Return 
.................... //    if (!(ui32DIState ^ pstStateMachine->m_ui32LastDIState) && pstStateMachine->m_fContinue == STATE_CONTINUE_OFF) 
.................... //    { 
.................... //        // No Change 
.................... //        // So Return 0 
.................... //        return 0; 
.................... //    } 
.................... //    // Step 3: IF Change found then do the following: 
.................... //    //     a. Update last state value 
.................... //    //     b. Check if the State is matching with the expected next state 
.................... //    //     c. If YES then call State function 
.................... //    //     d. If the State is not matching then perform Error Handling 
.................... //     
.................... //    // Stape 3a: Update last state value 
.................... //    //pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... // 
.................... //    // Step 3b: Check if the State is matching with the expected next states 
.................... //    for (i8ExpNxtState = 0; i8ExpNxtState < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtState++) 
.................... //    {        
.................... //        //pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].; 
.................... //        //if (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState) 
.................... //        //if (0 == (pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8ArrCurExpNextState[i8ExpNxtState]].m_ui32DIState ^ ui32DIState)) 
.................... //        ui8ExpNextState = pstStateMachine->m_stArrStateLookupTable[pstStateMachine->m_i8PrevState].m_i8ArrExpNextState[i8ExpNxtState]; 
.................... //        if (ui8ExpNextState == STATE_NOTHING) 
.................... //        { 
.................... //            // No State Matched, this is an Error 
.................... //            // Handle Error 
.................... //            return HandleStateError(pstStateMachine); 
.................... //        }     
.................... //         
.................... //        if (0 == (pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].m_ui32DIState ^ ui32DIState)) 
.................... //        {    
.................... //            // State Is matching 
.................... //            // Call State Function 
.................... //            pstStateMachine->m_stArrStateLookupTable[ui8ExpNextState].pFunStateFunction(i8StMacIndex, ui8ExpNextState); 
.................... //             
.................... //            pstStateMachine->m_i8PrevState = ui8ExpNextState; 
.................... //             
.................... //            //if (pstStateMachine->m_ui32StateDIFilter == 0x7000007) 
.................... //            //{ 
.................... //            //    output_bit(PIN_OUT_DO_07, 0); 
.................... //            //    g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = 0; 
.................... //            //}     
.................... //            // Stape 3a: Update last state value 
.................... //            pstStateMachine->m_ui32LastDIState = ui32DIState; 
.................... //             
.................... //            break; 
.................... //             
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            // Next State is not matching 
.................... //            // ERROR 
.................... //        } 
.................... //    } 
.................... // 
.................... // 
.................... //    // If Expected State does not match 
.................... //    if (i8ExpNxtState == MAX_NO_OF_EXP_NXT_STATES) 
.................... //    { 
.................... //        // Handle Error 
.................... //        return HandleStateError(pstStateMachine); 
.................... //    } 
.................... // 
.................... //    return VI_RETN_SUCCESS; 
.................... //} 
.................... // 
.................... //void InitilizeStates() 
.................... //{ 
.................... //   // g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... //     
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_H_ */ 
.................... // 
.................... // 
....................  
....................  
.................... #define STPR_1_EMPTY_ON              0 
.................... #define STPR_1_EMPTY_OFF             1 
.................... #define STPR_0_SET_TRANSFERED_ON     0 
.................... #define STPR_0_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_SET_TRANSFERED_ON     0 
.................... #define STPR_1_SET_TRANSFERED_OFF    1 
.................... #define STPR_1_CAN_SET_COUNT_DONE    0 
.................... #define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... #define PUSHER_EMPTY_ON              0 
.................... #define PUSHER_EMPTY_OFF             1 
.................... #define PUSHER_0_TIME_OUT_ON         0 
.................... #define PUSHER_0_TIME_OUT_OFF        1 
.................... #define PUSHER_0_ALL_DONE            0 
.................... #define PUSHER_0_ALL_NOT_DONE        1 
.................... #define PUSHER_1_TIME_OUT_ON         0 
.................... #define PUSHER_1_TIME_OUT_OFF        1 
.................... #define PUSHER_1_ALL_DONE            0 
.................... #define PUSHER_1_ALL_NOT_DONE        1 
.................... #define STACKER_READY_ON             0 
.................... #define STACKER_READY_OFF            1 
.................... #define PUSHER_0_FIRST_PUSH_ON       0 
.................... #define PUSHER_0_FIRST_PUSH_OFF      1 
.................... #define PUSHER_1_FIRST_PUSH_ON       0 
.................... #define PUSHER_1_FIRST_PUSH_OFF      1 
....................  
....................  
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... #define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
....................  
....................  
.................... #define NO_OF_ACTIVE_MACHINE        2 
....................  
.................... #define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... #define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... #define SAFE_MODE_DO_STATE           0x3FFF 
.................... #define PRE_PRODUCTION_DO_STATE      0xBFFF 
....................  
.................... //////////////////// State Machine 0 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM0_HWDI_FILTER	0xD0000010 
.................... #define 	STATE_SM0_HWDI_01	0xD0000010 
.................... #define 	STATE_SM0_HWDI_02	0x50000010 
.................... #define 	STATE_SM0_HWDI_03	0x10000010 
.................... #define 	STATE_SM0_HWDI_04	0x90000010 
.................... #define 	STATE_SM0_HWDI_05	0xD0000010 
.................... #define 	STATE_SM0_HWDI_06	0x80000010 
.................... #define 	STATE_SM0_HWDI_07	0xC0000010 
.................... #define 	STATE_SM0_HWDI_08	0xD0000010 
.................... #define 	STATE_SM0_HWDI_09	0xD0000000 
.................... #define 	STATE_SM0_HWDI_10	0xD0000010 
....................  
.................... #define 	STATE_SM0_HWDO_FILTER	0x8000 
.................... #define 	STATE_SM0_HWDO_01	0x8000 
.................... #define 	STATE_SM0_HWDO_02	0x8000 
.................... #define 	STATE_SM0_HWDO_03	0x0000 
.................... #define 	STATE_SM0_HWDO_04	0x0000 
.................... #define 	STATE_SM0_HWDO_05	0x0000 
.................... #define 	STATE_SM0_HWDO_06	0x0000 
.................... #define 	STATE_SM0_HWDO_07	0x0000 
.................... #define 	STATE_SM0_HWDO_08	0x0000 
.................... #define 	STATE_SM0_HWDO_09	0x0000 
.................... #define 	STATE_SM0_HWDO_10	0x8000 
....................  
....................  
.................... //////////////////// State Machine 0 DI DO States End ////////////////////////// 
....................  
.................... //////////////////// State Machine 1 DI DO States Start //////////////////////// 
.................... #define 	STATE_SM1_HWDI_FILTER	0x08001800 
.................... #define 	STATE_SM1_HWDI_01	0x08000800 
.................... #define 	STATE_SM1_HWDI_02	0x00000800 
.................... #define 	STATE_SM1_HWDI_03	0x00001800 
.................... #define 	STATE_SM1_HWDI_04	0x08000000 
....................  
.................... #define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... #define 	STATE_SM1_HWDO_01	0x4000 
.................... #define 	STATE_SM1_HWDO_02	0x0000 
.................... #define 	STATE_SM1_HWDO_03	0x4000 
.................... #define 	STATE_SM1_HWDO_04	0x4000 
....................  
.................... //#define 	STATE_SM1_HWDI_FILTER	0x0C001800 
.................... //#define 	STATE_SM1_HWDI_01	0x0C000800 
.................... //#define 	STATE_SM1_HWDI_02	0x08000800 
.................... //#define 	STATE_SM1_HWDI_03	0x04000800 
.................... //#define 	STATE_SM1_HWDI_04	0x04001800 
.................... //#define 	STATE_SM1_HWDI_05	0x00000800 
.................... //#define 	STATE_SM1_HWDI_06	0x0C000000 
.................... // 
.................... //#define 	STATE_SM1_HWDO_FILTER	0x4000 
.................... //#define 	STATE_SM1_HWDO_01	0x4000 
.................... //#define 	STATE_SM1_HWDO_02	0x4000 
.................... //#define 	STATE_SM1_HWDO_03	0x0000 
.................... //#define 	STATE_SM1_HWDO_04	0x4000 
.................... //#define 	STATE_SM1_HWDO_05	0x4000 
.................... //#define 	STATE_SM1_HWDO_06	0x4000 
.................... //////////////////// State Machine 1 DI DO States End ////////////////////////// 
....................  
.................... ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
....................  
.................... unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
....................  
....................  
....................  
.................... //void InitializeStateMachines() 
.................... //{ 
....................     //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
....................     //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //} 
.................... /* 
.................... // 01 : Home State 
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     // Take action 
....................     // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
....................     // Also only the changes will added to the original ALL DOs  
....................     unsigned int16 ui16Temp0 = 0; 
....................     unsigned int16 ui16Temp1 = 0; 
....................     //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     // Hold the Current DO Values to temp 
....................     ui16Temp0 = g_unDOState.m_ui16AllDOs; 
....................  
....................     // Bitwise AND with the State DO Filter with the Value to change 
....................     ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
....................                 g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................      
....................     // Finally Bitwise OR operation between original value to the temp 
....................     g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
....................  
....................     return 0; 
.................... }  
.................... */ 
.................... unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... { 
....................  
....................         unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
....................         unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................         unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................         unsigned int16 ui8BitValue = 0; 
....................          
....................         for(int i = 0; i < 16; i++) 
....................         { 
....................             if(1 == ((ui8Filter >> i)&0x0001)) 
....................             { 
....................                 ui8BitValue = ((ui8Value >> i)&0x0001); 
....................                 ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
....................             } 
....................         } 
....................  
....................     g_unDOState.m_ui16AllDOs = ui8DO; 
....................     return 0; 
.................... }  
....................  
.................... unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... { 
....................     UN_ALL_DOS unFilter; 
....................     UN_ALL_DOS unValue; 
....................      
....................     unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
....................     unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
....................      
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
....................     if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
....................      
....................     return 0; 
....................      
.................... }     
....................  
....................          
....................  
....................          
.................... // 02: Start to Pick 
.................... unsigned int8 StateFunc_State02() 
.................... { 
....................     // We got message from outer board that Stacker Ready and Hopper Ready 
....................     // Now PD will start moving downword 
....................     //g_unAllDOs.m_bArr[2] = 1; 
....................     //g_unAllDOs.m_bArr[3] = 0; 
....................     // Expected Next State Declaration 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
....................     g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
....................     return 0; 
.................... } 
....................  
....................  
.................... void InitExpNextStateDefault() 
.................... { 
....................     int8 i8StMcCount = 0; 
....................     int8 i8StCount   = 0; 
....................     int8 i8ExpNxtCount = 0; 
....................     for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
....................     { 
....................         // For all Active Look up tables 
....................         for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
....................         { 
....................             for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
....................             { 
....................                 g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
....................             } 
....................         } 
....................     } 
.................... } 
....................  
.................... void PostProductionSafeMode() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in Push State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... void PowerOnDOStateInit() 
.................... { 
....................     g_unDOState.m_ui16AllDOs = 0xFFFF; 
....................      
....................     // 1. Stopper 0 is in drag State 
....................     // 2. Can Stopper 1 is in Push state 
....................     // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
....................     g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
....................     ExecuteALLDOs(); 
.................... } 
....................  
.................... #endif /* _VI_STATE_MACHINE_FOR_CP_H_ */ 
....................  
....................  
.................... //#include "vmSystemConfig.h" 
.................... ////#include "vmStateMachine.h" 
.................... // 
.................... //#define STPR_1_EMPTY_ON              0 
.................... //#define STPR_1_EMPTY_OFF             1 
.................... //#define STPR_0_SET_TRANSFERED_ON     0 
.................... //#define STPR_0_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_SET_TRANSFERED_ON     0 
.................... //#define STPR_1_SET_TRANSFERED_OFF    1 
.................... //#define STPR_1_CAN_SET_COUNT_DONE    0 
.................... //#define STPR_1_CAN_SET_COUNT_NOT_DONE 1 
.................... //#define PUSHER_EMPTY_ON              0 
.................... //#define PUSHER_EMPTY_OFF             1 
.................... //#define PUSHER_0_TIME_OUT_ON         0 
.................... //#define PUSHER_0_TIME_OUT_OFF        1 
.................... //#define PUSHER_0_ALL_DONE            0 
.................... //#define PUSHER_0_ALL_NOT_DONE        1 
.................... //#define PUSHER_1_TIME_OUT_ON         0 
.................... //#define PUSHER_1_TIME_OUT_OFF        1 
.................... //#define PUSHER_1_ALL_DONE            0 
.................... //#define PUSHER_1_ALL_NOT_DONE        1 
.................... //#define STACKER_READY_ON             0 
.................... //#define STACKER_READY_OFF            1 
.................... //#define PUSHER_0_FIRST_PUSH_ON       0 
.................... //#define PUSHER_0_FIRST_PUSH_OFF      1 
.................... //#define PUSHER_1_FIRST_PUSH_ON       0 
.................... //#define PUSHER_1_FIRST_PUSH_OFF      1 
.................... // 
.................... // 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_OFF 0 
.................... //#define SPCL_FLAG_SM_1_START_TRANSFER_ON  1 
.................... // 
.................... // 
.................... //#define NO_OF_ACTIVE_MACHINE        5 
.................... // 
.................... //#define INITAIL_DI_STATE_ON_PWR_ON   0xFFFF3F5F 
.................... //#define INITAIL_DO_STATE_ON_PWR_ON   0x3FFF 
.................... //#define SAFE_MODE_DO_STATE           0x3FFF 
.................... //#define PRE_PRODUCTION_DO_STATE      0xBFFF 
.................... // 
.................... //ST_STATE_MACHINE g_stArrStateMachines[NO_OF_ACTIVE_MACHINE]; 
.................... // 
.................... //unsigned int8 g_fStateMac1StartCanTransfer = SPCL_FLAG_SM_1_START_TRANSFER_ON; 
.................... // 
.................... // 
.................... // 
.................... ////void InitializeStateMachines() 
.................... ////{ 
.................... //    //g_unDIState.m_ui32AllDIs = 0xFFFFFFFF; 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... ////} 
.................... ///* 
.................... //// 01 : Home State 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... //    // Take action 
.................... //    // Main intention is to not change values of other DO fields, except the fields under the state DO Filter 
.................... //    // Also only the changes will added to the original ALL DOs  
.................... //    unsigned int16 ui16Temp0 = 0; 
.................... //    unsigned int16 ui16Temp1 = 0; 
.................... //    //g_unAllDOs.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... //     
.................... //    // Hold the Current DO Values to temp 
.................... //    ui16Temp0 = g_unDOState.m_ui16AllDOs; 
.................... // 
.................... //    // Bitwise AND with the State DO Filter with the Value to change 
.................... //    ui16Temp1 = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState & 
.................... //                g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... //     
.................... //    // Finally Bitwise OR operation between original value to the temp 
.................... //    g_unDOState.m_ui16AllDOs = ui16Temp0 | ui16Temp1; 
.................... // 
.................... //    return 0; 
.................... //}  
.................... //*/ 
.................... //unsigned int8 StateFunc_GenericState_(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... // 
.................... ////        unsigned int16 ui8DO       = g_unDOState.m_ui16AllDOs; 
.................... ////        unsigned int16 ui8Filter   = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////        unsigned int16 ui8Value    = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////        unsigned int16 ui8BitValue = 0; 
.................... ////         
.................... ////        for(int i = 0; i < 16; i++) 
.................... ////        { 
.................... ////            if(1 == ((ui8Filter >> i)&0x0001)) 
.................... ////            { 
.................... ////                ui8BitValue = ((ui8Value >> i)&0x0001); 
.................... ////                ui8DO = (ui8DO & (~(1 << i))) | (ui8BitValue << i); 
.................... ////            } 
.................... ////        } 
.................... //// 
.................... ////    g_unDOState.m_ui16AllDOs = ui8DO; 
.................... ////    return 0; 
.................... //}  
.................... // 
.................... //unsigned int8 StateFunc_GenericState(int8 i8StateMachine, int8 i8State) 
.................... //{ 
.................... ////    UN_ALL_DOS unFilter; 
.................... ////    UN_ALL_DOS unValue; 
.................... ////     
.................... ////    unFilter.m_ui16AllDOs = g_stArrStateMachines[i8StateMachine].m_ui16StateDOFilter; 
.................... ////    unValue.m_ui16AllDOs  = g_stArrStateMachines[i8StateMachine].m_stArrStateLookupTable[i8State].m_ui16DOState; 
.................... ////     
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn00) g_unDOState.m_stAllDOBits.m_ui1HWDOCn00 = unValue.m_stAllDOBits.m_ui1HWDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn01) g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = unValue.m_stAllDOBits.m_ui1HWDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn02) g_unDOState.m_stAllDOBits.m_ui1HWDOCn02 = unValue.m_stAllDOBits.m_ui1HWDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn03) g_unDOState.m_stAllDOBits.m_ui1HWDOCn03 = unValue.m_stAllDOBits.m_ui1HWDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn04) g_unDOState.m_stAllDOBits.m_ui1HWDOCn04 = unValue.m_stAllDOBits.m_ui1HWDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn05) g_unDOState.m_stAllDOBits.m_ui1HWDOCn05 = unValue.m_stAllDOBits.m_ui1HWDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn06) g_unDOState.m_stAllDOBits.m_ui1HWDOCn06 = unValue.m_stAllDOBits.m_ui1HWDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1HWDOCn07) g_unDOState.m_stAllDOBits.m_ui1HWDOCn07 = unValue.m_stAllDOBits.m_ui1HWDOCn07; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn00) g_unDOState.m_stAllDOBits.m_ui1SRDOCn00 = unValue.m_stAllDOBits.m_ui1SRDOCn00; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn01) g_unDOState.m_stAllDOBits.m_ui1SRDOCn01 = unValue.m_stAllDOBits.m_ui1SRDOCn01; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn02) g_unDOState.m_stAllDOBits.m_ui1SRDOCn02 = unValue.m_stAllDOBits.m_ui1SRDOCn02; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn03) g_unDOState.m_stAllDOBits.m_ui1SRDOCn03 = unValue.m_stAllDOBits.m_ui1SRDOCn03; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn04) g_unDOState.m_stAllDOBits.m_ui1SRDOCn04 = unValue.m_stAllDOBits.m_ui1SRDOCn04; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn05) g_unDOState.m_stAllDOBits.m_ui1SRDOCn05 = unValue.m_stAllDOBits.m_ui1SRDOCn05; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn06) g_unDOState.m_stAllDOBits.m_ui1SRDOCn06 = unValue.m_stAllDOBits.m_ui1SRDOCn06; 
.................... ////    if(unFilter.m_stAllDOBits.m_ui1SRDOCn07) g_unDOState.m_stAllDOBits.m_ui1SRDOCn07 = unValue.m_stAllDOBits.m_ui1SRDOCn07; 
.................... ////     
.................... //}     
.................... // 
.................... //         
.................... // 
.................... //         
.................... //// 02: Start to Pick 
.................... //unsigned int8 StateFunc_State02() 
.................... //{ 
.................... //    // We got message from outer board that Stacker Ready and Hopper Ready 
.................... //    // Now PD will start moving downword 
.................... //    //g_unAllDOs.m_bArr[2] = 1; 
.................... //    //g_unAllDOs.m_bArr[3] = 0; 
.................... //    // Expected Next State Declaration 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[0] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[1] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[2] = STATE_03; 
.................... //    g_stArrStateMachines[0].m_stArrStateLookupTable[STATE_02].m_i8ArrExpNextState[3] = STATE_03; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... // 
.................... //void InitExpNextStateDefault() 
.................... //{ 
.................... //    int8 i8StMcCount = 0; 
.................... //    int8 i8StCount   = 0; 
.................... //    int8 i8ExpNxtCount = 0; 
.................... //    for (i8StMcCount = 0; i8StMcCount < NO_OF_ACTIVE_MACHINE; i8StMcCount++) 
.................... //    { 
.................... //        // For all Active Look up tables 
.................... //        for (i8StCount = 0; i8StCount < MAX_NUMBER_OF_STATE; i8StCount++) 
.................... //        { 
.................... //            for (i8ExpNxtCount = 0; i8ExpNxtCount < MAX_NO_OF_EXP_NXT_STATES; i8ExpNxtCount++) 
.................... //            { 
.................... //                g_stArrStateMachines[i8StMcCount].m_stArrStateLookupTable[i8StCount].m_i8ArrExpNextState[i8ExpNxtCount] = STATE_NOTHING; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //} 
.................... // 
.................... //void PostProductionSafeMode() 
.................... //{ 
.................... //    //g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in Push State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //    //g_unDOState.m_ui16AllDOs = SAFE_MODE_DO_STATE; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //void PowerOnDOStateInit() 
.................... //{ 
.................... //   // g_unDOState.m_ui16AllDOs = 0xFFFF; 
.................... //     
.................... //    // 1. Stopper 0 is in drag State 
.................... //    // 2. Can Stopper 1 is in Push state 
.................... //    // 3. Pusher 0, Pusher 1 and Can Guide all is in drag state 
.................... //   // g_unDOState.m_ui16AllDOs = INITAIL_DO_STATE_ON_PWR_ON; 
.................... //    //ExecuteALLDOs(); 
.................... //} 
.................... // 
.................... //#endif /* _VM_STATE_MACHINE_FOR_IMW_M0_H_ */ 
....................  
.................... //#include "vmDigitalIOConfig.h" 
.................... #include "vmADCManager.h" 
.................... /*  
....................  * File:   vmADCManager.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 12, 2018, 11:38 PM 
....................  */ 
....................  
.................... #ifndef VM_ADCMANAGER_H 
.................... #define	VM_ADCMANAGER_H 
....................  
.................... //#include "vmCalibration.h" 
.................... #include "vmM0ADCModuleCommon.h" 
.................... /*  
....................  * File:   vmM0ADCModuleCommon.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 13, 2018, 4:59 PM 
....................  */ 
....................  
.................... #ifndef VM_M0_ADC_MODULE_COMMON_H 
.................... #define	VM_M0_ADC_MODULE_COMMON_H 
....................  
.................... #define PIPE_ACCEPTED              2 
.................... #define PIPE_REJECTED              0 
.................... #define PIPE_OVER_WEIGHT           1 
.................... #define PIPE_UNDER_WEIGHT          0 
....................  
.................... #define SYS_MODE_NOTHING        0 
.................... #define SYS_MODE_HOME           1 
.................... #define SYS_MODE_PRE_PROD       2 
.................... #define SYS_MODE_PROD           3 
.................... #define SYS_MODE_CONFIG         4 
.................... #define SYS_MODE_CALIB          5 
.................... #define SYS_MODE_POST_PROD      6 
.................... #define SYS_MODE_WAKE_UP        7 
.................... #define SYS_MODE_PRE_PROD_SCRAP 8 
....................  
.................... #define ADC_MEAN_DATA_INTERMEDIATE_WEIGHT   31 
.................... #define ADC_MEAN_DATA_INTERMEDIATE_TARE     32 
.................... #define ADC_MEAN_DATA_FINAL_WEIGHT          33 
.................... #define ADC_MEAN_DATA_FINAL_TARE            34 
.................... #define ADC_MEAN_DATA_CALIB_WEIGHT          35 
.................... #define ADC_MEAN_DATA_NOTHING               36 
....................  
.................... unsigned int8 g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
....................  
.................... #define FLAG_WT_CALCULATION_DONE     1 
.................... #define FLAG_WT_CALCULATION_NOT_DONE 0 
....................  
.................... unsigned int8 g_fWtCalculationState = FLAG_WT_CALCULATION_NOT_DONE; 
....................  
.................... #define IBU_RESET_CALIB_OFF    0 
.................... #define IBU_RESET_CALIB_ON     1 
....................  
.................... #define HMI_REJECTION_AUTO_CALIB_MODE   0 
.................... #define HMI_REJECTION_FIXED_CALIB_MODE  1 
....................  
....................  
.................... unsigned int16 g_ui16RejectionStatus      = PIPE_REJECTED; 
.................... unsigned int8  g_ui8SystemMode            = SYS_MODE_NOTHING; 
.................... unsigned int32 g_ui32DynamicTareValue     = 0; 
.................... unsigned int32 g_ui32DynamicTareADCValue  = 0; 
.................... unsigned int16 g_ui16PipeCount            = 0; 
....................  
.................... unsigned int16 g_ui16PrevDynamicTareValue = 0; 
.................... int32          g_i32StaticTareValue       = 0;  // TODO Should keep in EEPROM 
.................... unsigned int8  g_fResetCalibStatus        = IBU_RESET_CALIB_OFF; 
....................  
.................... int32          g_i32ADCSumValue          = 0; 
.................... int32          g_i32ADCAvgValue          = 0; 
.................... unsigned int16 g_ui16ADCCalibValueEEPROM = 0; 
.................... unsigned int16 g_ui16CalibPointEEPROM    = 0; 
.................... int16          g_i16CalibResetPrevValue  = 0; 
.................... int16          g_i16DynamicErrValue      = 0; 
....................  
....................  
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int32 m_i32AvgWeight; 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_CUR_BATCH_INFO; 
....................  
.................... ST_CUR_BATCH_INFO g_stCurBatchInfo; 
....................  
....................        
.................... #define STATE_HOME          0 
.................... #define STATE_PRE_PROD      1 
.................... #define STATE_PROD          2 
.................... #define STATE_POST_PROD     3 
.................... #define STATE_CALIB         4 
.................... #define STATE_NONE          5 
....................  
.................... unsigned int8  g_ui8ExpectedNextState[2] = {0}; 
....................  
.................... #endif	/* VM_M0_ADC_MODULE_COMMON_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... //#include "../Common/vmModbusGlobal.h" 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  1200   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int32 m_i32Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
*
005F0:  MOVLB  A
005F2:  CLRF   x74
.................... { 
....................     unsigned int8 ui8LoopCount   = 0; 
....................     g_stAvgWtQueue.m_i8Rear      = -1; 
005F4:  MOVLB  6
005F6:  SETF   xD7
....................     g_stAvgWtQueue.m_i8Length    = SIZE_AVG_WT_ARR; 
005F8:  MOVLW  32
005FA:  MOVWF  xD8
....................     g_stAvgWtQueue.m_i32CurAvg   = 0; 
005FC:  CLRF   xDD
005FE:  CLRF   xDC
00600:  CLRF   xDB
00602:  CLRF   xDA
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
00604:  CLRF   xD9
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
00606:  MOVLB  A
00608:  CLRF   x74
0060A:  MOVF   x74,W
0060C:  SUBLW  31
0060E:  BTFSS  FD8.0
00610:  GOTO   0634
....................     { 
....................         g_stAvgWtQueue.m_i32Arr[ui8LoopCount] = 0; 
00614:  MOVF   x74,W
00616:  MULLW  04
00618:  MOVF   FF3,W
0061A:  CLRF   03
0061C:  ADDLW  0F
0061E:  MOVWF  FE9
00620:  MOVLW  06
00622:  ADDWFC 03,W
00624:  MOVWF  FEA
00626:  CLRF   FEF
00628:  CLRF   FEC
0062A:  CLRF   FEC
0062C:  CLRF   FEC
0062E:  INCF   x74,F
00630:  GOTO   060A
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32LstAvg = 0; 
00634:  MOVLB  6
00636:  CLRF   xE1
00638:  CLRF   xE0
0063A:  CLRF   xDF
0063C:  CLRF   xDE
0063E:  MOVLB  0
00640:  GOTO   0B20 (RETURN)
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int32 i32LastWeight) 
*
0224A:  MOVLB  A
0224C:  CLRF   x8D
0224E:  CLRF   x8E
02250:  CLRF   x92
02252:  CLRF   x91
02254:  CLRF   x90
02256:  CLRF   x8F
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
.................... //    // Check the weight deviation from Selected SKU Average Weight 
.................... //    if (i32LastWeight > (g_stCurBatchInfo.m_i32AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
.................... //        i32LastWeight < (g_stCurBatchInfo.m_i32AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
.................... //    { 
.................... //        // The weight is out of range, we are not inserting this weight into Average weight queue  
.................... //        return; 
.................... //    } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
02258:  MOVLB  6
0225A:  INCF   xD7,F
....................      
....................     // Check queue rear with size. 
....................     if(g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
0225C:  MOVF   xD8,W
0225E:  SUBWF  xD7,W
02260:  BTFSS  FD8.0
02262:  GOTO   226C
....................     { 
....................         // Queue is full. 
....................         // Set flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 1; 
02266:  MOVLW  01
02268:  MOVWF  xD9
....................          
....................         // Reset rear. 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
0226A:  CLRF   xD7
....................     } 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i32LastWeight >= g_stAvgWtQueue.m_i32LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
0226C:  MOVLW  B0
0226E:  ADDWF  xDE,W
02270:  MOVWF  00
02272:  MOVLW  04
02274:  ADDWFC xDF,W
02276:  MOVWF  01
02278:  MOVLW  00
0227A:  ADDWFC xE0,W
0227C:  MOVWF  02
0227E:  MOVLW  00
02280:  ADDWFC xE1,W
02282:  MOVWF  03
02284:  MOVLB  A
02286:  SUBWF  x8C,W
02288:  BTFSS  FD8.0
0228A:  GOTO   22C4
0228E:  BTFSS  FD8.2
02290:  GOTO   22BE
02294:  MOVF   02,W
02296:  SUBWF  x8B,W
02298:  BTFSS  FD8.0
0229A:  GOTO   22C4
0229E:  BTFSS  FD8.2
022A0:  GOTO   22BE
022A4:  MOVF   01,W
022A6:  SUBWF  x8A,W
022A8:  BTFSS  FD8.0
022AA:  GOTO   22C4
022AE:  BTFSS  FD8.2
022B0:  GOTO   22BE
022B4:  MOVF   00,W
022B6:  SUBWF  x89,W
022B8:  BTFSS  FD8.0
022BA:  GOTO   22C4
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
022BE:  MOVLB  6
022C0:  CLRF   xD7
022C2:  MOVLB  A
....................     } 
....................      
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i32Arr[g_stAvgWtQueue.m_i8Rear] = i32LastWeight; 
022C4:  MOVLB  6
022C6:  MOVF   xD7,W
022C8:  MULLW  04
022CA:  MOVF   FF3,W
022CC:  CLRF   03
022CE:  ADDLW  0F
022D0:  MOVWF  FE9
022D2:  MOVLW  06
022D4:  ADDWFC 03,W
022D6:  MOVWF  FEA
022D8:  MOVFF  A89,FEF
022DC:  MOVFF  A8A,FEC
022E0:  MOVFF  A8B,FEC
022E4:  MOVFF  A8C,FEC
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
022E8:  DECFSZ xD9,W
022EA:  GOTO   22FC
....................     { 
....................         // Set maximum entry will be same as queue size. 
....................         i8MaxEntry = SIZE_AVG_WT_ARR; 
022EE:  MOVLW  32
022F0:  MOVLB  A
022F2:  MOVWF  x8E
....................          
....................         // Reset queue full flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 0; 
022F4:  MOVLB  6
022F6:  CLRF   xD9
....................     } 
022F8:  GOTO   2306
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
022FC:  MOVLW  01
022FE:  ADDWF  xD7,W
02300:  MOVLB  A
02302:  MOVWF  x8E
02304:  MOVLB  6
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
02306:  MOVLB  A
02308:  CLRF   x8D
0230A:  MOVF   x8E,W
0230C:  SUBWF  x8D,W
0230E:  BTFSC  FD8.0
02310:  GOTO   234C
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i32Arr[i8LoopCount]; 
02314:  MOVF   x8D,W
02316:  MULLW  04
02318:  MOVF   FF3,W
0231A:  CLRF   03
0231C:  ADDLW  0F
0231E:  MOVWF  FE9
02320:  MOVLW  06
02322:  ADDWFC 03,W
02324:  MOVWF  FEA
02326:  MOVFF  FEF,00
0232A:  MOVFF  FEC,01
0232E:  MOVFF  FEC,02
02332:  MOVFF  FEC,03
02336:  MOVF   00,W
02338:  ADDWF  x8F,F
0233A:  MOVF   01,W
0233C:  ADDWFC x90,F
0233E:  MOVF   02,W
02340:  ADDWFC x91,F
02342:  MOVF   03,W
02344:  ADDWFC x92,F
02346:  INCF   x8D,F
02348:  GOTO   230A
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32CurAvg = (int32)(i32Sum / (int32)i8MaxEntry); 
0234C:  MOVFF  A8E,00
02350:  CLRF   01
02352:  CLRF   02
02354:  CLRF   03
02356:  MOVFF  03,A96
0235A:  MOVFF  02,A95
0235E:  MOVFF  01,A94
02362:  MOVFF  00,A93
02366:  BCF    FD8.1
02368:  MOVFF  A92,A9A
0236C:  MOVFF  A91,A99
02370:  MOVFF  A90,A98
02374:  MOVFF  A8F,A97
02378:  MOVFF  03,A9E
0237C:  MOVFF  02,A9D
02380:  MOVFF  01,A9C
02384:  MOVFF  00,A9B
02388:  MOVLB  0
0238A:  CALL   1E02
0238E:  MOVFF  03,6DD
02392:  MOVFF  02,6DC
02396:  MOVFF  01,6DB
0239A:  MOVFF  00,6DA
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i32LstAvg = g_stAvgWtQueue.m_i32CurAvg; 
0239E:  MOVFF  6DD,6E1
023A2:  MOVFF  6DC,6E0
023A6:  MOVFF  6DB,6DF
023AA:  MOVFF  6DA,6DE
023AE:  GOTO   25AC (RETURN)
.................... } 
....................  
.................... void IBUSendProdModeAvgData() 
023B2:  MOVLB  A
023B4:  CLRF   x96
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBU Data Node 
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32Padding  = 0; 
023B6:  MOVLB  0
023B8:  CLRF   x67
023BA:  CLRF   x66
023BC:  CLRF   x65
023BE:  CLRF   x64
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg   = g_stAvgWtQueue.m_i32CurAvg; 
023C0:  MOVFF  6DD,63
023C4:  MOVFF  6DC,62
023C8:  MOVFF  6DB,61
023CC:  MOVFF  6DA,60
....................      
....................     // Stuff IBU Command 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_PROD_AVG_WT_DATA; 
023D0:  MOVLW  87
023D2:  MOVLB  A
023D4:  MOVWF  x8B
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
023D6:  MOVLW  01
023D8:  MOVWF  x96
023DA:  MOVF   x96,W
023DC:  SUBLW  08
023DE:  BTFSS  FD8.0
023E0:  GOTO   241A
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
023E4:  CLRF   03
023E6:  MOVF   x96,W
023E8:  ADDLW  8B
023EA:  MOVWF  01
023EC:  MOVLW  0A
023EE:  ADDWFC 03,F
023F0:  MOVFF  03,A98
023F4:  MOVLW  01
023F6:  SUBWF  x96,W
023F8:  CLRF   03
023FA:  ADDLW  60
023FC:  MOVWF  FE9
023FE:  MOVLW  00
02400:  ADDWFC 03,W
02402:  MOVWF  FEA
02404:  MOVFF  FEF,A99
02408:  MOVFF  A98,FEA
0240C:  MOVFF  01,FE9
02410:  MOVFF  A99,FEF
02414:  INCF   x96,F
02416:  GOTO   23DA
....................     } 
....................      
....................     // Send to IBU Insert. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
0241A:  MOVLW  01
0241C:  MOVWF  x98
0241E:  SETF   x97
02420:  MOVLW  0A
02422:  MOVWF  x9A
02424:  MOVLW  89
02426:  MOVWF  x99
02428:  MOVLB  0
0242A:  CALL   1114
0242E:  GOTO   25B0 (RETURN)
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_M0.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
....................  
.................... #define EEPROM_ADDRESS_FOR_LCF                       100 
.................... #define EEPROM_ADDRESS_FOR_MAX_WT                    110    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_MIN_WT                    114    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY       118 
.................... #define EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY  120 
.................... #define EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY       122 
.................... #define EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY 124    // 2-Byte 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
*
017E8:  MOVLB  A
017EA:  CLRF   x84
017EC:  CLRF   x83
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
017EE:  MOVFF  A82,A84
017F2:  MOVFF  A81,A83
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
017F6:  CLRF   x8A
017F8:  MOVLW  64
017FA:  MOVWF  x89
017FC:  MOVFF  A84,A8C
01800:  MOVFF  A83,A8B
01804:  MOVLB  0
01806:  CALL   1766
0180A:  GOTO   1A82 (RETURN)
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
*
0075A:  MOVLB  A
0075C:  CLRF   x75
0075E:  CLRF   x74
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
00760:  CLRF   x7D
00762:  MOVLW  64
00764:  MOVWF  x7C
00766:  MOVLB  0
00768:  CALL   0644
0076C:  MOVFF  02,A75
00770:  MOVFF  01,A74
....................      
....................     return((int16)ui16RetrieveLCF); 
00774:  MOVLB  A
00776:  MOVFF  A74,01
0077A:  MOVFF  A75,02
0077E:  MOVLB  0
00780:  GOTO   0BB4 (RETURN)
.................... } 
....................  
.................... void WriteMaxWeightToEEPROM(int32 i32MaxWeight) 
*
0180E:  MOVLB  A
01810:  CLRF   x86
01812:  CLRF   x85
01814:  CLRF   x88
01816:  CLRF   x87
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 16); 
01818:  MOVFF  A83,A85
0181C:  MOVFF  A84,A86
01820:  CLRF   03
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
01822:  CLRF   x88
01824:  MOVLW  6E
01826:  MOVWF  x87
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
01828:  MOVFF  A88,A8A
0182C:  MOVFF  A87,A89
01830:  MOVFF  A86,A8C
01834:  MOVFF  A85,A8B
01838:  MOVLB  0
0183A:  CALL   1766
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 0); 
0183E:  MOVFF  A84,03
01842:  MOVFF  A83,02
01846:  MOVFF  A82,A86
0184A:  MOVFF  A81,A85
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
0184E:  MOVLW  02
01850:  MOVLB  A
01852:  ADDWF  x87,F
01854:  MOVLW  00
01856:  ADDWFC x88,F
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
01858:  MOVFF  A88,A8A
0185C:  MOVFF  A87,A89
01860:  MOVFF  A86,A8C
01864:  MOVFF  A85,A8B
01868:  MOVLB  0
0186A:  CALL   1766
0186E:  GOTO   1BB8 (RETURN)
.................... } 
....................  
.................... void WriteMinWeightToEEPROM(int32 i32MinWeight) 
01872:  MOVLB  A
01874:  CLRF   x86
01876:  CLRF   x85
01878:  CLRF   x88
0187A:  CLRF   x87
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 16); 
0187C:  MOVFF  A83,A85
01880:  MOVFF  A84,A86
01884:  CLRF   03
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
01886:  CLRF   x88
01888:  MOVLW  72
0188A:  MOVWF  x87
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
0188C:  MOVFF  A88,A8A
01890:  MOVFF  A87,A89
01894:  MOVFF  A86,A8C
01898:  MOVFF  A85,A8B
0189C:  MOVLB  0
0189E:  CALL   1766
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 0); 
018A2:  MOVFF  A84,03
018A6:  MOVFF  A83,02
018AA:  MOVFF  A82,A86
018AE:  MOVFF  A81,A85
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
018B2:  MOVLW  02
018B4:  MOVLB  A
018B6:  ADDWF  x87,F
018B8:  MOVLW  00
018BA:  ADDWFC x88,F
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue);     
018BC:  MOVFF  A88,A8A
018C0:  MOVFF  A87,A89
018C4:  MOVFF  A86,A8C
018C8:  MOVFF  A85,A8B
018CC:  MOVLB  0
018CE:  CALL   1766
018D2:  GOTO   1BCC (RETURN)
.................... } 
....................  
.................... int32 ReadMaxWeightFromEEPROM(void) 
*
009BE:  MOVLB  A
009C0:  CLRF   x75
009C2:  CLRF   x74
009C4:  CLRF   x77
009C6:  CLRF   x76
009C8:  CLRF   x7B
009CA:  CLRF   x7A
009CC:  CLRF   x79
009CE:  CLRF   x78
.................... { 
....................     unsigned int16 ui16WordValue     = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MaxWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
009D0:  CLRF   x77
009D2:  MOVLW  6E
009D4:  MOVWF  x76
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
009D6:  MOVFF  A77,A7D
009DA:  MOVFF  A76,A7C
009DE:  MOVLB  0
009E0:  CALL   0644
009E4:  MOVFF  02,A75
009E8:  MOVFF  01,A74
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MaxWeight = (int32)ui16WordValue; 
009EC:  MOVLB  A
009EE:  CLRF   x7B
009F0:  CLRF   x7A
009F2:  MOVFF  A75,A79
009F6:  MOVFF  A74,A78
....................     // Shift data to MSB. 
....................     i32MaxWeight = (i32MaxWeight << 16); 
009FA:  MOVFF  A79,A7B
009FE:  MOVFF  A78,A7A
00A02:  CLRF   x78
00A04:  CLRF   x79
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
00A06:  MOVLW  02
00A08:  ADDWF  x76,F
00A0A:  MOVLW  00
00A0C:  ADDWFC x77,F
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
00A0E:  MOVFF  A77,A7D
00A12:  MOVFF  A76,A7C
00A16:  MOVLB  0
00A18:  CALL   0644
00A1C:  MOVFF  02,A75
00A20:  MOVFF  01,A74
....................     i32MaxWeight = (((int16)ui16WordValue) | (i32MaxWeight & 0xFFFF0000)); 
00A24:  CLRF   00
00A26:  CLRF   01
00A28:  MOVLB  A
00A2A:  MOVFF  A7A,A7A
00A2E:  MOVFF  A7B,A7B
00A32:  MOVF   00,W
00A34:  IORWF  x74,W
00A36:  MOVWF  x78
00A38:  MOVF   01,W
00A3A:  IORWF  x75,W
00A3C:  MOVWF  x79
....................      
....................     return i32MaxWeight; 
00A3E:  MOVFF  A78,00
00A42:  MOVFF  A79,01
00A46:  MOVFF  A7A,02
00A4A:  MOVFF  A7B,03
00A4E:  MOVLB  0
00A50:  GOTO   0C10 (RETURN)
.................... } 
....................  
.................... int32 ReadMinWeightFromEEPROM(void) 
00A54:  MOVLB  A
00A56:  CLRF   x75
00A58:  CLRF   x74
00A5A:  CLRF   x77
00A5C:  CLRF   x76
00A5E:  CLRF   x7B
00A60:  CLRF   x7A
00A62:  CLRF   x79
00A64:  CLRF   x78
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MinWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
00A66:  CLRF   x77
00A68:  MOVLW  72
00A6A:  MOVWF  x76
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
00A6C:  MOVFF  A77,A7D
00A70:  MOVFF  A76,A7C
00A74:  MOVLB  0
00A76:  CALL   0644
00A7A:  MOVFF  02,A75
00A7E:  MOVFF  01,A74
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MinWeight = (int32)ui16WordValue; 
00A82:  MOVLB  A
00A84:  CLRF   x7B
00A86:  CLRF   x7A
00A88:  MOVFF  A75,A79
00A8C:  MOVFF  A74,A78
....................     // Shift data to MSB. 
....................     i32MinWeight = (i32MinWeight << 16); 
00A90:  MOVFF  A79,A7B
00A94:  MOVFF  A78,A7A
00A98:  CLRF   x78
00A9A:  CLRF   x79
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
00A9C:  MOVLW  02
00A9E:  ADDWF  x76,F
00AA0:  MOVLW  00
00AA2:  ADDWFC x77,F
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
00AA4:  MOVFF  A77,A7D
00AA8:  MOVFF  A76,A7C
00AAC:  MOVLB  0
00AAE:  CALL   0644
00AB2:  MOVFF  02,A75
00AB6:  MOVFF  01,A74
....................     i32MinWeight = (((int16)ui16WordValue) | (i32MinWeight & 0xFFFF0000)); 
00ABA:  CLRF   00
00ABC:  CLRF   01
00ABE:  MOVLB  A
00AC0:  MOVFF  A7A,A7A
00AC4:  MOVFF  A7B,A7B
00AC8:  MOVF   00,W
00ACA:  IORWF  x74,W
00ACC:  MOVWF  x78
00ACE:  MOVF   01,W
00AD0:  IORWF  x75,W
00AD2:  MOVWF  x79
....................      
....................     return i32MinWeight;     
00AD4:  MOVFF  A78,00
00AD8:  MOVFF  A79,01
00ADC:  MOVFF  A7A,02
00AE0:  MOVFF  A7B,03
00AE4:  MOVLB  0
00AE6:  GOTO   0C24 (RETURN)
.................... } 
....................  
.................... void WritePipePresenceDelayToEEPROM(unsigned int16 ui16PipePresenceDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY, ui16PipePresenceDelay); 
*
018D6:  MOVLB  A
018D8:  CLRF   x8A
018DA:  MOVLW  76
018DC:  MOVWF  x89
018DE:  MOVFF  A82,A8C
018E2:  MOVFF  A81,A8B
018E6:  MOVLB  0
018E8:  CALL   1766
018EC:  GOTO   1C3A (RETURN)
.................... } 
....................  
.................... unsigned int16 ReadPipePresenceDelayFromEEPROM(void) 
*
006B2:  MOVLB  A
006B4:  CLRF   x75
006B6:  CLRF   x74
.................... { 
....................     unsigned int16 ui16PipePresenceDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipePresenceDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY); 
006B8:  CLRF   x7D
006BA:  MOVLW  76
006BC:  MOVWF  x7C
006BE:  MOVLB  0
006C0:  CALL   0644
006C4:  MOVFF  02,A75
006C8:  MOVFF  01,A74
....................      
....................     return ui16PipePresenceDelayTime; 
006CC:  MOVLB  A
006CE:  MOVFF  A74,01
006D2:  MOVFF  A75,02
006D6:  MOVLB  0
006D8:  GOTO   0B24 (RETURN)
.................... } 
....................  
.................... void WritePipeStabilizationDelayToEEPROM(unsigned int16 ui16PipeStabilizationDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY, ui16PipeStabilizationDelay);     
*
018F0:  MOVLB  A
018F2:  CLRF   x8A
018F4:  MOVLW  78
018F6:  MOVWF  x89
018F8:  MOVFF  A82,A8C
018FC:  MOVFF  A81,A8B
01900:  MOVLB  0
01902:  CALL   1766
01906:  GOTO   1C5C (RETURN)
.................... } 
....................  
.................... unsigned int16 ReadPipeStabilizationDelayFromEEPROM(void) 
*
006DC:  MOVLB  A
006DE:  CLRF   x75
006E0:  CLRF   x74
.................... { 
....................     unsigned int16 ui16PipeStabilizationDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipeStabilizationDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY); 
006E2:  CLRF   x7D
006E4:  MOVLW  78
006E6:  MOVWF  x7C
006E8:  MOVLB  0
006EA:  CALL   0644
006EE:  MOVFF  02,A75
006F2:  MOVFF  01,A74
....................      
....................     return ui16PipeStabilizationDelayTime;     
006F6:  MOVLB  A
006F8:  MOVFF  A74,01
006FC:  MOVFF  A75,02
00700:  MOVLB  0
00702:  GOTO   0B30 (RETURN)
.................... } 
....................  
....................  
.................... void WritePipeTransferDelayToEEPROM(unsigned int16 g_ui16PipeTransferDelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY, g_ui16PipeTransferDelayTime);     
*
0190A:  MOVLB  A
0190C:  CLRF   x8A
0190E:  MOVLW  7A
01910:  MOVWF  x89
01912:  MOVFF  A82,A8C
01916:  MOVFF  A81,A8B
0191A:  MOVLB  0
0191C:  CALL   1766
01920:  GOTO   1C7E (RETURN)
.................... } 
....................  
.................... unsigned int16 ReadPipeTransferDelayTime(void) 
*
00706:  MOVLB  A
00708:  CLRF   x75
0070A:  CLRF   x74
.................... { 
....................     unsigned int16 ui16PipeTransferDelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16PipeTransferDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY); 
0070C:  CLRF   x7D
0070E:  MOVLW  7A
00710:  MOVWF  x7C
00712:  MOVLB  0
00714:  CALL   0644
00718:  MOVFF  02,A75
0071C:  MOVFF  01,A74
....................      
....................     return ui16PipeTransferDelayTime;      
00720:  MOVLB  A
00722:  MOVFF  A74,01
00726:  MOVFF  A75,02
0072A:  MOVLB  0
0072C:  GOTO   0B3C (RETURN)
.................... }     
....................  
.................... void WriteWeighingCylinderActivationDelayToEEPROM(unsigned int16 ui16DelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY, ui16DelayTime);     
*
01924:  MOVLB  A
01926:  CLRF   x8A
01928:  MOVLW  7C
0192A:  MOVWF  x89
0192C:  MOVFF  A82,A8C
01930:  MOVFF  A81,A8B
01934:  MOVLB  0
01936:  CALL   1766
0193A:  GOTO   1CE4 (RETURN)
.................... } 
....................  
.................... unsigned int16 ReadWeighingCylinderActivationDelayfromEEPROM(void) 
*
00730:  MOVLB  A
00732:  CLRF   x75
00734:  CLRF   x74
.................... { 
....................     unsigned int16 ui16DelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16DelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY); 
00736:  CLRF   x7D
00738:  MOVLW  7C
0073A:  MOVWF  x7C
0073C:  MOVLB  0
0073E:  CALL   0644
00742:  MOVFF  02,A75
00746:  MOVFF  01,A74
....................      
....................     return ui16DelayTime;     
0074A:  MOVLB  A
0074C:  MOVFF  A74,01
00750:  MOVFF  A75,02
00754:  MOVLB  0
00756:  GOTO   0B48 (RETURN)
.................... } 
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
.................... #include "vmM0Common.h" 
.................... /*  
....................  * File:   vmM0Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on August 10, 2019, 9:35 AM 
....................  */ 
....................  
.................... #ifndef VMM0COMMON_H 
.................... #define	VMM0COMMON_H 
....................  
.................... //unsigned int8 g_ui8IBCTareDataSendDone = FALSE; 
....................  
.................... #define STATE_NOTHING            190 
.................... #define STATE_CALIB_STEP_WAITING 130 
.................... #define STATE_CALIB_STEP_1       131 
.................... #define STATE_CALIB_STEP_2       132 
.................... #define STATE_CALIB_STEP_3       133 
.................... #define STATE_CALIB_STEP_4       134 
.................... #define STATE_CALIB_STEP_5       135 
.................... #define STATE_CALIB_STEP_6       136 
.................... #define STATE_CALIB_STEP_7       137 
.................... #define STATE_CALIB_STEP_8       138 
.................... #define STATE_CALIB_STEP_9       139 
.................... #define STATE_CALIB_STEP_10      140 
....................  
.................... unsigned int8 g_ui8CurrentState  = 0; 
.................... unsigned int8 g_ui8StateWaiting = STATE_NOTHING; 
....................  
.................... unsigned int32 g_ui32CurPipeADCValue = 0; 
.................... unsigned int32 g_ui32CurPipeWeight   = 0; 
....................  
.................... #endif	/* VMM0COMMON_H */ 
....................  
....................  
....................  
.................... #define LOAD_CELL_FACTOR         818 
.................... //#define ADC_SCANNING_START     0 
.................... //#define ADC_SCANNING_RUNNING   1 
.................... //#define ADC_SCANNING_STOP      2 
.................... #define ADC_SCAN_ON              1 
.................... #define ADC_SCAN_OFF             0 
....................  
.................... #define TIMER_IGNORE_ON          1 
.................... #define TIMER_IGNORE_OFF         0 
....................  
.................... int8 g_fIgnore_TIMER = TIMER_IGNORE_OFF; 
....................  
....................  
.................... #define COLLECT_DYNAMIC_TARE_DATA           3 
.................... #define COLLECT_WEIGHING_DATA               4 
.................... #define COLLECT_NOTHING                     5 
....................  
.................... #define SIZE_DATA_QUEUE                     20 
.................... #define SIZE_ADC_DATA_QUEUE                 200      //200 
.................... #define SIZE_DATA_QUEUE_FOR_TARE            200 
.................... #define SIZE_DATA_QUEUE_FOR_WEIGHING        200 
.................... #define MAX_TARE_MULTIPLAYER                100 
....................  
.................... #define ADC_DATA_NOT_READY                  0 
.................... #define ADC_DATA_READY                      1 
....................  
.................... #define ADC_DATA_Q_VALUES_TRIMMING_PERCNTG     30 
....................  
.................... #define ADC_MEAN_CALCULATION_START    0 
.................... #define ADC_MEAN_CALCULATION_STOP     1 
.................... #define ADC_MEAN_CALCULATION_RUNNING  2 
.................... #define ADC_MEAN_CALCULATION_DONE     3 
....................  
.................... unsigned int8 g_ui8ADCMeanCalState = ADC_MEAN_CALCULATION_STOP; 
.................... unsigned int32 g_ui32ADCCurMeanValue = 0; 
.................... unsigned int32 g_ui32ADCCurSum       = 0; 
.................... unsigned int32 g_ui32TarePrev     = 0; 
.................... unsigned int32 g_ui32PipeWtPrev   = 0; 
.................... unsigned int16 g_ui16ADCSumLoopCount = 0; 
.................... int16          g_i16LoadCellFactor   = 0; 
.................... float32        g_f32LoadCellFactor   = 0; 
....................  
.................... //AMIT 02/12/2020 START 
.................... unsigned int32 g_ui32ADCArr[SIZE_ADC_DATA_QUEUE]; 
.................... int16          g_i16ADCArrIdx = 0; 
.................... //AMIT 02/12/2020 END 
....................  
.................... unsigned int8  g_ui8ADCScanningStatus   = ADC_SCAN_OFF; 
.................... unsigned int32 g_ui32ADCValue           = 0; 
.................... unsigned int8  g_ui8DataCollectionState = COLLECT_NOTHING; 
.................... unsigned int8  g_fADCDataReadyStatus    = ADC_DATA_NOT_READY; 
.................... unsigned int8 g_ui8CurMaxDataCount    = 0; 
....................  
.................... unsigned int16    g_ui16NoOfADCData   = 0; 
.................... unsigned int32    g_ui32ADCAvg        = 0; 
....................  
.................... //unsigned int8       g_ui8ArrSortedTemp[SIZE_DATA_QUEUE]          = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrMeanShiftVal[SIZE_DATA_QUEUE]       = {0}; 
.................... //ST_MEAN_SHIFT_VALUE g_ui16ArrSortedMeanShiftVal[SIZE_DATA_QUEUE] = {0}; 
....................  
.................... void ResetADCDataQ(int8 i8CollectionState); 
.................... unsigned int32 GetADCMeanValue(); 
.................... unsigned int32 GetTareData(); 
.................... int16          GetWeighingData(unsigned int32); 
.................... //void           IBUSendWeighingData(); 
.................... //void           IBUSendTareData(); 
.................... void           IBUSendTareData(unsigned int32); 
....................  
....................  
....................  
.................... int32 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
*
0205A:  MOVLB  A
0205C:  CLRF   x7A
0205E:  CLRF   x79
02060:  CLRF   x78
02062:  CLRF   x77
02064:  CLRF   x7E
02066:  CLRF   x7D
02068:  CLRF   x7C
0206A:  CLRF   x7B
0206C:  CLRF   x82
0206E:  CLRF   x81
02070:  CLRF   x80
02072:  CLRF   x7F
.................... { 
....................     int32 i32ActualWeight = 0; 
....................     int32    i32Temp = 0; 
....................     float32  f32Temp = 0; 
....................  
....................     f32Temp = (float32)ui32ADCMean * g_f32LoadCellFactor;   //g_f32LoadCellFactor 
02074:  MOVFF  A76,A86
02078:  MOVFF  A75,A85
0207C:  MOVFF  A74,A84
02080:  MOVFF  A73,A83
02084:  MOVLB  0
02086:  GOTO   1EAE
0208A:  MOVFF  03,A86
0208E:  MOVFF  02,A85
02092:  MOVFF  01,A84
02096:  MOVFF  00,A83
0209A:  MOVFF  03,A8A
0209E:  MOVFF  02,A89
020A2:  MOVFF  01,A88
020A6:  MOVFF  00,A87
020AA:  MOVFF  705,A8E
020AE:  MOVFF  704,A8D
020B2:  MOVFF  703,A8C
020B6:  MOVFF  702,A8B
020BA:  GOTO   1EF2
020BE:  MOVFF  03,A82
020C2:  MOVFF  02,A81
020C6:  MOVFF  01,A80
020CA:  MOVFF  00,A7F
....................     i32Temp = (int32)f32Temp; 
020CE:  MOVFF  A82,A86
020D2:  MOVFF  A81,A85
020D6:  MOVFF  A80,A84
020DA:  MOVFF  A7F,A83
020DE:  GOTO   2012
020E2:  MOVFF  03,A7E
020E6:  MOVFF  02,A7D
020EA:  MOVFF  01,A7C
020EE:  MOVFF  00,A7B
....................     i32Temp /= 1000; 
020F2:  BCF    FD8.1
020F4:  MOVFF  A7E,A9A
020F8:  MOVFF  A7D,A99
020FC:  MOVFF  A7C,A98
02100:  MOVFF  A7B,A97
02104:  MOVLB  A
02106:  CLRF   x9E
02108:  CLRF   x9D
0210A:  MOVLW  03
0210C:  MOVWF  x9C
0210E:  MOVLW  E8
02110:  MOVWF  x9B
02112:  MOVLB  0
02114:  CALL   1E02
02118:  MOVFF  03,A7E
0211C:  MOVFF  02,A7D
02120:  MOVFF  01,A7C
02124:  MOVFF  00,A7B
....................     i32ActualWeight = i32Temp; 
02128:  MOVFF  A7E,A7A
0212C:  MOVFF  A7D,A79
02130:  MOVFF  A7C,A78
02134:  MOVFF  A7B,A77
....................  
....................     return i32ActualWeight; 
02138:  MOVFF  A77,00
0213C:  MOVFF  A78,01
02140:  MOVFF  A79,02
02144:  MOVFF  A7A,03
02148:  RETURN 0
.................... } 
.................... ////////int16 GetCalibratedWeight(unsigned int32 ui32ADCMean) 
.................... ////////{ 
.................... ////////    int16 i16ActualWeight = 0; 
.................... ////////    int32    i32Temp = 0; 
.................... ////////    float32  f32Temp = 0; 
.................... ////////    unsigned int32 ui32DiffValue = 0; 
.................... ////////     
.................... //////// 
.................... ////////    if(COLLECT_DYNAMIC_TARE_DATA == g_stADCDataQ.m_i8CollectionState) 
.................... ////////    { 
.................... ////////        ui32DiffValue = ui32ADCMean; 
.................... ////////        f32Temp = (float32)ui32DiffValue * g_f32LoadCellFactor;   //g_f32LoadCellFactor 
.................... ////////        i32Temp = (int32)f32Temp; 
.................... ////////        i32Temp /= 1000; 
.................... ////////        i16ActualWeight = (int16)i32Temp; 
.................... ////////    } 
.................... ////////    else if(COLLECT_WEIGHING_DATA == g_stADCDataQ.m_i8CollectionState) 
.................... ////////    { 
.................... ////////        ui32DiffValue = ui32ADCMean - g_ui32DynamicTareADCValue; 
.................... ////////        f32Temp = (float32)ui32DiffValue * g_f32LoadCellFactor; 
.................... ////////        i32Temp = (int32)f32Temp; 
.................... ////////        i32Temp /= 1000; 
.................... ////////        i16ActualWeight = (int16)i32Temp; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        /* Do Nothing */ 
.................... ////////    } 
.................... ////////  
.................... ////////    return i16ActualWeight; 
.................... ////////} 
....................  
.................... int16 GetWeighingData(unsigned int32 ui32ADCMean) 
.................... { 
....................     int16 i16CalibratedWeight = 0; 
....................     unsigned int16 ui16TempTareWeight   = 0; 
....................     unsigned int16 ui16TempDynErrValue  = 0;     
....................      
....................     i16CalibratedWeight = GetCalibratedWeight(ui32ADCMean); 
....................      
....................      
....................     return i16CalibratedWeight; 
.................... } 
....................  
....................  
.................... void IBUSendWeighingData(int32 i32PipeWeight) 
*
02432:  MOVLB  A
02434:  CLRF   x84
02436:  CLRF   x88
02438:  CLRF   x87
0243A:  CLRF   x86
0243C:  CLRF   x85
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8             i8LoopCount         = 0; 
....................     int32            i32AvgWeight        = 0; 
....................      
....................     // To insert current pipe weight into average weight queue. 
....................     i32AvgWeight = i32PipeWeight; 
0243E:  MOVFF  A76,A88
02442:  MOVFF  A75,A87
02446:  MOVFF  A74,A86
0244A:  MOVFF  A73,A85
....................     // Increment pipe count. 
....................     g_ui16PipeCount++; 
0244E:  MOVLB  5
02450:  INCF   xE0,F
02452:  BTFSC  FD8.2
02454:  INCF   xE1,F
....................      
....................     // Now Check if the Weight is within tolerance limit or not 
....................     if (i32PipeWeight > g_stCurBatchInfo.m_i32MaxWt) 
02456:  MOVLB  6
02458:  MOVF   x08,W
0245A:  MOVLB  A
0245C:  SUBWF  x76,W
0245E:  BTFSS  FD8.0
02460:  GOTO   24B6
02464:  BTFSS  FD8.2
02466:  GOTO   24A4
0246A:  MOVLB  6
0246C:  MOVF   x07,W
0246E:  MOVLB  A
02470:  SUBWF  x75,W
02472:  BTFSS  FD8.0
02474:  GOTO   24B6
02478:  BTFSS  FD8.2
0247A:  GOTO   24A4
0247E:  MOVLB  6
02480:  MOVF   x06,W
02482:  MOVLB  A
02484:  SUBWF  x74,W
02486:  BTFSS  FD8.0
02488:  GOTO   24B6
0248C:  BTFSS  FD8.2
0248E:  GOTO   24A4
02492:  MOVF   x73,W
02494:  MOVLB  6
02496:  SUBWF  x05,W
02498:  BTFSS  FD8.0
0249A:  BRA    24A2
0249C:  MOVLB  A
0249E:  GOTO   24B6
024A2:  MOVLB  A
....................     { 
....................         // Set Weighing Status. 
....................         g_ui16RejectionStatus = PIPE_OVER_WEIGHT; 
024A4:  MOVLB  5
024A6:  CLRF   xD6
024A8:  MOVLW  01
024AA:  MOVWF  xD5
....................          
....................         // Set Indication of Tower light. 
....................         output_bit(PIN_OUT_DO_03, 0);  
024AC:  BCF    F7C.2
024AE:  BCF    F84.2
....................          
....................     } 
024B0:  GOTO   251A
024B4:  MOVLB  A
....................     else if (i32PipeWeight < g_stCurBatchInfo.m_i32MinWt) 
024B6:  MOVF   x76,W
024B8:  MOVLB  6
024BA:  SUBWF  x0C,W
024BC:  BTFSS  FD8.0
024BE:  GOTO   2512
024C2:  BTFSS  FD8.2
024C4:  GOTO   2502
024C8:  MOVLB  A
024CA:  MOVF   x75,W
024CC:  MOVLB  6
024CE:  SUBWF  x0B,W
024D0:  BTFSS  FD8.0
024D2:  GOTO   2512
024D6:  BTFSS  FD8.2
024D8:  GOTO   2502
024DC:  MOVLB  A
024DE:  MOVF   x74,W
024E0:  MOVLB  6
024E2:  SUBWF  x0A,W
024E4:  BTFSS  FD8.0
024E6:  GOTO   2512
024EA:  BTFSS  FD8.2
024EC:  GOTO   2502
024F0:  MOVF   x09,W
024F2:  MOVLB  A
024F4:  SUBWF  x73,W
024F6:  BTFSS  FD8.0
024F8:  BRA    2500
024FA:  MOVLB  6
024FC:  GOTO   2512
02500:  MOVLB  6
....................     { 
....................         // Set Weighing Status.         
....................         g_ui16RejectionStatus = PIPE_UNDER_WEIGHT; 
02502:  MOVLB  5
02504:  CLRF   xD6
02506:  CLRF   xD5
....................          
....................         // Set Indication of Tower light. 
....................         output_bit(PIN_OUT_DO_04, 0);         
02508:  BCF    F7C.3
0250A:  BCF    F84.3
....................     } 
0250C:  GOTO   251A
02510:  MOVLB  6
....................     else 
....................     { 
....................         g_ui16RejectionStatus = PIPE_ACCEPTED; 
02512:  MOVLB  5
02514:  CLRF   xD6
02516:  MOVLW  02
02518:  MOVWF  xD5
....................         // Set Rejection State OFF 
....................         //g_unDIState.m_stAllDIBits.m_ui1GDICn01 = BOX_ACCEPTED; 
....................     } 
....................  
....................  
....................     // Prepare IBU Data Node 
....................     g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_i32PipeWeight  = i32PipeWeight; 
0251A:  MOVFF  A76,3F
0251E:  MOVFF  A75,3E
02522:  MOVFF  A74,3D
02526:  MOVFF  A73,3C
....................     g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PassStatus = g_ui16RejectionStatus; 
0252A:  MOVFF  5D6,43
0252E:  MOVFF  5D5,42
....................     g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PipeCount  = g_ui16PipeCount; 
02532:  MOVFF  5E1,41
02536:  MOVFF  5E0,40
....................      
....................     // Stuff IBU Command 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_PROD_WEIGH_DATA; 
0253A:  MOVLW  84
0253C:  MOVLB  A
0253E:  MOVWF  x79
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
02540:  MOVLW  01
02542:  MOVWF  x84
02544:  MOVF   x84,W
02546:  SUBLW  08
02548:  BTFSS  FD8.0
0254A:  GOTO   2584
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUProdModeWtStsData.m_ui8Arr[i8LoopCount - 1]; 
0254E:  CLRF   03
02550:  MOVF   x84,W
02552:  ADDLW  79
02554:  MOVWF  01
02556:  MOVLW  0A
02558:  ADDWFC 03,F
0255A:  MOVFF  03,A8A
0255E:  MOVLW  01
02560:  SUBWF  x84,W
02562:  CLRF   03
02564:  ADDLW  3C
02566:  MOVWF  FE9
02568:  MOVLW  00
0256A:  ADDWFC 03,W
0256C:  MOVWF  FEA
0256E:  MOVFF  FEF,A8B
02572:  MOVFF  A8A,FEA
02576:  MOVFF  01,FE9
0257A:  MOVFF  A8B,FEF
0257E:  INCF   x84,F
02580:  GOTO   2544
....................     } 
....................      
....................     // Send to IBU Insert. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
02584:  MOVLW  01
02586:  MOVWF  x98
02588:  SETF   x97
0258A:  MOVLW  0A
0258C:  MOVWF  x9A
0258E:  MOVLW  77
02590:  MOVWF  x99
02592:  MOVLB  0
02594:  CALL   1114
....................      
....................     // Send last pipe weight to calculate running average weight. 
....................     InsertAvgWtQueue(i32AvgWeight); 
02598:  MOVFF  A88,A8C
0259C:  MOVFF  A87,A8B
025A0:  MOVFF  A86,A8A
025A4:  MOVFF  A85,A89
025A8:  GOTO   224A
....................      
....................     // Send calculated average weight to HMI. 
....................     IBUSendProdModeAvgData(); 
025AC:  GOTO   23B2
025B0:  GOTO   2A92 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void IBUSendTareData(unsigned int32 ui32ADCMean) 
*
0214A:  MOVLB  A
0214C:  CLRF   x84
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................  
....................     // Prepare IBU Data Node 
....................     g_unIBUProdModeTrData.m_stTareData.m_i32Padding  = 0; 
0214E:  CLRF   47
02150:  CLRF   46
02152:  CLRF   45
02154:  CLRF   44
....................     g_unIBUProdModeTrData.m_stTareData.m_i32TareData = ui32ADCMean; 
02156:  MOVFF  A76,4B
0215A:  MOVFF  A75,4A
0215E:  MOVFF  A74,49
02162:  MOVFF  A73,48
....................      
....................     // Stuff IBU Command 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_PROD_TARE_DATA; 
02166:  MOVLW  86
02168:  MOVWF  x79
....................  
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
0216A:  MOVLW  01
0216C:  MOVWF  x84
0216E:  MOVF   x84,W
02170:  SUBLW  08
02172:  BTFSS  FD8.0
02174:  GOTO   21AE
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUProdModeTrData.m_ui8Arr[i8LoopCount - 1]; 
02178:  CLRF   03
0217A:  MOVF   x84,W
0217C:  ADDLW  79
0217E:  MOVWF  01
02180:  MOVLW  0A
02182:  ADDWFC 03,F
02184:  MOVFF  03,A86
02188:  MOVLW  01
0218A:  SUBWF  x84,W
0218C:  CLRF   03
0218E:  ADDLW  44
02190:  MOVWF  FE9
02192:  MOVLW  00
02194:  ADDWFC 03,W
02196:  MOVWF  FEA
02198:  MOVFF  FEF,A87
0219C:  MOVFF  A86,FEA
021A0:  MOVFF  01,FE9
021A4:  MOVFF  A87,FEF
021A8:  INCF   x84,F
021AA:  GOTO   216E
....................     } 
....................  
....................     // Send to IBU Insert 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
021AE:  MOVLW  01
021B0:  MOVWF  x98
021B2:  SETF   x97
021B4:  MOVLW  0A
021B6:  MOVWF  x9A
021B8:  MOVLW  77
021BA:  MOVWF  x99
021BC:  MOVLB  0
021BE:  CALL   1114
021C2:  GOTO   280E (RETURN)
.................... } 
....................  
....................  
....................  
.................... void IBUSendCalibResetData(unsigned int32 ui32ADCMean) 
021C6:  MOVLB  A
021C8:  CLRF   x84
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................     //CHANGE_RUNNING_AVG START 
....................      
....................     // 1. Send Dynamic Tare ADC Value : g_ui32DynamicTareADCValue 
....................     // 2. Send Current Dynamic Weight : ui32ADCMean 
....................      
....................     // Set dynamic tare ADC value and weight ADC value in variables. 
....................     g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForTare   = g_ui32DynamicTareADCValue; 
021CA:  MOVFF  5DF,5B
021CE:  MOVFF  5DE,5A
021D2:  MOVFF  5DD,59
021D6:  MOVFF  5DC,58
....................     g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForWeight = ui32ADCMean; 
021DA:  MOVFF  A76,5F
021DE:  MOVFF  A75,5E
021E2:  MOVFF  A74,5D
021E6:  MOVFF  A73,5C
....................  
....................      
....................     // Stuff IBU Command. 
....................     // 1. Dynamic Tare ADC value. 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_RESET_CALIB_DATA; 
021EA:  MOVLW  68
021EC:  MOVWF  x79
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
021EE:  MOVLW  01
021F0:  MOVWF  x84
021F2:  MOVF   x84,W
021F4:  SUBLW  08
021F6:  BTFSS  FD8.0
021F8:  GOTO   2232
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUResetCalibData.m_ui8Arr[i8LoopCount - 1]; 
021FC:  CLRF   03
021FE:  MOVF   x84,W
02200:  ADDLW  79
02202:  MOVWF  01
02204:  MOVLW  0A
02206:  ADDWFC 03,F
02208:  MOVFF  03,A86
0220C:  MOVLW  01
0220E:  SUBWF  x84,W
02210:  CLRF   03
02212:  ADDLW  58
02214:  MOVWF  FE9
02216:  MOVLW  00
02218:  ADDWFC 03,W
0221A:  MOVWF  FEA
0221C:  MOVFF  FEF,A87
02220:  MOVFF  A86,FEA
02224:  MOVFF  01,FE9
02228:  MOVFF  A87,FEF
0222C:  INCF   x84,F
0222E:  GOTO   21F2
....................     } 
....................      
....................     // Insert in IBU queue. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
02232:  MOVLW  01
02234:  MOVWF  x98
02236:  SETF   x97
02238:  MOVLW  0A
0223A:  MOVWF  x9A
0223C:  MOVLW  77
0223E:  MOVWF  x99
02240:  MOVLB  0
02242:  CALL   1114
02246:  GOTO   29C4 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void AfterADCMeanCalculationDone() 
.................... { 
....................  
....................     // Final Weight Calculation 
....................     if (ADC_MEAN_DATA_FINAL_WEIGHT == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................  
....................         // Step 6: Reset ADC Data Queue 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................          
....................         // Calibration mode 
....................         if (SYS_MODE_CALIB == g_ui8SystemMode) 
....................         { 
....................             // The Final Tare Calculation Done so move to Next Step 
....................             g_ui8CurrentState++; 
....................             g_ui8StateWaiting = STATE_NOTHING; 
....................         } 
....................         if (SYS_MODE_PROD == g_ui8SystemMode) 
....................         { 
....................             g_ui8CurrentState++; 
....................             g_ui8StateWaiting = STATE_NOTHING; 
....................         } 
....................  
....................         //g_fWtCalculationState = FLAG_WT_CALCULATION_DONE; 
....................          
....................         //g_fWeighingStatus = WEIGHING_OFF; 
....................     } 
....................  
....................     // Final Tare Value Set 
....................     if (ADC_MEAN_DATA_FINAL_TARE  == g_ui8ADCMeanDataState) 
....................     { 
....................         // Calibration mode 
....................         if (SYS_MODE_CALIB == g_ui8SystemMode) 
....................         { 
....................             // The Final Tare Calculation Done so move to Next Step 
....................             g_ui8CurrentState++; 
....................             g_ui8StateWaiting = STATE_NOTHING; 
....................         } 
....................         if (SYS_MODE_PROD == g_ui8SystemMode) 
....................         { 
....................             g_ui8CurrentState++; 
....................             g_ui8StateWaiting = STATE_NOTHING; 
....................         } 
....................          
....................         // ADC Mean Calculation Done 
....................         //IBUSendTareData(g_ui32ADCCurMeanValue); 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................     } 
....................      
....................     if (ADC_MEAN_DATA_CALIB_WEIGHT  == g_ui8ADCMeanDataState) 
....................     { 
....................         // ADC Mean Calculation Done 
....................         IBUSendCalibResetData(g_ui32ADCCurMeanValue); 
....................         ResetADCDataQ(COLLECT_NOTHING); 
....................     } 
....................      
....................     // Reset Flags 
....................     g_ui8ADCMeanCalState  = ADC_MEAN_CALCULATION_STOP; 
....................     g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
.................... } 
....................  
....................  
....................  
.................... void SendAlarmtoAnotherMCU(void) 
*
01D7A:  MOVLB  A
01D7C:  CLRF   x80
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................  
....................     // Stuff IBU Command. 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_AIR_PRESSURE_ALARM; 
01D7E:  MOVLW  99
01D80:  MOVWF  x75
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01D82:  MOVLW  01
01D84:  MOVWF  x80
01D86:  MOVF   x80,W
01D88:  SUBLW  08
01D8A:  BTFSS  FD8.0
01D8C:  GOTO   1DA6
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = 0; 
01D90:  CLRF   03
01D92:  MOVF   x80,W
01D94:  ADDLW  75
01D96:  MOVWF  FE9
01D98:  MOVLW  0A
01D9A:  ADDWFC 03,W
01D9C:  MOVWF  FEA
01D9E:  CLRF   FEF
01DA0:  INCF   x80,F
01DA2:  GOTO   1D86
....................     } 
....................      
....................     // Insert in IBU queue. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode);     
01DA6:  MOVLW  01
01DA8:  MOVWF  x98
01DAA:  SETF   x97
01DAC:  MOVLW  0A
01DAE:  MOVWF  x9A
01DB0:  MOVLW  73
01DB2:  MOVWF  x99
01DB4:  MOVLB  0
01DB6:  CALL   1114
01DBA:  GOTO   30E6 (RETURN)
.................... } 
....................  
.................... void SendResetAlarmtoAnotherMCU(void) 
01DBE:  MOVLB  A
01DC0:  CLRF   x80
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................  
....................     // Stuff IBU Command. 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_RESET_AIR_PRESSURE_ALARM; 
01DC2:  MOVLW  9A
01DC4:  MOVWF  x75
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01DC6:  MOVLW  01
01DC8:  MOVWF  x80
01DCA:  MOVF   x80,W
01DCC:  SUBLW  08
01DCE:  BTFSS  FD8.0
01DD0:  GOTO   1DEA
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = 0; 
01DD4:  CLRF   03
01DD6:  MOVF   x80,W
01DD8:  ADDLW  75
01DDA:  MOVWF  FE9
01DDC:  MOVLW  0A
01DDE:  ADDWFC 03,W
01DE0:  MOVWF  FEA
01DE2:  CLRF   FEF
01DE4:  INCF   x80,F
01DE6:  GOTO   1DCA
....................     } 
....................      
....................     // Insert in IBU queue. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode);     
01DEA:  MOVLW  01
01DEC:  MOVWF  x98
01DEE:  SETF   x97
01DF0:  MOVLW  0A
01DF2:  MOVWF  x9A
01DF4:  MOVLW  73
01DF6:  MOVWF  x99
01DF8:  MOVLB  0
01DFA:  CALL   1114
01DFE:  GOTO   3106 (RETURN)
.................... } 
....................  
.................... #endif	/* VM_ADCMANAGER_H */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
....................  
....................  
.................... // PWT Start 
.................... #define PIPE_PRESENT      0 
.................... #define PIPE_NOT_PRESENT  1 
.................... #define DELAY_STABILIZE_PIPE_PRESENSE  500   // INPUT From HMI 
.................... #define DELAY_PIPE_SENSE_DI_STATE      500   // INPUT From HMI 
.................... #define DELAY_PIPE_STABILIZATION       1500  // INPUT From HMI 
.................... #define DELAY_PIPE_TRANSFER            3000  // INPUT From HMI 
....................  
.................... #define FLAG_PIPE_PRESENCE_DELAY_ON              1 
.................... #define FLAG_PIPE_PRESENCE_DELAY_OFF             0 
.................... #define FLAG_PIPE_STABILIZATION_DELAY_ON         1 
.................... #define FLAG_PIPE_STABILIZATION_DELAY_OFF        0 
....................  
.................... unsigned int16 g_ui16DOToggleTikCnt         = 0; 
.................... //unsigned int16 g_ui16DlyPipeDIStateTikCnt   = 0; 
.................... unsigned int16 g_ui16DlyStabilizationTikCnt  = 0; 
.................... unsigned int16 g_ui16DlyPipePresenceTikCnt   = 0; // Pipe Presence Tick Count 
....................  
.................... unsigned int8  g_ui16DlyPipePresenceState  = FLAG_PIPE_PRESENCE_DELAY_OFF; 
.................... unsigned int8  g_ui8DlyStabilizationState  = FLAG_PIPE_STABILIZATION_DELAY_OFF; 
....................  
.................... unsigned int8  g_ui8PipePresence = PIPE_NOT_PRESENT; 
....................  
.................... unsigned int16 g_ui16DelayStabilizePipePresense = DELAY_STABILIZE_PIPE_PRESENSE; 
....................  
.................... unsigned int16 g_ui16DelayFlexi = g_ui16PipeStabilizationDelayTime; 
.................... // PWT End 
....................  
.................... #define T0_DIV_PRESCALE                 RTCC_DIV_8 
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS      (0xFFFF - 0x0271 + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US   (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US    (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_NOT_CHANGED    1 
.................... #define FLAG_DI_STATE_CHANGED        0 
.................... #define ADC_READ_ON                  10 
.................... #define ADC_READ_OFF                 11 
....................  
.................... //#define DELAY_PUSHER               400 
.................... //#define DELAY_CAN_STPR_1           2000 
.................... //#define DELAY_CAN_PUSHER_1_TIMER_2 500 
.................... //#define DELAY_START_CAN_PLACER     20 
.................... #define DELAY_INTRMDAT_DATA_SEND     300 
.................... #define DELAY_REJECT_PUSHER_BACK     1000 
.................... #define PUSHER_DELAY_START_ON          0 
.................... #define PUSHER_DELAY_START_OFF         1 
....................  
.................... #define BOX_LEFT_DELAY_START           0 
.................... #define BOX_LEFT_DELAY_END             1 
.................... #define AFTER_BOX_LEFT_DELAY_TIME      200 
.................... #define LOCK_DATA_SENDING              10 
.................... #define UNLOCK_DATA_SENDING            11 
....................  
.................... #define WAITING_STOP                   9 
.................... #define WAITING_START                  10 
.................... #define WAITING_TIME                   2000 // In milliseconds. 
.................... #define WEIGHING_ON                    12 
.................... #define WEIGHING_OFF                   13 
.................... #define WEIGHING_CALC                  14 
.................... #define HOME_MODE_WAITING              3000 
....................  
.................... #define AIR_PRESSURE_LEVEL_BELOW_RATED  10 
.................... #define AIR_PRESSURE_LEVEL_ABOVE_RATED  11 
....................  
.................... // TESTING Start 
.................... #define DELAY_GET_ADC_DATA           500 
.................... unsigned int16 g_uiCountSendADCData = 0; 
.................... // TESTING End 
....................  
....................  
.................... unsigned int8  g_fDIChangeState =  FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fADCCurrState  =  ADC_READ_OFF; 
.................... unsigned int16 g_ui16IntmidDataSendTikCount = 0; 
.................... unsigned int16 g_uiPusherDelayTikCount      = 0; 
.................... int8 g_fPusherDelayStatus     = PUSHER_DELAY_START_OFF; 
.................... int8 g_fRejectPusherPrevState = 1; 
.................... //unsigned int8  g_fBeforeHomeStateDelayStatus = BOX_LEFT_DELAY_END; 
.................... unsigned int16  g_ui16AfterBoxLeftDelayTimeCounter = 0; 
.................... unsigned int8   g_fBoxLeftDelayState = BOX_LEFT_DELAY_END; 
.................... unsigned int8   g_fExitTimeDataSendingStatus = UNLOCK_DATA_SENDING; 
.................... unsigned int8   g_fCurrentAirPressureLevel   = AIR_PRESSURE_LEVEL_ABOVE_RATED; 
....................  
....................  
.................... unsigned int8   g_fWaitingStatus             = WAITING_STOP; 
.................... unsigned int8   g_fWeighingStatus            = WEIGHING_OFF; 
.................... unsigned int8   g_fHomeWaitingStatus         = WAITING_STOP; 
.................... unsigned int8   g_fTareStartStatus           = WAITING_STOP; 
.................... unsigned int16  g_ui16TimingCounter          = 0; 
.................... unsigned int16  g_ui16TickCounter             = 0; 
.................... unsigned int8   g_ui8AirPressureAlarmSendCount = 0; 
.................... unsigned int16  g_ui16WeighingCylinderActuationDelayCnt = 0; 
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
.................... // Init Polling Timer. 
.................... void InitDigitalIOPollingTimer(void) 
.................... { 
....................     // Setup Timer0 at 1 ms Time. 
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_PRESCALE ); 
*
00C9A:  MOVLW  90
00C9C:  MOVWF  FD5
00C9E:  MOVLW  43
00CA0:  MOVWF  FD6
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO => Need to change the value load in timer 
00CA2:  BTFSS  FD5.4
00CA4:  GOTO   0CAC
00CA8:  MOVLW  FD
00CAA:  MOVWF  FD4
00CAC:  MOVLW  8F
00CAE:  MOVWF  FD3
....................     // Enable Timer0. 
....................     clear_interrupt( INT_TIMER0 ); 
00CB0:  MOVLB  E
00CB2:  BCF    x33.5
....................     enable_interrupts( INT_TIMER0 ); 
00CB4:  BSF    x29.5
00CB6:  MOVLB  0
00CB8:  GOTO   3000 (RETURN)
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
....................  
....................  
....................       
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8PipeSensorState              = 1; 
.................... unsigned int8 g_ui8LeftSensorState              = 1; 
.................... unsigned int8 g_ui8RightSensorState             = 1; 
.................... unsigned int8 g_ui8AirPressureSensorState       = 1; 
.................... unsigned int8 g_ui8PipeSensorPrvState           = 1; 
.................... unsigned int8 g_ui8LeftWeighingCylinderState    = 1; 
.................... unsigned int8 g_ui8RightWeighingCylinderState   = 1; 
.................... unsigned int8 g_ui8WeighingCylinderState        = 1; 
....................  
.................... #INT_TIMER0 
.................... void DigitalIOPolling_isr(void) 
*
00290:  MOVLB  0
.................... { 
....................  
....................     if (g_ui16DOToggleTikCnt++ > 500) 
00292:  MOVLB  A
00294:  MOVFF  A37,AA6
00298:  MOVF   x36,W
0029A:  INCF   x36,F
0029C:  BTFSC  FD8.2
0029E:  INCF   x37,F
002A0:  MOVWF  xA5
002A2:  MOVF   xA6,W
002A4:  SUBLW  00
002A6:  BTFSC  FD8.0
002A8:  GOTO   02C2
002AC:  XORLW  FF
002AE:  BTFSS  FD8.2
002B0:  GOTO   02BE
002B4:  MOVF   xA5,W
002B6:  SUBLW  F4
002B8:  BTFSC  FD8.0
002BA:  GOTO   02C2
....................     { 
....................         g_ui16DOToggleTikCnt = 0; 
002BE:  CLRF   x37
002C0:  CLRF   x36
....................     } 
....................      
....................     // Digital Input (DI) Polling Start for Pipe Sensor 
....................     g_ui8LeftSensorState            = input(PIN_IN_DI_00); 
002C2:  BSF    F82.1
002C4:  CLRF   x5E
002C6:  BTFSC  F8A.1
002C8:  INCF   x5E,F
....................     g_ui8RightSensorState           = input(PIN_IN_DI_01); 
002CA:  BSF    F82.2
002CC:  CLRF   x5F
002CE:  BTFSC  F8A.2
002D0:  INCF   x5F,F
....................     g_ui8AirPressureSensorState     = input(PIN_IN_DI_02); 
002D2:  BSF    F82.3
002D4:  CLRF   x60
002D6:  BTFSC  F8A.3
002D8:  INCF   x60,F
....................     g_ui8LeftWeighingCylinderState  = input(PIN_IN_DI_03); 
002DA:  BSF    F87.6
002DC:  CLRF   x62
002DE:  BTFSC  F8F.6
002E0:  INCF   x62,F
....................     g_ui8RightWeighingCylinderState = input(PIN_IN_DI_04); 
002E2:  BSF    F87.7
002E4:  CLRF   x63
002E6:  BTFSC  F8F.7
002E8:  INCF   x63,F
....................      
....................     // Merging both sensor state. 
....................     g_ui8PipeSensorState = (g_ui8LeftSensorState & g_ui8RightSensorState); 
002EA:  MOVF   x5E,W
002EC:  ANDWF  x5F,W
002EE:  MOVWF  x5D
....................      
....................     // Check If there is any State Change 
....................     if (g_ui8PipeSensorPrvState != g_ui8PipeSensorState) 
002F0:  MOVF   x5D,W
002F2:  SUBWF  x61,W
002F4:  BTFSC  FD8.2
002F6:  GOTO   0306
....................     { 
....................         // Pipe Sensor State Changed 
....................         g_ui16DlyPipePresenceTikCnt  = 0; 
002FA:  CLRF   x3B
002FC:  CLRF   x3A
....................         g_ui16DlyPipePresenceState   = FLAG_PIPE_PRESENCE_DELAY_ON; 
002FE:  MOVLW  01
00300:  MOVWF  x3C
....................          
....................         // Check How long it will lasts 
....................         // Update the Previous State 
....................         g_ui8PipeSensorPrvState = g_ui8PipeSensorState; 
00302:  MOVFF  A5D,A61
....................     } 
....................      
....................     // Merging both side weighing cylinder state. 
....................     g_ui8WeighingCylinderState = (g_ui8LeftWeighingCylinderState | g_ui8RightWeighingCylinderState); 
00306:  MOVF   x62,W
00308:  IORWF  x63,W
0030A:  MOVWF  x64
....................      
....................     // Check if both side weighing cylinder stretched full stroke. 
....................     if(!g_ui8WeighingCylinderState) 
0030C:  MOVF   x64,F
0030E:  BTFSS  FD8.2
00310:  GOTO   0372
....................     { 
....................         // Check if the state continues for certain time to  
....................         // ensure it is a false trigger or not. 
....................         if(++g_ui16WeighingCylinderActuationDelayCnt == g_ui16WeighingCylinderUpActivationDelay)                           // g_ui16WeighingCylinderUpActivationDelay 
00314:  INCF   x5B,F
00316:  BTFSC  FD8.2
00318:  INCF   x5C,F
0031A:  MOVLB  5
0031C:  MOVF   xFF,W
0031E:  MOVLB  A
00320:  SUBWF  x5B,W
00322:  BTFSS  FD8.2
00324:  GOTO   036E
00328:  MOVLB  6
0032A:  MOVF   x00,W
0032C:  MOVLB  A
0032E:  SUBWF  x5C,W
00330:  BTFSS  FD8.2
00332:  GOTO   036E
....................         { 
....................             // Reset counter. 
....................             //g_ui16WeighingCylinderActuationDelayCnt = 0; 
....................              
....................             // Weighing cylinder stretched full stroke. 
....................             // Trigger Production toNext stage. 
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
00336:  MOVLB  5
00338:  MOVF   xD7,W
0033A:  SUBLW  05
0033C:  BTFSS  FD8.2
0033E:  GOTO   0350
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
00342:  MOVLB  6
00344:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
00346:  MOVLW  BE
00348:  MOVWF  xE3
....................             } 
0034A:  GOTO   0366
0034E:  MOVLB  5
....................             else if (SYS_MODE_PROD == g_ui8SystemMode) 
00350:  MOVF   xD7,W
00352:  SUBLW  03
00354:  BTFSS  FD8.2
00356:  GOTO   0368
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
0035A:  MOVLB  6
0035C:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
0035E:  MOVLW  BE
00360:  MOVWF  xE3
....................             } 
00362:  GOTO   0366
00366:  MOVLB  5
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................         } 
00368:  GOTO   036C
0036C:  MOVLB  A
....................         else 
....................         { 
....................             /* Do nothing */ 
....................         } 
....................          
....................     } 
0036E:  GOTO   0376
....................     else 
....................     { 
....................         // Reset counter. 
....................         g_ui16WeighingCylinderActuationDelayCnt = 0; 
00372:  CLRF   x5C
00374:  CLRF   x5B
....................     } 
....................      
....................     // Check if DI from pressure switch goes low. 
....................     if(1 == g_ui8AirPressureSensorState) 
00376:  DECFSZ x60,W
00378:  GOTO   03B0
....................     { 
....................         // Check if it continues for One second. 
....................         // If yes; then it is a valid indication. 
....................         // Else ignore this. 
....................         if(++g_ui16TickCounter >= 1000) 
0037C:  INCF   x58,F
0037E:  BTFSC  FD8.2
00380:  INCF   x59,F
00382:  MOVF   x59,W
00384:  SUBLW  02
00386:  BTFSC  FD8.0
00388:  GOTO   03AC
0038C:  XORLW  FF
0038E:  BTFSS  FD8.2
00390:  GOTO   039E
00394:  MOVF   x58,W
00396:  SUBLW  E7
00398:  BTFSC  FD8.0
0039A:  GOTO   03AC
....................         { 
....................             // Check DI state again. 
....................             if(1 == g_ui8AirPressureSensorState) 
0039E:  DECFSZ x60,W
003A0:  GOTO   03AC
....................             { 
....................                 // Set flag to denote, pressure switch  
....................                 // indicating air-pressure goes below  
....................                 // from rated level. 
....................                 g_fCurrentAirPressureLevel = AIR_PRESSURE_LEVEL_BELOW_RATED; 
003A4:  MOVLW  0A
003A6:  MOVWF  x51
....................                  
....................                 // Reset counter. 
....................                 g_ui16TickCounter = 0; 
003A8:  CLRF   x59
003AA:  CLRF   x58
....................             } 
....................         } 
....................     } 
003AC:  GOTO   03B8
....................     else // DI state goes up. 
....................     { 
....................         // Was not a valid indication. 
....................         // False trigger. 
....................         // Reset tick counter. 
....................         g_ui16TickCounter = 0; 
003B0:  CLRF   x59
003B2:  CLRF   x58
....................          
....................         // Unmark the set flag for air-pressure  
....................         // goes low from rated level. 
....................         // This will work after corrective action will be 
....................         // taken for rated air-pressure achievement. 
....................         g_fCurrentAirPressureLevel = AIR_PRESSURE_LEVEL_ABOVE_RATED; 
003B4:  MOVLW  0B
003B6:  MOVWF  x51
....................     } 
....................  
....................         
....................     // Step 3: Check if the ADC is ready with data or not 
....................     // Check if ADC is ready 
....................     if (ADC_SCAN_ON    == g_ui8ADCScanningStatus && 
....................         ADC_DATA_READY == g_fADCDataReadyStatus) 
003B8:  DECFSZ x28,W
003BA:  GOTO   0448
003BE:  DECFSZ x2E,W
003C0:  GOTO   0448
....................     { 
....................         // Increment the Counter 
....................         g_i16ADCArrIdx++; 
003C4:  INCF   x26,F
003C6:  BTFSC  FD8.2
003C8:  INCF   x27,F
....................         //g_stADCDataQ.m_i16Rear++; 
....................         if (g_i16ADCArrIdx >= SIZE_ADC_DATA_QUEUE) 
003CA:  MOVF   x27,F
003CC:  BTFSS  FD8.2
003CE:  GOTO   03DC
003D2:  MOVF   x26,W
003D4:  SUBLW  C7
003D6:  BTFSC  FD8.0
003D8:  GOTO   040E
....................         { 
....................             // Stop ADC Scanning 
....................             g_ui8ADCScanningStatus = ADC_SCAN_OFF; 
003DC:  CLRF   x28
....................             // ADC Data Queue overflowed 
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
003DE:  MOVLB  5
003E0:  MOVF   xD7,W
003E2:  SUBLW  05
003E4:  BTFSS  FD8.2
003E6:  GOTO   03F4
....................             { 
....................                 // Trigger Calibration Next stage 
....................                 g_ui8CurrentState++; 
003EA:  MOVLB  6
003EC:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
003EE:  MOVLW  BE
003F0:  MOVWF  xE3
003F2:  MOVLB  5
....................             } 
....................             if (SYS_MODE_PROD == g_ui8SystemMode) 
003F4:  MOVF   xD7,W
003F6:  SUBLW  03
003F8:  BTFSS  FD8.2
003FA:  GOTO   0408
....................             { 
....................                 // Trigger Production Next stage 
....................                 g_ui8CurrentState++; 
003FE:  MOVLB  6
00400:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
00402:  MOVLW  BE
00404:  MOVWF  xE3
00406:  MOVLB  5
....................             } 
....................         } 
00408:  GOTO   043C
0040C:  MOVLB  A
....................         else 
....................         { 
....................             //g_stADCDataQ.m_ui32Arr[g_stADCDataQ.m_i16Rear] = g_ui32ADCValue; 
....................             g_ui32ADCArr[g_i16ADCArrIdx] = g_ui32ADCValue; 
0040E:  RLCF   x26,W
00410:  MOVWF  02
00412:  RLCF   x27,W
00414:  MOVWF  03
00416:  RLCF   02,F
00418:  RLCF   03,F
0041A:  MOVLW  FC
0041C:  ANDWF  02,F
0041E:  MOVF   02,W
00420:  ADDLW  06
00422:  MOVWF  FE9
00424:  MOVLW  07
00426:  ADDWFC 03,W
00428:  MOVWF  FEA
0042A:  MOVFF  A29,FEF
0042E:  MOVFF  A2A,FEC
00432:  MOVFF  A2B,FEC
00436:  MOVFF  A2C,FEC
0043A:  MOVLB  5
....................         } 
....................  
....................         // Reset Temp ADC Variable 
....................         g_ui32ADCValue = 0; 
0043C:  MOVLB  A
0043E:  CLRF   x2C
00440:  CLRF   x2B
00442:  CLRF   x2A
00444:  CLRF   x29
....................         // Reset Data Ready Status 
....................         g_fADCDataReadyStatus = ADC_DATA_NOT_READY; 
00446:  CLRF   x2E
....................     } 
....................      
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay Start 
....................     //---------------------------------------------------- 
....................     if (IBU_WAIT_FOR_ACK_TIMEOUT_ON == g_fIBUMsgAckDelayStatus) 
00448:  MOVLB  3
0044A:  DECFSZ x8C,W
0044C:  GOTO   0474
....................     { 
....................         g_ui16IBUWaitForACKTikCount++; 
00450:  INCF   x8D,F
00452:  BTFSC  FD8.2
00454:  INCF   x8E,F
....................         if (g_ui16IBUWaitForACKTikCount >= DELAY_IBU_MSG_ACK_NOT_RCV) 
00456:  MOVF   x8E,F
00458:  BTFSS  FD8.2
0045A:  GOTO   0468
0045E:  MOVF   x8D,W
00460:  SUBLW  1D
00462:  BTFSC  FD8.0
00464:  GOTO   0474
....................         { 
....................             g_ui16IBUWaitForACKTikCount = 0; 
00468:  CLRF   x8E
0046A:  CLRF   x8D
....................              
....................             // Reset flag denoting IBU is free now. 
....................             g_fIBUSendBusy = IBU_SENDING_FREE; 
0046C:  MOVLB  1
0046E:  CLRF   xFE
....................              
....................             g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00470:  MOVLB  3
00472:  CLRF   x8C
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay End 
....................     //---------------------------------------------------- 
....................     //---------------------------------------------------- 
....................     // Start : Check for Pipe Sense Time 
....................     //---------------------------------------------------- 
....................     if (FLAG_PIPE_PRESENCE_DELAY_ON == g_ui16DlyPipePresenceState) 
00474:  MOVLB  A
00476:  DECFSZ x3C,W
00478:  GOTO   04C6
....................     { 
....................         g_ui16DlyPipePresenceTikCnt++; 
0047C:  INCF   x3A,F
0047E:  BTFSC  FD8.2
00480:  INCF   x3B,F
....................         if (g_ui16DlyPipePresenceTikCnt >= g_ui16PipePresenceDelayTime) 
00482:  MOVLB  5
00484:  MOVF   xFA,W
00486:  MOVLB  A
00488:  SUBWF  x3B,W
0048A:  BTFSS  FD8.0
0048C:  GOTO   04C6
00490:  BTFSS  FD8.2
00492:  GOTO   04A4
00496:  MOVLB  5
00498:  MOVF   xF9,W
0049A:  MOVLB  A
0049C:  SUBWF  x3A,W
0049E:  BTFSS  FD8.0
004A0:  GOTO   04C6
....................         { 
....................             g_ui16DlyPipePresenceTikCnt = 0; 
004A4:  CLRF   x3B
004A6:  CLRF   x3A
....................              
....................             // Reset flag denoting IBU is free now. 
....................             //g_fIBUSendBusy = IBU_SENDING_FREE; 
....................             if (0 == g_ui8PipeSensorState) 
004A8:  MOVF   x5D,F
004AA:  BTFSS  FD8.2
004AC:  GOTO   04B6
....................             { 
....................                 g_ui8PipePresence = PIPE_PRESENT; 
004B0:  CLRF   x3E
....................             } 
004B2:  GOTO   04C4
....................             else if (1 == g_ui8PipeSensorState) 
004B6:  DECFSZ x5D,W
004B8:  GOTO   04C4
....................             { 
....................                 g_ui8PipePresence = PIPE_NOT_PRESENT; 
004BC:  MOVLW  01
004BE:  MOVWF  x3E
....................             } 
004C0:  GOTO   04C4
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................              
....................             g_ui16DlyPipePresenceState = FLAG_PIPE_PRESENCE_DELAY_OFF; 
004C4:  CLRF   x3C
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // End : Check for Pipe Sense Time 
....................     //----------------------------------------------------     
....................     //---------------------------------------------------- 
....................     // Start : Check for Pipe Stabilization Delay 
....................     //---------------------------------------------------- 
....................     if (FLAG_PIPE_STABILIZATION_DELAY_ON == g_ui8DlyStabilizationState) 
004C6:  DECFSZ x3D,W
004C8:  GOTO   0522
....................     { 
....................         g_ui16DlyStabilizationTikCnt++; 
004CC:  INCF   x38,F
004CE:  BTFSC  FD8.2
004D0:  INCF   x39,F
....................         if (g_ui16DlyStabilizationTikCnt >= g_ui16DelayFlexi) 
004D2:  MOVF   x42,W
004D4:  SUBWF  x39,W
004D6:  BTFSS  FD8.0
004D8:  GOTO   0522
004DC:  BTFSS  FD8.2
004DE:  GOTO   04EC
004E2:  MOVF   x41,W
004E4:  SUBWF  x38,W
004E6:  BTFSS  FD8.0
004E8:  GOTO   0522
....................         { 
....................             g_ui16DlyStabilizationTikCnt = 0; 
004EC:  CLRF   x39
004EE:  CLRF   x38
....................             g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_OFF; 
004F0:  CLRF   x3D
....................              
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
004F2:  MOVLB  5
004F4:  MOVF   xD7,W
004F6:  SUBLW  05
004F8:  BTFSS  FD8.2
004FA:  GOTO   050C
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
004FE:  MOVLB  6
00500:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
00502:  MOVLW  BE
00504:  MOVWF  xE3
....................             } 
00506:  GOTO   051E
0050A:  MOVLB  5
....................             else if (SYS_MODE_PROD == g_ui8SystemMode) 
0050C:  MOVF   xD7,W
0050E:  SUBLW  03
00510:  BTFSS  FD8.2
00512:  GOTO   0520
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
00516:  MOVLB  6
00518:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
0051A:  MOVLW  BE
0051C:  MOVWF  xE3
0051E:  MOVLB  5
00520:  MOVLB  A
....................             } 
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // End : Check for Pipe Stabilization Delay 
....................     //---------------------------------------------------- 
....................  
....................      
....................     // Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO =>  
00522:  BTFSS  FD5.4
00524:  GOTO   052C
00528:  MOVLW  FD
0052A:  MOVWF  FD4
0052C:  MOVLW  8F
0052E:  MOVWF  FD3
....................     clear_interrupt( INT_TIMER0 ); 
00530:  MOVLB  E
00532:  BCF    x33.5
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
....................  
.................... #include "mzPWTStateMachine.h" 
.................... /*  
....................  * File:   mzPWTStateMachine.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 29, 2019, 8:12 PM 
....................  */ 
....................  
.................... #ifndef MZ_PWT_STATEMACHINE_H 
.................... #define	MZ_PWT_STATEMACHINE_H 
....................  
.................... #include "vmM0Common.h" 
.................... /*  
....................  * File:   vmM0Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on August 10, 2019, 9:35 AM 
....................  */ 
....................  
.................... #ifndef VMM0COMMON_H 
.................... #define	VMM0COMMON_H 
....................  
.................... //unsigned int8 g_ui8IBCTareDataSendDone = FALSE; 
....................  
.................... #define STATE_NOTHING            190 
.................... #define STATE_CALIB_STEP_WAITING 130 
.................... #define STATE_CALIB_STEP_1       131 
.................... #define STATE_CALIB_STEP_2       132 
.................... #define STATE_CALIB_STEP_3       133 
.................... #define STATE_CALIB_STEP_4       134 
.................... #define STATE_CALIB_STEP_5       135 
.................... #define STATE_CALIB_STEP_6       136 
.................... #define STATE_CALIB_STEP_7       137 
.................... #define STATE_CALIB_STEP_8       138 
.................... #define STATE_CALIB_STEP_9       139 
.................... #define STATE_CALIB_STEP_10      140 
....................  
.................... unsigned int8 g_ui8CurrentState  = 0; 
.................... unsigned int8 g_ui8StateWaiting = STATE_NOTHING; 
....................  
.................... unsigned int32 g_ui32CurPipeADCValue = 0; 
.................... unsigned int32 g_ui32CurPipeWeight   = 0; 
....................  
.................... #endif	/* VMM0COMMON_H */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
....................  
00534:  BCF    x33.5
00536:  MOVLB  0
00538:  GOTO   007E
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
.................... #include "vmSystemConfig.h" 
.................... #include "vmStateMachineForIMW_M0.h" 
.................... //#include "vmDigitalIOConfig.h" 
.................... #include "vmADCManager.h" 
.................... #include "../Common/vmIBUConfig.h" 
....................  
....................  
.................... // PWT Start 
.................... #define PIPE_PRESENT      0 
.................... #define PIPE_NOT_PRESENT  1 
.................... #define DELAY_STABILIZE_PIPE_PRESENSE  500   // INPUT From HMI 
.................... #define DELAY_PIPE_SENSE_DI_STATE      500   // INPUT From HMI 
.................... #define DELAY_PIPE_STABILIZATION       1500  // INPUT From HMI 
.................... #define DELAY_PIPE_TRANSFER            3000  // INPUT From HMI 
....................  
.................... #define FLAG_PIPE_PRESENCE_DELAY_ON              1 
.................... #define FLAG_PIPE_PRESENCE_DELAY_OFF             0 
.................... #define FLAG_PIPE_STABILIZATION_DELAY_ON         1 
.................... #define FLAG_PIPE_STABILIZATION_DELAY_OFF        0 
....................  
.................... unsigned int16 g_ui16DOToggleTikCnt         = 0; 
.................... //unsigned int16 g_ui16DlyPipeDIStateTikCnt   = 0; 
.................... unsigned int16 g_ui16DlyStabilizationTikCnt  = 0; 
.................... unsigned int16 g_ui16DlyPipePresenceTikCnt   = 0; // Pipe Presence Tick Count 
....................  
.................... unsigned int8  g_ui16DlyPipePresenceState  = FLAG_PIPE_PRESENCE_DELAY_OFF; 
.................... unsigned int8  g_ui8DlyStabilizationState  = FLAG_PIPE_STABILIZATION_DELAY_OFF; 
....................  
.................... unsigned int8  g_ui8PipePresence = PIPE_NOT_PRESENT; 
....................  
.................... unsigned int16 g_ui16DelayStabilizePipePresense = DELAY_STABILIZE_PIPE_PRESENSE; 
....................  
.................... unsigned int16 g_ui16DelayFlexi = g_ui16PipeStabilizationDelayTime; 
.................... // PWT End 
....................  
.................... #define T0_DIV_PRESCALE                 RTCC_DIV_8 
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS      (0xFFFF - 0x0271 + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US   (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US    (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_NOT_CHANGED    1 
.................... #define FLAG_DI_STATE_CHANGED        0 
.................... #define ADC_READ_ON                  10 
.................... #define ADC_READ_OFF                 11 
....................  
.................... //#define DELAY_PUSHER               400 
.................... //#define DELAY_CAN_STPR_1           2000 
.................... //#define DELAY_CAN_PUSHER_1_TIMER_2 500 
.................... //#define DELAY_START_CAN_PLACER     20 
.................... #define DELAY_INTRMDAT_DATA_SEND     300 
.................... #define DELAY_REJECT_PUSHER_BACK     1000 
.................... #define PUSHER_DELAY_START_ON          0 
.................... #define PUSHER_DELAY_START_OFF         1 
....................  
.................... #define BOX_LEFT_DELAY_START           0 
.................... #define BOX_LEFT_DELAY_END             1 
.................... #define AFTER_BOX_LEFT_DELAY_TIME      200 
.................... #define LOCK_DATA_SENDING              10 
.................... #define UNLOCK_DATA_SENDING            11 
....................  
.................... #define WAITING_STOP                   9 
.................... #define WAITING_START                  10 
.................... #define WAITING_TIME                   2000 // In milliseconds. 
.................... #define WEIGHING_ON                    12 
.................... #define WEIGHING_OFF                   13 
.................... #define WEIGHING_CALC                  14 
.................... #define HOME_MODE_WAITING              3000 
....................  
.................... #define AIR_PRESSURE_LEVEL_BELOW_RATED  10 
.................... #define AIR_PRESSURE_LEVEL_ABOVE_RATED  11 
....................  
.................... // TESTING Start 
.................... #define DELAY_GET_ADC_DATA           500 
.................... unsigned int16 g_uiCountSendADCData = 0; 
.................... // TESTING End 
....................  
....................  
.................... unsigned int8  g_fDIChangeState =  FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int8  g_fADCCurrState  =  ADC_READ_OFF; 
.................... unsigned int16 g_ui16IntmidDataSendTikCount = 0; 
.................... unsigned int16 g_uiPusherDelayTikCount      = 0; 
.................... int8 g_fPusherDelayStatus     = PUSHER_DELAY_START_OFF; 
.................... int8 g_fRejectPusherPrevState = 1; 
.................... //unsigned int8  g_fBeforeHomeStateDelayStatus = BOX_LEFT_DELAY_END; 
.................... unsigned int16  g_ui16AfterBoxLeftDelayTimeCounter = 0; 
.................... unsigned int8   g_fBoxLeftDelayState = BOX_LEFT_DELAY_END; 
.................... unsigned int8   g_fExitTimeDataSendingStatus = UNLOCK_DATA_SENDING; 
.................... unsigned int8   g_fCurrentAirPressureLevel   = AIR_PRESSURE_LEVEL_ABOVE_RATED; 
....................  
....................  
.................... unsigned int8   g_fWaitingStatus             = WAITING_STOP; 
.................... unsigned int8   g_fWeighingStatus            = WEIGHING_OFF; 
.................... unsigned int8   g_fHomeWaitingStatus         = WAITING_STOP; 
.................... unsigned int8   g_fTareStartStatus           = WAITING_STOP; 
.................... unsigned int16  g_ui16TimingCounter          = 0; 
.................... unsigned int16  g_ui16TickCounter             = 0; 
.................... unsigned int8   g_ui8AirPressureAlarmSendCount = 0; 
.................... unsigned int16  g_ui16WeighingCylinderActuationDelayCnt = 0; 
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
.................... // Init Polling Timer. 
.................... void InitDigitalIOPollingTimer(void) 
.................... { 
....................     // Setup Timer0 at 1 ms Time. 
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_PRESCALE ); 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO => Need to change the value load in timer 
....................     // Enable Timer0. 
....................     clear_interrupt( INT_TIMER0 ); 
....................     enable_interrupts( INT_TIMER0 ); 
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Initialization Functions ******************************** 
.................... //***************************************************************************** 
....................  
....................  
....................       
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8PipeSensorState              = 1; 
.................... unsigned int8 g_ui8LeftSensorState              = 1; 
.................... unsigned int8 g_ui8RightSensorState             = 1; 
.................... unsigned int8 g_ui8AirPressureSensorState       = 1; 
.................... unsigned int8 g_ui8PipeSensorPrvState           = 1; 
.................... unsigned int8 g_ui8LeftWeighingCylinderState    = 1; 
.................... unsigned int8 g_ui8RightWeighingCylinderState   = 1; 
.................... unsigned int8 g_ui8WeighingCylinderState        = 1; 
....................  
.................... #INT_TIMER0 
.................... void DigitalIOPolling_isr(void) 
.................... { 
....................  
....................     if (g_ui16DOToggleTikCnt++ > 500) 
....................     { 
....................         g_ui16DOToggleTikCnt = 0; 
....................     } 
....................      
....................     // Digital Input (DI) Polling Start for Pipe Sensor 
....................     g_ui8LeftSensorState            = input(PIN_IN_DI_00); 
....................     g_ui8RightSensorState           = input(PIN_IN_DI_01); 
....................     g_ui8AirPressureSensorState     = input(PIN_IN_DI_02); 
....................     g_ui8LeftWeighingCylinderState  = input(PIN_IN_DI_03); 
....................     g_ui8RightWeighingCylinderState = input(PIN_IN_DI_04); 
....................      
....................     // Merging both sensor state. 
....................     g_ui8PipeSensorState = (g_ui8LeftSensorState & g_ui8RightSensorState); 
....................      
....................     // Check If there is any State Change 
....................     if (g_ui8PipeSensorPrvState != g_ui8PipeSensorState) 
....................     { 
....................         // Pipe Sensor State Changed 
....................         g_ui16DlyPipePresenceTikCnt  = 0; 
....................         g_ui16DlyPipePresenceState   = FLAG_PIPE_PRESENCE_DELAY_ON; 
....................          
....................         // Check How long it will lasts 
....................         // Update the Previous State 
....................         g_ui8PipeSensorPrvState = g_ui8PipeSensorState; 
....................     } 
....................      
....................     // Merging both side weighing cylinder state. 
....................     g_ui8WeighingCylinderState = (g_ui8LeftWeighingCylinderState | g_ui8RightWeighingCylinderState); 
....................      
....................     // Check if both side weighing cylinder stretched full stroke. 
....................     if(!g_ui8WeighingCylinderState) 
....................     { 
....................         // Check if the state continues for certain time to  
....................         // ensure it is a false trigger or not. 
....................         if(++g_ui16WeighingCylinderActuationDelayCnt == g_ui16WeighingCylinderUpActivationDelay)                           // g_ui16WeighingCylinderUpActivationDelay 
....................         { 
....................             // Reset counter. 
....................             //g_ui16WeighingCylinderActuationDelayCnt = 0; 
....................              
....................             // Weighing cylinder stretched full stroke. 
....................             // Trigger Production toNext stage. 
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................             else if (SYS_MODE_PROD == g_ui8SystemMode) 
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................         } 
....................         else 
....................         { 
....................             /* Do nothing */ 
....................         } 
....................          
....................     } 
....................     else 
....................     { 
....................         // Reset counter. 
....................         g_ui16WeighingCylinderActuationDelayCnt = 0; 
....................     } 
....................      
....................     // Check if DI from pressure switch goes low. 
....................     if(1 == g_ui8AirPressureSensorState) 
....................     { 
....................         // Check if it continues for One second. 
....................         // If yes; then it is a valid indication. 
....................         // Else ignore this. 
....................         if(++g_ui16TickCounter >= 1000) 
....................         { 
....................             // Check DI state again. 
....................             if(1 == g_ui8AirPressureSensorState) 
....................             { 
....................                 // Set flag to denote, pressure switch  
....................                 // indicating air-pressure goes below  
....................                 // from rated level. 
....................                 g_fCurrentAirPressureLevel = AIR_PRESSURE_LEVEL_BELOW_RATED; 
....................                  
....................                 // Reset counter. 
....................                 g_ui16TickCounter = 0; 
....................             } 
....................         } 
....................     } 
....................     else // DI state goes up. 
....................     { 
....................         // Was not a valid indication. 
....................         // False trigger. 
....................         // Reset tick counter. 
....................         g_ui16TickCounter = 0; 
....................          
....................         // Unmark the set flag for air-pressure  
....................         // goes low from rated level. 
....................         // This will work after corrective action will be 
....................         // taken for rated air-pressure achievement. 
....................         g_fCurrentAirPressureLevel = AIR_PRESSURE_LEVEL_ABOVE_RATED; 
....................     } 
....................  
....................         
....................     // Step 3: Check if the ADC is ready with data or not 
....................     // Check if ADC is ready 
....................     if (ADC_SCAN_ON    == g_ui8ADCScanningStatus && 
....................         ADC_DATA_READY == g_fADCDataReadyStatus) 
....................     { 
....................         // Increment the Counter 
....................         g_i16ADCArrIdx++; 
....................         //g_stADCDataQ.m_i16Rear++; 
....................         if (g_i16ADCArrIdx >= SIZE_ADC_DATA_QUEUE) 
....................         { 
....................             // Stop ADC Scanning 
....................             g_ui8ADCScanningStatus = ADC_SCAN_OFF; 
....................             // ADC Data Queue overflowed 
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
....................             { 
....................                 // Trigger Calibration Next stage 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................             if (SYS_MODE_PROD == g_ui8SystemMode) 
....................             { 
....................                 // Trigger Production Next stage 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             //g_stADCDataQ.m_ui32Arr[g_stADCDataQ.m_i16Rear] = g_ui32ADCValue; 
....................             g_ui32ADCArr[g_i16ADCArrIdx] = g_ui32ADCValue; 
....................         } 
....................  
....................         // Reset Temp ADC Variable 
....................         g_ui32ADCValue = 0; 
....................         // Reset Data Ready Status 
....................         g_fADCDataReadyStatus = ADC_DATA_NOT_READY; 
....................     } 
....................      
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay Start 
....................     //---------------------------------------------------- 
....................     if (IBU_WAIT_FOR_ACK_TIMEOUT_ON == g_fIBUMsgAckDelayStatus) 
....................     { 
....................         g_ui16IBUWaitForACKTikCount++; 
....................         if (g_ui16IBUWaitForACKTikCount >= DELAY_IBU_MSG_ACK_NOT_RCV) 
....................         { 
....................             g_ui16IBUWaitForACKTikCount = 0; 
....................              
....................             // Reset flag denoting IBU is free now. 
....................             g_fIBUSendBusy = IBU_SENDING_FREE; 
....................              
....................             g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay End 
....................     //---------------------------------------------------- 
....................     //---------------------------------------------------- 
....................     // Start : Check for Pipe Sense Time 
....................     //---------------------------------------------------- 
....................     if (FLAG_PIPE_PRESENCE_DELAY_ON == g_ui16DlyPipePresenceState) 
....................     { 
....................         g_ui16DlyPipePresenceTikCnt++; 
....................         if (g_ui16DlyPipePresenceTikCnt >= g_ui16PipePresenceDelayTime) 
....................         { 
....................             g_ui16DlyPipePresenceTikCnt = 0; 
....................              
....................             // Reset flag denoting IBU is free now. 
....................             //g_fIBUSendBusy = IBU_SENDING_FREE; 
....................             if (0 == g_ui8PipeSensorState) 
....................             { 
....................                 g_ui8PipePresence = PIPE_PRESENT; 
....................             } 
....................             else if (1 == g_ui8PipeSensorState) 
....................             { 
....................                 g_ui8PipePresence = PIPE_NOT_PRESENT; 
....................             } 
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................              
....................             g_ui16DlyPipePresenceState = FLAG_PIPE_PRESENCE_DELAY_OFF; 
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // End : Check for Pipe Sense Time 
....................     //----------------------------------------------------     
....................     //---------------------------------------------------- 
....................     // Start : Check for Pipe Stabilization Delay 
....................     //---------------------------------------------------- 
....................     if (FLAG_PIPE_STABILIZATION_DELAY_ON == g_ui8DlyStabilizationState) 
....................     { 
....................         g_ui16DlyStabilizationTikCnt++; 
....................         if (g_ui16DlyStabilizationTikCnt >= g_ui16DelayFlexi) 
....................         { 
....................             g_ui16DlyStabilizationTikCnt = 0; 
....................             g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_OFF; 
....................              
....................             if (SYS_MODE_CALIB == g_ui8SystemMode) 
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................             else if (SYS_MODE_PROD == g_ui8SystemMode) 
....................             { 
....................                 // Go to the Next State 
....................                 g_ui8CurrentState++; 
....................                 g_ui8StateWaiting = STATE_NOTHING; 
....................             } 
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // End : Check for Pipe Stabilization Delay 
....................     //---------------------------------------------------- 
....................  
....................      
....................     // Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS );  // TODO =>  
....................     clear_interrupt( INT_TIMER0 ); 
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Above -> 1MS Timer Implementation ****************************************** 
.................... //***************************************************************************** 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
....................  
....................  
.................... int i = 0; 
.................... void PWTStateMachine() 
.................... { 
....................     switch (g_ui8CurrentState) 
*
025B4:  MOVLB  6
025B6:  MOVF   xE2,W
025B8:  XORLW  83
025BA:  MOVLB  0
025BC:  BTFSC  FD8.2
025BE:  GOTO   260E
025C2:  XORLW  07
025C4:  BTFSC  FD8.2
025C6:  GOTO   2642
025CA:  XORLW  01
025CC:  BTFSC  FD8.2
025CE:  GOTO   2678
025D2:  XORLW  03
025D4:  BTFSC  FD8.2
025D6:  GOTO   27A6
025DA:  XORLW  01
025DC:  BTFSC  FD8.2
025DE:  GOTO   2820
025E2:  XORLW  0F
025E4:  BTFSC  FD8.2
025E6:  GOTO   2856
025EA:  XORLW  01
025EC:  BTFSC  FD8.2
025EE:  GOTO   2984
025F2:  XORLW  03
025F4:  BTFSC  FD8.2
025F6:  GOTO   2AA8
025FA:  XORLW  01
025FC:  BTFSC  FD8.2
025FE:  GOTO   2AE6
02602:  XORLW  07
02604:  BTFSC  FD8.2
02606:  GOTO   2B30
0260A:  GOTO   2B68
....................     { 
....................         case STATE_CALIB_STEP_1: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
0260E:  MOVLB  6
02610:  MOVF   xE3,W
02612:  SUBLW  82
02614:  BTFSS  FD8.2
02616:  GOTO   261E
....................             { 
....................                 break; 
0261A:  GOTO   2B6E
....................             } 
....................             // Check if the Pipe Present or not 
....................             if (PIPE_PRESENT == g_ui8PipePresence) 
0261E:  MOVLB  A
02620:  MOVF   x3E,F
02622:  BTFSS  FD8.2
02624:  GOTO   263C
....................             { 
....................                 // Wait for a while to stabilize the pipe 
....................                 g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_ON; 
02628:  MOVLW  01
0262A:  MOVWF  x3D
....................                 g_ui16DelayFlexi = g_ui16PipeStabilizationDelayTime; 
0262C:  MOVFF  5FC,A42
02630:  MOVFF  5FB,A41
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
02634:  MOVLW  82
02636:  MOVLB  6
02638:  MOVWF  xE3
0263A:  MOVLB  A
....................             } 
....................         } 
....................         break; 
0263C:  MOVLB  6
0263E:  GOTO   2B6E
....................         case STATE_CALIB_STEP_2: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02642:  MOVLB  6
02644:  MOVF   xE3,W
02646:  SUBLW  82
02648:  BTFSS  FD8.2
0264A:  GOTO   2656
....................             { 
....................                 break; 
0264E:  GOTO   2B6E
....................             } 
02652:  GOTO   2674
....................             else if (STATE_CALIB_STEP_2 == g_ui8CurrentState) 
02656:  MOVF   xE2,W
02658:  SUBLW  84
0265A:  BTFSS  FD8.2
0265C:  GOTO   2674
....................             { 
....................                 // Start Filling up the Tare Array of 200 samples 
....................                 // Step 1: Start Reading the ADC Data for Tare 
....................                 g_i16ADCArrIdx = -1; 
02660:  MOVLB  A
02662:  SETF   x27
02664:  SETF   x26
....................  
....................                 // Step 2: Start ADC Scanning 
....................                 g_ui8ADCScanningStatus = ADC_SCAN_ON; 
02666:  MOVLW  01
02668:  MOVWF  x28
....................  
....................                 // Wait for ADC Array to fill completely 
....................                 // It will be triggered from ADC Filling 
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
0266A:  MOVLW  82
0266C:  MOVLB  6
0266E:  MOVWF  xE3
....................             } 
02670:  GOTO   2674
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02674:  GOTO   2B6E
....................         case STATE_CALIB_STEP_3: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02678:  MOVLB  6
0267A:  MOVF   xE3,W
0267C:  SUBLW  82
0267E:  BTFSS  FD8.2
02680:  GOTO   268C
....................             { 
....................                 break; 
02684:  GOTO   2B6E
....................             } 
02688:  GOTO   27A2
....................             else if (STATE_CALIB_STEP_3 == g_ui8CurrentState) 
0268C:  MOVF   xE2,W
0268E:  SUBLW  85
02690:  BTFSS  FD8.2
02692:  GOTO   27A2
....................             { 
....................                 // Calculate the Average 
....................                 g_ui32ADCCurSum = 0; 
02696:  CLRF   xF5
02698:  CLRF   xF4
0269A:  CLRF   xF3
0269C:  CLRF   xF2
....................                 for(g_ui16ADCSumLoopCount = 0; g_ui16ADCSumLoopCount < SIZE_ADC_DATA_QUEUE; g_ui16ADCSumLoopCount++) 
0269E:  CLRF   xFF
026A0:  CLRF   xFE
026A2:  MOVF   xFF,F
026A4:  BTFSS  FD8.2
026A6:  GOTO   271E
026AA:  MOVF   xFE,W
026AC:  SUBLW  C7
026AE:  BTFSS  FD8.0
026B0:  GOTO   271E
....................                 { 
....................                     g_ui32ADCCurSum += g_ui32ADCArr[g_ui16ADCSumLoopCount]; 
026B4:  RLCF   xFE,W
026B6:  MOVWF  02
026B8:  RLCF   xFF,W
026BA:  MOVWF  03
026BC:  RLCF   02,F
026BE:  RLCF   03,F
026C0:  MOVLW  FC
026C2:  ANDWF  02,F
026C4:  MOVF   02,W
026C6:  ADDLW  06
026C8:  MOVWF  FE9
026CA:  MOVLW  07
026CC:  ADDWFC 03,W
026CE:  MOVWF  FEA
026D0:  MOVFF  FEF,00
026D4:  MOVFF  FEC,01
026D8:  MOVFF  FEC,02
026DC:  MOVFF  FEC,03
026E0:  MOVF   00,W
026E2:  ADDWF  xF2,F
026E4:  MOVF   01,W
026E6:  ADDWFC xF3,F
026E8:  MOVF   02,W
026EA:  ADDWFC xF4,F
026EC:  MOVF   03,W
026EE:  ADDWFC xF5,F
....................                     g_ui32ADCArr[g_ui16ADCSumLoopCount] = 0; 
026F0:  RLCF   xFE,W
026F2:  MOVWF  02
026F4:  RLCF   xFF,W
026F6:  MOVWF  03
026F8:  RLCF   02,F
026FA:  RLCF   03,F
026FC:  MOVLW  FC
026FE:  ANDWF  02,F
02700:  MOVF   02,W
02702:  ADDLW  06
02704:  MOVWF  FE9
02706:  MOVLW  07
02708:  ADDWFC 03,W
0270A:  MOVWF  FEA
0270C:  CLRF   FEF
0270E:  CLRF   FEC
02710:  CLRF   FEC
02712:  CLRF   FEC
02714:  INCF   xFE,F
02716:  BTFSC  FD8.2
02718:  INCF   xFF,F
0271A:  GOTO   26A2
....................                 } 
....................                 if (!g_ui32ADCCurSum ) 
0271E:  MOVF   xF2,F
02720:  BTFSS  FD8.2
02722:  GOTO   2752
02726:  MOVF   xF3,F
02728:  BTFSS  FD8.2
0272A:  GOTO   2752
0272E:  MOVF   xF4,F
02730:  BTFSS  FD8.2
02732:  GOTO   2752
02736:  MOVF   xF5,F
02738:  BTFSS  FD8.2
0273A:  GOTO   2752
....................                 { 
....................                     // Sum is 0, so update with the previous tare value 
....................                     g_ui32ADCCurMeanValue = g_ui32TarePrev; 
0273E:  MOVFF  6F9,6F1
02742:  MOVFF  6F8,6F0
02746:  MOVFF  6F7,6EF
0274A:  MOVFF  6F6,6EE
....................                 } 
0274E:  GOTO   2798
....................                 else 
....................                 { 
....................                     g_ui32ADCCurMeanValue = g_ui32ADCCurSum / SIZE_ADC_DATA_QUEUE; 
02752:  BCF    FD8.1
02754:  MOVFF  6F5,A9A
02758:  MOVFF  6F4,A99
0275C:  MOVFF  6F3,A98
02760:  MOVFF  6F2,A97
02764:  MOVLB  A
02766:  CLRF   x9E
02768:  CLRF   x9D
0276A:  CLRF   x9C
0276C:  MOVLW  C8
0276E:  MOVWF  x9B
02770:  MOVLB  0
02772:  CALL   1E02
02776:  MOVFF  03,6F1
0277A:  MOVFF  02,6F0
0277E:  MOVFF  01,6EF
02782:  MOVFF  00,6EE
....................                     g_ui32TarePrev = g_ui32ADCCurMeanValue; 
02786:  MOVFF  6F1,6F9
0278A:  MOVFF  6F0,6F8
0278E:  MOVFF  6EF,6F7
02792:  MOVFF  6EE,6F6
02796:  MOVLB  6
....................                 } 
....................                 g_ui8CurrentState++; 
02798:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
0279A:  MOVLW  BE
0279C:  MOVWF  xE3
....................             } 
0279E:  GOTO   27A2
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................  
....................         } 
....................         break; 
027A2:  GOTO   2B6E
....................         case STATE_CALIB_STEP_4: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
027A6:  MOVLB  6
027A8:  MOVF   xE3,W
027AA:  SUBLW  82
027AC:  BTFSS  FD8.2
027AE:  GOTO   27BA
....................             { 
....................                 break; 
027B2:  GOTO   2B6E
....................             } 
027B6:  GOTO   281C
....................             else if (STATE_CALIB_STEP_4 == g_ui8CurrentState) 
027BA:  MOVF   xE2,W
027BC:  SUBLW  86
027BE:  BTFSS  FD8.2
027C0:  GOTO   281C
....................             { 
....................                 // Tare Calculation Done 
....................                 // Step 1 : Store the ADV Mean Value to Tare Value 
....................                 g_ui32DynamicTareADCValue = g_ui32ADCCurMeanValue; 
027C4:  MOVFF  6F1,5DF
027C8:  MOVFF  6F0,5DE
027CC:  MOVFF  6EF,5DD
027D0:  MOVFF  6EE,5DC
....................                 // Step 2 : Calculate the Calibrated Tare Weight 
....................                 g_ui32DynamicTareValue = GetCalibratedWeight(g_ui32DynamicTareADCValue); 
027D4:  MOVFF  5DF,A76
027D8:  MOVFF  5DE,A75
027DC:  MOVFF  5DD,A74
027E0:  MOVFF  5DC,A73
027E4:  MOVLB  0
027E6:  CALL   205A
027EA:  MOVFF  03,5DB
027EE:  MOVFF  02,5DA
027F2:  MOVFF  01,5D9
027F6:  MOVFF  00,5D8
....................                 // Step 3: Send the Tare Value to IBU 
....................                 IBUSendTareData(g_ui32DynamicTareValue); 
027FA:  MOVFF  5DB,A76
027FE:  MOVFF  5DA,A75
02802:  MOVFF  5D9,A74
02806:  MOVFF  5D8,A73
0280A:  GOTO   214A
....................  
....................                 output_bit(PIN_OUT_DO_00, 0); 
0280E:  BCF    F80.2
02810:  BCF    F88.2
....................                 // Wait for a while to stabilize the pipe 
....................                 //g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_ON; 
....................                 //g_ui16DelayFlexi = g_ui16PipeStabilizationDelayTime; 
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
02812:  MOVLW  82
02814:  MOVLB  6
02816:  MOVWF  xE3
....................             } 
02818:  GOTO   281C
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
0281C:  GOTO   2B6E
....................         case STATE_CALIB_STEP_5: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02820:  MOVLB  6
02822:  MOVF   xE3,W
02824:  SUBLW  82
02826:  BTFSS  FD8.2
02828:  GOTO   2834
....................             { 
....................                 break; 
0282C:  GOTO   2B6E
....................             } 
02830:  GOTO   2852
....................             else if (STATE_CALIB_STEP_5 == g_ui8CurrentState) 
02834:  MOVF   xE2,W
02836:  SUBLW  87
02838:  BTFSS  FD8.2
0283A:  GOTO   2852
....................             { 
....................                 // Pipe got stabilized now start Filling ADC Data Array 
....................                 // Step 1: Start Reading the ADC Data for Pipe Weight 
....................                 ////ResetADCDataQ(COLLECT_WEIGHING_DATA); 
....................                 g_i16ADCArrIdx = -1; 
0283E:  MOVLB  A
02840:  SETF   x27
02842:  SETF   x26
....................                 //memset(g_ui32ADCArr, 0, SIZE_ADC_DATA_QUEUE); 
....................                 // Step 2: Start ADC Scanning 
....................                 g_ui8ADCScanningStatus = ADC_SCAN_ON; 
02844:  MOVLW  01
02846:  MOVWF  x28
....................                 // Step 3: Wait until the step completes 
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
02848:  MOVLW  82
0284A:  MOVLB  6
0284C:  MOVWF  xE3
....................             } 
0284E:  GOTO   2852
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02852:  GOTO   2B6E
....................         case STATE_CALIB_STEP_6: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02856:  MOVLB  6
02858:  MOVF   xE3,W
0285A:  SUBLW  82
0285C:  BTFSS  FD8.2
0285E:  GOTO   286A
....................             { 
....................                 break; 
02862:  GOTO   2B6E
....................             } 
02866:  GOTO   2980
....................             else if (STATE_CALIB_STEP_6 == g_ui8CurrentState) 
0286A:  MOVF   xE2,W
0286C:  SUBLW  88
0286E:  BTFSS  FD8.2
02870:  GOTO   2980
....................             { 
....................                 // Calculate the Average 
....................                 g_ui32ADCCurSum = 0; 
02874:  CLRF   xF5
02876:  CLRF   xF4
02878:  CLRF   xF3
0287A:  CLRF   xF2
....................                 for(g_ui16ADCSumLoopCount = 0; g_ui16ADCSumLoopCount < SIZE_ADC_DATA_QUEUE; g_ui16ADCSumLoopCount++) 
0287C:  CLRF   xFF
0287E:  CLRF   xFE
02880:  MOVF   xFF,F
02882:  BTFSS  FD8.2
02884:  GOTO   28FC
02888:  MOVF   xFE,W
0288A:  SUBLW  C7
0288C:  BTFSS  FD8.0
0288E:  GOTO   28FC
....................                 { 
....................                     g_ui32ADCCurSum += g_ui32ADCArr[g_ui16ADCSumLoopCount]; 
02892:  RLCF   xFE,W
02894:  MOVWF  02
02896:  RLCF   xFF,W
02898:  MOVWF  03
0289A:  RLCF   02,F
0289C:  RLCF   03,F
0289E:  MOVLW  FC
028A0:  ANDWF  02,F
028A2:  MOVF   02,W
028A4:  ADDLW  06
028A6:  MOVWF  FE9
028A8:  MOVLW  07
028AA:  ADDWFC 03,W
028AC:  MOVWF  FEA
028AE:  MOVFF  FEF,00
028B2:  MOVFF  FEC,01
028B6:  MOVFF  FEC,02
028BA:  MOVFF  FEC,03
028BE:  MOVF   00,W
028C0:  ADDWF  xF2,F
028C2:  MOVF   01,W
028C4:  ADDWFC xF3,F
028C6:  MOVF   02,W
028C8:  ADDWFC xF4,F
028CA:  MOVF   03,W
028CC:  ADDWFC xF5,F
....................                     g_ui32ADCArr[g_ui16ADCSumLoopCount] = 0; 
028CE:  RLCF   xFE,W
028D0:  MOVWF  02
028D2:  RLCF   xFF,W
028D4:  MOVWF  03
028D6:  RLCF   02,F
028D8:  RLCF   03,F
028DA:  MOVLW  FC
028DC:  ANDWF  02,F
028DE:  MOVF   02,W
028E0:  ADDLW  06
028E2:  MOVWF  FE9
028E4:  MOVLW  07
028E6:  ADDWFC 03,W
028E8:  MOVWF  FEA
028EA:  CLRF   FEF
028EC:  CLRF   FEC
028EE:  CLRF   FEC
028F0:  CLRF   FEC
028F2:  INCF   xFE,F
028F4:  BTFSC  FD8.2
028F6:  INCF   xFF,F
028F8:  GOTO   2880
....................                 } 
....................                 if (!g_ui32ADCCurSum) 
028FC:  MOVF   xF2,F
028FE:  BTFSS  FD8.2
02900:  GOTO   2930
02904:  MOVF   xF3,F
02906:  BTFSS  FD8.2
02908:  GOTO   2930
0290C:  MOVF   xF4,F
0290E:  BTFSS  FD8.2
02910:  GOTO   2930
02914:  MOVF   xF5,F
02916:  BTFSS  FD8.2
02918:  GOTO   2930
....................                 { 
....................                     // Sum is 0, so update with the previous pipe weight value 
....................                     g_ui32ADCCurMeanValue = g_ui32PipeWtPrev; 
0291C:  MOVFF  6FD,6F1
02920:  MOVFF  6FC,6F0
02924:  MOVFF  6FB,6EF
02928:  MOVFF  6FA,6EE
....................                 } 
0292C:  GOTO   2976
....................                 else 
....................                 { 
....................                     g_ui32ADCCurMeanValue = g_ui32ADCCurSum / SIZE_ADC_DATA_QUEUE; 
02930:  BCF    FD8.1
02932:  MOVFF  6F5,A9A
02936:  MOVFF  6F4,A99
0293A:  MOVFF  6F3,A98
0293E:  MOVFF  6F2,A97
02942:  MOVLB  A
02944:  CLRF   x9E
02946:  CLRF   x9D
02948:  CLRF   x9C
0294A:  MOVLW  C8
0294C:  MOVWF  x9B
0294E:  MOVLB  0
02950:  CALL   1E02
02954:  MOVFF  03,6F1
02958:  MOVFF  02,6F0
0295C:  MOVFF  01,6EF
02960:  MOVFF  00,6EE
....................                     g_ui32PipeWtPrev = g_ui32ADCCurMeanValue; 
02964:  MOVFF  6F1,6FD
02968:  MOVFF  6F0,6FC
0296C:  MOVFF  6EF,6FB
02970:  MOVFF  6EE,6FA
02974:  MOVLB  6
....................                 } 
....................                 //g_ui32ADCCurMeanValue = g_ui32ADCCurSum / SIZE_ADC_DATA_QUEUE; 
....................                 g_ui8CurrentState++; 
02976:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING; 
02978:  MOVLW  BE
0297A:  MOVWF  xE3
....................             } 
0297C:  GOTO   2980
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02980:  GOTO   2B6E
....................         case STATE_CALIB_STEP_7: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02984:  MOVLB  6
02986:  MOVF   xE3,W
02988:  SUBLW  82
0298A:  BTFSS  FD8.2
0298C:  GOTO   2998
....................             { 
....................                 break; 
02990:  GOTO   2B6E
....................             } 
02994:  GOTO   2AA4
....................             else if (STATE_CALIB_STEP_7 == g_ui8CurrentState) 
02998:  MOVF   xE2,W
0299A:  SUBLW  89
0299C:  BTFSS  FD8.2
0299E:  GOTO   2AA4
....................             { 
....................                 if (SYS_MODE_CALIB == g_ui8SystemMode) 
029A2:  MOVLB  5
029A4:  MOVF   xD7,W
029A6:  SUBLW  05
029A8:  BTFSS  FD8.2
029AA:  GOTO   29CA
....................                 { 
....................                     // IN Calibration Mode We are sending Two Values to HMI 
....................                     // Dynamic Tare ADC Value and Actual Weight ADC Values 
....................                     IBUSendCalibResetData(g_ui32ADCCurMeanValue); 
029AE:  MOVFF  6F1,A76
029B2:  MOVFF  6F0,A75
029B6:  MOVFF  6EF,A74
029BA:  MOVFF  6EE,A73
029BE:  MOVLB  0
029C0:  GOTO   21C6
....................                 } 
029C4:  GOTO   2A96
029C8:  MOVLB  5
....................                 else if (SYS_MODE_PROD == g_ui8SystemMode) 
029CA:  MOVF   xD7,W
029CC:  SUBLW  03
029CE:  BTFSS  FD8.2
029D0:  GOTO   2A98
....................                 { 
....................                     // Weighing Calculation Done 
....................                     // Step 1: Calculate the Pipe Weight ADC Value. 
....................                     // Check if current weight is a valid weight of any proper pipe. 
....................                     if(g_ui32ADCCurMeanValue > g_ui32DynamicTareADCValue) 
029D4:  MOVF   xDF,W
029D6:  MOVLB  6
029D8:  SUBWF  xF1,W
029DA:  BTFSS  FD8.0
029DC:  GOTO   2A74
029E0:  BTFSS  FD8.2
029E2:  GOTO   2A20
029E6:  MOVLB  5
029E8:  MOVF   xDE,W
029EA:  MOVLB  6
029EC:  SUBWF  xF0,W
029EE:  BTFSS  FD8.0
029F0:  GOTO   2A74
029F4:  BTFSS  FD8.2
029F6:  GOTO   2A20
029FA:  MOVLB  5
029FC:  MOVF   xDD,W
029FE:  MOVLB  6
02A00:  SUBWF  xEF,W
02A02:  BTFSS  FD8.0
02A04:  GOTO   2A74
02A08:  BTFSS  FD8.2
02A0A:  GOTO   2A20
02A0E:  MOVF   xEE,W
02A10:  MOVLB  5
02A12:  SUBWF  xDC,W
02A14:  BTFSS  FD8.0
02A16:  BRA    2A1E
02A18:  MOVLB  6
02A1A:  GOTO   2A74
02A1E:  MOVLB  6
....................                     { 
....................                         // It is a valid weight of pipe. 
....................                         // Calculate weight. 
....................                         g_ui32CurPipeADCValue = g_ui32ADCCurMeanValue - g_ui32DynamicTareADCValue; 
02A20:  MOVLB  5
02A22:  MOVF   xDC,W
02A24:  MOVLB  6
02A26:  SUBWF  xEE,W
02A28:  MOVWF  xE4
02A2A:  MOVLB  5
02A2C:  MOVF   xDD,W
02A2E:  MOVLB  6
02A30:  SUBWFB xEF,W
02A32:  MOVWF  xE5
02A34:  MOVLB  5
02A36:  MOVF   xDE,W
02A38:  MOVLB  6
02A3A:  SUBWFB xF0,W
02A3C:  MOVWF  xE6
02A3E:  MOVLB  5
02A40:  MOVF   xDF,W
02A42:  MOVLB  6
02A44:  SUBWFB xF1,W
02A46:  MOVWF  xE7
....................                         // Step 2: Calculate the Actual Weight. 
....................                         g_ui32CurPipeWeight = GetCalibratedWeight(g_ui32CurPipeADCValue); 
02A48:  MOVFF  6E7,A76
02A4C:  MOVFF  6E6,A75
02A50:  MOVFF  6E5,A74
02A54:  MOVFF  6E4,A73
02A58:  MOVLB  0
02A5A:  CALL   205A
02A5E:  MOVFF  03,6EB
02A62:  MOVFF  02,6EA
02A66:  MOVFF  01,6E9
02A6A:  MOVFF  00,6E8
....................                     } 
02A6E:  GOTO   2A7E
02A72:  MOVLB  6
....................                     else  // Erroneous ADC value arrived. weight will be zero to indicate. 
....................                     { 
....................                         // set zero weight to indicate erroneous operation. 
....................                         g_ui32CurPipeWeight = 0; 
02A74:  CLRF   xEB
02A76:  CLRF   xEA
02A78:  CLRF   xE9
02A7A:  CLRF   xE8
02A7C:  MOVLB  0
....................                     } 
....................                      
....................                     // Step 3: Send the Actual Weight to HMI 
....................                     IBUSendWeighingData(g_ui32CurPipeWeight); 
02A7E:  MOVFF  6EB,A76
02A82:  MOVFF  6EA,A75
02A86:  MOVFF  6E9,A74
02A8A:  MOVFF  6E8,A73
02A8E:  GOTO   2432
....................                 } 
02A92:  GOTO   2A96
02A96:  MOVLB  5
....................                 else 
....................                 { 
....................                     /* Do Nothing */ 
....................                 } 
....................                       
....................                 g_ui8CurrentState++; 
02A98:  MOVLB  6
02A9A:  INCF   xE2,F
....................                 g_ui8StateWaiting = STATE_NOTHING;                 
02A9C:  MOVLW  BE
02A9E:  MOVWF  xE3
....................                                  
....................             } 
02AA0:  GOTO   2AA4
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02AA4:  GOTO   2B6E
....................         case STATE_CALIB_STEP_8: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02AA8:  MOVLB  6
02AAA:  MOVF   xE3,W
02AAC:  SUBLW  82
02AAE:  BTFSS  FD8.2
02AB0:  GOTO   2ABC
....................             { 
....................                 break; 
02AB4:  GOTO   2B6E
....................             } 
02AB8:  GOTO   2AE2
....................             else if (STATE_CALIB_STEP_8 == g_ui8CurrentState) 
02ABC:  MOVF   xE2,W
02ABE:  SUBLW  8A
02AC0:  BTFSS  FD8.2
02AC2:  GOTO   2AE2
....................             { 
....................                 // Step 1: Pull Down the Weighing Pusher 
....................                 output_bit(PIN_OUT_DO_00, 1); 
02AC6:  BSF    F80.2
02AC8:  BCF    F88.2
....................                 // Step 2: Wait for a While 
....................                 g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_ON; 
02ACA:  MOVLW  01
02ACC:  MOVLB  A
02ACE:  MOVWF  x3D
....................                 g_ui16DelayFlexi = g_ui16PipeStabilizationDelayTime; 
02AD0:  MOVFF  5FC,A42
02AD4:  MOVFF  5FB,A41
....................                 // Wait until the step completes 
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
02AD8:  MOVLW  82
02ADA:  MOVLB  6
02ADC:  MOVWF  xE3
....................             } 
02ADE:  GOTO   2AE2
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02AE2:  GOTO   2B6E
....................         case STATE_CALIB_STEP_9: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02AE6:  MOVLB  6
02AE8:  MOVF   xE3,W
02AEA:  SUBLW  82
02AEC:  BTFSS  FD8.2
02AEE:  GOTO   2AFA
....................             { 
....................                 break; 
02AF2:  GOTO   2B6E
....................             } 
02AF6:  GOTO   2B2C
....................             else if (STATE_CALIB_STEP_9 == g_ui8CurrentState) 
02AFA:  MOVF   xE2,W
02AFC:  SUBLW  8B
02AFE:  BTFSS  FD8.2
02B00:  GOTO   2B2C
....................             { 
....................                 // Step 1: Pull up the Pipe Transfer Pusher. 
....................                 output_bit(PIN_OUT_DO_01, 0); 
02B04:  BCF    F80.3
02B06:  BCF    F88.3
....................                 // Reset weighing cylinder up activation delay counter. 
....................                 g_ui16WeighingCylinderActuationDelayCnt = 0;                 
02B08:  MOVLB  A
02B0A:  CLRF   x5C
02B0C:  CLRF   x5B
....................                 // Step 2: Wait for a While 
....................                 g_ui8DlyStabilizationState = FLAG_PIPE_STABILIZATION_DELAY_ON; 
02B0E:  MOVLW  01
02B10:  MOVWF  x3D
....................                 g_ui16DelayFlexi = g_ui16PipeTransferDelayTime; 
02B12:  MOVFF  5FE,A42
02B16:  MOVFF  5FD,A41
....................                 // Wait until the step completes 
....................                 g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
02B1A:  MOVLW  82
02B1C:  MOVLB  6
02B1E:  MOVWF  xE3
....................                  
....................                 // Reset Indicating Tower light(If any) 
....................                 output_bit(PIN_OUT_DO_04, 1); 
02B20:  BSF    F7C.3
02B22:  BCF    F84.3
....................                 output_bit(PIN_OUT_DO_03, 1);                 
02B24:  BSF    F7C.2
02B26:  BCF    F84.2
....................             } 
02B28:  GOTO   2B2C
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................         } 
....................         break; 
02B2C:  GOTO   2B6E
....................         case STATE_CALIB_STEP_10: 
....................         { 
....................             if (STATE_CALIB_STEP_WAITING == g_ui8StateWaiting) 
02B30:  MOVLB  6
02B32:  MOVF   xE3,W
02B34:  SUBLW  82
02B36:  BTFSS  FD8.2
02B38:  GOTO   2B44
....................             { 
....................                 break; 
02B3C:  GOTO   2B6E
....................             } 
02B40:  GOTO   2B62
....................             else if (STATE_CALIB_STEP_10 == g_ui8CurrentState) 
02B44:  MOVF   xE2,W
02B46:  SUBLW  8C
02B48:  BTFSS  FD8.2
02B4A:  GOTO   2B62
....................             { 
....................                 // Step 1: Pull down the Pipe Transfer Pusher 
....................                 //output_high(PIN_OUT_DO_01); 
.................... //                for (i = 0; i < 10; i++) 
.................... //                { 
.................... //                    output_bit(PIN_OUT_DO_01, 1); 
.................... //                    delay_ms(1); 
.................... //                } 
....................                 output_bit(PIN_OUT_DO_01, 1); 
02B4E:  BSF    F80.3
02B50:  BCF    F88.3
....................                 // Step 2: Loop back to Step 1 
....................                 g_ui8CurrentState = STATE_CALIB_STEP_1; 
02B52:  MOVLW  83
02B54:  MOVWF  xE2
....................                 //g_ui8StateWaiting = STATE_CALIB_STEP_WAITING; 
....................                 g_ui8PipePresence = PIPE_NOT_PRESENT; 
02B56:  MOVLW  01
02B58:  MOVLB  A
02B5A:  MOVWF  x3E
....................             } 
02B5C:  GOTO   2B60
02B60:  MOVLB  6
....................             else 
....................             { 
....................                 // Do Nothing 
....................             } 
....................  
....................         } 
....................         break; 
02B62:  GOTO   2B6E
02B66:  MOVLB  0
....................         default: 
....................         { 
....................             // Nothing to do 
....................         } 
....................         break; 
02B68:  MOVLB  6
02B6A:  GOTO   2B6E
....................     } 
02B6E:  MOVLB  0
02B70:  GOTO   3162 (RETURN)
.................... } 
....................  
.................... #endif	/* MZ_PWT_STATEMACHINE_H */ 
....................  
....................  
.................... #include "vmIBCProcessM0.h" 
.................... /*  
....................  * File:   vmIBUProcessM0.h 
....................  * Author: Amit 
....................  * 
....................  * Created on December 9, 2018, 6:17 PM 
....................  */ 
....................  
.................... #ifndef VM_IBU_PROCESS_M0_H 
.................... #define	VM_IBU_PROCESS_M0_H 
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "vmM0ADCModuleCommon.h" 
.................... /*  
....................  * File:   vmM0ADCModuleCommon.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 13, 2018, 4:59 PM 
....................  */ 
....................  
.................... #ifndef VM_M0_ADC_MODULE_COMMON_H 
.................... #define	VM_M0_ADC_MODULE_COMMON_H 
....................  
.................... #define PIPE_ACCEPTED              2 
.................... #define PIPE_REJECTED              0 
.................... #define PIPE_OVER_WEIGHT           1 
.................... #define PIPE_UNDER_WEIGHT          0 
....................  
.................... #define SYS_MODE_NOTHING        0 
.................... #define SYS_MODE_HOME           1 
.................... #define SYS_MODE_PRE_PROD       2 
.................... #define SYS_MODE_PROD           3 
.................... #define SYS_MODE_CONFIG         4 
.................... #define SYS_MODE_CALIB          5 
.................... #define SYS_MODE_POST_PROD      6 
.................... #define SYS_MODE_WAKE_UP        7 
.................... #define SYS_MODE_PRE_PROD_SCRAP 8 
....................  
.................... #define ADC_MEAN_DATA_INTERMEDIATE_WEIGHT   31 
.................... #define ADC_MEAN_DATA_INTERMEDIATE_TARE     32 
.................... #define ADC_MEAN_DATA_FINAL_WEIGHT          33 
.................... #define ADC_MEAN_DATA_FINAL_TARE            34 
.................... #define ADC_MEAN_DATA_CALIB_WEIGHT          35 
.................... #define ADC_MEAN_DATA_NOTHING               36 
....................  
.................... unsigned int8 g_ui8ADCMeanDataState = ADC_MEAN_DATA_NOTHING; 
....................  
.................... #define FLAG_WT_CALCULATION_DONE     1 
.................... #define FLAG_WT_CALCULATION_NOT_DONE 0 
....................  
.................... unsigned int8 g_fWtCalculationState = FLAG_WT_CALCULATION_NOT_DONE; 
....................  
.................... #define IBU_RESET_CALIB_OFF    0 
.................... #define IBU_RESET_CALIB_ON     1 
....................  
.................... #define HMI_REJECTION_AUTO_CALIB_MODE   0 
.................... #define HMI_REJECTION_FIXED_CALIB_MODE  1 
....................  
....................  
.................... unsigned int16 g_ui16RejectionStatus      = PIPE_REJECTED; 
.................... unsigned int8  g_ui8SystemMode            = SYS_MODE_NOTHING; 
.................... unsigned int32 g_ui32DynamicTareValue     = 0; 
.................... unsigned int32 g_ui32DynamicTareADCValue  = 0; 
.................... unsigned int16 g_ui16PipeCount            = 0; 
....................  
.................... unsigned int16 g_ui16PrevDynamicTareValue = 0; 
.................... int32          g_i32StaticTareValue       = 0;  // TODO Should keep in EEPROM 
.................... unsigned int8  g_fResetCalibStatus        = IBU_RESET_CALIB_OFF; 
....................  
.................... int32          g_i32ADCSumValue          = 0; 
.................... int32          g_i32ADCAvgValue          = 0; 
.................... unsigned int16 g_ui16ADCCalibValueEEPROM = 0; 
.................... unsigned int16 g_ui16CalibPointEEPROM    = 0; 
.................... int16          g_i16CalibResetPrevValue  = 0; 
.................... int16          g_i16DynamicErrValue      = 0; 
....................  
....................  
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int32 m_i32AvgWeight; 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_CUR_BATCH_INFO; 
....................  
.................... ST_CUR_BATCH_INFO g_stCurBatchInfo; 
....................  
....................        
.................... #define STATE_HOME          0 
.................... #define STATE_PRE_PROD      1 
.................... #define STATE_PROD          2 
.................... #define STATE_POST_PROD     3 
.................... #define STATE_CALIB         4 
.................... #define STATE_NONE          5 
....................  
.................... unsigned int8  g_ui8ExpectedNextState[2] = {0}; 
....................  
.................... #endif	/* VM_M0_ADC_MODULE_COMMON_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... //#include "../Common/vmModbusGlobal.h" 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  1200   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int32 m_i32Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
.................... { 
....................     unsigned int8 ui8LoopCount   = 0; 
....................     g_stAvgWtQueue.m_i8Rear      = -1; 
....................     g_stAvgWtQueue.m_i8Length    = SIZE_AVG_WT_ARR; 
....................     g_stAvgWtQueue.m_i32CurAvg   = 0; 
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
....................     { 
....................         g_stAvgWtQueue.m_i32Arr[ui8LoopCount] = 0; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32LstAvg = 0; 
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int32 i32LastWeight) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
.................... //    // Check the weight deviation from Selected SKU Average Weight 
.................... //    if (i32LastWeight > (g_stCurBatchInfo.m_i32AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
.................... //        i32LastWeight < (g_stCurBatchInfo.m_i32AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
.................... //    { 
.................... //        // The weight is out of range, we are not inserting this weight into Average weight queue  
.................... //        return; 
.................... //    } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
....................      
....................     // Check queue rear with size. 
....................     if(g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
....................     { 
....................         // Queue is full. 
....................         // Set flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 1; 
....................          
....................         // Reset rear. 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i32LastWeight >= g_stAvgWtQueue.m_i32LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i32Arr[g_stAvgWtQueue.m_i8Rear] = i32LastWeight; 
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
....................     { 
....................         // Set maximum entry will be same as queue size. 
....................         i8MaxEntry = SIZE_AVG_WT_ARR; 
....................          
....................         // Reset queue full flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 0; 
....................     } 
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i32Arr[i8LoopCount]; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32CurAvg = (int32)(i32Sum / (int32)i8MaxEntry); 
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i32LstAvg = g_stAvgWtQueue.m_i32CurAvg; 
.................... } 
....................  
.................... void IBUSendProdModeAvgData() 
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBU Data Node 
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32Padding  = 0; 
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg   = g_stAvgWtQueue.m_i32CurAvg; 
....................      
....................     // Stuff IBU Command 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_PROD_AVG_WT_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBU Insert. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_M0.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
....................  
.................... #define EEPROM_ADDRESS_FOR_LCF                       100 
.................... #define EEPROM_ADDRESS_FOR_MAX_WT                    110    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_MIN_WT                    114    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY       118 
.................... #define EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY  120 
.................... #define EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY       122 
.................... #define EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY 124    // 2-Byte 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
....................      
....................     return((int16)ui16RetrieveLCF); 
.................... } 
....................  
.................... void WriteMaxWeightToEEPROM(int32 i32MaxWeight) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 16); 
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 0); 
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
.................... } 
....................  
.................... void WriteMinWeightToEEPROM(int32 i32MinWeight) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 16); 
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 0); 
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue);     
.................... } 
....................  
.................... int32 ReadMaxWeightFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16WordValue     = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MaxWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MaxWeight = (int32)ui16WordValue; 
....................     // Shift data to MSB. 
....................     i32MaxWeight = (i32MaxWeight << 16); 
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     i32MaxWeight = (((int16)ui16WordValue) | (i32MaxWeight & 0xFFFF0000)); 
....................      
....................     return i32MaxWeight; 
.................... } 
....................  
.................... int32 ReadMinWeightFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MinWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MinWeight = (int32)ui16WordValue; 
....................     // Shift data to MSB. 
....................     i32MinWeight = (i32MinWeight << 16); 
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     i32MinWeight = (((int16)ui16WordValue) | (i32MinWeight & 0xFFFF0000)); 
....................      
....................     return i32MinWeight;     
.................... } 
....................  
.................... void WritePipePresenceDelayToEEPROM(unsigned int16 ui16PipePresenceDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY, ui16PipePresenceDelay); 
.................... } 
....................  
.................... unsigned int16 ReadPipePresenceDelayFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16PipePresenceDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipePresenceDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY); 
....................      
....................     return ui16PipePresenceDelayTime; 
.................... } 
....................  
.................... void WritePipeStabilizationDelayToEEPROM(unsigned int16 ui16PipeStabilizationDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY, ui16PipeStabilizationDelay);     
.................... } 
....................  
.................... unsigned int16 ReadPipeStabilizationDelayFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16PipeStabilizationDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipeStabilizationDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY); 
....................      
....................     return ui16PipeStabilizationDelayTime;     
.................... } 
....................  
....................  
.................... void WritePipeTransferDelayToEEPROM(unsigned int16 g_ui16PipeTransferDelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY, g_ui16PipeTransferDelayTime);     
.................... } 
....................  
.................... unsigned int16 ReadPipeTransferDelayTime(void) 
.................... { 
....................     unsigned int16 ui16PipeTransferDelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16PipeTransferDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY); 
....................      
....................     return ui16PipeTransferDelayTime;      
.................... }     
....................  
.................... void WriteWeighingCylinderActivationDelayToEEPROM(unsigned int16 ui16DelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY, ui16DelayTime);     
.................... } 
....................  
.................... unsigned int16 ReadWeighingCylinderActivationDelayfromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16DelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16DelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY); 
....................      
....................     return ui16DelayTime;     
.................... } 
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
....................  
....................  
....................  
.................... void ProcessIBUMsg(void) 
*
0193E:  MOVLB  A
01940:  CLRF   x73
.................... { 
....................     int8 i8LoopCount = 0; 
....................     ST_IBU_DATA_NODE stIBURcvNode; 
....................      
....................     // Get Node from IBU Receive Message Queue 
....................     DeleteIBUMsgQueue(&g_stIBURcvQueue, &stIBURcvNode); 
01942:  MOVLW  02
01944:  MOVWF  x82
01946:  MOVLW  C4
01948:  MOVWF  x81
0194A:  MOVLW  0A
0194C:  MOVWF  x84
0194E:  MOVLW  74
01950:  MOVWF  x83
01952:  MOVLB  0
01954:  GOTO   167A
....................     // There is some valid message in IBU Receive Buffer 
....................     // Try to process that message 
....................     switch (stIBURcvNode.g_ui8ArrIBUData[0]) 
01958:  MOVLB  A
0195A:  MOVF   x76,W
0195C:  XORLW  64
0195E:  MOVLB  0
01960:  BTFSC  FD8.2
01962:  GOTO   19D2
01966:  XORLW  01
01968:  BTFSC  FD8.2
0196A:  GOTO   19DC
0196E:  XORLW  0A
01970:  BTFSC  FD8.2
01972:  GOTO   19F2
01976:  XORLW  ED
01978:  BTFSC  FD8.2
0197A:  GOTO   19FC
0197E:  XORLW  14
01980:  BTFSC  FD8.2
01982:  GOTO   1A12
01986:  XORLW  1B
01988:  BTFSC  FD8.2
0198A:  GOTO   1A1C
0198E:  XORLW  E1
01990:  BTFSC  FD8.2
01992:  GOTO   1A26
01996:  XORLW  0A
01998:  BTFSC  FD8.2
0199A:  GOTO   1AD8
0199E:  XORLW  10
019A0:  BTFSC  FD8.2
019A2:  GOTO   1AEE
019A6:  XORLW  1D
019A8:  BTFSC  FD8.2
019AA:  GOTO   1AF8
019AE:  XORLW  1A
019B0:  BTFSC  FD8.2
019B2:  GOTO   1AFE
019B6:  XORLW  F2
019B8:  BTFSC  FD8.2
019BA:  GOTO   1BD2
019BE:  XORLW  1B
019C0:  BTFSC  FD8.2
019C2:  GOTO   1BD8
019C6:  XORLW  03
019C8:  BTFSC  FD8.2
019CA:  GOTO   1C88
019CE:  GOTO   1CEC
....................     { 
....................         case IBU_CMD_MODE_HOME: 
....................             g_ui8SystemMode = SYS_MODE_HOME; 
019D2:  MOVLW  01
019D4:  MOVLB  5
019D6:  MOVWF  xD7
....................             break; 
019D8:  GOTO   1CF2
....................              
....................         case IBU_CMD_MODE_CALIB: 
....................             g_ui8SystemMode = SYS_MODE_CALIB; 
019DC:  MOVLW  05
019DE:  MOVLB  5
019E0:  MOVWF  xD7
....................             g_ui8CurrentState = STATE_CALIB_STEP_1; 
019E2:  MOVLW  83
019E4:  MOVLB  6
019E6:  MOVWF  xE2
....................             g_ui8StateWaiting = STATE_NOTHING; 
019E8:  MOVLW  BE
019EA:  MOVWF  xE3
....................             break; 
019EC:  MOVLB  5
019EE:  GOTO   1CF2
....................              
....................         case IBU_CMD_MODE_PRE_PROD: 
....................             g_ui8SystemMode = SYS_MODE_PRE_PROD; 
019F2:  MOVLW  02
019F4:  MOVLB  5
019F6:  MOVWF  xD7
....................             break;   
019F8:  GOTO   1CF2
....................          
....................         case IBU_CMD_MODE_PROD: 
....................             g_ui8SystemMode = SYS_MODE_PROD; 
019FC:  MOVLW  03
019FE:  MOVLB  5
01A00:  MOVWF  xD7
....................             g_ui8CurrentState = STATE_CALIB_STEP_1; 
01A02:  MOVLW  83
01A04:  MOVLB  6
01A06:  MOVWF  xE2
....................             g_ui8StateWaiting = STATE_NOTHING; 
01A08:  MOVLW  BE
01A0A:  MOVWF  xE3
....................             break; 
01A0C:  MOVLB  5
01A0E:  GOTO   1CF2
....................              
....................         case IBU_CMD_MODE_POST_PROD: 
....................             g_ui8SystemMode = SYS_MODE_POST_PROD; 
01A12:  MOVLW  06
01A14:  MOVLB  5
01A16:  MOVWF  xD7
....................             break; 
01A18:  GOTO   1CF2
....................              
....................         case IBU_CMD_MODE_CONFIG: 
....................             g_ui8SystemMode = SYS_MODE_CONFIG; 
01A1C:  MOVLW  04
01A1E:  MOVLB  5
01A20:  MOVWF  xD7
....................             break;             
01A22:  GOTO   1CF2
....................      
....................         case IBU_CMD_SET_LOAD_CELL_FACTOR: 
....................             
....................             // Receive current load cell factor. 
....................             for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01A26:  MOVLW  01
01A28:  MOVLB  A
01A2A:  MOVWF  x73
01A2C:  MOVF   x73,W
01A2E:  SUBLW  08
01A30:  BTFSS  FD8.0
01A32:  GOTO   1A6C
....................             { 
....................                 g_unIBUCurrLoadCellFactor.m_ui8Arr[i8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[i8LoopCount]; 
01A36:  MOVLW  01
01A38:  SUBWF  x73,W
01A3A:  CLRF   03
01A3C:  ADDLW  68
01A3E:  MOVWF  01
01A40:  MOVLW  00
01A42:  ADDWFC 03,F
01A44:  MOVFF  03,A82
01A48:  CLRF   03
01A4A:  MOVF   x73,W
01A4C:  ADDLW  76
01A4E:  MOVWF  FE9
01A50:  MOVLW  0A
01A52:  ADDWFC 03,W
01A54:  MOVWF  FEA
01A56:  MOVFF  FEF,A83
01A5A:  MOVFF  A82,FEA
01A5E:  MOVFF  01,FE9
01A62:  MOVFF  A83,FEF
01A66:  INCF   x73,F
01A68:  GOTO   1A2C
....................             } 
....................              
....................             //g_stCurBatchInfo.m_i16AvgWeight = g_unIBUAvgNode.m_stIBUAvgNode.m_i16AvgWt; 
....................             // Store current LCF(Load Cell Factor) in RAM. 
....................             g_i16LoadCellFactor = (int16)g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor; 
01A6C:  MOVFF  69,701
01A70:  MOVFF  68,700
....................              
....................             // Store the LCF in EEPROM to retrieve data on system restart. 
....................             WriteLCFToEEPROM(g_i16LoadCellFactor); 
01A74:  MOVFF  701,A82
01A78:  MOVFF  700,A81
01A7C:  MOVLB  0
01A7E:  GOTO   17E8
....................              
....................             // Convert decimal load cell factor into fraction. 
....................             g_f32LoadCellFactor = (float32)g_i16LoadCellFactor / (float32)100; 
01A82:  MOVFF  701,A82
01A86:  MOVFF  700,A81
01A8A:  CALL   0784
01A8E:  MOVFF  03,A84
01A92:  MOVFF  02,A83
01A96:  MOVFF  01,A82
01A9A:  MOVFF  00,A81
01A9E:  MOVFF  03,A88
01AA2:  MOVFF  02,A87
01AA6:  MOVFF  01,A86
01AAA:  MOVFF  00,A85
01AAE:  MOVLB  A
01AB0:  CLRF   x8C
01AB2:  CLRF   x8B
01AB4:  MOVLW  48
01AB6:  MOVWF  x8A
01AB8:  MOVLW  85
01ABA:  MOVWF  x89
01ABC:  MOVLB  0
01ABE:  CALL   07C8
01AC2:  MOVFF  03,705
01AC6:  MOVFF  02,704
01ACA:  MOVFF  01,703
01ACE:  MOVFF  00,702
....................              
....................             break; 
01AD2:  MOVLB  5
01AD4:  GOTO   1CF2
....................  
....................         case IBU_CMD_START_CALIBRATION: 
....................             // Set flag to notify state_machine_0 that calibration mode is ON. 
....................             ////////g_fResetCalibStatus = IBU_RESET_CALIB_ON; 
....................             g_ui8SystemMode = SYS_MODE_CALIB; 
01AD8:  MOVLW  05
01ADA:  MOVLB  5
01ADC:  MOVWF  xD7
....................             g_ui8CurrentState = STATE_CALIB_STEP_1; 
01ADE:  MOVLW  83
01AE0:  MOVLB  6
01AE2:  MOVWF  xE2
....................             g_ui8StateWaiting = STATE_NOTHING; 
01AE4:  MOVLW  BE
01AE6:  MOVWF  xE3
....................             break; 
01AE8:  MOVLB  5
01AEA:  GOTO   1CF2
....................         case IBU_CMD_PRE_PROD_SCRAP_MODE: 
....................             // Set flag to notify state_machine_0 that calibration mode is ON. 
....................             g_ui8SystemMode = SYS_MODE_PRE_PROD_SCRAP; 
01AEE:  MOVLW  08
01AF0:  MOVLB  5
01AF2:  MOVWF  xD7
....................             break; 
01AF4:  GOTO   1CF2
....................         case IBU_CMD_TARE_REQUEST: 
....................             //ResetCalibTable(g_ui16DynamicTareValue); 
....................             break; 
01AF8:  MOVLB  5
01AFA:  GOTO   1CF2
....................         case IBU_CMD_PRE_PROD_TOLERANCE: 
....................             // Copy the Message for Parsing 
....................             for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01AFE:  MOVLW  01
01B00:  MOVLB  A
01B02:  MOVWF  x73
01B04:  MOVF   x73,W
01B06:  SUBLW  08
01B08:  BTFSS  FD8.0
01B0A:  GOTO   1B44
....................             { 
....................                 g_unIBUTolNode.m_ui8Arr[i8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[i8LoopCount]; 
01B0E:  MOVLW  01
01B10:  SUBWF  x73,W
01B12:  CLRF   03
01B14:  ADDLW  4C
01B16:  MOVWF  01
01B18:  MOVLW  00
01B1A:  ADDWFC 03,F
01B1C:  MOVFF  03,A82
01B20:  CLRF   03
01B22:  MOVF   x73,W
01B24:  ADDLW  76
01B26:  MOVWF  FE9
01B28:  MOVLW  0A
01B2A:  ADDWFC 03,W
01B2C:  MOVWF  FEA
01B2E:  MOVFF  FEF,A83
01B32:  MOVFF  A82,FEA
01B36:  MOVFF  01,FE9
01B3A:  MOVFF  A83,FEF
01B3E:  INCF   x73,F
01B40:  GOTO   1B04
....................             } 
....................              
....................             // Store the received data in respective register. 
....................             g_stCurBatchInfo.m_i32MaxWt = g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
01B44:  MOVFF  4F,608
01B48:  MOVFF  4E,607
01B4C:  MOVFF  4D,606
01B50:  MOVFF  4C,605
....................             g_stCurBatchInfo.m_i32MinWt = g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt; 
01B54:  MOVFF  53,60C
01B58:  MOVFF  52,60B
01B5C:  MOVFF  51,60A
01B60:  MOVFF  50,609
....................              
....................             // Send acknowledgement to HMI. 
....................             // a. prepare IBU data node. 
....................             g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOL_STORE_ACK; 
01B64:  MOVLW  97
01B66:  MOVLB  1
01B68:  MOVWF  x6B
....................              
....................             // b. Stuff data; here padding. 
....................             for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01B6A:  MOVLW  01
01B6C:  MOVLB  A
01B6E:  MOVWF  x73
01B70:  MOVF   x73,W
01B72:  SUBLW  08
01B74:  BTFSS  FD8.0
01B76:  GOTO   1B92
....................             { 
....................                 g_unIBUTolNode.m_ui8Arr[i8LoopCount - 1] = 0; 
01B7A:  MOVLW  01
01B7C:  SUBWF  x73,W
01B7E:  CLRF   03
01B80:  ADDLW  4C
01B82:  MOVWF  FE9
01B84:  MOVLW  00
01B86:  ADDWFC 03,W
01B88:  MOVWF  FEA
01B8A:  CLRF   FEF
01B8C:  INCF   x73,F
01B8E:  GOTO   1B70
....................             } 
....................  
....................             // c. Insert data in IBU sent message queue. 
....................             InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
01B92:  MOVLW  01
01B94:  MOVWF  x98
01B96:  SETF   x97
01B98:  MOVWF  x9A
01B9A:  MOVLW  69
01B9C:  MOVWF  x99
01B9E:  MOVLB  0
01BA0:  CALL   1114
....................              
....................             // Store data in EEPROM. 
....................             WriteMaxWeightToEEPROM(g_stCurBatchInfo.m_i32MaxWt); 
01BA4:  MOVFF  608,A84
01BA8:  MOVFF  607,A83
01BAC:  MOVFF  606,A82
01BB0:  MOVFF  605,A81
01BB4:  GOTO   180E
....................             WriteMinWeightToEEPROM(g_stCurBatchInfo.m_i32MinWt); 
01BB8:  MOVFF  60C,A84
01BBC:  MOVFF  60B,A83
01BC0:  MOVFF  60A,A82
01BC4:  MOVFF  609,A81
01BC8:  GOTO   1872
....................             break; 
01BCC:  MOVLB  5
01BCE:  GOTO   1CF2
....................         case IBU_CMD_START_PROD: 
....................             break; 
01BD2:  MOVLB  5
01BD4:  GOTO   1CF2
....................         case IBU_CMD_STORE_PROD_DELAY_TIMERS: 
....................             // Copy the data. 
....................             for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01BD8:  MOVLW  01
01BDA:  MOVLB  A
01BDC:  MOVWF  x73
01BDE:  MOVF   x73,W
01BE0:  SUBLW  08
01BE2:  BTFSS  FD8.0
01BE4:  GOTO   1C1E
....................             { 
....................                 g_unProdDelayTimers.m_ui8Arr[i8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[i8LoopCount]; 
01BE8:  MOVLW  01
01BEA:  SUBWF  x73,W
01BEC:  CLRF   03
01BEE:  ADDLW  70
01BF0:  MOVWF  01
01BF2:  MOVLW  00
01BF4:  ADDWFC 03,F
01BF6:  MOVFF  03,A82
01BFA:  CLRF   03
01BFC:  MOVF   x73,W
01BFE:  ADDLW  76
01C00:  MOVWF  FE9
01C02:  MOVLW  0A
01C04:  ADDWFC 03,W
01C06:  MOVWF  FEA
01C08:  MOVFF  FEF,A83
01C0C:  MOVFF  A82,FEA
01C10:  MOVFF  01,FE9
01C14:  MOVFF  A83,FEF
01C18:  INCF   x73,F
01C1A:  GOTO   1BDE
....................             } 
....................  
....................             // Check the message header.     1. Pipe presence delay 2. Pipe stabilization delay 3. Pipe transfer delay. 
....................             if(PIPE_PRESENCE_DELAY == g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader) 
01C1E:  MOVLB  0
01C20:  DECFSZ x70,W
01C22:  GOTO   1C3E
....................             { 
....................                 // Parse the data. 
....................                 g_ui16PipePresenceDelayTime = g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer; 
01C26:  MOVFF  72,5FA
01C2A:  MOVFF  71,5F9
....................                  
....................                 // Store the data in EEPROM. 
....................                 WritePipePresenceDelayToEEPROM(g_ui16PipePresenceDelayTime); 
01C2E:  MOVFF  5FA,A82
01C32:  MOVFF  5F9,A81
01C36:  GOTO   18D6
....................             } 
01C3A:  GOTO   1C82
....................             else if(PIPE_STABILIZATION_DELAY == g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader) 
01C3E:  MOVF   x70,W
01C40:  SUBLW  02
01C42:  BTFSS  FD8.2
01C44:  GOTO   1C60
....................             { 
....................                 // Parse the data. 
....................                 g_ui16PipeStabilizationDelayTime = g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer; 
01C48:  MOVFF  72,5FC
01C4C:  MOVFF  71,5FB
....................                  
....................                 // Store the data in EEPROM. 
....................                 WritePipeStabilizationDelayToEEPROM(g_ui16PipeStabilizationDelayTime);                 
01C50:  MOVFF  5FC,A82
01C54:  MOVFF  5FB,A81
01C58:  GOTO   18F0
....................             } 
01C5C:  GOTO   1C82
....................             else if(PIPE_TRANSFER_DELAY == g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader) 
01C60:  MOVF   x70,W
01C62:  SUBLW  03
01C64:  BTFSS  FD8.2
01C66:  GOTO   1C82
....................             { 
....................                 // Parse the data. 
....................                 g_ui16PipeTransferDelayTime = g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer; 
01C6A:  MOVFF  72,5FE
01C6E:  MOVFF  71,5FD
....................                  
....................                 // Store the data in EEPROM. 
....................                 WritePipeTransferDelayToEEPROM(g_ui16PipeTransferDelayTime);                 
01C72:  MOVFF  5FE,A82
01C76:  MOVFF  5FD,A81
01C7A:  GOTO   190A
....................             } 
01C7E:  GOTO   1C82
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................             break; 
01C82:  MOVLB  5
01C84:  GOTO   1CF2
....................         case IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY: 
....................             // Copy the data. 
....................             for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
01C88:  MOVLW  01
01C8A:  MOVLB  A
01C8C:  MOVWF  x73
01C8E:  MOVF   x73,W
01C90:  SUBLW  08
01C92:  BTFSS  FD8.0
01C94:  GOTO   1CCE
....................             { 
....................                 g_unWeighingCylinderUpActivationDelay.m_ui8Arr[i8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[i8LoopCount]; 
01C98:  MOVLW  01
01C9A:  SUBWF  x73,W
01C9C:  CLRF   03
01C9E:  ADDLW  74
01CA0:  MOVWF  01
01CA2:  MOVLW  00
01CA4:  ADDWFC 03,F
01CA6:  MOVFF  03,A82
01CAA:  CLRF   03
01CAC:  MOVF   x73,W
01CAE:  ADDLW  76
01CB0:  MOVWF  FE9
01CB2:  MOVLW  0A
01CB4:  ADDWFC 03,W
01CB6:  MOVWF  FEA
01CB8:  MOVFF  FEF,A83
01CBC:  MOVFF  A82,FEA
01CC0:  MOVFF  01,FE9
01CC4:  MOVFF  A83,FEF
01CC8:  INCF   x73,F
01CCA:  GOTO   1C8E
....................             } 
....................  
....................             // Store the data in the respective register. 
....................             g_ui16WeighingCylinderUpActivationDelay = g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16DelayTime; 
01CCE:  MOVFF  75,600
01CD2:  MOVFF  74,5FF
....................              
....................             // Store the data in EEPROM. 
....................             WriteWeighingCylinderActivationDelayToEEPROM(g_ui16WeighingCylinderUpActivationDelay); 
01CD6:  MOVFF  600,A82
01CDA:  MOVFF  5FF,A81
01CDE:  MOVLB  0
01CE0:  GOTO   1924
....................             break; 
01CE4:  MOVLB  5
01CE6:  GOTO   1CF2
01CEA:  MOVLB  0
....................         default: 
....................             break; 
01CEC:  MOVLB  5
01CEE:  GOTO   1CF2
....................     } 
01CF2:  MOVLB  0
01CF4:  GOTO   3088 (RETURN)
.................... } 
....................  
.................... #endif	/* VM_IBU_PROCESS_M0_H */ 
....................  
....................  
.................... #include "vmAverageWeightCalculation.h" 
.................... /*  
....................  * File:   vmAverageWeightCalculation.h 
....................  * Author: OEM 
....................  * 
....................  * Created on December 20, 2018, 11:50 AM 
....................  */ 
....................  
.................... #ifndef VM_AVERAGE_WEIGHT_CALCULATION_H 
.................... #define	VM_AVERAGE_WEIGHT_CALCULATION_H 
....................  
.................... //#include "../Common/vmModbusGlobal.h" 
....................  
.................... #define SIZE_AVG_WT_ARR                 50 
.................... #define MAX_DEVIATIION_FROM_AVG_WT      1000  // We are considering +- 1000gm weight deviation 
.................... #define MAX_DEVIATION_FOR_BATCH_CHANGE  1200   // If Current weight 850gm deviated from last average weight then we consider batch must be changed. 
....................                                               // In that case we reset the queue. 
....................  
.................... typedef struct _ST_AVG_WT_QUEUE 
.................... { 
....................     int32 m_i32Arr[SIZE_AVG_WT_ARR]; 
....................     int8  m_i8Rear; 
....................     int8  m_i8Length; 
....................     int8  m_i8QueueFull; 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32LstAvg; 
.................... } ST_AVG_WT_QUEUE; 
....................  
.................... ST_AVG_WT_QUEUE g_stAvgWtQueue; 
....................  
.................... void InitializeAvgWtQueue() 
.................... { 
....................     unsigned int8 ui8LoopCount   = 0; 
....................     g_stAvgWtQueue.m_i8Rear      = -1; 
....................     g_stAvgWtQueue.m_i8Length    = SIZE_AVG_WT_ARR; 
....................     g_stAvgWtQueue.m_i32CurAvg   = 0; 
....................     g_stAvgWtQueue.m_i8QueueFull = 0; 
....................      
....................     // Initialize array member. 
....................     for(ui8LoopCount = 0; ui8LoopCount < SIZE_AVG_WT_ARR; ui8LoopCount++) 
....................     { 
....................         g_stAvgWtQueue.m_i32Arr[ui8LoopCount] = 0; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32LstAvg = 0; 
.................... } 
....................  
.................... void ResetAvgWtQueue(int8 i8Length) 
.................... { 
....................     if (i8Length <= SIZE_AVG_WT_ARR) 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = i8Length; 
....................     } 
....................     else 
....................     { 
....................         g_stAvgWtQueue.m_i8Length = SIZE_AVG_WT_ARR; 
....................     } 
.................... } 
....................  
.................... void InsertAvgWtQueue(int32 i32LastWeight) 
.................... { 
....................     int8  i8LoopCount = 0; 
....................     int8  i8MaxEntry  = 0; 
....................     int32 i32Sum      = 0; 
....................      
.................... //    // Check the weight deviation from Selected SKU Average Weight 
.................... //    if (i32LastWeight > (g_stCurBatchInfo.m_i32AvgWeight + MAX_DEVIATIION_FROM_AVG_WT) || 
.................... //        i32LastWeight < (g_stCurBatchInfo.m_i32AvgWeight - MAX_DEVIATIION_FROM_AVG_WT)) 
.................... //    { 
.................... //        // The weight is out of range, we are not inserting this weight into Average weight queue  
.................... //        return; 
.................... //    } 
....................      
....................     // Increment Rear 
....................     g_stAvgWtQueue.m_i8Rear++; 
....................      
....................     // Check queue rear with size. 
....................     if(g_stAvgWtQueue.m_i8Rear >= g_stAvgWtQueue.m_i8Length) 
....................     { 
....................         // Queue is full. 
....................         // Set flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 1; 
....................          
....................         // Reset rear. 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................     // Check if the current weight is a new batch weight. 
....................     if(i32LastWeight >= g_stAvgWtQueue.m_i32LstAvg + MAX_DEVIATION_FOR_BATCH_CHANGE) 
....................     { 
....................         g_stAvgWtQueue.m_i8Rear = 0; 
....................     } 
....................      
....................      
....................     // Insert into Queue 
....................     g_stAvgWtQueue.m_i32Arr[g_stAvgWtQueue.m_i8Rear] = i32LastWeight; 
....................      
....................     // Get the Max entry in queue 
....................     if (1 == g_stAvgWtQueue.m_i8QueueFull) 
....................     { 
....................         // Set maximum entry will be same as queue size. 
....................         i8MaxEntry = SIZE_AVG_WT_ARR; 
....................          
....................         // Reset queue full flag. 
....................         g_stAvgWtQueue.m_i8QueueFull = 0; 
....................     } 
....................     else 
....................     { 
....................         i8MaxEntry = g_stAvgWtQueue.m_i8Rear + 1; 
....................     } 
....................      
....................     // Get the summation of queue values    
....................     for (i8LoopCount = 0; i8LoopCount < i8MaxEntry; i8LoopCount++) 
....................     { 
....................         i32Sum += g_stAvgWtQueue.m_i32Arr[i8LoopCount]; 
....................     } 
....................      
....................     g_stAvgWtQueue.m_i32CurAvg = (int32)(i32Sum / (int32)i8MaxEntry); 
....................      
....................     // Store the current average in last average of all CBBs. 
....................     g_stAvgWtQueue.m_i32LstAvg = g_stAvgWtQueue.m_i32CurAvg; 
.................... } 
....................  
.................... void IBUSendProdModeAvgData() 
.................... { 
....................     ST_IBU_DATA_NODE stIBUDataNode; 
....................     int8 i8LoopCount = 0; 
....................      
....................  
....................     // Prepare IBU Data Node 
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32Padding  = 0; 
....................     g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg   = g_stAvgWtQueue.m_i32CurAvg; 
....................      
....................     // Stuff IBU Command 
....................     stIBUDataNode.g_ui8ArrIBUData[0] = IBU_CMD_PROD_AVG_WT_DATA; 
....................     for (i8LoopCount = 1; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         stIBUDataNode.g_ui8ArrIBUData[i8LoopCount] = g_unIBUProdModeAvg.m_ui8Arr[i8LoopCount - 1]; 
....................     } 
....................      
....................     // Send to IBU Insert. 
....................     InsertIBUMsgQueue(&g_stIBUSendQueue, &stIBUDataNode); 
.................... } 
.................... #endif	/* VM_AVERAGE_WEIGHT_CALCULATION_H */ 
....................  
....................  
.................... #include "vmEEPROMConfig_M0.h" 
.................... #ifndef _VM_EEPROM_CONFIG_BRITANIA_H_ 
.................... #define _VM_EEPROM_CONFIG_BRITANIA_H_ 
....................  
....................  
.................... #define EEPROM_ADDRESS_FOR_LCF                       100 
.................... #define EEPROM_ADDRESS_FOR_MAX_WT                    110    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_MIN_WT                    114    // 4-Byte 
.................... #define EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY       118 
.................... #define EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY  120 
.................... #define EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY       122 
.................... #define EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY 124    // 2-Byte 
....................  
.................... void WriteLCFToEEPROM(int16 i16CurrLoadCellFactor) 
.................... { 
....................     unsigned int16 ui16CurrLoadCellFactor = 0; 
....................      
....................     // cast the receive parameter in unsugned. 
....................     ui16CurrLoadCellFactor = (unsigned int16)i16CurrLoadCellFactor; 
....................      
....................     // Store data in EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_LCF,ui16CurrLoadCellFactor); 
.................... } 
....................  
.................... int16 ReadLCFFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16RetrieveLCF = 0; 
....................      
....................     // Retrieve stored LCF from EEPROM. 
....................     ui16RetrieveLCF = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_LCF); 
....................      
....................     return((int16)ui16RetrieveLCF); 
.................... } 
....................  
.................... void WriteMaxWeightToEEPROM(int32 i32MaxWeight) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 16); 
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MaxWeight >> 0); 
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
.................... } 
....................  
.................... void WriteMinWeightToEEPROM(int32 i32MinWeight) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................      
....................     // First store the MSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 16); 
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue); 
....................      
....................     // Now store the LSB of 32-bit data. 
....................     ui16WordValue = (unsigned int16)(i32MinWeight >> 0); 
....................     // Increment the address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     WriteEEPROMInt16(ui16EEPROMAddress, ui16WordValue);     
.................... } 
....................  
.................... int32 ReadMaxWeightFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16WordValue     = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MaxWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MAX_WT; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MaxWeight = (int32)ui16WordValue; 
....................     // Shift data to MSB. 
....................     i32MaxWeight = (i32MaxWeight << 16); 
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     i32MaxWeight = (((int16)ui16WordValue) | (i32MaxWeight & 0xFFFF0000)); 
....................      
....................     return i32MaxWeight; 
.................... } 
....................  
.................... int32 ReadMinWeightFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16WordValue = 0; 
....................     unsigned int16 ui16EEPROMAddress = 0; 
....................     int32          i32MinWeight      = 0; 
....................      
....................     // Copy the address. 
....................     ui16EEPROMAddress = EEPROM_ADDRESS_FOR_MIN_WT; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     // Retrieved the MSB of 32-bit data. 
....................     i32MinWeight = (int32)ui16WordValue; 
....................     // Shift data to MSB. 
....................     i32MinWeight = (i32MinWeight << 16); 
....................  
....................     // Now retrieve LSB of 32-bit data. 
....................     // Increment EEPROM address. 
....................     ui16EEPROMAddress = ui16EEPROMAddress + 2; 
....................     ui16WordValue = ReadEEPROMInt16(ui16EEPROMAddress); 
....................     i32MinWeight = (((int16)ui16WordValue) | (i32MinWeight & 0xFFFF0000)); 
....................      
....................     return i32MinWeight;     
.................... } 
....................  
.................... void WritePipePresenceDelayToEEPROM(unsigned int16 ui16PipePresenceDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY, ui16PipePresenceDelay); 
.................... } 
....................  
.................... unsigned int16 ReadPipePresenceDelayFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16PipePresenceDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipePresenceDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_PRESENCE_DELAY); 
....................      
....................     return ui16PipePresenceDelayTime; 
.................... } 
....................  
.................... void WritePipeStabilizationDelayToEEPROM(unsigned int16 ui16PipeStabilizationDelay) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY, ui16PipeStabilizationDelay);     
.................... } 
....................  
.................... unsigned int16 ReadPipeStabilizationDelayFromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16PipeStabilizationDelayTime = 0; 
....................      
....................     // Read data from EEPROM.     
....................     ui16PipeStabilizationDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_STABILIZATION_DELAY); 
....................      
....................     return ui16PipeStabilizationDelayTime;     
.................... } 
....................  
....................  
.................... void WritePipeTransferDelayToEEPROM(unsigned int16 g_ui16PipeTransferDelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY, g_ui16PipeTransferDelayTime);     
.................... } 
....................  
.................... unsigned int16 ReadPipeTransferDelayTime(void) 
.................... { 
....................     unsigned int16 ui16PipeTransferDelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16PipeTransferDelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_PIPE_TRANSFER_DELAY); 
....................      
....................     return ui16PipeTransferDelayTime;      
.................... }     
....................  
.................... void WriteWeighingCylinderActivationDelayToEEPROM(unsigned int16 ui16DelayTime) 
.................... { 
....................     // Write data to EEPROM. 
....................     WriteEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY, ui16DelayTime);     
.................... } 
....................  
.................... unsigned int16 ReadWeighingCylinderActivationDelayfromEEPROM(void) 
.................... { 
....................     unsigned int16 ui16DelayTime = 0; 
....................      
....................     // Read data from EEPROM. 
....................     ui16DelayTime = ReadEEPROMInt16(EEPROM_ADDRESS_FOR_WEGHNG_CYLDR_UP_ACT_DELAY); 
....................      
....................     return ui16DelayTime;     
.................... } 
.................... #endif /* _VM_EEPROM_CONFIG_BRITANIA_H_ */ 
....................  
....................  
....................  
.................... void InitGlobalVariables(void) 
.................... { 
.................... ////    g_ui16DIStatus = 0x1A; 
.................... ////    g_ui16DOStatus = 0x1A; 
.................... ////    g_ui16ErrorStatus = 0x1A; 
.................... ////    g_ui8IncrementIndex = 0; 
....................      
....................     // Set all pins digital. 
....................     setup_adc_ports(NO_ANALOGS); 
*
00AEA:  MOVLW  00
00AEC:  MOVLB  F
00AEE:  MOVWF  x58
00AF0:  MOVLB  E
00AF2:  MOVWF  x92
00AF4:  MOVWF  x9A
00AF6:  MOVWF  xA7
00AF8:  MOVWF  xAF
00AFA:  MOVWF  xB4
00AFC:  MOVWF  xBC
....................      
....................     // Initialize IBU Send Message Queue 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBURcvQueue); 
00AFE:  MOVLW  02
00B00:  MOVLB  A
00B02:  MOVWF  x75
00B04:  MOVLW  C4
00B06:  MOVWF  x74
00B08:  MOVLB  0
00B0A:  CALL   055E
....................     InitializeDataQueue(&g_stIBUSendQueue); 
00B0E:  MOVLW  01
00B10:  MOVLB  A
00B12:  MOVWF  x75
00B14:  SETF   x74
00B16:  MOVLB  0
00B18:  CALL   055E
....................     // Initialize Average Weight Queue 
....................     InitializeAvgWtQueue(); 
00B1C:  GOTO   05F0
....................      
....................     // Read EEPROM data and store in respective registers. 
....................     g_ui16PipePresenceDelayTime = ReadPipePresenceDelayFromEEPROM(); 
00B20:  GOTO   06B2
00B24:  MOVFF  02,5FA
00B28:  MOVFF  01,5F9
....................     g_ui16PipeStabilizationDelayTime = ReadPipeStabilizationDelayFromEEPROM(); 
00B2C:  GOTO   06DC
00B30:  MOVFF  02,5FC
00B34:  MOVFF  01,5FB
....................     g_ui16PipeTransferDelayTime = ReadPipeTransferDelayTime(); 
00B38:  GOTO   0706
00B3C:  MOVFF  02,5FE
00B40:  MOVFF  01,5FD
....................     g_ui16WeighingCylinderUpActivationDelay = ReadWeighingCylinderActivationDelayfromEEPROM(); 
00B44:  GOTO   0730
00B48:  MOVFF  02,600
00B4C:  MOVFF  01,5FF
....................      
....................     // Wakeup ADS1232 
....................     output_high(PIN_ADC_PDWN); 
00B50:  BCF    F86.7
00B52:  BSF    F7E.7
....................     output_high(PIN_ADC_SCLK); 
00B54:  BCF    F84.6
00B56:  BSF    F7C.6
....................      
....................     // Set Programmable Gain of ADS1232. 
....................     // Settled GAIN is 64. 
....................     output_high(PIN_ADC_GAIN_1); 
00B58:  BCF    F86.4
00B5A:  BSF    F7E.4
....................     output_low(PIN_ADC_GAIN_0); 
00B5C:  BCF    F86.3
00B5E:  BCF    F7E.3
....................      
....................     // Clearing the latch buffer of ADS1232. 
....................     int8 i8Count = 0; 
00B60:  MOVLB  A
00B62:  CLRF   x73
....................     for(i8Count = 0; i8Count < 100; i8Count++) 
00B64:  CLRF   x73
00B66:  MOVF   x73,W
00B68:  SUBLW  63
00B6A:  BTFSS  FD8.0
00B6C:  GOTO   0B8A
....................     { 
....................         delay_us(1); 
00B70:  CLRWDT
00B72:  BRA    0B74
00B74:  BRA    0B76
....................         output_high(PIN_ADC_SCLK); 
00B76:  BCF    F84.6
00B78:  BSF    F7C.6
....................         delay_us(1); 
00B7A:  CLRWDT
00B7C:  BRA    0B7E
00B7E:  BRA    0B80
....................         output_low(PIN_ADC_SCLK); 
00B80:  BCF    F84.6
00B82:  BCF    F7C.6
00B84:  INCF   x73,F
00B86:  GOTO   0B66
....................     } 
....................      
....................                                        
....................     //Initialize state occurrence. 
....................     g_ui8ExpectedNextState[0] = STATE_HOME; 
00B8A:  MOVLB  6
00B8C:  CLRF   x0D
....................     g_ui8ExpectedNextState[1] = STATE_HOME; 
00B8E:  CLRF   x0E
....................      
....................     // Initialize Batch Info  
....................     g_stCurBatchInfo.m_i32AvgWeight = 1000; 
00B90:  CLRF   x04
00B92:  CLRF   x03
00B94:  MOVLW  03
00B96:  MOVWF  x02
00B98:  MOVLW  E8
00B9A:  MOVWF  x01
....................     g_stCurBatchInfo.m_i32MaxWt = 50; 
00B9C:  CLRF   x08
00B9E:  CLRF   x07
00BA0:  CLRF   x06
00BA2:  MOVLW  32
00BA4:  MOVWF  x05
....................     g_stCurBatchInfo.m_i32MinWt = 50; 
00BA6:  CLRF   x0C
00BA8:  CLRF   x0B
00BAA:  CLRF   x0A
00BAC:  MOVWF  x09
....................      
....................     // Get the stored Load Cell Factor(LCF) from EEPROM. 
....................     g_i16LoadCellFactor = ReadLCFFromEEPROM(); 
00BAE:  MOVLB  0
00BB0:  GOTO   075A
00BB4:  MOVFF  02,701
00BB8:  MOVFF  01,700
....................  
....................     // Convert decimal LCF into fraction. 
....................     g_f32LoadCellFactor = (float32)g_i16LoadCellFactor / (float32)100; 
00BBC:  MOVFF  701,A82
00BC0:  MOVFF  700,A81
00BC4:  CALL   0784
00BC8:  MOVFF  03,A77
00BCC:  MOVFF  02,A76
00BD0:  MOVFF  01,A75
00BD4:  MOVFF  00,A74
00BD8:  MOVFF  03,A88
00BDC:  MOVFF  02,A87
00BE0:  MOVFF  01,A86
00BE4:  MOVFF  00,A85
00BE8:  MOVLB  A
00BEA:  CLRF   x8C
00BEC:  CLRF   x8B
00BEE:  MOVLW  48
00BF0:  MOVWF  x8A
00BF2:  MOVLW  85
00BF4:  MOVWF  x89
00BF6:  MOVLB  0
00BF8:  CALL   07C8
00BFC:  MOVFF  03,705
00C00:  MOVFF  02,704
00C04:  MOVFF  01,703
00C08:  MOVFF  00,702
....................  
....................     // Get Stored Max and Min weight of pipe from EEPROM. 
....................     g_stCurBatchInfo.m_i32MaxWt = ReadMaxWeightFromEEPROM(); 
00C0C:  GOTO   09BE
00C10:  MOVFF  03,608
00C14:  MOVFF  02,607
00C18:  MOVFF  01,606
00C1C:  MOVFF  00,605
....................     g_stCurBatchInfo.m_i32MinWt = ReadMinWeightFromEEPROM();     
00C20:  GOTO   0A54
00C24:  MOVFF  03,60C
00C28:  MOVFF  02,60B
00C2C:  MOVFF  01,60A
00C30:  MOVFF  00,609
00C34:  GOTO   2FEC (RETURN)
.................... } 
....................  
.................... void InitSystemInterrupts(void) 
.................... { 
....................      
....................      // Enable 1MS main timer. 
....................     clear_interrupt(INT_TIMER0); 
*
00C50:  MOVLB  E
00C52:  BCF    x33.5
....................     enable_interrupts(INT_TIMER0); 
00C54:  BSF    x29.5
....................      
....................     // Initialize UART-><- UART (IBU) receive Interrupt. 
....................     InitIBURxInterrupt(); 
00C56:  MOVLB  0
00C58:  GOTO   0C38
....................  
....................     // Initialize camera communication receive Interrupt. 
....................     InitCamRxInterrupt(); 
00C5C:  GOTO   0C44
00C60:  GOTO   2FF0 (RETURN)
....................          
.................... } 
....................  
.................... void InitializeStateMachines() 
.................... { 
....................     g_ui8NumberOfActiveMachines = NO_OF_ACTIVE_MACHINE; 
....................      
....................     g_ui32AllDOsCurrentState            = INITAIL_DO_STATE_ON_PWR_ON; 
....................     g_ui32AllDOsPreviousState           = INITAIL_DO_STATE_ON_PWR_ON; 
....................     g_ui32AllCountersCurrentState       = 0; 
....................     g_ui32AllCountersPreviousState      = 0; 
....................      
....................     //Initialize_StateMachine_0(); 
....................     //Initialize_StateMachine_1(); 
....................  
.................... }     
....................  
....................  
.................... void main() 
*
02B74:  BSF    F77.7
02B76:  BCF    F77.6
02B78:  CLRF   FF8
02B7A:  MOVLB  E
02B7C:  BCF    x1F.5
02B7E:  BSF    x22.5
02B80:  BCF    x23.3
02B82:  BSF    FF2.5
02B84:  BSF    07.7
02B86:  MOVLW  55
02B88:  MOVLB  D
02B8A:  MOVWF  xEF
02B8C:  MOVLW  AA
02B8E:  MOVWF  xEF
02B90:  BCF    xEF.0
02B92:  MOVLW  17
02B94:  MOVLB  E
02B96:  MOVWF  x0F
02B98:  MOVLW  11
02B9A:  MOVWF  x15
02B9C:  MOVLW  12
02B9E:  MOVWF  x62
02BA0:  MOVLW  0C
02BA2:  MOVWF  x68
02BA4:  MOVLW  55
02BA6:  MOVLB  D
02BA8:  MOVWF  xEF
02BAA:  MOVLW  AA
02BAC:  MOVWF  xEF
02BAE:  BSF    xEF.0
02BB0:  CLRF   2F
02BB2:  MOVLB  E
02BB4:  BSF    xE9.3
02BB6:  MOVLW  08
02BB8:  MOVWF  xE5
02BBA:  MOVLW  02
02BBC:  MOVWF  xE6
02BBE:  MOVLW  A6
02BC0:  MOVWF  xE8
02BC2:  MOVLW  90
02BC4:  MOVWF  xE7
02BC6:  BCF    F9E.3
02BC8:  MOVLW  40
02BCA:  MOVWF  F9A
02BCC:  MOVLW  A6
02BCE:  MOVWF  F9D
02BD0:  MOVLW  90
02BD2:  MOVWF  F9C
02BD4:  CLRF   39
02BD6:  CLRF   3A
02BD8:  CLRF   3B
02BDA:  MOVLB  1
02BDC:  CLRF   x42
02BDE:  CLRF   x57
02BE0:  CLRF   x58
02BE2:  CLRF   x59
02BE4:  MOVLW  A5
02BE6:  MOVWF  x5A
02BE8:  CLRF   x5B
02BEA:  CLRF   xFD
02BEC:  CLRF   xFE
02BEE:  MOVLW  01
02BF0:  MOVLB  3
02BF2:  MOVWF  x89
02BF4:  CLRF   x8A
02BF6:  CLRF   x8B
02BF8:  CLRF   x8C
02BFA:  CLRF   x8E
02BFC:  CLRF   x8D
02BFE:  CLRF   x9C
02C00:  CLRF   xAB
02C02:  CLRF   xAA
02C04:  CLRF   xAC
02C06:  MOVLB  4
02C08:  CLRF   x13
02C0A:  CLRF   x14
02C0C:  CLRF   x15
02C0E:  CLRF   x16
02C10:  MOVWF  x24
02C12:  CLRF   x35
02C14:  CLRF   x34
02C16:  CLRF   x33
02C18:  CLRF   x32
02C1A:  CLRF   x37
02C1C:  CLRF   x36
02C1E:  CLRF   x39
02C20:  CLRF   x38
02C22:  CLRF   x3B
02C24:  CLRF   x3A
02C26:  CLRF   x3D
02C28:  CLRF   x3C
02C2A:  CLRF   x3E
02C2C:  CLRF   x3F
02C2E:  CLRF   x41
02C30:  CLRF   x40
02C32:  MOVLB  5
02C34:  MOVWF  xD2
02C36:  MOVLW  24
02C38:  MOVWF  xD3
02C3A:  CLRF   xD4
02C3C:  CLRF   xD6
02C3E:  CLRF   xD5
02C40:  CLRF   xD7
02C42:  CLRF   xDB
02C44:  CLRF   xDA
02C46:  CLRF   xD9
02C48:  CLRF   xD8
02C4A:  CLRF   xDF
02C4C:  CLRF   xDE
02C4E:  CLRF   xDD
02C50:  CLRF   xDC
02C52:  CLRF   xE1
02C54:  CLRF   xE0
02C56:  CLRF   xE3
02C58:  CLRF   xE2
02C5A:  CLRF   xE7
02C5C:  CLRF   xE6
02C5E:  CLRF   xE5
02C60:  CLRF   xE4
02C62:  CLRF   xE8
02C64:  CLRF   xEC
02C66:  CLRF   xEB
02C68:  CLRF   xEA
02C6A:  CLRF   xE9
02C6C:  CLRF   xF0
02C6E:  CLRF   xEF
02C70:  CLRF   xEE
02C72:  CLRF   xED
02C74:  CLRF   xF2
02C76:  CLRF   xF1
02C78:  CLRF   xF4
02C7A:  CLRF   xF3
02C7C:  CLRF   xF6
02C7E:  CLRF   xF5
02C80:  CLRF   xF8
02C82:  CLRF   xF7
02C84:  CLRF   xFA
02C86:  CLRF   xF9
02C88:  CLRF   xFC
02C8A:  CLRF   xFB
02C8C:  CLRF   xFE
02C8E:  CLRF   xFD
02C90:  MOVLB  6
02C92:  CLRF   x00
02C94:  MOVLB  5
02C96:  CLRF   xFF
02C98:  MOVLB  6
02C9A:  CLRF   xE2
02C9C:  MOVLW  BE
02C9E:  MOVWF  xE3
02CA0:  CLRF   xE7
02CA2:  CLRF   xE6
02CA4:  CLRF   xE5
02CA6:  CLRF   xE4
02CA8:  CLRF   xEB
02CAA:  CLRF   xEA
02CAC:  CLRF   xE9
02CAE:  CLRF   xE8
02CB0:  CLRF   xEC
02CB2:  MOVLW  01
02CB4:  MOVWF  xED
02CB6:  CLRF   xF1
02CB8:  CLRF   xF0
02CBA:  CLRF   xEF
02CBC:  CLRF   xEE
02CBE:  CLRF   xF5
02CC0:  CLRF   xF4
02CC2:  CLRF   xF3
02CC4:  CLRF   xF2
02CC6:  CLRF   xF9
02CC8:  CLRF   xF8
02CCA:  CLRF   xF7
02CCC:  CLRF   xF6
02CCE:  CLRF   xFD
02CD0:  CLRF   xFC
02CD2:  CLRF   xFB
02CD4:  CLRF   xFA
02CD6:  CLRF   xFF
02CD8:  CLRF   xFE
02CDA:  MOVLB  7
02CDC:  CLRF   x01
02CDE:  CLRF   x00
02CE0:  CLRF   x05
02CE2:  CLRF   x04
02CE4:  CLRF   x03
02CE6:  CLRF   x02
02CE8:  MOVLB  A
02CEA:  CLRF   x27
02CEC:  CLRF   x26
02CEE:  CLRF   x28
02CF0:  CLRF   x2C
02CF2:  CLRF   x2B
02CF4:  CLRF   x2A
02CF6:  CLRF   x29
02CF8:  MOVLW  05
02CFA:  MOVWF  x2D
02CFC:  CLRF   x2E
02CFE:  CLRF   x2F
02D00:  CLRF   x31
02D02:  CLRF   x30
02D04:  CLRF   x35
02D06:  CLRF   x34
02D08:  CLRF   x33
02D0A:  CLRF   x32
02D0C:  CLRF   x37
02D0E:  CLRF   x36
02D10:  CLRF   x39
02D12:  CLRF   x38
02D14:  CLRF   x3B
02D16:  CLRF   x3A
02D18:  CLRF   x3C
02D1A:  CLRF   x3D
02D1C:  MOVLW  01
02D1E:  MOVWF  x3E
02D20:  MOVWF  x40
02D22:  MOVLW  F4
02D24:  MOVWF  x3F
02D26:  MOVFF  5FC,A42
02D2A:  MOVFF  5FB,A41
02D2E:  CLRF   x44
02D30:  CLRF   x43
02D32:  MOVLW  01
02D34:  MOVWF  x45
02D36:  MOVLW  0B
02D38:  MOVWF  x46
02D3A:  CLRF   x48
02D3C:  CLRF   x47
02D3E:  CLRF   x4A
02D40:  CLRF   x49
02D42:  MOVLW  01
02D44:  MOVWF  x4B
02D46:  MOVWF  x4C
02D48:  CLRF   x4E
02D4A:  CLRF   x4D
02D4C:  MOVWF  x4F
02D4E:  MOVLW  0B
02D50:  MOVWF  x50
02D52:  MOVWF  x51
02D54:  MOVLW  09
02D56:  MOVWF  x52
02D58:  MOVLW  0D
02D5A:  MOVWF  x53
02D5C:  MOVLW  09
02D5E:  MOVWF  x54
02D60:  MOVWF  x55
02D62:  CLRF   x57
02D64:  CLRF   x56
02D66:  CLRF   x59
02D68:  CLRF   x58
02D6A:  CLRF   x5A
02D6C:  CLRF   x5C
02D6E:  CLRF   x5B
02D70:  MOVLW  01
02D72:  MOVWF  x5D
02D74:  MOVWF  x5E
02D76:  MOVWF  x5F
02D78:  MOVWF  x60
02D7A:  MOVWF  x61
02D7C:  MOVWF  x62
02D7E:  MOVWF  x63
02D80:  MOVWF  x64
02D82:  CLRF   x65
02D84:  MOVLB  E
02D86:  CLRF   x92
02D88:  CLRF   x9A
02D8A:  CLRF   xA7
02D8C:  CLRF   xAF
02D8E:  CLRF   xB4
02D90:  CLRF   xBC
02D92:  CLRF   xD2
02D94:  CLRF   xD3
02D96:  CLRF   xD1
02D98:  CLRF   xD0
02D9A:  MOVLB  1
02D9C:  CLRF   x43
02D9E:  CLRF   x44
02DA0:  CLRF   x45
02DA2:  CLRF   x46
02DA4:  CLRF   x47
02DA6:  CLRF   x48
02DA8:  CLRF   x49
02DAA:  CLRF   x4A
02DAC:  CLRF   x4B
02DAE:  CLRF   x4C
02DB0:  CLRF   x4D
02DB2:  CLRF   x4E
02DB4:  CLRF   x4F
02DB6:  CLRF   x50
02DB8:  CLRF   x51
02DBA:  CLRF   x52
02DBC:  CLRF   x53
02DBE:  CLRF   x54
02DC0:  CLRF   x55
02DC2:  CLRF   x56
02DC4:  CLRF   x76
02DC6:  CLRF   x77
02DC8:  CLRF   x78
02DCA:  CLRF   x79
02DCC:  CLRF   x7A
02DCE:  CLRF   x7B
02DD0:  CLRF   x7C
02DD2:  CLRF   x7D
02DD4:  CLRF   x7E
02DD6:  CLRF   x7F
02DD8:  CLRF   x80
02DDA:  CLRF   x81
02DDC:  CLRF   x82
02DDE:  CLRF   x83
02DE0:  CLRF   x84
02DE2:  CLRF   x85
02DE4:  CLRF   x86
02DE6:  CLRF   x87
02DE8:  CLRF   x88
02DEA:  CLRF   x89
02DEC:  CLRF   x8A
02DEE:  CLRF   x8B
02DF0:  CLRF   x8C
02DF2:  CLRF   x8D
02DF4:  CLRF   x8E
02DF6:  CLRF   x8F
02DF8:  CLRF   x90
02DFA:  CLRF   x91
02DFC:  CLRF   x92
02DFE:  CLRF   x93
02E00:  CLRF   x94
02E02:  CLRF   x95
02E04:  CLRF   x96
02E06:  CLRF   x97
02E08:  CLRF   x98
02E0A:  CLRF   x99
02E0C:  CLRF   x9A
02E0E:  CLRF   x9B
02E10:  CLRF   x9C
02E12:  CLRF   x9D
02E14:  CLRF   x9E
02E16:  CLRF   x9F
02E18:  CLRF   xA0
02E1A:  CLRF   xA1
02E1C:  CLRF   xA2
02E1E:  CLRF   xA3
02E20:  CLRF   xA4
02E22:  CLRF   xA5
02E24:  CLRF   xA6
02E26:  CLRF   xA7
02E28:  CLRF   xA8
02E2A:  CLRF   xA9
02E2C:  CLRF   xAA
02E2E:  CLRF   xAB
02E30:  CLRF   xAC
02E32:  CLRF   xAD
02E34:  CLRF   xAE
02E36:  CLRF   xAF
02E38:  CLRF   xB0
02E3A:  CLRF   xB1
02E3C:  CLRF   xB2
02E3E:  CLRF   xB3
02E40:  CLRF   xB4
02E42:  CLRF   xB5
02E44:  CLRF   xB6
02E46:  CLRF   xB7
02E48:  CLRF   xB8
02E4A:  CLRF   xB9
02E4C:  CLRF   xBA
02E4E:  CLRF   xBB
02E50:  CLRF   xBC
02E52:  CLRF   xBD
02E54:  CLRF   xBE
02E56:  CLRF   xBF
02E58:  CLRF   xC0
02E5A:  CLRF   xC1
02E5C:  CLRF   xC2
02E5E:  CLRF   xC3
02E60:  CLRF   xC4
02E62:  CLRF   xC5
02E64:  CLRF   xC6
02E66:  CLRF   xC7
02E68:  CLRF   xC8
02E6A:  CLRF   xC9
02E6C:  CLRF   xCA
02E6E:  CLRF   xCB
02E70:  CLRF   xCC
02E72:  CLRF   xCD
02E74:  CLRF   xCE
02E76:  CLRF   xCF
02E78:  CLRF   xD0
02E7A:  CLRF   xD1
02E7C:  CLRF   xD2
02E7E:  CLRF   xD3
02E80:  CLRF   xD4
02E82:  CLRF   xD5
02E84:  CLRF   xD6
02E86:  CLRF   xD7
02E88:  CLRF   xD8
02E8A:  CLRF   xD9
02E8C:  CLRF   xDA
02E8E:  CLRF   xDB
02E90:  CLRF   xDC
02E92:  CLRF   xDD
02E94:  CLRF   xDE
02E96:  CLRF   xDF
02E98:  CLRF   xE0
02E9A:  CLRF   xE1
02E9C:  CLRF   xE2
02E9E:  CLRF   xE3
02EA0:  CLRF   xE4
02EA2:  CLRF   xE5
02EA4:  CLRF   xE6
02EA6:  CLRF   xE7
02EA8:  CLRF   xE8
02EAA:  CLRF   xE9
02EAC:  CLRF   xEA
02EAE:  CLRF   xEB
02EB0:  CLRF   xEC
02EB2:  CLRF   xED
02EB4:  CLRF   xEE
02EB6:  CLRF   xEF
02EB8:  CLRF   xF0
02EBA:  CLRF   xF1
02EBC:  CLRF   xF2
02EBE:  CLRF   xF3
02EC0:  CLRF   xF4
02EC2:  CLRF   xF5
02EC4:  CLRF   xF6
02EC6:  CLRF   xF7
02EC8:  CLRF   xF8
02ECA:  CLRF   xF9
02ECC:  CLRF   xFA
02ECE:  CLRF   xFB
02ED0:  CLRF   xFC
02ED2:  MOVLB  3
02ED4:  CLRF   x9D
02ED6:  CLRF   x9E
02ED8:  CLRF   x9F
02EDA:  CLRF   xA0
02EDC:  CLRF   xA1
02EDE:  CLRF   xA2
02EE0:  CLRF   xA3
02EE2:  CLRF   xA4
02EE4:  CLRF   xA5
02EE6:  CLRF   xA6
02EE8:  CLRF   xA7
02EEA:  CLRF   xA8
02EEC:  CLRF   xA9
02EEE:  CLRF   xAD
02EF0:  CLRF   xAE
02EF2:  CLRF   xAF
02EF4:  CLRF   xB0
02EF6:  CLRF   xB1
02EF8:  CLRF   xB2
02EFA:  CLRF   xB3
02EFC:  CLRF   xB4
02EFE:  CLRF   xB5
02F00:  CLRF   xB6
02F02:  CLRF   xB7
02F04:  CLRF   xB8
02F06:  CLRF   xB9
02F08:  CLRF   xBA
02F0A:  CLRF   xBB
02F0C:  CLRF   xBC
02F0E:  CLRF   xBD
02F10:  CLRF   xBE
02F12:  CLRF   xBF
02F14:  CLRF   xC0
02F16:  CLRF   xC1
02F18:  CLRF   xC2
02F1A:  CLRF   xC3
02F1C:  CLRF   xC4
02F1E:  CLRF   xC5
02F20:  CLRF   xC6
02F22:  CLRF   xC7
02F24:  CLRF   xC8
02F26:  CLRF   xC9
02F28:  CLRF   xCA
02F2A:  CLRF   xCB
02F2C:  CLRF   xCC
02F2E:  CLRF   xCD
02F30:  CLRF   xCE
02F32:  CLRF   xCF
02F34:  CLRF   xD0
02F36:  CLRF   xD1
02F38:  CLRF   xD2
02F3A:  CLRF   xD3
02F3C:  CLRF   xD4
02F3E:  CLRF   xD5
02F40:  CLRF   xD6
02F42:  CLRF   xD7
02F44:  CLRF   xD8
02F46:  CLRF   xD9
02F48:  CLRF   xDA
02F4A:  CLRF   xDB
02F4C:  CLRF   xDC
02F4E:  CLRF   xDD
02F50:  CLRF   xDE
02F52:  CLRF   xDF
02F54:  CLRF   xE0
02F56:  CLRF   xE1
02F58:  CLRF   xE2
02F5A:  CLRF   xE3
02F5C:  CLRF   xE4
02F5E:  CLRF   xE5
02F60:  CLRF   xE6
02F62:  CLRF   xE7
02F64:  CLRF   xE8
02F66:  CLRF   xE9
02F68:  CLRF   xEA
02F6A:  CLRF   xEB
02F6C:  CLRF   xEC
02F6E:  CLRF   xED
02F70:  CLRF   xEE
02F72:  CLRF   xEF
02F74:  CLRF   xF0
02F76:  CLRF   xF1
02F78:  CLRF   xF2
02F7A:  CLRF   xF3
02F7C:  CLRF   xF4
02F7E:  CLRF   xF5
02F80:  CLRF   xF6
02F82:  CLRF   xF7
02F84:  CLRF   xF8
02F86:  CLRF   xF9
02F88:  CLRF   xFA
02F8A:  CLRF   xFB
02F8C:  CLRF   xFC
02F8E:  CLRF   xFD
02F90:  CLRF   xFE
02F92:  CLRF   xFF
02F94:  MOVLB  4
02F96:  CLRF   x00
02F98:  CLRF   x01
02F9A:  CLRF   x02
02F9C:  CLRF   x03
02F9E:  CLRF   x04
02FA0:  CLRF   x05
02FA2:  CLRF   x06
02FA4:  CLRF   x07
02FA6:  CLRF   x08
02FA8:  CLRF   x09
02FAA:  CLRF   x0A
02FAC:  CLRF   x0B
02FAE:  CLRF   x0C
02FB0:  CLRF   x0D
02FB2:  CLRF   x0E
02FB4:  CLRF   x0F
02FB6:  CLRF   x10
02FB8:  CLRF   x11
02FBA:  CLRF   x12
02FBC:  CLRF   x17
02FBE:  CLRF   x18
02FC0:  CLRF   x19
02FC2:  CLRF   x1A
02FC4:  CLRF   x1B
02FC6:  CLRF   x1C
02FC8:  CLRF   x1D
02FCA:  CLRF   x1E
02FCC:  CLRF   x1F
02FCE:  CLRF   x20
02FD0:  CLRF   x21
02FD2:  CLRF   x22
02FD4:  CLRF   x23
02FD6:  MOVLB  6
02FD8:  CLRF   x0D
02FDA:  CLRF   x0E
.................... { 
.................... 	// Set Watch Dog Timer ON. 
....................     setup_wdt(WDT_4S | WDT_WINDOW_100_PERCENT); 
02FDC:  MOVLW  07
02FDE:  MOVLB  E
02FE0:  MOVWF  x3E
02FE2:  MOVLW  19
02FE4:  MOVWF  x3D
....................      
....................     // Initialization Section Start 
....................     //int8 i8StateMachineIndex = 0; 
....................      
....................     // Initialize all kind of system requirements. 
....................     InitGlobalVariables(); 
02FE6:  MOVLB  0
02FE8:  GOTO   0AEA
....................     InitSystemInterrupts(); 
02FEC:  GOTO   0C50
....................     //InitializeStateMachines(); //TODO Must go to Pre Production Mode 
....................     //InitilizeStates(); 
....................     delay_ms(10); 
02FF0:  MOVLW  0A
02FF2:  MOVLB  A
02FF4:  MOVWF  x73
02FF6:  MOVLB  0
02FF8:  GOTO   0C64
....................      
....................     // Initialize 1MS main timer i.e.=>TIMER0. 
....................     InitDigitalIOPollingTimer(); 
02FFC:  GOTO   0C9A
....................      
....................     // Initialize Receive Queue 
....................     InitializeRcvQ(); 
03000:  GOTO   0CE2
....................        
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL);    
03004:  MOVLW  C0
03006:  IORWF  FF2,F
....................      
....................      
....................     // TESTING Start. 
....................     ST_IBU_DATA_NODE stIBUData; 
....................  
....................     // Set system mode at start up. 
....................     g_ui8SystemMode = SYS_MODE_WAKE_UP; 
03008:  MOVLW  07
0300A:  MOVLB  5
0300C:  MOVWF  xD7
....................    
....................     // Set Rejection State ON. 
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn01  = PIPE_REJECTED; 
0300E:  MOVLB  4
03010:  BCF    x26.4
....................     g_unDIState.m_stAllDIBits.m_ui1GDICn02  = 1; 
03012:  BSF    x26.3
....................     g_unDOState.m_stAllDOBits.m_ui1HWDOCn01 = 1; 
03014:  BSF    x2A.6
....................      
....................    // Reset WDT. 
.................... 	restart_wdt(); 
03016:  MOVLB  E
03018:  MOVF   x3D,W
0301A:  CLRWDT
....................      
....................     for(;;) 
....................     { 
....................          
....................         // Step 1: Check if there is any message in IBU message queue to send through 
....................         //         UART. 
....................         if((IBU_SENDING_FREE == g_fIBUSendBusy) && 
....................             IsMSGInIBUQueue(&g_stIBUSendQueue)) 
0301C:  MOVLB  1
0301E:  MOVF   xFE,F
03020:  BTFSS  FD8.2
03022:  GOTO   304E
03026:  MOVLW  01
03028:  MOVLB  A
0302A:  MOVWF  x74
0302C:  SETF   x73
0302E:  MOVLB  0
03030:  CALL   0D00
03034:  MOVF   01,F
03036:  BTFSS  FD8.2
03038:  BRA    3040
0303A:  MOVLB  1
0303C:  GOTO   304E
....................         { 
....................             // Set flag to denote IBU is busy in sending data. 
....................             g_fIBUSendBusy = IBU_SENDING_BUSY; 
03040:  MOVLW  01
03042:  MOVLB  1
03044:  MOVWF  xFE
....................              
....................             // Send data from queue. 
....................             SendIBUMSGFromQ(); 
03046:  MOVLB  0
03048:  GOTO   0F42
0304C:  MOVLB  1
....................         } 
....................          
....................  
....................         // step 2: Check if there is any message received in IBU through UART. 
....................         //if ((g_ui8RCVQRear - g_ui8RCVQFront) >= SIZE_IBU_COMPLETE_SEND_MSG - 1) 
....................         g_ui8ElementInQ = ElementsInQ(); 
0304E:  MOVLB  0
03050:  GOTO   1082
03054:  MOVFF  01,142
....................         if (g_ui8ElementInQ >= SIZE_IBU_COMPLETE_SEND_MSG) 
03058:  MOVLB  1
0305A:  MOVF   x42,W
0305C:  SUBLW  11
0305E:  BTFSC  FD8.0
03060:  GOTO   306C
....................         { 
....................             // Hopefully a Complete Message Received 
....................             CheckIBUReceiveQ(); 
03064:  MOVLB  0
03066:  GOTO   12EC
0306A:  MOVLB  1
....................         }         
....................  
....................         // step 3: Check if there is any message in IBC Receive Queue 
....................         if (IsMSGInIBUQueue(&g_stIBURcvQueue)) 
0306C:  MOVLW  02
0306E:  MOVLB  A
03070:  MOVWF  x74
03072:  MOVLW  C4
03074:  MOVWF  x73
03076:  MOVLB  0
03078:  CALL   0D00
0307C:  MOVF   01,F
0307E:  BTFSC  FD8.2
03080:  GOTO   3088
....................         { 
....................             // Process IBC  
....................             ProcessIBUMsg(); 
03084:  GOTO   193E
....................         } 
....................          
....................         // Step 4: Check if ADC is ready to read data. 
....................         if (0 == input(PIN_ADC_DOUT_DRDY)) //&& IBU_SEND_UNLOCK == g_fIBUSendLockStatus) 
03088:  BSF    F84.5
0308A:  BTFSC  F8C.5
0308C:  GOTO   30CC
....................         { 
....................             g_ui32ADCValue = read(); 
03090:  GOTO   1CF8
03094:  MOVFF  03,A2C
03098:  MOVFF  02,A2B
0309C:  MOVFF  01,A2A
030A0:  MOVFF  00,A29
....................  
....................             if (g_ui32ADCValue) 
030A4:  MOVLB  A
030A6:  MOVF   x29,F
030A8:  BTFSS  FD8.2
030AA:  GOTO   30C6
030AE:  MOVF   x2A,F
030B0:  BTFSS  FD8.2
030B2:  GOTO   30C6
030B6:  MOVF   x2B,F
030B8:  BTFSS  FD8.2
030BA:  GOTO   30C6
030BE:  MOVF   x2C,F
030C0:  BTFSC  FD8.2
030C2:  GOTO   30CA
....................             { 
....................                 g_fADCDataReadyStatus = ADC_DATA_READY; 
030C6:  MOVLW  01
030C8:  MOVWF  x2E
030CA:  MOVLB  0
....................             } 
....................         } 
....................          
....................         // step 5: Check flag state of current air-pressure level. 
....................         if(AIR_PRESSURE_LEVEL_BELOW_RATED == g_fCurrentAirPressureLevel && 
....................            g_ui8AirPressureAlarmSendCount == 0) 
030CC:  MOVLB  A
030CE:  MOVF   x51,W
030D0:  SUBLW  0A
030D2:  BTFSS  FD8.2
030D4:  GOTO   30F0
030D8:  MOVF   x5A,F
030DA:  BTFSS  FD8.2
030DC:  GOTO   30F0
....................         { 
....................             // Send alarm signal to MCU-1 through IBU. 
....................             SendAlarmtoAnotherMCU(); 
030E0:  MOVLB  0
030E2:  GOTO   1D7A
....................              
....................             // Set send count. 
....................             g_ui8AirPressureAlarmSendCount = 1; 
030E6:  MOVLW  01
030E8:  MOVLB  A
030EA:  MOVWF  x5A
....................         } 
030EC:  GOTO   310E
....................         else if(AIR_PRESSURE_LEVEL_ABOVE_RATED == g_fCurrentAirPressureLevel && 
....................                 g_ui8AirPressureAlarmSendCount == 1) 
030F0:  MOVF   x51,W
030F2:  SUBLW  0B
030F4:  BTFSS  FD8.2
030F6:  GOTO   310E
030FA:  DECFSZ x5A,W
030FC:  GOTO   310E
....................         { 
....................             // Send reset alarm signal to MCU-1 through IBU. 
....................             SendResetAlarmtoAnotherMCU(); 
03100:  MOVLB  0
03102:  GOTO   1DBE
....................              
....................             // Reset alarm send count. 
....................             g_ui8AirPressureAlarmSendCount = 0; 
03106:  MOVLB  A
03108:  CLRF   x5A
....................         } 
0310A:  GOTO   310E
....................         else 
....................         { 
....................             /* Do Nothing */ 
....................         } 
....................          
....................          
....................         if (g_ui8CurrentState > STATE_CALIB_STEP_10) 
0310E:  MOVLB  6
03110:  MOVF   xE2,W
03112:  SUBLW  8C
03114:  BTFSC  FD8.0
03116:  GOTO   311E
....................         { 
....................             g_ui8CurrentState = STATE_CALIB_STEP_1; 
0311A:  MOVLW  83
0311C:  MOVWF  xE2
....................         } 
....................         // Step 6: Mode Scanner 
....................         switch(g_ui8SystemMode) //g_ui8AllBoardCurrentMode 
0311E:  MOVLW  01
03120:  MOVLB  5
03122:  SUBWF  xD7,W
03124:  ADDLW  F8
03126:  BTFSC  FD8.0
03128:  GOTO   3170
0312C:  ADDLW  08
0312E:  MOVLB  0
03130:  GOTO   317C
....................         { 
....................             // Enter once at wake up stage or after reset. 
....................             case SYS_MODE_WAKE_UP: 
....................             { 
....................                 // Set system mode at home state. 
....................                 g_ui8SystemMode = SYS_MODE_HOME; 
03134:  MOVLW  01
03136:  MOVLB  5
03138:  MOVWF  xD7
....................             } 
....................             break; 
0313A:  GOTO   3170
....................             case SYS_MODE_HOME: 
....................             { 
....................  
....................             } 
....................             break; 
0313E:  MOVLB  5
03140:  GOTO   3170
....................             case SYS_MODE_PRE_PROD: 
....................             { 
....................  
....................             } 
....................             break; 
03144:  MOVLB  5
03146:  GOTO   3170
....................             case SYS_MODE_PRE_PROD_SCRAP: 
....................             { 
....................                 // Nothing to do 
....................                 g_ui8SystemMode = g_ui8SystemMode; 
....................             } 
....................             break; 
0314A:  MOVLB  5
0314C:  GOTO   3170
....................             case SYS_MODE_CALIB:  // Intentional Fall through 
....................             case SYS_MODE_PROD: 
....................             { 
....................                 //PWTStateMachine(); 
....................                 // Check if air-pressure is above rated  
....................                 // level. 
....................                 if(AIR_PRESSURE_LEVEL_ABOVE_RATED == g_fCurrentAirPressureLevel) 
03150:  MOVLB  A
03152:  MOVF   x51,W
03154:  SUBLW  0B
03156:  BTFSS  FD8.2
03158:  GOTO   3168
....................                 { 
....................                     PWTStateMachine();                 
0315C:  MOVLB  0
0315E:  GOTO   25B4
....................                 } 
03162:  GOTO   3166
03166:  MOVLB  A
....................                 else  // Air-pressure is below rated level. 
....................                 { 
....................                     /* State Machine will not run.*/ 
....................                 } 
....................             } 
....................             break; 
03168:  MOVLB  5
0316A:  GOTO   3170
0316E:  MOVLB  5
....................         } 
....................         // Reset WDT. 
....................         restart_wdt(); 
03170:  MOVLB  E
03172:  MOVF   x3D,W
03174:  CLRWDT
03176:  GOTO   301C
....................     } 
.................... } 
....................  
0317A:  SLEEP 
....................  

Configuration Fuses:
   Word  1: DFFF   ECH RSTOSC_EXT NOCLKOUT CKS NOFCMEN
   Word  2: FF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FFFF   WDTSW WDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

ROM data:
F00000: 01 02 03 04                                        ....
