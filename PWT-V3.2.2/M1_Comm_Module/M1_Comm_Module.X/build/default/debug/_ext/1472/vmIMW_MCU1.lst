CCS PCH C Compiler, Version 5.083, 13314               16-Dec-20 11:54

               Filename:   D:\Work\Projects\PWT\01_Code\PWT-V3.2.2\M1_Comm_Module\M1_Comm_Module.X\build\default\debug\_ext\1472\vmIMW_MCU1.lst

               ROM used:   18270 bytes (28%)
                           Largest free fragment is 47262
               RAM used:   3055 (86%) at main() level
                           3126 (88%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

*
00000:  GOTO   42E2
*
00008:  GOTO   00DA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  MOVLB  E
00066:  BTFSS  x2D.5
00068:  GOTO   0072
0006C:  BTFSC  x37.5
0006E:  GOTO   037E
00072:  BTFSS  x2D.1
00074:  GOTO   007E
00078:  BTFSC  x37.1
0007A:  GOTO   048E
0007E:  BTFSS  x29.5
00080:  GOTO   008A
00084:  BTFSC  x33.5
00086:  GOTO   0220
0008A:  MOVFF  0E,00
0008E:  MOVFF  0F,01
00092:  MOVFF  10,02
00096:  MOVFF  11,03
0009A:  MOVFF  0C,FE9
0009E:  MOVFF  07,FEA
000A2:  BSF    07.7
000A4:  MOVFF  08,FE1
000A8:  MOVFF  09,FE2
000AC:  MOVFF  0A,FD9
000B0:  MOVFF  0B,FDA
000B4:  MOVFF  12,FF3
000B8:  MOVFF  13,FF4
000BC:  MOVFF  14,FFA
000C0:  MOVFF  15,FF5
000C4:  MOVFF  16,FF6
000C8:  MOVFF  17,FF7
000CC:  MOVF   04,W
000CE:  MOVFF  06,FE0
000D2:  MOVFF  05,FD8
000D6:  RETFIE 0
000D8:  MOVLB  0
000DA:  MOVWF  1A
000DC:  MOVFF  FD8,1B
000E0:  MOVFF  FE0,1C
000E4:  MOVLB  0
000E6:  MOVFF  FE9,22
000EA:  MOVFF  FEA,1D
000EE:  MOVFF  FE1,1E
000F2:  MOVFF  FE2,1F
000F6:  MOVFF  FD9,20
000FA:  MOVFF  FDA,21
000FE:  MOVFF  FF3,28
00102:  MOVFF  FF4,29
00106:  MOVFF  FFA,2A
0010A:  MOVFF  FF5,2B
0010E:  MOVFF  FF6,2C
00112:  MOVFF  FF7,2D
00116:  MOVFF  00,24
0011A:  MOVFF  01,25
0011E:  MOVFF  02,26
00122:  MOVFF  03,27
00126:  MOVLB  E
00128:  BTFSS  x2C.5
0012A:  GOTO   0134
0012E:  BTFSC  x36.5
00130:  GOTO   01CA
00134:  MOVFF  24,00
00138:  MOVFF  25,01
0013C:  MOVFF  26,02
00140:  MOVFF  27,03
00144:  MOVFF  22,FE9
00148:  MOVFF  1D,FEA
0014C:  BSF    1D.7
0014E:  MOVFF  1E,FE1
00152:  MOVFF  1F,FE2
00156:  MOVFF  20,FD9
0015A:  MOVFF  21,FDA
0015E:  MOVFF  28,FF3
00162:  MOVFF  29,FF4
00166:  MOVFF  2A,FFA
0016A:  MOVFF  2B,FF5
0016E:  MOVFF  2C,FF6
00172:  MOVFF  2D,FF7
00176:  MOVF   1A,W
00178:  MOVFF  1C,FE0
0017C:  MOVFF  1B,FD8
00180:  RETFIE 0
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F66K40.h" 
.................... //////////// Standard Header file for the PIC18F66K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F66K40 
00182:  MOVLB  C
00184:  MOVF   x34,W
00186:  CLRF   01
00188:  SUBWF  x33,W
0018A:  BC    0192
0018C:  MOVFF  C33,00
00190:  BRA    01AA
00192:  CLRF   00
00194:  MOVLW  08
00196:  MOVWF  x35
00198:  RLCF   x33,F
0019A:  RLCF   00,F
0019C:  MOVF   x34,W
0019E:  SUBWF  00,W
001A0:  BTFSC  FD8.0
001A2:  MOVWF  00
001A4:  RLCF   01,F
001A6:  DECFSZ x35,F
001A8:  BRA    0198
001AA:  MOVLB  0
001AC:  RETURN 0
*
003C0:  DATA 2F,61
003C2:  DATA 70,69
003C4:  DATA 2F,54
003C6:  DATA 65,73
003C8:  DATA 74,2F
003CA:  DATA 47,65
003CC:  DATA 74,53
003CE:  DATA 74,72
003D0:  DATA 69,6E
003D2:  DATA 67,47
003D4:  DATA 65,74
003D6:  DATA 4D,65
003D8:  DATA 74,68
003DA:  DATA 6F,64
003DC:  DATA 3F,61
003DE:  DATA 3D,25
003E0:  DATA 75,26
003E2:  DATA 62,3D
003E4:  DATA 25,4C
003E6:  DATA 75,26
003E8:  DATA 63,3D
003EA:  DATA 25,4C
003EC:  DATA 75,26
003EE:  DATA 64,3D
003F0:  DATA 25,4C
003F2:  DATA 75,26
003F4:  DATA 65,3D
003F6:  DATA 25,4C
003F8:  DATA 75,26
003FA:  DATA 6D,3D
003FC:  DATA 25,4C
003FE:  DATA 75,24
00400:  DATA 25,4C
00402:  DATA 75,24
00404:  DATA 25,4C
00406:  DATA 75,24
00408:  DATA 25,75
0040A:  DATA 00,00
*
00426:  MOVLB  C
00428:  MOVF   x2C,W
0042A:  MULWF  x2E
0042C:  MOVFF  FF3,01
00430:  MOVFF  FF4,00
00434:  MULWF  x2F
00436:  MOVF   FF3,W
00438:  ADDWF  00,F
0043A:  MOVF   x2D,W
0043C:  MULWF  x2E
0043E:  MOVF   FF3,W
00440:  ADDWFC 00,W
00442:  MOVWF  02
00444:  MOVLB  0
00446:  RETURN 0
00448:  CLRF   01
0044A:  CLRF   02
0044C:  CLRF   00
0044E:  CLRF   03
00450:  MOVLB  C
00452:  MOVF   x2E,W
00454:  BNZ   045A
00456:  MOVF   x2D,W
00458:  BZ    048A
0045A:  MOVLW  10
0045C:  MOVWF  x2F
0045E:  BCF    FD8.0
00460:  RLCF   x2B,F
00462:  RLCF   x2C,F
00464:  RLCF   00,F
00466:  RLCF   03,F
00468:  MOVF   x2E,W
0046A:  SUBWF  03,W
0046C:  BNZ   0472
0046E:  MOVF   x2D,W
00470:  SUBWF  00,W
00472:  BNC   0482
00474:  MOVF   x2D,W
00476:  SUBWF  00,F
00478:  BTFSS  FD8.0
0047A:  DECF   03,F
0047C:  MOVF   x2E,W
0047E:  SUBWF  03,F
00480:  BSF    FD8.0
00482:  RLCF   01,F
00484:  RLCF   02,F
00486:  DECFSZ x2F,F
00488:  BRA    045E
0048A:  MOVLB  0
0048C:  RETURN 0
*
009BE:  TSTFSZ 01
009C0:  BRA    09C8
009C2:  TSTFSZ 02
009C4:  BRA    09CA
009C6:  BRA    09D6
009C8:  INCF   02,F
009CA:  MOVFF  00,FEE
009CE:  DECFSZ 01,F
009D0:  BRA    09CA
009D2:  DECFSZ 02,F
009D4:  BRA    09CA
009D6:  RETURN 0
*
01EA8:  MOVLB  C
01EAA:  CLRF   x17
01EAC:  CLRF   x18
01EAE:  MOVLW  01
01EB0:  MOVWF  x19
01EB2:  CLRF   FDA
01EB4:  CLRF   FD9
01EB6:  MOVLW  0C
01EB8:  MOVWF  x1C
01EBA:  MOVLW  0F
01EBC:  MOVWF  x1B
01EBE:  MOVLW  0C
01EC0:  MOVWF  FEA
01EC2:  MOVLW  13
01EC4:  MOVWF  FE9
01EC6:  MOVFF  C1C,FE2
01ECA:  MOVFF  C1B,FE1
01ECE:  MOVFF  C19,C1A
01ED2:  BCF    FD8.0
01ED4:  MOVF   FE5,W
01ED6:  MULWF  FEE
01ED8:  MOVF   FF3,W
01EDA:  ADDWFC x17,F
01EDC:  MOVF   FF4,W
01EDE:  ADDWFC x18,F
01EE0:  DECFSZ x1A,F
01EE2:  BRA    1ED2
01EE4:  MOVFF  C17,FDE
01EE8:  MOVFF  C18,C17
01EEC:  CLRF   x18
01EEE:  BTFSC  FD8.0
01EF0:  INCF   x18,F
01EF2:  INCF   x1B,F
01EF4:  BTFSC  FD8.2
01EF6:  INCF   x1C,F
01EF8:  INCF   x19,F
01EFA:  MOVF   x19,W
01EFC:  SUBLW  05
01EFE:  BNZ   1EBE
01F00:  MOVLB  0
01F02:  RETURN 0
*
02012:  BTFSC  FD8.1
02014:  BRA    201E
02016:  MOVLW  0C
02018:  MOVWF  FEA
0201A:  MOVLW  1F
0201C:  MOVWF  FE9
0201E:  MOVLB  C
02020:  MOVF   x1A,W
02022:  XORWF  x1E,W
02024:  ANDLW  80
02026:  MOVWF  x24
02028:  BTFSS  x1A.7
0202A:  BRA    2042
0202C:  COMF   x17,F
0202E:  COMF   x18,F
02030:  COMF   x19,F
02032:  COMF   x1A,F
02034:  INCF   x17,F
02036:  BTFSC  FD8.2
02038:  INCF   x18,F
0203A:  BTFSC  FD8.2
0203C:  INCF   x19,F
0203E:  BTFSC  FD8.2
02040:  INCF   x1A,F
02042:  BTFSS  x1E.7
02044:  BRA    205C
02046:  COMF   x1B,F
02048:  COMF   x1C,F
0204A:  COMF   x1D,F
0204C:  COMF   x1E,F
0204E:  INCF   x1B,F
02050:  BTFSC  FD8.2
02052:  INCF   x1C,F
02054:  BTFSC  FD8.2
02056:  INCF   x1D,F
02058:  BTFSC  FD8.2
0205A:  INCF   x1E,F
0205C:  CLRF   00
0205E:  CLRF   01
02060:  CLRF   02
02062:  CLRF   03
02064:  CLRF   x1F
02066:  CLRF   x20
02068:  CLRF   x21
0206A:  CLRF   x22
0206C:  MOVF   x1E,W
0206E:  IORWF  x1D,W
02070:  IORWF  x1C,W
02072:  IORWF  x1B,W
02074:  BZ    20CE
02076:  MOVLW  20
02078:  MOVWF  x23
0207A:  BCF    FD8.0
0207C:  RLCF   x17,F
0207E:  RLCF   x18,F
02080:  RLCF   x19,F
02082:  RLCF   x1A,F
02084:  RLCF   x1F,F
02086:  RLCF   x20,F
02088:  RLCF   x21,F
0208A:  RLCF   x22,F
0208C:  MOVF   x1E,W
0208E:  SUBWF  x22,W
02090:  BNZ   20A2
02092:  MOVF   x1D,W
02094:  SUBWF  x21,W
02096:  BNZ   20A2
02098:  MOVF   x1C,W
0209A:  SUBWF  x20,W
0209C:  BNZ   20A2
0209E:  MOVF   x1B,W
020A0:  SUBWF  x1F,W
020A2:  BNC   20C2
020A4:  MOVF   x1B,W
020A6:  SUBWF  x1F,F
020A8:  MOVF   x1C,W
020AA:  BTFSS  FD8.0
020AC:  INCFSZ x1C,W
020AE:  SUBWF  x20,F
020B0:  MOVF   x1D,W
020B2:  BTFSS  FD8.0
020B4:  INCFSZ x1D,W
020B6:  SUBWF  x21,F
020B8:  MOVF   x1E,W
020BA:  BTFSS  FD8.0
020BC:  INCFSZ x1E,W
020BE:  SUBWF  x22,F
020C0:  BSF    FD8.0
020C2:  RLCF   00,F
020C4:  RLCF   01,F
020C6:  RLCF   02,F
020C8:  RLCF   03,F
020CA:  DECFSZ x23,F
020CC:  BRA    207A
020CE:  BTFSS  x24.7
020D0:  BRA    20E8
020D2:  COMF   00,F
020D4:  COMF   01,F
020D6:  COMF   02,F
020D8:  COMF   03,F
020DA:  INCF   00,F
020DC:  BTFSC  FD8.2
020DE:  INCF   01,F
020E0:  BTFSC  FD8.2
020E2:  INCF   02,F
020E4:  BTFSC  FD8.2
020E6:  INCF   03,F
020E8:  MOVFF  C1F,FEF
020EC:  MOVFF  C20,FEC
020F0:  MOVFF  C21,FEC
020F4:  MOVFF  C22,FEC
020F8:  MOVLB  0
020FA:  RETURN 0
*
03D7E:  TBLRD*+
03D80:  MOVFF  FF6,BFB
03D84:  MOVFF  FF7,BFC
03D88:  MOVF   FF5,W
03D8A:  MOVLB  E
03D8C:  BTFSS  x37.4
03D8E:  BRA    3D8C
03D90:  MOVWF  xDD
03D92:  MOVFF  BFB,FF6
03D96:  MOVFF  BFC,FF7
03D9A:  MOVLB  B
03D9C:  DECFSZ xFA,F
03D9E:  BRA    3DA2
03DA0:  BRA    3DA6
03DA2:  MOVLB  0
03DA4:  BRA    3D7E
03DA6:  MOVLB  0
03DA8:  RETURN 0
03DAA:  MOVF   01,W
03DAC:  CLRF   19
03DAE:  BTFSC  FF2.7
03DB0:  BSF    19.7
03DB2:  BCF    FF2.7
03DB4:  MOVFF  BFA,C33
03DB8:  MOVLW  64
03DBA:  MOVLB  C
03DBC:  MOVWF  x34
03DBE:  MOVLB  0
03DC0:  CALL   0182
03DC4:  BTFSC  19.7
03DC6:  BSF    FF2.7
03DC8:  MOVFF  00,BFA
03DCC:  MOVF   01,W
03DCE:  MOVLW  30
03DD0:  BNZ   3DE2
03DD2:  MOVLB  B
03DD4:  BTFSS  xFB.1
03DD6:  BRA    3DF8
03DD8:  BTFSC  xFB.3
03DDA:  BRA    3DF8
03DDC:  BTFSC  xFB.4
03DDE:  MOVLW  20
03DE0:  BRA    3DEA
03DE2:  MOVLB  B
03DE4:  BCF    xFB.3
03DE6:  BCF    xFB.4
03DE8:  BSF    xFB.0
03DEA:  ADDWF  01,F
03DEC:  MOVF   01,W
03DEE:  MOVLB  E
03DF0:  BTFSS  x37.4
03DF2:  BRA    3DF0
03DF4:  MOVWF  xDD
03DF6:  MOVLB  B
03DF8:  CLRF   19
03DFA:  BTFSC  FF2.7
03DFC:  BSF    19.7
03DFE:  BCF    FF2.7
03E00:  MOVFF  BFA,C33
03E04:  MOVLW  0A
03E06:  MOVLB  C
03E08:  MOVWF  x34
03E0A:  MOVLB  0
03E0C:  CALL   0182
03E10:  BTFSC  19.7
03E12:  BSF    FF2.7
03E14:  MOVFF  00,BFA
03E18:  MOVF   01,W
03E1A:  MOVLW  30
03E1C:  BNZ   3E2E
03E1E:  MOVLB  B
03E20:  BTFSC  xFB.3
03E22:  BRA    3E3C
03E24:  BTFSS  xFB.0
03E26:  BRA    3E3C
03E28:  BTFSC  xFB.4
03E2A:  MOVLW  20
03E2C:  MOVLB  0
03E2E:  ADDWF  01,F
03E30:  MOVF   01,W
03E32:  MOVLB  E
03E34:  BTFSS  x37.4
03E36:  BRA    3E34
03E38:  MOVWF  xDD
03E3A:  MOVLB  B
03E3C:  MOVLW  30
03E3E:  ADDWF  xFA,F
03E40:  MOVF   xFA,W
03E42:  MOVLB  E
03E44:  BTFSS  x37.4
03E46:  BRA    3E44
03E48:  MOVWF  xDD
03E4A:  MOVLB  0
03E4C:  RETURN 0
03E4E:  MOVFF  FEA,C06
03E52:  MOVFF  FE9,C05
03E56:  MOVLB  B
03E58:  SWAPF  xFB,W
03E5A:  IORLW  F0
03E5C:  MOVLB  C
03E5E:  MOVWF  x01
03E60:  ADDWF  x01,F
03E62:  ADDLW  E2
03E64:  MOVWF  x02
03E66:  ADDLW  32
03E68:  MOVWF  x04
03E6A:  MOVLB  B
03E6C:  MOVF   xFB,W
03E6E:  ANDLW  0F
03E70:  MOVLB  C
03E72:  ADDWF  x02,F
03E74:  ADDWF  x02,F
03E76:  ADDWF  x04,F
03E78:  ADDLW  E9
03E7A:  MOVWF  x03
03E7C:  ADDWF  x03,F
03E7E:  ADDWF  x03,F
03E80:  MOVLB  B
03E82:  SWAPF  xFA,W
03E84:  ANDLW  0F
03E86:  MOVLB  C
03E88:  ADDWF  x03,F
03E8A:  ADDWF  x04,F
03E8C:  RLCF   x03,F
03E8E:  RLCF   x04,F
03E90:  COMF   x04,F
03E92:  RLCF   x04,F
03E94:  MOVLB  B
03E96:  MOVF   xFA,W
03E98:  ANDLW  0F
03E9A:  MOVLB  C
03E9C:  ADDWF  x04,F
03E9E:  RLCF   x01,F
03EA0:  MOVLW  07
03EA2:  MOVWF  x00
03EA4:  MOVLW  0A
03EA6:  DECF   x03,F
03EA8:  ADDWF  x04,F
03EAA:  BNC   3EA6
03EAC:  DECF   x02,F
03EAE:  ADDWF  x03,F
03EB0:  BNC   3EAC
03EB2:  DECF   x01,F
03EB4:  ADDWF  x02,F
03EB6:  BNC   3EB2
03EB8:  DECF   x00,F
03EBA:  ADDWF  x01,F
03EBC:  BNC   3EB8
03EBE:  MOVLW  0C
03EC0:  MOVWF  FEA
03EC2:  CLRF   FE9
03EC4:  MOVLW  07
03EC6:  ANDWF  x05,W
03EC8:  BCF    x05.6
03ECA:  ADDWF  FE9,F
03ECC:  MOVLW  00
03ECE:  ADDWFC FEA,F
03ED0:  MOVF   FE9,W
03ED2:  SUBLW  04
03ED4:  BNZ   3EDE
03ED6:  MOVF   FEA,W
03ED8:  SUBLW  0C
03EDA:  BNZ   3EDE
03EDC:  BSF    x05.6
03EDE:  MOVF   FEF,W
03EE0:  MOVWF  00
03EE2:  BNZ   3EF4
03EE4:  BTFSC  x05.6
03EE6:  BRA    3EF4
03EE8:  BTFSC  x05.4
03EEA:  BRA    3F08
03EEC:  BTFSC  x05.3
03EEE:  BRA    3EF4
03EF0:  MOVLW  20
03EF2:  BRA    3EFA
03EF4:  BSF    x05.3
03EF6:  BCF    x05.4
03EF8:  MOVLW  30
03EFA:  ADDWF  00,F
03EFC:  MOVF   00,W
03EFE:  MOVLB  E
03F00:  BTFSS  x37.4
03F02:  BRA    3F00
03F04:  MOVWF  xDD
03F06:  MOVLB  C
03F08:  MOVF   FEE,W
03F0A:  BTFSS  x05.6
03F0C:  BRA    3ED0
03F0E:  MOVLB  0
03F10:  RETURN 0
03F12:  BTFSC  FD8.1
03F14:  BRA    3F1E
03F16:  MOVLW  0C
03F18:  MOVWF  FEA
03F1A:  MOVLW  14
03F1C:  MOVWF  FE9
03F1E:  CLRF   00
03F20:  CLRF   01
03F22:  CLRF   02
03F24:  CLRF   03
03F26:  MOVLB  C
03F28:  CLRF   x14
03F2A:  CLRF   x15
03F2C:  CLRF   x16
03F2E:  CLRF   x17
03F30:  MOVF   x13,W
03F32:  IORWF  x12,W
03F34:  IORWF  x11,W
03F36:  IORWF  x10,W
03F38:  BZ    3F92
03F3A:  MOVLW  20
03F3C:  MOVWF  x18
03F3E:  BCF    FD8.0
03F40:  RLCF   x0C,F
03F42:  RLCF   x0D,F
03F44:  RLCF   x0E,F
03F46:  RLCF   x0F,F
03F48:  RLCF   x14,F
03F4A:  RLCF   x15,F
03F4C:  RLCF   x16,F
03F4E:  RLCF   x17,F
03F50:  MOVF   x13,W
03F52:  SUBWF  x17,W
03F54:  BNZ   3F66
03F56:  MOVF   x12,W
03F58:  SUBWF  x16,W
03F5A:  BNZ   3F66
03F5C:  MOVF   x11,W
03F5E:  SUBWF  x15,W
03F60:  BNZ   3F66
03F62:  MOVF   x10,W
03F64:  SUBWF  x14,W
03F66:  BNC   3F86
03F68:  MOVF   x10,W
03F6A:  SUBWF  x14,F
03F6C:  MOVF   x11,W
03F6E:  BTFSS  FD8.0
03F70:  INCFSZ x11,W
03F72:  SUBWF  x15,F
03F74:  MOVF   x12,W
03F76:  BTFSS  FD8.0
03F78:  INCFSZ x12,W
03F7A:  SUBWF  x16,F
03F7C:  MOVF   x13,W
03F7E:  BTFSS  FD8.0
03F80:  INCFSZ x13,W
03F82:  SUBWF  x17,F
03F84:  BSF    FD8.0
03F86:  RLCF   00,F
03F88:  RLCF   01,F
03F8A:  RLCF   02,F
03F8C:  RLCF   03,F
03F8E:  DECFSZ x18,F
03F90:  BRA    3F3E
03F92:  MOVFF  C14,FEF
03F96:  MOVFF  C15,FEC
03F9A:  MOVFF  C16,FEC
03F9E:  MOVFF  C17,FEC
03FA2:  MOVLB  0
03FA4:  RETURN 0
03FA6:  MOVF   FE9,W
03FA8:  MOVLB  C
03FAA:  MOVWF  x00
03FAC:  MOVLW  3B
03FAE:  MOVWF  x07
03FB0:  MOVLW  9A
03FB2:  MOVWF  x06
03FB4:  MOVLW  CA
03FB6:  MOVWF  x05
03FB8:  CLRF   x04
03FBA:  MOVLW  0A
03FBC:  MOVWF  x02
03FBE:  BSF    FD8.1
03FC0:  MOVLW  0B
03FC2:  MOVWF  FEA
03FC4:  MOVLW  FA
03FC6:  MOVWF  FE9
03FC8:  MOVFF  BFD,C0F
03FCC:  MOVFF  BFC,C0E
03FD0:  MOVFF  BFB,C0D
03FD4:  MOVFF  BFA,C0C
03FD8:  MOVFF  C07,C13
03FDC:  MOVFF  C06,C12
03FE0:  MOVFF  C05,C11
03FE4:  MOVFF  C04,C10
03FE8:  MOVLB  0
03FEA:  RCALL  3F12
03FEC:  MOVF   01,W
03FEE:  MOVF   00,F
03FF0:  BNZ   4018
03FF2:  MOVLB  C
03FF4:  MOVF   x02,W
03FF6:  XORLW  01
03FF8:  BTFSS  FD8.2
03FFA:  BRA    4000
03FFC:  MOVLB  0
03FFE:  BRA    4018
04000:  MOVF   x00,W
04002:  BZ    401C
04004:  ANDLW  0F
04006:  SUBWF  x02,W
04008:  BZ    400C
0400A:  BC    402C
0400C:  BTFSC  x00.7
0400E:  BRA    402C
04010:  BTFSC  x00.6
04012:  BRA    401C
04014:  MOVLW  20
04016:  BRA    401E
04018:  MOVLB  C
0401A:  CLRF   x00
0401C:  MOVLW  30
0401E:  ADDWF  00,F
04020:  MOVF   00,W
04022:  MOVLB  E
04024:  BTFSS  x37.4
04026:  BRA    4024
04028:  MOVWF  xDD
0402A:  MOVLB  C
0402C:  BCF    FD8.1
0402E:  MOVFF  C07,C0F
04032:  MOVFF  C06,C0E
04036:  MOVFF  C05,C0D
0403A:  MOVFF  C04,C0C
0403E:  CLRF   x13
04040:  CLRF   x12
04042:  CLRF   x11
04044:  MOVLW  0A
04046:  MOVWF  x10
04048:  MOVLB  0
0404A:  RCALL  3F12
0404C:  MOVFF  03,C07
04050:  MOVFF  02,C06
04054:  MOVFF  01,C05
04058:  MOVFF  00,C04
0405C:  MOVLB  C
0405E:  DECFSZ x02,F
04060:  BRA    3FBE
04062:  MOVLB  0
04064:  RETURN 0
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VM_PIN_CONFIG_H_ 
.................... #define _VM_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // RS485 Communication Pin Mapping. 
.................... #define PIN_RS485_XMIT              PIN_E0 
.................... #define PIN_RS485_RCV               PIN_E1 
.................... #define PIN_RS485_RTS               PIN_G0			 
....................  
.................... // GPSR Communication PIN Mapping; SIM900/SIM800/Quectel. 
.................... #define PIN_GPRS_COMM_XMIT          PIN_G1 
.................... #define PIN_GPRS_COMM_RCV           PIN_G2 
....................  
.................... // UART -><- UART(IBU) Communication PIN Mapping. 
.................... #define PIN_IBU_RCV                 PIN_C7 
.................... #define PIN_IBU_XMIT                PIN_C6 
....................  
.................... // Extra UART PIN Mapping.(For Spare Purpose) 
.................... #define PIN_EXT_UART_XMIT           PIN_C0 
.................... #define PIN_EXT_UART_RCV            PIN_C1 
....................  
.................... // Digital Input(DI) PIN Mapping. 
.................... #define PIN_INPUT_DI_00             PIN_C2 
.................... #define PIN_INPUT_DI_01             PIN_C3 
....................  
.................... // Digital Output PIN Mapping. 
.................... #define PIN_OUT_DO_00               PIN_E5 
.................... #define PIN_OUT_DO_01               PIN_E4 
....................  
.................... // Spare Serial Clock and Serial Data PIN Mapping. 
.................... #define PIN_MCU1_SCLK               PIN_D6 
.................... #define PIN_MCU1_SDA                PIN_D5 
....................    
....................  
.................... #endif /* _VM_PIN_CONFIG_H_ */ 
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
....................  
.................... //********* CPU Settings ******************************************* 
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
009F6:  MOVLW  0C
009F8:  MOVWF  FEA
009FA:  MOVLW  0B
009FC:  MOVWF  FE9
009FE:  MOVF   FEF,W
00A00:  BZ    0A24
00A02:  MOVLW  06
00A04:  MOVWF  01
00A06:  MOVLW  BF
00A08:  MOVWF  00
00A0A:  CLRWDT
00A0C:  DECFSZ 00,F
00A0E:  BRA    0A0A
00A10:  DECFSZ 01,F
00A12:  BRA    0A06
00A14:  MOVLW  7A
00A16:  MOVWF  00
00A18:  DECFSZ 00,F
00A1A:  BRA    0A18
00A1C:  BRA    0A1E
00A1E:  CLRWDT
00A20:  DECFSZ FEF,F
00A22:  BRA    0A02
00A24:  RETURN 0
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ############### Using UART3 -> Configure for RS485 ########################## 
.................... #PIN_SELECT U3RX=PIN_E1 
.................... #PIN_SELECT U3TX=PIN_E0 
.................... #use rs232(baud=38400,UART3,stream=RS485,ERRORS) 
*
0040C:  MOVLB  E
0040E:  BTFSS  x37.1
00410:  BRA    040E
00412:  MOVFF  EEE,2F
00416:  MOVFF  EEA,01
0041A:  BTFSS  2F.1
0041C:  BRA    0422
0041E:  BCF    xEE.4
00420:  BSF    xEE.4
00422:  MOVLB  0
00424:  RETURN 0
*
0179C:  MOVLB  E
0179E:  BTFSS  x37.0
017A0:  BRA    179E
017A2:  MOVWF  xEB
017A4:  MOVLB  0
017A6:  RETURN 0
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
*
001AE:  MOVLB  E
001B0:  BTFSS  x36.5
001B2:  BRA    01B0
001B4:  MOVFF  F9C,2F
001B8:  MOVFF  F98,01
001BC:  BTFSS  2F.1
001BE:  BRA    01C4
001C0:  BCF    F9C.4
001C2:  BSF    F9C.4
001C4:  MOVLB  0
001C6:  GOTO   0208 (RETURN)
*
00DDA:  MOVLB  E
00DDC:  BTFSS  x36.4
00DDE:  BRA    0DDC
00DE0:  MOVWF  F99
00DE2:  MOVLB  0
00DE4:  RETURN 0
....................  
.................... //// ############### Using UART2 -> Configure for GPRS Module;EC20 ############### 
.................... //#PIN_SELECT U2RX=PIN_G2 
.................... //#PIN_SELECT U2TX=PIN_G1 
.................... //#use rs232(baud=115200,UART2,stream=GSM_M66,ERRORS) 
....................  
.................... // ################# Using UART2 -> Configure for LAN Module; USR_K3 ########### 
.................... #PIN_SELECT U5RX=PIN_E3 
.................... #PIN_SELECT U5TX=PIN_E2 
.................... #use rs232(baud=115200,UART5,stream=LAN_USR,ERRORS) 
*
00362:  MOVLB  E
00364:  BTFSS  x37.5
00366:  BRA    0364
00368:  MOVFF  EE0,2F
0036C:  MOVFF  EDC,01
00370:  BTFSS  2F.1
00372:  BRA    0378
00374:  BCF    xE0.4
00376:  BSF    xE0.4
00378:  MOVLB  0
0037A:  GOTO   039C (RETURN)
....................  
.................... #pragma priority INT_RDA,INT_RDA5,INT_RDA3 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                          time.c                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
*
01FAA:  MOVLB  C
01FAC:  CLRF   x10
.................... { 
....................     unsigned int8 ui8ReturnValue = 0; 
....................     switch(month) 
01FAE:  MOVF   x0E,W
01FB0:  XORLW  00
01FB2:  MOVLB  0
01FB4:  BZ    1FE4
01FB6:  XORLW  02
01FB8:  BZ    1FE4
01FBA:  XORLW  06
01FBC:  BZ    1FE4
01FBE:  XORLW  02
01FC0:  BZ    1FE4
01FC2:  XORLW  01
01FC4:  BZ    1FE4
01FC6:  XORLW  0E
01FC8:  BZ    1FE4
01FCA:  XORLW  02
01FCC:  BZ    1FE4
01FCE:  XORLW  0A
01FD0:  BZ    1FEC
01FD2:  XORLW  02
01FD4:  BZ    1FFE
01FD6:  XORLW  06
01FD8:  BZ    1FFE
01FDA:  XORLW  0D
01FDC:  BZ    1FFE
01FDE:  XORLW  02
01FE0:  BZ    1FFE
01FE2:  BRA    2008
....................     { 
....................        case JANUARY: 
....................        case MARCH: 
....................        case MAY: 
....................        case JULY: 
....................        case AUGUST: 
....................        case OCTOBER: 
....................        case DECEMBER: 
....................            ui8ReturnValue = 31; 
01FE4:  MOVLW  1F
01FE6:  MOVLB  C
01FE8:  MOVWF  x10
....................            break; 
01FEA:  BRA    200A
....................        case FEBRUARY: 
....................             if(IsLeapYear) 
01FEC:  MOVLB  C
01FEE:  MOVF   x0F,F
01FF0:  BZ    1FF8
....................             { 
....................                 ui8ReturnValue = 29; 
01FF2:  MOVLW  1D
01FF4:  MOVWF  x10
....................             } 
01FF6:  BRA    1FFC
....................             else 
....................             { 
....................                 ui8ReturnValue = 28; 
01FF8:  MOVLW  1C
01FFA:  MOVWF  x10
....................             } 
....................             break; 
01FFC:  BRA    200A
....................        case APRIL: 
....................        case JUNE: 
....................        case SEPTEMBER: 
....................        case NOVEMBER: 
....................           ui8ReturnValue = 30; 
01FFE:  MOVLW  1E
02000:  MOVLB  C
02002:  MOVWF  x10
....................           break; 
02004:  BRA    200A
02006:  MOVLB  0
....................        // error 
....................        default: 
....................            break; 
02008:  MOVLB  C
....................     } 
....................      
....................     return ui8ReturnValue; 
0200A:  MOVFF  C10,01
0200E:  MOVLB  0
02010:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... int1 LeapYear(unsigned int16 year) 
.................... { 
....................     if( ((year + 1900) % 400 == 0) ||  
....................         (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
01F04:  MOVLW  6C
01F06:  MOVLB  C
01F08:  ADDWF  x0B,W
01F0A:  MOVWF  x0D
01F0C:  MOVLW  07
01F0E:  ADDWFC x0C,W
01F10:  MOVWF  x0E
01F12:  CLRF   19
01F14:  BTFSC  FF2.7
01F16:  BSF    19.7
01F18:  BCF    FF2.7
01F1A:  MOVWF  x2C
01F1C:  MOVFF  C0D,C2B
01F20:  MOVLW  01
01F22:  MOVWF  x2E
01F24:  MOVLW  90
01F26:  MOVWF  x2D
01F28:  MOVLB  0
01F2A:  CALL   0448
01F2E:  BTFSC  19.7
01F30:  BSF    FF2.7
01F32:  MOVFF  00,C0D
01F36:  MOVLB  C
01F38:  MOVFF  03,C0E
01F3C:  MOVF   x0D,F
01F3E:  BNZ   1F44
01F40:  MOVF   x0E,F
01F42:  BZ    1F9A
01F44:  MOVLW  6C
01F46:  ADDWF  x0B,W
01F48:  MOVWF  x0D
01F4A:  MOVLW  07
01F4C:  ADDWFC x0C,W
01F4E:  MOVWF  x0E
01F50:  MOVLW  03
01F52:  ANDWF  x0D,F
01F54:  CLRF   x0E
01F56:  MOVF   x0D,F
01F58:  BNZ   1FA2
01F5A:  MOVF   x0E,F
01F5C:  BNZ   1FA2
01F5E:  MOVLW  6C
01F60:  ADDWF  x0B,W
01F62:  MOVWF  x0D
01F64:  MOVLW  07
01F66:  ADDWFC x0C,W
01F68:  MOVWF  x0E
01F6A:  CLRF   19
01F6C:  BTFSC  FF2.7
01F6E:  BSF    19.7
01F70:  BCF    FF2.7
01F72:  MOVWF  x2C
01F74:  MOVFF  C0D,C2B
01F78:  CLRF   x2E
01F7A:  MOVLW  64
01F7C:  MOVWF  x2D
01F7E:  MOVLB  0
01F80:  CALL   0448
01F84:  BTFSC  19.7
01F86:  BSF    FF2.7
01F88:  MOVFF  00,C0D
01F8C:  MOVLB  C
01F8E:  MOVFF  03,C0E
01F92:  MOVF   x0D,F
01F94:  BNZ   1F9A
01F96:  MOVF   x0E,F
01F98:  BZ    1FA2
....................     { 
....................        return TRUE; 
01F9A:  MOVLW  01
01F9C:  MOVWF  01
01F9E:  BRA    1FA6
....................     } 
01FA0:  BRA    1FA6
....................     else 
....................     { 
....................         return FALSE; 
01FA2:  MOVLW  00
01FA4:  MOVWF  01
....................     } 
01FA6:  MOVLB  0
01FA8:  RETURN 0
.................... } 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT) 
*
020FC:  MOVLB  B
020FE:  CLRF   xFD
02100:  CLRF   xFC
02102:  CLRF   xFB
02104:  CLRF   xFA
02106:  BCF    xFE.0
02108:  MOVLB  C
0210A:  CLRF   x00
0210C:  MOVLB  B
0210E:  CLRF   xFF
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
02110:  MOVF   xF8,F
02112:  BNZ   211A
02114:  MOVF   xF9,F
02116:  BTFSC  FD8.2
02118:  BRA    2632
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
0211A:  MOVFF  BF8,FE9
0211E:  MOVFF  BF9,FEA
02122:  MOVF   FEF,W
02124:  ADDWF  xFA,F
02126:  MOVLW  00
02128:  ADDWFC xFB,F
0212A:  ADDWFC xFC,F
0212C:  ADDWFC xFD,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
0212E:  MOVLW  01
02130:  ADDWF  xF8,W
02132:  MOVWF  FE9
02134:  MOVLW  00
02136:  ADDWFC xF9,W
02138:  MOVWF  FEA
0213A:  MOVF   FEF,W
0213C:  MOVLB  C
0213E:  CLRF   x04
02140:  CLRF   x03
02142:  CLRF   x02
02144:  MOVWF  x01
02146:  MOVFF  FEA,C06
0214A:  MOVFF  FE9,C05
0214E:  MOVFF  C04,C12
02152:  MOVFF  C03,C11
02156:  MOVFF  C02,C10
0215A:  MOVWF  x0F
0215C:  CLRF   x16
0215E:  CLRF   x15
02160:  CLRF   x14
02162:  MOVLW  3C
02164:  MOVWF  x13
02166:  MOVLB  0
02168:  RCALL  1EA8
0216A:  MOVFF  C06,FEA
0216E:  MOVFF  C05,FE9
02172:  MOVF   00,W
02174:  MOVLB  B
02176:  ADDWF  xFA,F
02178:  MOVF   01,W
0217A:  ADDWFC xFB,F
0217C:  MOVF   02,W
0217E:  ADDWFC xFC,F
02180:  MOVF   03,W
02182:  ADDWFC xFD,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
02184:  MOVLW  02
02186:  ADDWF  xF8,W
02188:  MOVWF  FE9
0218A:  MOVLW  00
0218C:  ADDWFC xF9,W
0218E:  MOVWF  FEA
02190:  MOVF   FEF,W
02192:  MOVLB  C
02194:  CLRF   x04
02196:  CLRF   x03
02198:  CLRF   x02
0219A:  MOVWF  x01
0219C:  MOVFF  FEA,C06
021A0:  MOVFF  FE9,C05
021A4:  MOVFF  C04,C12
021A8:  MOVFF  C03,C11
021AC:  MOVFF  C02,C10
021B0:  MOVWF  x0F
021B2:  CLRF   x16
021B4:  CLRF   x15
021B6:  MOVLW  0E
021B8:  MOVWF  x14
021BA:  MOVLW  10
021BC:  MOVWF  x13
021BE:  MOVLB  0
021C0:  RCALL  1EA8
021C2:  MOVFF  C06,FEA
021C6:  MOVFF  C05,FE9
021CA:  MOVF   00,W
021CC:  MOVLB  B
021CE:  ADDWF  xFA,F
021D0:  MOVF   01,W
021D2:  ADDWFC xFB,F
021D4:  MOVF   02,W
021D6:  ADDWFC xFC,F
021D8:  MOVF   03,W
021DA:  ADDWFC xFD,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
021DC:  MOVLW  05
021DE:  ADDWF  xF8,W
021E0:  MOVWF  FE9
021E2:  MOVLW  00
021E4:  ADDWFC xF9,W
021E6:  MOVWF  FEA
021E8:  MOVFF  FEC,C0C
021EC:  MOVF   FED,F
021EE:  MOVFF  FEF,C0B
021F2:  MOVLB  0
021F4:  RCALL  1F04
021F6:  MOVLB  B
021F8:  BCF    xFE.0
021FA:  BTFSC  01.0
021FC:  BSF    xFE.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
021FE:  MOVLW  04
02200:  ADDWF  xF8,W
02202:  MOVWF  FE9
02204:  MOVLW  00
02206:  ADDWFC xF9,W
02208:  MOVWF  FEA
0220A:  CLRF   19
0220C:  BTFSC  FF2.7
0220E:  BSF    19.7
02210:  BCF    FF2.7
02212:  MOVFF  FEF,C33
02216:  MOVLW  0C
02218:  MOVLB  C
0221A:  MOVWF  x34
0221C:  MOVLB  0
0221E:  CALL   0182
02222:  BTFSC  19.7
02224:  BSF    FF2.7
02226:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
0222A:  MOVLB  C
0222C:  CLRF   x00
0222E:  MOVLW  01
02230:  MOVLB  B
02232:  MOVWF  xFF
02234:  MOVLW  04
02236:  ADDWF  xF8,W
02238:  MOVWF  FE9
0223A:  MOVLW  00
0223C:  ADDWFC xF9,W
0223E:  MOVWF  FEA
02240:  MOVF   FEF,W
02242:  MOVLB  C
02244:  MOVF   x00,F
02246:  BNZ   22CA
02248:  MOVLB  B
0224A:  SUBWF  xFF,W
0224C:  BZ    2256
0224E:  BTFSS  FD8.0
02250:  BRA    2256
02252:  MOVLB  C
02254:  BRA    22CA
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
02256:  MOVLW  01
02258:  SUBWF  xFF,W
0225A:  MOVLB  C
0225C:  MOVWF  x01
0225E:  MOVLW  00
02260:  SUBWFB x00,W
02262:  MOVWF  x02
02264:  MOVLW  00
02266:  MOVLB  B
02268:  BTFSC  xFE.0
0226A:  MOVLW  01
0226C:  MOVLB  C
0226E:  MOVWF  x03
02270:  MOVFF  C01,C0E
02274:  MOVWF  x0F
02276:  MOVLB  0
02278:  RCALL  1FAA
0227A:  MOVFF  FEA,C03
0227E:  MOVFF  FE9,C02
02282:  MOVLB  C
02284:  CLRF   x12
02286:  CLRF   x11
02288:  CLRF   x10
0228A:  MOVFF  01,C0F
0228E:  CLRF   x16
02290:  MOVLW  01
02292:  MOVWF  x15
02294:  MOVLW  51
02296:  MOVWF  x14
02298:  MOVLW  80
0229A:  MOVWF  x13
0229C:  MOVLB  0
0229E:  RCALL  1EA8
022A0:  MOVFF  C03,FEA
022A4:  MOVFF  C02,FE9
022A8:  MOVF   00,W
022AA:  MOVLB  B
022AC:  ADDWF  xFA,F
022AE:  MOVF   01,W
022B0:  ADDWFC xFB,F
022B2:  MOVF   02,W
022B4:  ADDWFC xFC,F
022B6:  MOVF   03,W
022B8:  ADDWFC xFD,F
022BA:  INCF   xFF,F
022BC:  BTFSS  FD8.2
022BE:  BRA    22C6
022C0:  MOVLB  C
022C2:  INCF   x00,F
022C4:  MOVLB  B
022C6:  BRA    2234
022C8:  MOVLB  C
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
022CA:  MOVLW  03
022CC:  MOVLB  B
022CE:  ADDWF  xF8,W
022D0:  MOVWF  01
022D2:  MOVLW  00
022D4:  ADDWFC xF9,W
022D6:  MOVWF  03
022D8:  MOVFF  01,C01
022DC:  MOVLB  C
022DE:  MOVWF  x02
022E0:  MOVWF  FEA
022E2:  MOVFF  01,FE9
022E6:  MOVFF  FEF,C03
022EA:  MOVLW  04
022EC:  MOVLB  B
022EE:  ADDWF  xF8,W
022F0:  MOVWF  FE9
022F2:  MOVLW  00
022F4:  ADDWFC xF9,W
022F6:  MOVWF  FEA
022F8:  MOVFF  FEF,C0E
022FC:  MOVLW  00
022FE:  BTFSC  xFE.0
02300:  MOVLW  01
02302:  MOVLB  C
02304:  MOVWF  x05
02306:  MOVWF  x0F
02308:  MOVLB  0
0230A:  RCALL  1FAA
0230C:  CLRF   19
0230E:  BTFSC  FF2.7
02310:  BSF    19.7
02312:  BCF    FF2.7
02314:  MOVFF  C03,C33
02318:  MOVFF  01,C34
0231C:  CALL   0182
02320:  BTFSC  19.7
02322:  BSF    FF2.7
02324:  MOVLB  C
02326:  MOVFF  C02,FEA
0232A:  MOVFF  C01,FE9
0232E:  MOVFF  00,FEF
....................       unixTime += (timeT->tm_mday) * 86400; 
02332:  MOVLW  03
02334:  MOVLB  B
02336:  ADDWF  xF8,W
02338:  MOVWF  FE9
0233A:  MOVLW  00
0233C:  ADDWFC xF9,W
0233E:  MOVWF  FEA
02340:  MOVFF  FEA,C03
02344:  MOVFF  FE9,C02
02348:  MOVLB  C
0234A:  CLRF   x12
0234C:  CLRF   x11
0234E:  CLRF   x10
02350:  MOVFF  FEF,C0F
02354:  CLRF   x16
02356:  MOVLW  01
02358:  MOVWF  x15
0235A:  MOVLW  51
0235C:  MOVWF  x14
0235E:  MOVLW  80
02360:  MOVWF  x13
02362:  MOVLB  0
02364:  RCALL  1EA8
02366:  MOVFF  C03,FEA
0236A:  MOVFF  C02,FE9
0236E:  MOVF   00,W
02370:  MOVLB  B
02372:  ADDWF  xFA,F
02374:  MOVF   01,W
02376:  ADDWFC xFB,F
02378:  MOVF   02,W
0237A:  ADDWFC xFC,F
0237C:  MOVF   03,W
0237E:  ADDWFC xFD,F
....................        
....................       if(isLeapYear) 
02380:  BTFSS  xFE.0
02382:  BRA    242E
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
02384:  MOVLW  08
02386:  ADDWF  xF8,W
02388:  MOVWF  01
0238A:  MOVLW  00
0238C:  ADDWFC xF9,W
0238E:  MOVWF  03
02390:  MOVFF  01,C01
02394:  MOVLB  C
02396:  MOVWF  x02
02398:  MOVFF  FEA,C04
0239C:  MOVFF  FE9,C03
023A0:  BCF    FD8.1
023A2:  MOVFF  BFD,C1A
023A6:  MOVFF  BFC,C19
023AA:  MOVFF  BFB,C18
023AE:  MOVFF  BFA,C17
023B2:  CLRF   x1E
023B4:  MOVLW  01
023B6:  MOVWF  x1D
023B8:  MOVLW  51
023BA:  MOVWF  x1C
023BC:  MOVLW  80
023BE:  MOVWF  x1B
023C0:  MOVLB  0
023C2:  RCALL  2012
023C4:  MOVFF  C04,FEA
023C8:  MOVFF  C03,FE9
023CC:  MOVFF  03,C08
023D0:  MOVFF  02,C07
023D4:  MOVFF  01,C06
023D8:  MOVFF  00,C05
023DC:  BSF    FD8.1
023DE:  MOVLW  0C
023E0:  MOVWF  FEA
023E2:  MOVLW  0B
023E4:  MOVWF  FE9
023E6:  MOVFF  03,C1A
023EA:  MOVFF  02,C19
023EE:  MOVFF  01,C18
023F2:  MOVFF  00,C17
023F6:  MOVLB  C
023F8:  CLRF   x1E
023FA:  CLRF   x1D
023FC:  MOVLW  01
023FE:  MOVWF  x1C
02400:  MOVLW  6E
02402:  MOVWF  x1B
02404:  MOVLB  0
02406:  RCALL  2012
02408:  MOVFF  C0B,00
0240C:  MOVFF  C0C,01
02410:  MOVFF  C0D,02
02414:  MOVFF  C0E,03
02418:  MOVFF  C02,FEA
0241C:  MOVFF  C01,FE9
02420:  MOVFF  01,FEC
02424:  MOVF   FED,F
02426:  MOVFF  00,FEF
....................       } 
0242A:  BRA    24D4
0242C:  MOVLB  B
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
0242E:  MOVLW  08
02430:  ADDWF  xF8,W
02432:  MOVWF  01
02434:  MOVLW  00
02436:  ADDWFC xF9,W
02438:  MOVWF  03
0243A:  MOVFF  01,C01
0243E:  MOVLB  C
02440:  MOVWF  x02
02442:  MOVFF  FEA,C04
02446:  MOVFF  FE9,C03
0244A:  BCF    FD8.1
0244C:  MOVFF  BFD,C1A
02450:  MOVFF  BFC,C19
02454:  MOVFF  BFB,C18
02458:  MOVFF  BFA,C17
0245C:  CLRF   x1E
0245E:  MOVLW  01
02460:  MOVWF  x1D
02462:  MOVLW  51
02464:  MOVWF  x1C
02466:  MOVLW  80
02468:  MOVWF  x1B
0246A:  MOVLB  0
0246C:  RCALL  2012
0246E:  MOVFF  C04,FEA
02472:  MOVFF  C03,FE9
02476:  MOVFF  03,C08
0247A:  MOVFF  02,C07
0247E:  MOVFF  01,C06
02482:  MOVFF  00,C05
02486:  BSF    FD8.1
02488:  MOVLW  0C
0248A:  MOVWF  FEA
0248C:  MOVLW  0B
0248E:  MOVWF  FE9
02490:  MOVFF  03,C1A
02494:  MOVFF  02,C19
02498:  MOVFF  01,C18
0249C:  MOVFF  00,C17
024A0:  MOVLB  C
024A2:  CLRF   x1E
024A4:  CLRF   x1D
024A6:  MOVLW  01
024A8:  MOVWF  x1C
024AA:  MOVLW  6D
024AC:  MOVWF  x1B
024AE:  MOVLB  0
024B0:  RCALL  2012
024B2:  MOVFF  C0B,00
024B6:  MOVFF  C0C,01
024BA:  MOVFF  C0D,02
024BE:  MOVFF  C0E,03
024C2:  MOVFF  C02,FEA
024C6:  MOVFF  C01,FE9
024CA:  MOVFF  01,FEC
024CE:  MOVF   FED,F
024D0:  MOVFF  00,FEF
....................       } 
....................        
....................       i = 1970;  // Change done by Amit, initially it was i = 70; 
024D4:  MOVLW  07
024D6:  MOVLB  C
024D8:  MOVWF  x00
024DA:  MOVLW  B2
024DC:  MOVLB  B
024DE:  MOVWF  xFF
....................       if(timeT->tm_year - 1970 >= 0) 
024E0:  MOVLW  05
024E2:  ADDWF  xF8,W
024E4:  MOVWF  FE9
024E6:  MOVLW  00
024E8:  ADDWFC xF9,W
024EA:  MOVWF  FEA
024EC:  MOVFF  FEC,C02
024F0:  MOVF   FED,F
024F2:  MOVFF  FEF,C01
024F6:  MOVLW  B2
024F8:  MOVLB  C
024FA:  SUBWF  x01,F
024FC:  MOVLW  07
024FE:  SUBWFB x02,F
....................       { 
....................          while(i < (timeT->tm_year)) 
02500:  MOVLW  05
02502:  MOVLB  B
02504:  ADDWF  xF8,W
02506:  MOVWF  FE9
02508:  MOVLW  00
0250A:  ADDWFC xF9,W
0250C:  MOVWF  FEA
0250E:  MOVFF  FEC,03
02512:  MOVF   FED,F
02514:  MOVFF  FEF,01
02518:  MOVLB  C
0251A:  MOVF   x00,W
0251C:  SUBWF  03,W
0251E:  BNC   2576
02520:  BNZ   2532
02522:  MOVF   01,W
02524:  MOVLB  B
02526:  SUBWF  xFF,W
02528:  BTFSS  FD8.0
0252A:  BRA    2530
0252C:  MOVLB  C
0252E:  BRA    2576
02530:  MOVLB  C
....................          { 
....................             isLeapYear = LeapYear(i); 
02532:  MOVFF  C00,C0C
02536:  MOVFF  BFF,C0B
0253A:  MOVLB  0
0253C:  RCALL  1F04
0253E:  MOVLB  B
02540:  BCF    xFE.0
02542:  BTFSC  01.0
02544:  BSF    xFE.0
....................             if(isLeapYear) 
02546:  BTFSS  xFE.0
02548:  BRA    2558
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
0254A:  MOVLW  85
0254C:  ADDWF  xFB,F
0254E:  MOVLW  E2
02550:  ADDWFC xFC,F
02552:  MOVLW  01
02554:  ADDWFC xFD,F
....................             } 
02556:  BRA    2568
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
02558:  MOVLW  80
0255A:  ADDWF  xFA,F
0255C:  MOVLW  33
0255E:  ADDWFC xFB,F
02560:  MOVLW  E1
02562:  ADDWFC xFC,F
02564:  MOVLW  01
02566:  ADDWFC xFD,F
....................             } 
....................             i++; 
02568:  INCF   xFF,F
0256A:  BTFSS  FD8.2
0256C:  BRA    2572
0256E:  MOVLB  C
02570:  INCF   x00,F
02572:  MOVLB  C
02574:  BRA    2500
....................          } 
....................       } 
....................       // To match GMT to IST we have to adjust 5hrs 30 mints.. 
....................       unixTime = unixTime - 19800;  // 19800 is the  
02576:  MOVLW  58
02578:  MOVLB  B
0257A:  SUBWF  xFA,F
0257C:  MOVLW  4D
0257E:  SUBWFB xFB,F
02580:  MOVLW  00
02582:  SUBWFB xFC,F
02584:  SUBWFB xFD,F
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
02586:  MOVLW  07
02588:  ADDWF  xF8,W
0258A:  MOVWF  01
0258C:  MOVLW  00
0258E:  ADDWFC xF9,W
02590:  MOVWF  03
02592:  MOVFF  01,C01
02596:  MOVLB  C
02598:  MOVWF  x02
0259A:  MOVFF  FEA,C04
0259E:  MOVFF  FE9,C03
025A2:  BCF    FD8.1
025A4:  MOVFF  BFD,C1A
025A8:  MOVFF  BFC,C19
025AC:  MOVFF  BFB,C18
025B0:  MOVFF  BFA,C17
025B4:  CLRF   x1E
025B6:  MOVLW  01
025B8:  MOVWF  x1D
025BA:  MOVLW  51
025BC:  MOVWF  x1C
025BE:  MOVLW  80
025C0:  MOVWF  x1B
025C2:  MOVLB  0
025C4:  RCALL  2012
025C6:  MOVFF  C04,FEA
025CA:  MOVFF  C03,FE9
025CE:  MOVFF  03,C08
025D2:  MOVFF  02,C07
025D6:  MOVFF  01,C06
025DA:  MOVFF  00,C05
025DE:  MOVLW  04
025E0:  MOVLB  C
025E2:  ADDWF  x05,F
025E4:  MOVLW  00
025E6:  ADDWFC x06,F
025E8:  ADDWFC x07,F
025EA:  ADDWFC x08,F
025EC:  BSF    FD8.1
025EE:  MOVLW  0C
025F0:  MOVWF  FEA
025F2:  MOVLW  0B
025F4:  MOVWF  FE9
025F6:  MOVFF  C08,C1A
025FA:  MOVFF  C07,C19
025FE:  MOVFF  C06,C18
02602:  MOVFF  C05,C17
02606:  CLRF   x1E
02608:  CLRF   x1D
0260A:  CLRF   x1C
0260C:  MOVLW  07
0260E:  MOVWF  x1B
02610:  MOVLB  0
02612:  RCALL  2012
02614:  MOVFF  C0B,00
02618:  MOVFF  C0C,01
0261C:  MOVFF  C0D,02
02620:  MOVFF  C0E,03
02624:  MOVFF  C02,FEA
02628:  MOVFF  C01,FE9
0262C:  MOVFF  00,FEF
02630:  MOVLB  B
....................    } 
....................  
....................    return unixTime; 
02632:  MOVFF  BFA,00
02636:  MOVFF  BFB,01
0263A:  MOVFF  BFC,02
0263E:  MOVFF  BFD,03
02642:  MOVLB  0
02644:  GOTO   39AE (RETURN)
.................... } 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime ( struct_tm * timeptr, char * szTime) 
.................... { 
....................    char szDay[8]; 
....................    char szMon[8]; 
....................     
....................    WeekdayAbbreviations(timeptr->tm_wday, szDay); 
....................    MonthAbbreviations(timeptr->tm_mon, szMon); 
....................     
....................    sprintf(szTime,"%s %s %d %02d:%02d:%02d %04Lu", 
....................       szDay, 
....................       szMon, 
....................       timeptr->tm_mday + 1, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + 1900)); 
....................        
....................    return szTime; 
.................... } 
....................  
.................... /* Converts the given calendar time (in seconds) to local time  
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime ( time_t * timer, char *szTime ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime(time_t * timer) 
02648:  MOVLB  B
0264A:  BCF    xFE.0
0264C:  BCF    xFE.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;//1970 is not a leap year 
....................  
....................    if(timer != NULL) 
0264E:  MOVF   xF8,F
02650:  BNZ   2658
02652:  MOVF   xF9,F
02654:  BTFSC  FD8.2
02656:  BRA    2A4E
....................    { 
....................       timeCounter = *timer; 
02658:  MOVFF  BF9,03
0265C:  MOVFF  BF8,FE9
02660:  MOVFF  03,FEA
02664:  MOVFF  FEF,BFA
02668:  MOVFF  FEC,BFB
0266C:  MOVFF  FEC,BFC
02670:  MOVFF  FEC,BFD
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
02674:  BCF    FD8.1
02676:  MOVFF  BFD,C1A
0267A:  MOVFF  BFC,C19
0267E:  MOVFF  BFB,C18
02682:  MOVFF  BFA,C17
02686:  MOVLB  C
02688:  CLRF   x1E
0268A:  MOVLW  01
0268C:  MOVWF  x1D
0268E:  MOVLW  51
02690:  MOVWF  x1C
02692:  MOVLW  80
02694:  MOVWF  x1B
02696:  MOVLB  0
02698:  RCALL  2012
0269A:  MOVFF  03,C02
0269E:  MOVFF  02,C01
026A2:  MOVFF  01,C00
026A6:  MOVFF  00,BFF
026AA:  MOVLW  04
026AC:  MOVLB  B
026AE:  ADDWF  xFF,F
026B0:  MOVLW  00
026B2:  MOVLB  C
026B4:  ADDWFC x00,F
026B6:  ADDWFC x01,F
026B8:  ADDWFC x02,F
026BA:  BSF    FD8.1
026BC:  MOVLW  0C
026BE:  MOVWF  FEA
026C0:  MOVLW  03
026C2:  MOVWF  FE9
026C4:  MOVFF  C02,C1A
026C8:  MOVFF  C01,C19
026CC:  MOVFF  C00,C18
026D0:  MOVFF  BFF,C17
026D4:  CLRF   x1E
026D6:  CLRF   x1D
026D8:  CLRF   x1C
026DA:  MOVLW  07
026DC:  MOVWF  x1B
026DE:  MOVLB  0
026E0:  RCALL  2012
026E2:  MOVFF  C03,3B
026E6:  MOVFF  C04,01
026EA:  MOVFF  C05,02
026EE:  MOVFF  C06,03
....................       g_lTime.tm_year = 70;//we are starting in 1970 
026F2:  CLRF   3A
026F4:  MOVLW  46
026F6:  MOVWF  39
....................        
....................       while(!done) 
026F8:  MOVLB  B
026FA:  BTFSC  xFE.0
026FC:  BRA    27E8
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
026FE:  BTFSC  xFD.7
02700:  BRA    2718
02702:  MOVF   xFD,W
02704:  SUBLW  01
02706:  BNC   2750
02708:  BNZ   2718
0270A:  MOVF   xFC,W
0270C:  SUBLW  E2
0270E:  BNC   2750
02710:  BNZ   2718
02712:  MOVF   xFB,W
02714:  SUBLW  84
02716:  BNC   2750
02718:  BTFSS  xFE.1
0271A:  BRA    2750
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
0271C:  BCF    FD8.1
0271E:  MOVFF  BFD,C1A
02722:  MOVFF  BFC,C19
02726:  MOVFF  BFB,C18
0272A:  MOVFF  BFA,C17
0272E:  MOVLB  C
02730:  CLRF   x1E
02732:  MOVLW  01
02734:  MOVWF  x1D
02736:  MOVLW  51
02738:  MOVWF  x1C
0273A:  MOVLW  80
0273C:  MOVWF  x1B
0273E:  MOVLB  0
02740:  RCALL  2012
02742:  MOVFF  01,3D
02746:  MOVFF  00,3C
....................             break; 
0274A:  MOVLB  B
0274C:  BRA    27E8
....................          } 
0274E:  BRA    27A4
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
02750:  BTFSC  xFD.7
02752:  BRA    2772
02754:  MOVF   xFD,W
02756:  SUBLW  01
02758:  BNC   27A4
0275A:  BNZ   2772
0275C:  MOVF   xFC,W
0275E:  SUBLW  E1
02760:  BNC   27A4
02762:  BNZ   2772
02764:  MOVF   xFB,W
02766:  SUBLW  33
02768:  BNC   27A4
0276A:  BNZ   2772
0276C:  MOVF   xFA,W
0276E:  SUBLW  7F
02770:  BNC   27A4
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02772:  BCF    FD8.1
02774:  MOVFF  BFD,C1A
02778:  MOVFF  BFC,C19
0277C:  MOVFF  BFB,C18
02780:  MOVFF  BFA,C17
02784:  MOVLB  C
02786:  CLRF   x1E
02788:  MOVLW  01
0278A:  MOVWF  x1D
0278C:  MOVLW  51
0278E:  MOVWF  x1C
02790:  MOVLW  80
02792:  MOVWF  x1B
02794:  MOVLB  0
02796:  RCALL  2012
02798:  MOVFF  01,3D
0279C:  MOVFF  00,3C
....................             break; 
027A0:  MOVLB  B
027A2:  BRA    27E8
....................          } 
....................           
....................          if(isLeapYear) 
027A4:  BTFSS  xFE.1
027A6:  BRA    27BA
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
027A8:  MOVLW  00
027AA:  SUBWF  xFA,F
027AC:  MOVLW  85
027AE:  SUBWFB xFB,F
027B0:  MOVLW  E2
027B2:  SUBWFB xFC,F
027B4:  MOVLW  01
027B6:  SUBWFB xFD,F
....................          } 
027B8:  BRA    27CA
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
027BA:  MOVLW  80
027BC:  SUBWF  xFA,F
027BE:  MOVLW  33
027C0:  SUBWFB xFB,F
027C2:  MOVLW  E1
027C4:  SUBWFB xFC,F
027C6:  MOVLW  01
027C8:  SUBWFB xFD,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
027CA:  INCF   39,F
027CC:  BTFSC  FD8.2
027CE:  INCF   3A,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
027D0:  MOVFF  3A,C0C
027D4:  MOVFF  39,C0B
027D8:  MOVLB  0
027DA:  CALL   1F04
027DE:  MOVLB  B
027E0:  BCF    xFE.1
027E2:  BTFSC  01.0
027E4:  BSF    xFE.1
027E6:  BRA    26FA
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
027E8:  CLRF   38
....................       while(!done) 
027EA:  BTFSC  xFE.0
027EC:  BRA    2922
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
027EE:  MOVLW  00
027F0:  BTFSC  xFE.1
027F2:  MOVLW  01
027F4:  MOVWF  xFF
027F6:  MOVFF  38,C0E
027FA:  MOVFF  FE8,C0F
027FE:  MOVLB  0
02800:  CALL   1FAA
02804:  MOVFF  FEA,C01
02808:  MOVFF  FE9,C00
0280C:  MOVLB  C
0280E:  CLRF   x12
02810:  CLRF   x11
02812:  CLRF   x10
02814:  MOVFF  01,C0F
02818:  CLRF   x16
0281A:  MOVLW  01
0281C:  MOVWF  x15
0281E:  MOVLW  51
02820:  MOVWF  x14
02822:  MOVLW  80
02824:  MOVWF  x13
02826:  MOVLB  0
02828:  CALL   1EA8
0282C:  MOVFF  C01,FEA
02830:  MOVFF  C00,FE9
02834:  MOVLB  B
02836:  BTFSC  xFD.7
02838:  BRA    2858
0283A:  MOVF   xFD,W
0283C:  SUBWF  03,W
0283E:  BNC   285C
02840:  BNZ   2858
02842:  MOVF   xFC,W
02844:  SUBWF  02,W
02846:  BNC   285C
02848:  BNZ   2858
0284A:  MOVF   xFB,W
0284C:  SUBWF  01,W
0284E:  BNC   285C
02850:  BNZ   2858
02852:  MOVF   00,W
02854:  SUBWF  xFA,W
02856:  BC    285C
....................          { 
....................             break; 
02858:  BRA    2922
....................          } 
0285A:  BRA    2920
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
0285C:  MOVLW  00
0285E:  BTFSC  xFE.1
02860:  MOVLW  01
02862:  MOVWF  xFF
02864:  MOVFF  38,C0E
02868:  MOVFF  FE8,C0F
0286C:  MOVLB  0
0286E:  CALL   1FAA
02872:  MOVFF  FEA,C01
02876:  MOVFF  FE9,C00
0287A:  MOVLB  C
0287C:  CLRF   x12
0287E:  CLRF   x11
02880:  CLRF   x10
02882:  MOVFF  01,C0F
02886:  CLRF   x16
02888:  MOVLW  01
0288A:  MOVWF  x15
0288C:  MOVLW  51
0288E:  MOVWF  x14
02890:  MOVLW  80
02892:  MOVWF  x13
02894:  MOVLB  0
02896:  CALL   1EA8
0289A:  MOVFF  C01,FEA
0289E:  MOVFF  C00,FE9
028A2:  MOVLB  B
028A4:  BTFSC  xFD.7
028A6:  BRA    2920
028A8:  MOVF   03,W
028AA:  SUBWF  xFD,W
028AC:  BNC   2920
028AE:  BNZ   28C6
028B0:  MOVF   02,W
028B2:  SUBWF  xFC,W
028B4:  BNC   2920
028B6:  BNZ   28C6
028B8:  MOVF   01,W
028BA:  SUBWF  xFB,W
028BC:  BNC   2920
028BE:  BNZ   28C6
028C0:  MOVF   00,W
028C2:  SUBWF  xFA,W
028C4:  BNC   2920
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
028C6:  MOVLW  00
028C8:  BTFSC  xFE.1
028CA:  MOVLW  01
028CC:  MOVWF  xFF
028CE:  MOVFF  38,C0E
028D2:  MOVFF  FE8,C0F
028D6:  MOVLB  0
028D8:  CALL   1FAA
028DC:  MOVFF  FEA,C01
028E0:  MOVFF  FE9,C00
028E4:  MOVLB  C
028E6:  CLRF   x12
028E8:  CLRF   x11
028EA:  CLRF   x10
028EC:  MOVFF  01,C0F
028F0:  CLRF   x16
028F2:  MOVLW  01
028F4:  MOVWF  x15
028F6:  MOVLW  51
028F8:  MOVWF  x14
028FA:  MOVLW  80
028FC:  MOVWF  x13
028FE:  MOVLB  0
02900:  CALL   1EA8
02904:  MOVFF  C01,FEA
02908:  MOVFF  C00,FE9
0290C:  MOVF   00,W
0290E:  MOVLB  B
02910:  SUBWF  xFA,F
02912:  MOVF   01,W
02914:  SUBWFB xFB,F
02916:  MOVF   02,W
02918:  SUBWFB xFC,F
0291A:  MOVF   03,W
0291C:  SUBWFB xFD,F
....................             g_lTime.tm_mon++; 
0291E:  INCF   38,F
....................          } 
02920:  BRA    27EA
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
02922:  BCF    FD8.1
02924:  MOVFF  BFD,C1A
02928:  MOVFF  BFC,C19
0292C:  MOVFF  BFB,C18
02930:  MOVFF  BFA,C17
02934:  MOVLB  C
02936:  CLRF   x1E
02938:  MOVLW  01
0293A:  MOVWF  x1D
0293C:  MOVLW  51
0293E:  MOVWF  x1C
02940:  MOVLW  80
02942:  MOVWF  x1B
02944:  MOVLB  0
02946:  CALL   2012
0294A:  MOVFF  00,37
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
0294E:  MOVLB  C
02950:  CLRF   x12
02952:  CLRF   x11
02954:  CLRF   x10
02956:  MOVFF  37,C0F
0295A:  CLRF   x16
0295C:  MOVLW  01
0295E:  MOVWF  x15
02960:  MOVLW  51
02962:  MOVWF  x14
02964:  MOVLW  80
02966:  MOVWF  x13
02968:  MOVLB  0
0296A:  CALL   1EA8
0296E:  MOVF   00,W
02970:  MOVLB  B
02972:  SUBWF  xFA,F
02974:  MOVF   01,W
02976:  SUBWFB xFB,F
02978:  MOVF   02,W
0297A:  SUBWFB xFC,F
0297C:  MOVF   03,W
0297E:  SUBWFB xFD,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
02980:  BCF    FD8.1
02982:  MOVFF  BFD,C1A
02986:  MOVFF  BFC,C19
0298A:  MOVFF  BFB,C18
0298E:  MOVFF  BFA,C17
02992:  MOVLB  C
02994:  CLRF   x1E
02996:  CLRF   x1D
02998:  MOVLW  0E
0299A:  MOVWF  x1C
0299C:  MOVLW  10
0299E:  MOVWF  x1B
029A0:  MOVLB  0
029A2:  CALL   2012
029A6:  MOVFF  00,36
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
029AA:  MOVLB  C
029AC:  CLRF   x02
029AE:  CLRF   x01
029B0:  CLRF   x00
029B2:  MOVFF  36,BFF
029B6:  MOVFF  C02,C12
029BA:  MOVFF  C01,C11
029BE:  MOVFF  C00,C10
029C2:  MOVFF  36,C0F
029C6:  CLRF   x16
029C8:  CLRF   x15
029CA:  MOVLW  0E
029CC:  MOVWF  x14
029CE:  MOVLW  10
029D0:  MOVWF  x13
029D2:  MOVLB  0
029D4:  CALL   1EA8
029D8:  MOVF   00,W
029DA:  MOVLB  B
029DC:  SUBWF  xFA,F
029DE:  MOVF   01,W
029E0:  SUBWFB xFB,F
029E2:  MOVF   02,W
029E4:  SUBWFB xFC,F
029E6:  MOVF   03,W
029E8:  SUBWFB xFD,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
029EA:  BCF    FD8.1
029EC:  MOVFF  BFD,C1A
029F0:  MOVFF  BFC,C19
029F4:  MOVFF  BFB,C18
029F8:  MOVFF  BFA,C17
029FC:  MOVLB  C
029FE:  CLRF   x1E
02A00:  CLRF   x1D
02A02:  CLRF   x1C
02A04:  MOVLW  3C
02A06:  MOVWF  x1B
02A08:  MOVLB  0
02A0A:  CALL   2012
02A0E:  MOVFF  00,35
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
02A12:  MOVLB  C
02A14:  CLRF   x00
02A16:  MOVFF  35,BFF
02A1A:  CLRF   19
02A1C:  BTFSC  FF2.7
02A1E:  BSF    19.7
02A20:  BCF    FF2.7
02A22:  MOVFF  C00,C2D
02A26:  MOVFF  35,C2C
02A2A:  CLRF   x2F
02A2C:  MOVLW  3C
02A2E:  MOVWF  x2E
02A30:  MOVLB  0
02A32:  CALL   0426
02A36:  BTFSC  19.7
02A38:  BSF    FF2.7
02A3A:  MOVF   01,W
02A3C:  MOVLB  B
02A3E:  SUBWF  xFA,F
02A40:  MOVF   02,W
02A42:  SUBWFB xFB,F
02A44:  MOVLW  00
02A46:  SUBWFB xFC,F
02A48:  SUBWFB xFD,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
02A4A:  MOVFF  BFA,34
....................    } 
....................     
....................    return &g_lTime; 
02A4E:  MOVLW  34
02A50:  MOVWF  01
02A52:  MOVLW  00
02A54:  MOVWF  02
02A56:  MOVLB  0
02A58:  GOTO   39CC (RETURN)
.................... } 
.................... #endif 
....................  
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
*
042B2:  CLRF   19
042B4:  BTFSC  FF2.7
042B6:  BSF    19.7
042B8:  BCF    FF2.7
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
042BA:  MOVLB  C
042BC:  CLRF   x2D
042BE:  MOVFF  BED,C2C
042C2:  MOVLW  03
042C4:  MOVWF  x2F
042C6:  MOVLW  E8
042C8:  MOVWF  x2E
042CA:  MOVLB  0
042CC:  CALL   0426
042D0:  BTFSC  19.7
042D2:  BSF    FF2.7
042D4:  MOVFF  02,91
042D8:  MOVFF  01,90
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
042DC:  MOVLW  01
042DE:  MOVWF  x92
042E0:  RETURN 0
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
*
00B30:  MOVLB  C
00B32:  CLRF   x0F
00B34:  CLRF   x0E
00B36:  SETF   x11
00B38:  SETF   x10
00B3A:  MOVLW  A0
00B3C:  MOVWF  x13
00B3E:  MOVLW  01
00B40:  MOVWF  x12
00B42:  CLRF   x14
00B44:  CLRF   x15
00B46:  CLRF   x16
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
00B48:  MOVF   x0D,W
00B4A:  SUBWF  x14,W
00B4C:  BNZ   0B50
.................... 		{ 
.................... 			break; 
00B4E:  BRA    0BB8
.................... 		} 
....................  
.................... 		uiByteCount++; 
00B50:  INCF   x14,F
.................... 		bShiftCount = 0; 
00B52:  CLRF   x15
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
00B54:  MOVF   x15,F
00B56:  BNZ   0B8A
.................... 			{ 
.................... 				if (1 == uiByteCount) 
00B58:  DECFSZ x14,W
00B5A:  BRA    0B76
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
00B5C:  MOVLW  01
00B5E:  SUBWF  x14,W
00B60:  ADDWF  x0B,W
00B62:  MOVWF  FE9
00B64:  MOVLW  00
00B66:  ADDWFC x0C,W
00B68:  MOVWF  FEA
00B6A:  MOVF   FEF,W
00B6C:  XORWF  x10,W
00B6E:  MOVWF  x0E
00B70:  MOVFF  C11,C0F
.................... 				} 
00B74:  BRA    0B88
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
00B76:  MOVLW  01
00B78:  SUBWF  x14,W
00B7A:  ADDWF  x0B,W
00B7C:  MOVWF  FE9
00B7E:  MOVLW  00
00B80:  ADDWFC x0C,W
00B82:  MOVWF  FEA
00B84:  MOVF   FEF,W
00B86:  XORWF  x0E,F
.................... 				} 
.................... 			} 
00B88:  BRA    0B92
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
00B8A:  MOVF   x12,W
00B8C:  XORWF  x0E,F
00B8E:  MOVF   x13,W
00B90:  XORWF  x0F,F
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
00B92:  MOVLB  C
00B94:  INCF   x15,F
....................  
.................... 			if (bShiftCount > 8) 
00B96:  MOVF   x15,W
00B98:  SUBLW  08
00B9A:  BC    0B9E
.................... 			{ 
.................... 				break; 
00B9C:  BRA    0BB6
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
00B9E:  MOVF   x0E,W
00BA0:  ANDLW  01
00BA2:  MOVWF  x16
....................  
.................... 			uiCRC = uiCRC >> 1; 
00BA4:  BCF    FD8.0
00BA6:  RRCF   x0F,F
00BA8:  RRCF   x0E,F
....................  
.................... 			if (1 == bShiftCarry) 
00BAA:  DECFSZ x16,W
00BAC:  BRA    0BB2
.................... 			{ 
.................... 				continue; 
00BAE:  BRA    0B54
.................... 			} 
00BB0:  BRA    0BB4
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
00BB2:  BRA    0B92
.................... 			} 
00BB4:  BRA    0B54
.................... 		} 
00BB6:  BRA    0B48
.................... 	} 
....................  
.................... 	return uiCRC; 
00BB8:  MOVFF  C0E,01
00BBC:  MOVFF  C0F,02
00BC0:  MOVLB  0
00BC2:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
.................... #include "vmCircularQ.h" 
.................... /*  
....................  * File:   vmCircularQ.h 
....................  * Author: AmitDP 
....................  * 
....................  * Created on February 26, 2020, 2:17 PM 
....................  */ 
....................  
.................... #ifndef VM_CIRCULAR_Q_H 
.................... #define	VM_CIRCULAR_Q_H 
....................  
....................  
.................... #define SIZE_RCV_QUEUE 200 
....................  
.................... typedef struct _ST_RCV_QUEUE 
.................... { 
....................     int8 m_ui8QArr[SIZE_RCV_QUEUE]; 
....................     int8 m_ui8Front; 
....................     int8 m_ui8Rear; 
.................... } ST_RCV_QUEUE; 
....................  
.................... ST_RCV_QUEUE g_stRcvQueue; 
.................... unsigned int8 g_ui8ElementInQ = 0; 
....................  
.................... void InitializeRcvQ() 
.................... { 
....................     memset(g_stRcvQueue.m_ui8QArr, SIZE_RCV_QUEUE, 0); 
*
009D8:  MOVLW  01
009DA:  MOVWF  FEA
009DC:  MOVLW  09
009DE:  MOVWF  FE9
009E0:  MOVLW  C8
009E2:  MOVWF  00
009E4:  CLRF   02
009E6:  CLRF   01
009E8:  RCALL  09BE
....................     g_stRcvQueue.m_ui8Front = -1; 
009EA:  MOVLB  1
009EC:  SETF   xD1
....................     g_stRcvQueue.m_ui8Rear  = -1; 
009EE:  SETF   xD2
009F0:  MOVLB  0
009F2:  GOTO   45AC (RETURN)
.................... } 
....................  
.................... //int isFull() 
.................... //{ 
.................... //    if( (front == rear + 1) || (front == 0 && rear == SIZE_RCV_QUEUE-1)) return 1; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... //int8 items[SIZE_RCV_QUEUE]; 
.................... //int front = -1, rear =-1; 
.................... unsigned int8 ElementsInQ(void) 
*
00A26:  MOVLW  0A
00A28:  MOVLB  B
00A2A:  MOVWF  xED
.................... { 
....................     unsigned int8 ui8Retval = 10; 
....................      
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
00A2C:  MOVLB  1
00A2E:  MOVF   xD1,W
00A30:  SUBLW  FF
00A32:  BNZ   0A40
....................     { 
....................         //return = 0; 
....................         ui8Retval = 0; 
00A34:  MOVLB  B
00A36:  CLRF   xED
....................         return ui8Retval; 
00A38:  MOVFF  BED,01
00A3C:  BRA    0A66
00A3E:  MOVLB  1
....................     } 
....................      
....................      
....................     if (g_stRcvQueue.m_ui8Front > g_stRcvQueue.m_ui8Rear) 
00A40:  MOVF   xD1,W
00A42:  SUBWF  xD2,W
00A44:  BC    0A58
....................     { 
....................         //return = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
....................         ui8Retval = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
00A46:  MOVLW  C8
00A48:  BSF    FD8.0
00A4A:  SUBFWB xD1,W
00A4C:  ADDWF  xD2,W
00A4E:  ADDLW  01
00A50:  MOVLB  B
00A52:  MOVWF  xED
....................     } 
00A54:  BRA    0A62
00A56:  MOVLB  1
....................     else 
....................     { 
....................         //return = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
....................         ui8Retval = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
00A58:  MOVF   xD1,W
00A5A:  SUBWF  xD2,W
00A5C:  ADDLW  01
00A5E:  MOVLB  B
00A60:  MOVWF  xED
....................     } 
....................      
....................     return ui8Retval; 
00A62:  MOVFF  BED,01
00A66:  MOVLB  0
00A68:  GOTO   45D0 (RETURN)
.................... } 
....................  
.................... unsigned int8 IsQFull(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if( (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear + 1) || 
....................         (g_stRcvQueue.m_ui8Front == 0 && g_stRcvQueue.m_ui8Rear == SIZE_RCV_QUEUE - 1)) 
....................     { 
....................         // Queue is Full 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     }    
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int isEmpty() 
.................... //{ 
.................... //    if(front == -1) return 1; 
.................... //    return 0; 
.................... //} 
....................  
.................... unsigned int8 IsQEmpty(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if(g_stRcvQueue.m_ui8Front == -1) 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     return ui8RetVal; 
.................... } 
....................  
.................... //void enQueue(int element) 
.................... //{ 
.................... //    if(isFull()) printf("\n Queue is full!! \n"); 
.................... //    else 
.................... //    { 
.................... //        if(front == -1) front = 0; 
.................... //        rear = (rear + 1) % SIZE_RCV_QUEUE; 
.................... //        items[rear] = element; 
.................... //        printf("\n Inserted -> %d", element); 
.................... //    } 
.................... //} 
....................  
.................... void EnQueue(unsigned int8 ui8Element) 
.................... { 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = ui8Element; 
.................... } 
....................  
.................... unsigned int8 DeQueue(void) 
.................... { 
....................     unsigned int8 ui8Element = 0; 
....................     unsigned int8 ui8RetVal  = 0; 
....................      
....................     ui8RetVal = IsQEmpty(); 
....................     if(ui8RetVal) 
....................     { 
....................         ui8RetVal = 0; 
....................         //return 0; //?? 
....................     } 
....................     else 
....................     { 
....................         ui8Element = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         if (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear) 
....................         { 
....................             g_stRcvQueue.m_ui8Front = -1; 
....................             g_stRcvQueue.m_ui8Rear  = -1; 
....................         } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
....................         else 
....................         { 
....................             g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         } 
....................         //printf("\n Deleted element -> %d \n", ui8Element); 
....................         ui8RetVal = ui8Element; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int deQueue() 
.................... //{ 
.................... //    int element; 
.................... //    if(isEmpty()) { 
.................... //        printf("\n Queue is empty !! \n"); 
.................... //        return(-1); 
.................... //    } else { 
.................... //        element = items[front]; 
.................... //        if (front == rear){ 
.................... //            front = -1; 
.................... //            rear = -1; 
.................... //        } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
.................... //        else { 
.................... //            front = (front + 1) % SIZE_RCV_QUEUE; 
.................... //             
.................... //        } 
.................... //        printf("\n Deleted element -> %d \n", element); 
.................... //        return(element); 
.................... //    } 
.................... //} 
....................  
....................  
.................... #endif	/* VM_CIRCULAR_Q_H */ 
....................  
....................  
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
*
005DE:  MOVF   F98,W
.................... 	enable_interrupts(INT_RDA); 
005E0:  MOVLB  E
005E2:  BSF    x2C.5
005E4:  MOVLB  0
005E6:  GOTO   45A0 (RETURN)
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
008AA:  MOVLB  B
008AC:  CLRF   xEF
008AE:  CLRF   xF0
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
008B0:  MOVLW  C3
008B2:  ADDWF  xED,W
008B4:  MOVWF  01
008B6:  MOVLW  00
008B8:  ADDWFC xEE,W
008BA:  MOVWF  03
008BC:  MOVLW  C4
008BE:  ADDWF  xED,W
008C0:  MOVWF  FE9
008C2:  MOVLW  00
008C4:  ADDWFC xEE,W
008C6:  MOVWF  FEA
008C8:  SETF   FEF
008CA:  MOVLW  FF
008CC:  MOVFF  03,FEA
008D0:  MOVFF  01,FE9
008D4:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
008D6:  CLRF   xEF
008D8:  MOVF   xEF,W
008DA:  SUBLW  0E
008DC:  BNC   0938
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
008DE:  CLRF   xF0
008E0:  MOVF   xF0,W
008E2:  SUBLW  08
008E4:  BNC   0934
008E6:  CLRF   19
008E8:  BTFSC  FF2.7
008EA:  BSF    19.7
008EC:  BCF    FF2.7
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
008EE:  MOVLB  C
008F0:  CLRF   x2D
008F2:  MOVFF  BEF,C2C
008F6:  CLRF   x2F
008F8:  MOVLW  0D
008FA:  MOVWF  x2E
008FC:  MOVLB  0
008FE:  RCALL  0426
00900:  BTFSC  19.7
00902:  BSF    FF2.7
00904:  MOVFF  02,BF2
00908:  MOVFF  01,BF1
0090C:  MOVLW  02
0090E:  MOVLB  B
00910:  ADDWF  xF1,F
00912:  MOVLW  00
00914:  ADDWFC xF2,F
00916:  MOVF   xF0,W
00918:  ADDWF  xF1,W
0091A:  MOVWF  01
0091C:  MOVLW  00
0091E:  ADDWFC xF2,W
00920:  MOVWF  03
00922:  MOVF   01,W
00924:  ADDWF  xED,W
00926:  MOVWF  FE9
00928:  MOVF   xEE,W
0092A:  ADDWFC 03,W
0092C:  MOVWF  FEA
0092E:  CLRF   FEF
00930:  INCF   xF0,F
00932:  BRA    08E0
....................         } 
00934:  INCF   xEF,F
00936:  BRA    08D8
....................     } 
00938:  MOVLB  0
0093A:  RETURN 0
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
*
00BC4:  MOVLB  C
00BC6:  CLRF   x05
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
00BC8:  CLRF   x05
00BCA:  MOVF   x05,W
00BCC:  SUBLW  08
00BCE:  BNC   0C00
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
00BD0:  MOVLW  02
00BD2:  ADDWF  x05,W
00BD4:  ADDWF  x03,W
00BD6:  MOVWF  01
00BD8:  MOVLW  00
00BDA:  ADDWFC x04,W
00BDC:  MOVWF  03
00BDE:  MOVLW  02
00BE0:  ADDWF  x05,W
00BE2:  ADDWF  x01,W
00BE4:  MOVWF  FE9
00BE6:  MOVLW  00
00BE8:  ADDWFC x02,W
00BEA:  MOVWF  FEA
00BEC:  MOVFF  FEF,C08
00BF0:  MOVFF  03,FEA
00BF4:  MOVFF  01,FE9
00BF8:  MOVFF  C08,FEF
00BFC:  INCF   x05,F
00BFE:  BRA    0BCA
....................     } 
00C00:  MOVLB  0
00C02:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
00C04:  MOVLB  B
00C06:  MOVF   xFA,W
00C08:  IORWF  xFB,W
00C0A:  BNZ   0C0E
....................     { 
....................         return; 
00C0C:  BRA    0DD6
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
00C0E:  MOVLW  C3
00C10:  ADDWF  xF8,W
00C12:  MOVWF  FE9
00C14:  MOVLW  00
00C16:  ADDWFC xF9,W
00C18:  MOVWF  FEA
00C1A:  MOVF   FEF,F
00C1C:  BNZ   0C30
00C1E:  MOVLW  C4
00C20:  ADDWF  xF8,W
00C22:  MOVWF  FE9
00C24:  MOVLW  00
00C26:  ADDWFC xF9,W
00C28:  MOVWF  FEA
00C2A:  MOVF   FEF,W
00C2C:  SUBLW  0E
00C2E:  BZ    0C54
00C30:  MOVLW  C4
00C32:  ADDWF  xF8,W
00C34:  MOVWF  FE9
00C36:  MOVLW  00
00C38:  ADDWFC xF9,W
00C3A:  MOVWF  FEA
00C3C:  MOVFF  FEF,BFC
00C40:  MOVLW  C3
00C42:  ADDWF  xF8,W
00C44:  MOVWF  FE9
00C46:  MOVLW  00
00C48:  ADDWFC xF9,W
00C4A:  MOVWF  FEA
00C4C:  MOVLW  01
00C4E:  SUBWF  FEF,W
00C50:  SUBWF  xFC,W
00C52:  BNZ   0C58
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
00C54:  BRA    0DD6
....................     }     
00C56:  BRA    0DD6
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
00C58:  MOVLW  C3
00C5A:  ADDWF  xF8,W
00C5C:  MOVWF  FE9
00C5E:  MOVLW  00
00C60:  ADDWFC xF9,W
00C62:  MOVWF  FEA
00C64:  MOVF   FEF,W
00C66:  SUBLW  FF
00C68:  BNZ   0CE2
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
00C6A:  MOVLW  C3
00C6C:  ADDWF  xF8,W
00C6E:  MOVWF  FE9
00C70:  MOVLW  00
00C72:  ADDWFC xF9,W
00C74:  MOVWF  FEA
00C76:  CLRF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
00C78:  MOVLW  C4
00C7A:  ADDWF  xF8,W
00C7C:  MOVWF  FE9
00C7E:  MOVLW  00
00C80:  ADDWFC xF9,W
00C82:  MOVWF  FEA
00C84:  CLRF   FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00C86:  MOVLW  C4
00C88:  ADDWF  xF8,W
00C8A:  MOVWF  FE9
00C8C:  MOVLW  00
00C8E:  ADDWFC xF9,W
00C90:  MOVWF  FEA
00C92:  CLRF   19
00C94:  BTFSC  FF2.7
00C96:  BSF    19.7
00C98:  BCF    FF2.7
00C9A:  MOVLB  C
00C9C:  CLRF   x2D
00C9E:  MOVFF  FEF,C2C
00CA2:  CLRF   x2F
00CA4:  MOVLW  0D
00CA6:  MOVWF  x2E
00CA8:  MOVLB  0
00CAA:  CALL   0426
00CAE:  BTFSC  19.7
00CB0:  BSF    FF2.7
00CB2:  MOVFF  02,03
00CB6:  MOVF   01,W
00CB8:  MOVLB  B
00CBA:  ADDWF  xF8,W
00CBC:  MOVWF  01
00CBE:  MOVF   xF9,W
00CC0:  ADDWFC 03,F
00CC2:  MOVFF  01,BFC
00CC6:  MOVFF  03,BFD
00CCA:  MOVFF  BFB,C02
00CCE:  MOVFF  BFA,C01
00CD2:  MOVFF  03,C04
00CD6:  MOVFF  01,C03
00CDA:  MOVLB  0
00CDC:  RCALL  0BC4
....................     }  
00CDE:  BRA    0DD4
00CE0:  MOVLB  B
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
00CE2:  MOVLW  C4
00CE4:  ADDWF  xF8,W
00CE6:  MOVWF  FE9
00CE8:  MOVLW  00
00CEA:  ADDWFC xF9,W
00CEC:  MOVWF  FEA
00CEE:  MOVF   FEF,W
00CF0:  SUBLW  0E
00CF2:  BNZ   0D6E
00CF4:  MOVLW  C3
00CF6:  ADDWF  xF8,W
00CF8:  MOVWF  FE9
00CFA:  MOVLW  00
00CFC:  ADDWFC xF9,W
00CFE:  MOVWF  FEA
00D00:  MOVF   FEF,F
00D02:  BZ    0D6E
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
00D04:  MOVLW  C4
00D06:  ADDWF  xF8,W
00D08:  MOVWF  FE9
00D0A:  MOVLW  00
00D0C:  ADDWFC xF9,W
00D0E:  MOVWF  FEA
00D10:  CLRF   FEF
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00D12:  MOVLW  C4
00D14:  ADDWF  xF8,W
00D16:  MOVWF  FE9
00D18:  MOVLW  00
00D1A:  ADDWFC xF9,W
00D1C:  MOVWF  FEA
00D1E:  CLRF   19
00D20:  BTFSC  FF2.7
00D22:  BSF    19.7
00D24:  BCF    FF2.7
00D26:  MOVLB  C
00D28:  CLRF   x2D
00D2A:  MOVFF  FEF,C2C
00D2E:  CLRF   x2F
00D30:  MOVLW  0D
00D32:  MOVWF  x2E
00D34:  MOVLB  0
00D36:  CALL   0426
00D3A:  BTFSC  19.7
00D3C:  BSF    FF2.7
00D3E:  MOVFF  02,03
00D42:  MOVF   01,W
00D44:  MOVLB  B
00D46:  ADDWF  xF8,W
00D48:  MOVWF  01
00D4A:  MOVF   xF9,W
00D4C:  ADDWFC 03,F
00D4E:  MOVFF  01,BFC
00D52:  MOVFF  03,BFD
00D56:  MOVFF  BFB,C02
00D5A:  MOVFF  BFA,C01
00D5E:  MOVFF  03,C04
00D62:  MOVFF  01,C03
00D66:  MOVLB  0
00D68:  RCALL  0BC4
....................     }  
00D6A:  BRA    0DD4
00D6C:  MOVLB  B
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
00D6E:  MOVLW  C4
00D70:  ADDWF  xF8,W
00D72:  MOVWF  FE9
00D74:  MOVLW  00
00D76:  ADDWFC xF9,W
00D78:  MOVWF  FEA
00D7A:  INCF   FEF,F
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00D7C:  MOVLW  C4
00D7E:  ADDWF  xF8,W
00D80:  MOVWF  FE9
00D82:  MOVLW  00
00D84:  ADDWFC xF9,W
00D86:  MOVWF  FEA
00D88:  CLRF   19
00D8A:  BTFSC  FF2.7
00D8C:  BSF    19.7
00D8E:  BCF    FF2.7
00D90:  MOVLB  C
00D92:  CLRF   x2D
00D94:  MOVFF  FEF,C2C
00D98:  CLRF   x2F
00D9A:  MOVLW  0D
00D9C:  MOVWF  x2E
00D9E:  MOVLB  0
00DA0:  CALL   0426
00DA4:  BTFSC  19.7
00DA6:  BSF    FF2.7
00DA8:  MOVFF  02,03
00DAC:  MOVF   01,W
00DAE:  MOVLB  B
00DB0:  ADDWF  xF8,W
00DB2:  MOVWF  01
00DB4:  MOVF   xF9,W
00DB6:  ADDWFC 03,F
00DB8:  MOVFF  01,BFC
00DBC:  MOVFF  03,BFD
00DC0:  MOVFF  BFB,C02
00DC4:  MOVFF  BFA,C01
00DC8:  MOVFF  03,C04
00DCC:  MOVFF  01,C03
00DD0:  MOVLB  0
00DD2:  RCALL  0BC4
00DD4:  MOVLB  B
....................     } 
00DD6:  MOVLB  0
00DD8:  RETURN 0
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
0113E:  MOVLW  C3
01140:  MOVLB  B
01142:  ADDWF  xFB,W
01144:  MOVWF  FE9
01146:  MOVLW  00
01148:  ADDWFC xFC,W
0114A:  MOVWF  FEA
0114C:  MOVF   FEF,W
0114E:  SUBLW  FF
01150:  BNZ   1154
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
01152:  BRA    121E
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
01154:  MOVLW  C3
01156:  ADDWF  xFB,W
01158:  MOVWF  FE9
0115A:  MOVLW  00
0115C:  ADDWFC xFC,W
0115E:  MOVWF  FEA
01160:  CLRF   19
01162:  BTFSC  FF2.7
01164:  BSF    19.7
01166:  BCF    FF2.7
01168:  MOVLB  C
0116A:  CLRF   x2D
0116C:  MOVFF  FEF,C2C
01170:  CLRF   x2F
01172:  MOVLW  0D
01174:  MOVWF  x2E
01176:  MOVLB  0
01178:  CALL   0426
0117C:  BTFSC  19.7
0117E:  BSF    FF2.7
01180:  MOVFF  02,03
01184:  MOVF   01,W
01186:  MOVLB  B
01188:  ADDWF  xFB,W
0118A:  MOVWF  01
0118C:  MOVF   xFC,W
0118E:  ADDWFC 03,F
01190:  MOVFF  01,BFF
01194:  MOVFF  03,C00
01198:  MOVFF  03,C02
0119C:  MOVFF  01,C01
011A0:  MOVFF  BFE,C04
011A4:  MOVFF  BFD,C03
011A8:  MOVLB  0
011AA:  RCALL  0BC4
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
011AC:  MOVLW  C3
011AE:  MOVLB  B
011B0:  ADDWF  xFB,W
011B2:  MOVWF  FE9
011B4:  MOVLW  00
011B6:  ADDWFC xFC,W
011B8:  MOVWF  FEA
011BA:  MOVFF  FEF,BFF
011BE:  MOVLW  C4
011C0:  ADDWF  xFB,W
011C2:  MOVWF  FE9
011C4:  MOVLW  00
011C6:  ADDWFC xFC,W
011C8:  MOVWF  FEA
011CA:  MOVF   FEF,W
011CC:  SUBWF  xFF,W
011CE:  BNZ   11EE
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
011D0:  MOVLW  C3
011D2:  ADDWF  xFB,W
011D4:  MOVWF  FE9
011D6:  MOVLW  00
011D8:  ADDWFC xFC,W
011DA:  MOVWF  FEA
011DC:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
011DE:  MOVLW  C4
011E0:  ADDWF  xFB,W
011E2:  MOVWF  FE9
011E4:  MOVLW  00
011E6:  ADDWFC xFC,W
011E8:  MOVWF  FEA
011EA:  SETF   FEF
....................     }  
011EC:  BRA    121E
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
011EE:  MOVLW  C3
011F0:  ADDWF  xFB,W
011F2:  MOVWF  FE9
011F4:  MOVLW  00
011F6:  ADDWFC xFC,W
011F8:  MOVWF  FEA
011FA:  MOVF   FEF,W
011FC:  SUBLW  0E
011FE:  BNZ   1210
....................         pstIBUMSGQueue->m_i8Front = 0;  
01200:  MOVLW  C3
01202:  ADDWF  xFB,W
01204:  MOVWF  FE9
01206:  MOVLW  00
01208:  ADDWFC xFC,W
0120A:  MOVWF  FEA
0120C:  CLRF   FEF
0120E:  BRA    121E
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
01210:  MOVLW  C3
01212:  ADDWF  xFB,W
01214:  MOVWF  FE9
01216:  MOVLW  00
01218:  ADDWFC xFC,W
0121A:  MOVWF  FEA
0121C:  INCF   FEF,F
....................    
....................     return; 
0121E:  MOVLB  0
01220:  GOTO   1388 (RETURN)
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
015DC:  MOVLW  C3
015DE:  MOVLB  B
015E0:  ADDWF  xEE,W
015E2:  MOVWF  FE9
015E4:  MOVLW  00
015E6:  ADDWFC xEF,W
015E8:  MOVWF  FEA
015EA:  MOVF   FEF,W
015EC:  SUBLW  FF
015EE:  BNZ   15F2
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
015F0:  BRA    164E
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
015F2:  MOVLW  C3
015F4:  ADDWF  xEE,W
015F6:  MOVWF  FE9
015F8:  MOVLW  00
015FA:  ADDWFC xEF,W
015FC:  MOVWF  FEA
015FE:  CLRF   19
01600:  BTFSC  FF2.7
01602:  BSF    19.7
01604:  BCF    FF2.7
01606:  MOVLB  C
01608:  CLRF   x2D
0160A:  MOVFF  FEF,C2C
0160E:  CLRF   x2F
01610:  MOVLW  0D
01612:  MOVWF  x2E
01614:  MOVLB  0
01616:  CALL   0426
0161A:  BTFSC  19.7
0161C:  BSF    FF2.7
0161E:  MOVFF  02,03
01622:  MOVF   01,W
01624:  MOVLB  B
01626:  ADDWF  xEE,W
01628:  MOVWF  01
0162A:  MOVF   xEF,W
0162C:  ADDWFC 03,F
0162E:  MOVFF  01,BF2
01632:  MOVFF  03,BF3
01636:  MOVFF  03,C02
0163A:  MOVFF  01,C01
0163E:  MOVFF  BF1,C04
01642:  MOVFF  BF0,C03
01646:  MOVLB  0
01648:  CALL   0BC4
0164C:  MOVLB  B
0164E:  MOVLB  0
01650:  GOTO   16AE (RETURN)
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
00A6C:  MOVLW  C3
00A6E:  MOVLB  B
00A70:  ADDWF  xF2,W
00A72:  MOVWF  FE9
00A74:  MOVLW  00
00A76:  ADDWFC xF3,W
00A78:  MOVWF  FEA
00A7A:  MOVF   FEF,W
00A7C:  SUBLW  FF
00A7E:  BNZ   0A82
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
00A80:  BRA    0AF2
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
00A82:  MOVLW  C3
00A84:  ADDWF  xF2,W
00A86:  MOVWF  FE9
00A88:  MOVLW  00
00A8A:  ADDWFC xF3,W
00A8C:  MOVWF  FEA
00A8E:  MOVFF  FEF,BF4
00A92:  MOVLW  C4
00A94:  ADDWF  xF2,W
00A96:  MOVWF  FE9
00A98:  MOVLW  00
00A9A:  ADDWFC xF3,W
00A9C:  MOVWF  FEA
00A9E:  MOVF   FEF,W
00AA0:  SUBWF  xF4,W
00AA2:  BNZ   0AC2
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
00AA4:  MOVLW  C3
00AA6:  ADDWF  xF2,W
00AA8:  MOVWF  FE9
00AAA:  MOVLW  00
00AAC:  ADDWFC xF3,W
00AAE:  MOVWF  FEA
00AB0:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
00AB2:  MOVLW  C4
00AB4:  ADDWF  xF2,W
00AB6:  MOVWF  FE9
00AB8:  MOVLW  00
00ABA:  ADDWFC xF3,W
00ABC:  MOVWF  FEA
00ABE:  SETF   FEF
....................     }  
00AC0:  BRA    0AF2
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
00AC2:  MOVLW  C3
00AC4:  ADDWF  xF2,W
00AC6:  MOVWF  FE9
00AC8:  MOVLW  00
00ACA:  ADDWFC xF3,W
00ACC:  MOVWF  FEA
00ACE:  MOVF   FEF,W
00AD0:  SUBLW  0E
00AD2:  BNZ   0AE4
....................         pstIBUMSGQueue->m_i8Front = 0;  
00AD4:  MOVLW  C3
00AD6:  ADDWF  xF2,W
00AD8:  MOVWF  FE9
00ADA:  MOVLW  00
00ADC:  ADDWFC xF3,W
00ADE:  MOVWF  FEA
00AE0:  CLRF   FEF
00AE2:  BRA    0AF2
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
00AE4:  MOVLW  C3
00AE6:  ADDWF  xF2,W
00AE8:  MOVWF  FE9
00AEA:  MOVLW  00
00AEC:  ADDWFC xF3,W
00AEE:  MOVWF  FEA
00AF0:  INCF   FEF,F
00AF2:  MOVLB  0
00AF4:  RETURN 0
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
01118:  MOVLB  B
0111A:  CLRF   xEF
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
0111C:  MOVLW  C3
0111E:  ADDWF  xED,W
01120:  MOVWF  FE9
01122:  MOVLW  00
01124:  ADDWFC xEE,W
01126:  MOVWF  FEA
01128:  MOVF   FEF,W
0112A:  SUBLW  FF
0112C:  BNZ   1132
....................     { 
....................         ui8RetVal = 0; 
0112E:  CLRF   xEF
....................     } 
01130:  BRA    1136
....................     else 
....................     { 
....................         ui8RetVal = 1; 
01132:  MOVLW  01
01134:  MOVWF  xEF
....................     } 
....................      
....................     return ui8RetVal; 
01136:  MOVFF  BEF,01
0113A:  MOVLB  0
0113C:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
*
01654:  MOVLB  B
01656:  CLRF   xED
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
01658:  MOVLB  4
0165A:  MOVF   x3D,W
0165C:  SUBLW  09
0165E:  BC    167A
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
01660:  CLRF   x3D
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
01662:  MOVLW  02
01664:  MOVLB  B
01666:  MOVWF  xF3
01668:  MOVLW  90
0166A:  MOVWF  xF2
0166C:  MOVLB  0
0166E:  CALL   0A6C
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
01672:  MOVLB  2
01674:  CLRF   x8F
....................         return; 
01676:  BRA    177A
01678:  MOVLB  4
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
0167A:  INCF   x3D,F
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
0167C:  MOVLB  B
0167E:  CLRF   xED
01680:  MOVF   xED,W
01682:  SUBLW  08
01684:  BNC   169A
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
01686:  CLRF   03
01688:  MOVF   xED,W
0168A:  ADDLW  FC
0168C:  MOVWF  FE9
0168E:  MOVLW  01
01690:  ADDWFC 03,W
01692:  MOVWF  FEA
01694:  CLRF   FEF
01696:  INCF   xED,F
01698:  BRA    1680
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0169A:  MOVLW  02
0169C:  MOVWF  xEF
0169E:  MOVLW  90
016A0:  MOVWF  xEE
016A2:  MOVLW  01
016A4:  MOVWF  xF1
016A6:  MOVLW  FA
016A8:  MOVWF  xF0
016AA:  MOVLB  0
016AC:  BRA    15DC
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
016AE:  MOVLB  4
016B0:  DECFSZ x3D,W
016B2:  BRA    16BE
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
016B4:  INCFSZ x2D,W
016B6:  BRA    16BC
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
016B8:  CLRF   x2D
....................         } 
016BA:  BRA    16BE
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
016BC:  INCF   x2D,F
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
016BE:  MOVFF  42D,1FA
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
016C2:  MOVFF  42D,42E
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
016C6:  MOVLW  21
016C8:  MOVWF  x2F
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
016CA:  MOVFF  1FC,430
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
016CE:  MOVFF  1FD,431
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
016D2:  MOVFF  1FE,432
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
016D6:  MOVFF  1FF,433
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
016DA:  MOVFF  200,434
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
016DE:  MOVFF  201,435
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
016E2:  MOVFF  202,436
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
016E6:  MOVFF  203,437
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
016EA:  MOVFF  204,438
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
016EE:  MOVLW  04
016F0:  MOVLB  C
016F2:  MOVWF  x0C
016F4:  MOVLW  2E
016F6:  MOVWF  x0B
016F8:  MOVLW  0B
016FA:  MOVWF  x0D
016FC:  MOVLB  0
016FE:  CALL   0B30
01702:  MOVFF  02,43C
01706:  MOVFF  01,43B
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
0170A:  MOVFF  43C,BEF
0170E:  MOVFF  43B,439
01712:  MOVLB  4
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
01714:  MOVFF  43C,43A
01718:  MOVLB  4
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
0171A:  MOVLW  A5
0171C:  MOVLB  0
0171E:  CALL   0DDA
....................     fputc(STX, UART); 
01722:  MOVLW  A5
01724:  CALL   0DDA
....................     fputc(STX, UART); 
01728:  MOVLW  A5
0172A:  CALL   0DDA
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
0172E:  MOVLB  B
01730:  CLRF   xED
01732:  MOVF   xED,W
01734:  SUBLW  0C
01736:  BNC   1758
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
01738:  CLRF   03
0173A:  MOVF   xED,W
0173C:  ADDLW  2E
0173E:  MOVWF  FE9
01740:  MOVLW  04
01742:  ADDWFC 03,W
01744:  MOVWF  FEA
01746:  MOVFF  FEF,BEE
0174A:  MOVF   xEE,W
0174C:  MOVLB  0
0174E:  CALL   0DDA
01752:  MOVLB  B
01754:  INCF   xED,F
01756:  BRA    1732
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
01758:  MOVLW  B5
0175A:  MOVLB  0
0175C:  CALL   0DDA
....................     fputc(ETX, UART); 
01760:  MOVLW  B5
01762:  CALL   0DDA
....................     delay_us(5); 
01766:  CLRWDT
01768:  MOVLW  07
0176A:  MOVWF  00
0176C:  DECFSZ 00,F
0176E:  BRA    176C
01770:  BRA    1772
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
01772:  MOVLW  01
01774:  MOVLB  4
01776:  MOVWF  x1D
01778:  MOVLB  2
0177A:  MOVLB  0
0177C:  GOTO   4626 (RETURN)
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
*
00AF6:  MOVLB  B
00AF8:  MOVF   xF1,W
00AFA:  MOVLB  4
00AFC:  SUBWF  x2D,W
00AFE:  BNZ   0B20
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
00B00:  MOVLW  02
00B02:  MOVLB  B
00B04:  MOVWF  xF3
00B06:  MOVLW  90
00B08:  MOVWF  xF2
00B0A:  MOVLB  0
00B0C:  RCALL  0A6C
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
00B0E:  MOVLB  4
00B10:  CLRF   x3D
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00B12:  CLRF   x1D
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00B14:  CLRF   x1F
00B16:  CLRF   x1E
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00B18:  MOVLB  2
00B1A:  CLRF   x8F
....................     } 
00B1C:  BRA    0B2A
00B1E:  MOVLB  4
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00B20:  CLRF   x1D
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00B22:  CLRF   x1F
00B24:  CLRF   x1E
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00B26:  MOVLB  2
00B28:  CLRF   x8F
....................     } 
00B2A:  MOVLB  0
00B2C:  GOTO   103A (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
*
00DE6:  MOVFF  1D1,BED
00DEA:  MOVLB  B
00DEC:  CLRF   xEE
00DEE:  MOVFF  1D1,BEF
00DF2:  CLRF   xF0
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
00DF4:  MOVFF  1D1,4A4
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
00DF8:  MOVFF  1D2,4A5
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
00DFC:  MOVLB  4
00DFE:  CLRF   xA7
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
00E00:  CLRF   xA6
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
00E02:  MOVLB  1
00E04:  MOVF   xD3,F
00E06:  BZ    0E70
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00E08:  MOVLW  01
00E0A:  ADDWF  xD1,W
00E0C:  MOVLB  B
00E0E:  MOVWF  xF2
00E10:  CLRF   19
00E12:  BTFSC  FF2.7
00E14:  BSF    19.7
00E16:  BCF    FF2.7
00E18:  MOVFF  FE8,C33
00E1C:  MOVLW  C8
00E1E:  MOVLB  C
00E20:  MOVWF  x34
00E22:  MOVLB  0
00E24:  CALL   0182
00E28:  BTFSC  19.7
00E2A:  BSF    FF2.7
00E2C:  MOVFF  00,BEF
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
00E30:  CLRF   03
00E32:  MOVLB  1
00E34:  MOVF   xD1,W
00E36:  ADDLW  09
00E38:  MOVWF  FE9
00E3A:  MOVLW  01
00E3C:  ADDWFC 03,W
00E3E:  MOVWF  FEA
00E40:  MOVF   FEF,W
00E42:  SUBLW  A5
00E44:  BNZ   0E68
00E46:  CLRF   03
00E48:  MOVLB  B
00E4A:  MOVF   xEF,W
00E4C:  ADDLW  09
00E4E:  MOVWF  FE9
00E50:  MOVLW  01
00E52:  ADDWFC 03,W
00E54:  MOVWF  FEA
00E56:  MOVF   FEF,W
00E58:  SUBLW  A5
00E5A:  BTFSC  FD8.2
00E5C:  BRA    0E62
00E5E:  MOVLB  1
00E60:  BRA    0E68
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
00E62:  MOVLB  1
00E64:  BRA    0E70
....................         } 
00E66:  BRA    0E6E
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
00E68:  MOVFF  BEF,1D1
....................             g_ui8ElementInQ--; 
00E6C:  DECF   xD3,F
....................         } 
00E6E:  BRA    0E04
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
00E70:  MOVF   xD3,F
00E72:  BNZ   0E76
....................     { 
....................         // The message exhausted 
....................         return; 
00E74:  BRA    1112
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
00E76:  MOVF   xD3,W
00E78:  SUBLW  0D
00E7A:  BC    0F0C
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
00E7C:  MOVLW  0E
00E7E:  ADDWF  xD1,W
00E80:  MOVLB  B
00E82:  MOVWF  xF2
00E84:  CLRF   19
00E86:  BTFSC  FF2.7
00E88:  BSF    19.7
00E8A:  BCF    FF2.7
00E8C:  MOVFF  FE8,C33
00E90:  MOVLW  C8
00E92:  MOVLB  C
00E94:  MOVWF  x34
00E96:  MOVLB  0
00E98:  CALL   0182
00E9C:  BTFSC  19.7
00E9E:  BSF    FF2.7
00EA0:  MOVFF  00,BF0
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00EA4:  CLRF   03
00EA6:  MOVLB  1
00EA8:  MOVF   xD1,W
00EAA:  ADDLW  09
00EAC:  MOVWF  FE9
00EAE:  MOVLW  01
00EB0:  ADDWFC 03,W
00EB2:  MOVWF  FEA
00EB4:  MOVF   FEF,W
00EB6:  SUBLW  A5
00EB8:  BNZ   0F08
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
00EBA:  CLRF   03
00EBC:  MOVLB  B
00EBE:  MOVF   xF0,W
00EC0:  ADDLW  09
00EC2:  MOVWF  FE9
00EC4:  MOVLW  01
00EC6:  ADDWFC 03,W
00EC8:  MOVWF  FEA
00ECA:  MOVF   FEF,W
00ECC:  SUBLW  B5
00ECE:  BNZ   0ED8
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
00ED0:  MOVLB  1
00ED2:  BRA    0F0C
....................             } 
00ED4:  BRA    0F06
00ED6:  MOVLB  B
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00ED8:  MOVLW  01
00EDA:  MOVLB  1
00EDC:  ADDWF  xD1,W
00EDE:  MOVLB  B
00EE0:  MOVWF  xF2
00EE2:  CLRF   19
00EE4:  BTFSC  FF2.7
00EE6:  BSF    19.7
00EE8:  BCF    FF2.7
00EEA:  MOVFF  FE8,C33
00EEE:  MOVLW  C8
00EF0:  MOVLB  C
00EF2:  MOVWF  x34
00EF4:  MOVLB  0
00EF6:  CALL   0182
00EFA:  BTFSC  19.7
00EFC:  BSF    FF2.7
00EFE:  MOVFF  00,1D1
....................                 g_ui8ElementInQ--; 
00F02:  MOVLB  1
00F04:  DECF   xD3,F
....................             } 
....................         } 
00F06:  BRA    0F0A
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
00F08:  BRA    1112
....................         } 
00F0A:  BRA    0E76
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F0C:  MOVLW  01
00F0E:  ADDWF  xD1,W
00F10:  MOVLB  B
00F12:  MOVWF  xF2
00F14:  CLRF   19
00F16:  BTFSC  FF2.7
00F18:  BSF    19.7
00F1A:  BCF    FF2.7
00F1C:  MOVFF  FE8,C33
00F20:  MOVLW  C8
00F22:  MOVLB  C
00F24:  MOVWF  x34
00F26:  MOVLB  0
00F28:  CALL   0182
00F2C:  BTFSC  19.7
00F2E:  BSF    FF2.7
00F30:  MOVFF  00,1D1
....................     g_ui8ElementInQ--; 
00F34:  MOVLB  1
00F36:  DECF   xD3,F
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
00F38:  MOVLB  B
00F3A:  CLRF   xEE
00F3C:  MOVF   xEE,W
00F3E:  SUBLW  0C
00F40:  BNC   0FA8
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
00F42:  CLRF   03
00F44:  MOVF   xEE,W
00F46:  ADDLW  20
00F48:  MOVWF  01
00F4A:  MOVLW  04
00F4C:  ADDWFC 03,F
00F4E:  MOVFF  03,BF2
00F52:  CLRF   03
00F54:  MOVLB  1
00F56:  MOVF   xD1,W
00F58:  ADDLW  09
00F5A:  MOVWF  FE9
00F5C:  MOVLW  01
00F5E:  ADDWFC 03,W
00F60:  MOVWF  FEA
00F62:  MOVFF  FEF,BF3
00F66:  MOVLB  B
00F68:  MOVFF  BF2,FEA
00F6C:  MOVFF  01,FE9
00F70:  MOVFF  BF3,FEF
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F74:  MOVLW  01
00F76:  MOVLB  1
00F78:  ADDWF  xD1,W
00F7A:  MOVLB  B
00F7C:  MOVWF  xF2
00F7E:  CLRF   19
00F80:  BTFSC  FF2.7
00F82:  BSF    19.7
00F84:  BCF    FF2.7
00F86:  MOVFF  FE8,C33
00F8A:  MOVLW  C8
00F8C:  MOVLB  C
00F8E:  MOVWF  x34
00F90:  MOVLB  0
00F92:  CALL   0182
00F96:  BTFSC  19.7
00F98:  BSF    FF2.7
00F9A:  MOVFF  00,1D1
....................         g_ui8ElementInQ--; 
00F9E:  MOVLB  1
00FA0:  DECF   xD3,F
00FA2:  MOVLB  B
00FA4:  INCF   xEE,F
00FA6:  BRA    0F3C
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
00FA8:  MOVLB  1
00FAA:  MOVF   xD3,F
00FAC:  BZ    0FF2
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00FAE:  CLRF   03
00FB0:  MOVF   xD1,W
00FB2:  ADDLW  09
00FB4:  MOVWF  FE9
00FB6:  MOVLW  01
00FB8:  ADDWFC 03,W
00FBA:  MOVWF  FEA
00FBC:  MOVF   FEF,W
00FBE:  SUBLW  A5
00FC0:  BNZ   0FC4
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
00FC2:  BRA    0FF2
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00FC4:  MOVLW  01
00FC6:  ADDWF  xD1,W
00FC8:  MOVLB  B
00FCA:  MOVWF  xF2
00FCC:  CLRF   19
00FCE:  BTFSC  FF2.7
00FD0:  BSF    19.7
00FD2:  BCF    FF2.7
00FD4:  MOVFF  FE8,C33
00FD8:  MOVLW  C8
00FDA:  MOVLB  C
00FDC:  MOVWF  x34
00FDE:  MOVLB  0
00FE0:  CALL   0182
00FE4:  BTFSC  19.7
00FE6:  BSF    FF2.7
00FE8:  MOVFF  00,1D1
....................         g_ui8ElementInQ--; 
00FEC:  MOVLB  1
00FEE:  DECF   xD3,F
00FF0:  BRA    0FAA
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
00FF2:  MOVLW  01
00FF4:  ADDWF  xD2,W
00FF6:  MOVLB  B
00FF8:  MOVWF  xF2
00FFA:  CLRF   19
00FFC:  BTFSC  FF2.7
00FFE:  BSF    19.7
01000:  BCF    FF2.7
01002:  MOVFF  FE8,C33
01006:  MOVLW  C8
01008:  MOVLB  C
0100A:  MOVWF  x34
0100C:  MOVLB  0
0100E:  CALL   0182
01012:  BTFSC  19.7
01014:  BSF    FF2.7
01016:  MOVFF  00,BEF
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
0101A:  MOVLB  B
0101C:  MOVF   xEF,W
0101E:  MOVLB  1
01020:  SUBWF  xD1,W
01022:  BNZ   102A
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
01024:  SETF   xD2
01026:  MOVFF  1D2,1D1
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
0102A:  MOVLB  4
0102C:  MOVF   x21,W
0102E:  SUBLW  2C
01030:  BNZ   1040
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
01032:  MOVFF  420,BF1
01036:  MOVLB  0
01038:  BRA    0AF6
....................         return; 
0103A:  MOVLB  1
0103C:  BRA    1112
0103E:  MOVLB  4
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
01040:  MOVF   x21,W
01042:  SUBLW  21
01044:  BNZ   1110
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
01046:  MOVLW  04
01048:  MOVLB  C
0104A:  MOVWF  x0C
0104C:  MOVLW  20
0104E:  MOVWF  x0B
01050:  MOVLW  0B
01052:  MOVWF  x0D
01054:  MOVLB  0
01056:  RCALL  0B30
01058:  MOVFF  02,43C
0105C:  MOVFF  01,43B
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
01060:  MOVFF  43C,BF1
01064:  MOVLB  B
01066:  CLRF   xF2
01068:  MOVLB  4
0106A:  MOVF   x2C,W
0106C:  MOVLB  B
0106E:  SUBWF  xF1,W
01070:  BNZ   110E
01072:  MOVF   xF2,F
01074:  BNZ   110E
01076:  MOVFF  43C,BF2
0107A:  MOVFF  43B,BF1
0107E:  CLRF   xF2
01080:  MOVLB  4
01082:  MOVF   x2B,W
01084:  MOVLB  B
01086:  SUBWF  xF1,W
01088:  BNZ   110E
0108A:  MOVF   xF2,F
0108C:  BNZ   110E
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
0108E:  MOVFF  422,1EF
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
01092:  MOVFF  423,1F0
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
01096:  MOVFF  424,1F1
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
0109A:  MOVFF  425,1F2
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
0109E:  MOVFF  426,1F3
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
010A2:  MOVFF  427,1F4
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
010A6:  MOVFF  428,1F5
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
010AA:  MOVFF  429,1F6
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
010AE:  MOVFF  42A,1F7
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
010B2:  MOVLW  03
010B4:  MOVWF  xF9
010B6:  MOVLW  55
010B8:  MOVWF  xF8
010BA:  MOVLW  01
010BC:  MOVWF  xFB
010BE:  MOVLW  ED
010C0:  MOVWF  xFA
010C2:  MOVLB  0
010C4:  RCALL  0C04
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
010C6:  MOVLW  2C
010C8:  MOVLB  4
010CA:  MOVWF  x21
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
010CC:  MOVLW  A5
010CE:  MOVLB  0
010D0:  RCALL  0DDA
....................             fputc(STX, UART); 
010D2:  MOVLW  A5
010D4:  RCALL  0DDA
....................             fputc(STX, UART); 
010D6:  MOVLW  A5
010D8:  RCALL  0DDA
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
010DA:  MOVLB  B
010DC:  CLRF   xEE
010DE:  MOVF   xEE,W
010E0:  SUBLW  0C
010E2:  BNC   1102
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
010E4:  CLRF   03
010E6:  MOVF   xEE,W
010E8:  ADDLW  20
010EA:  MOVWF  FE9
010EC:  MOVLW  04
010EE:  ADDWFC 03,W
010F0:  MOVWF  FEA
010F2:  MOVFF  FEF,BF1
010F6:  MOVF   xF1,W
010F8:  MOVLB  0
010FA:  RCALL  0DDA
010FC:  MOVLB  B
010FE:  INCF   xEE,F
01100:  BRA    10DE
....................             } 
....................             fputc(ETX, UART); 
01102:  MOVLW  B5
01104:  MOVLB  0
01106:  RCALL  0DDA
....................             fputc(ETX, UART); 
01108:  MOVLW  B5
0110A:  RCALL  0DDA
0110C:  MOVLB  B
....................         } 
....................     } 
0110E:  MOVLB  4
01110:  MOVLB  1
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
01112:  MOVLB  0
01114:  GOTO   45E2 (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
*
001CA:  MOVLB  0
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
001CC:  MOVLB  1
001CE:  MOVF   xD1,W
001D0:  SUBLW  FF
001D2:  BNZ   01D6
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
001D4:  CLRF   xD1
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
001D6:  MOVLW  01
001D8:  ADDWF  xD2,W
001DA:  MOVLB  C
001DC:  MOVWF  x32
001DE:  MOVWF  x33
001E0:  MOVLW  C8
001E2:  MOVWF  x34
001E4:  MOVLB  0
001E6:  RCALL  0182
001E8:  MOVFF  00,1D2
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
001EC:  CLRF   03
001EE:  MOVLB  1
001F0:  MOVF   xD2,W
001F2:  ADDLW  09
001F4:  MOVWF  FE9
001F6:  MOVLW  01
001F8:  ADDWFC 03,W
001FA:  MOVWF  FEA
001FC:  MOVFF  FEA,C34
00200:  MOVFF  FE9,C33
00204:  MOVLB  0
00206:  BRA    01AE
00208:  MOVFF  C34,FEA
0020C:  MOVFF  C33,FE9
00210:  MOVFF  01,FEF
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
00214:  MOVF   F98,W
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
00216:  MOVLB  E
00218:  BCF    x36.5
0021A:  MOVLB  0
0021C:  GOTO   0134
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED                   11 
.................... #define FLAG_DI_STATE_NOT_CHANGED               12 
....................  
.................... //#define CHECK_FOR_AT_RESPONSE                   15 
.................... //#define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... //#define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        10 // In Minutes. 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              40 // In Seconds. 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 // In Minutes. 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               18 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... #define  RESET_TIME_INTERVAL_COUNTING           20 
.................... #define  POWER_CUT_TIME_COUNTING                21 
.................... #define  NETWORK_RECONNECT_HALT_TIME_COUNTING   22 
.................... #define  MODEM_RESET_PROCESS_ON                 24 
.................... #define  MODEM_RESET_PROCESS_OFF                25 
.................... #define  PERIODIC_MODEM_RESET_TIMEOUT           30 // In minutes. 
....................  
.................... #define  TIME_STAMP_WRITE_INTERVAL_TIME         60 // In seconds. 
.................... #define  TIME_STAMP_SIGNAL_ON                   20 
.................... #define  TIME_STAMP_SIGNAL_COMPLETE             21 
....................  
.................... #define  KEEP_ALIVE_SEND_PROCESS_ON             33 
.................... #define  KEEP_ALIVE_SEND_PROCESS_OFF            44 
....................  
.................... #define  CHECK_FOR_QUERY_START                  45 
.................... #define  CHECK_FOR_QUERY_END                    46 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... unsigned int8  g_ui8TSWriteIntrvlCounter              = 0; 
.................... unsigned int8  g_fTSWriteToEEPROMSignal               = TIME_STAMP_SIGNAL_COMPLETE; 
.................... unsigned int8  g_ui8KeepAliveMonitoringCounter        = 180; 
.................... unsigned int8  g_fKeepAliveSendStatus                 = KEEP_ALIVE_SEND_PROCESS_OFF; 
.................... unsigned int8  g_fKeepAliveQueryCheck                 = CHECK_FOR_QUERY_END; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
*
005B2:  MOVLW  90
005B4:  MOVWF  FD5
005B6:  MOVLW  43
005B8:  MOVWF  FD6
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
005BA:  BTFSS  FD5.4
005BC:  BRA    05C2
005BE:  MOVLW  FD
005C0:  MOVWF  FD4
005C2:  MOVLW  8F
005C4:  MOVWF  FD3
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
005C6:  MOVLB  E
005C8:  BCF    x33.5
.................... 	enable_interrupts( INT_TIMER0 ); 
005CA:  BSF    x29.5
005CC:  MOVLB  0
005CE:  GOTO   4598 (RETURN)
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
*
00220:  MOVLB  0
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;   
00222:  MOVLB  4
00224:  INCF   xFA,F
00226:  BTFSC  FD8.2
00228:  INCF   xFB,F
....................      
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)   
0022A:  MOVF   xFB,W
0022C:  SUBLW  02
0022E:  BC    028E
00230:  XORLW  FF
00232:  BNZ   023A
00234:  MOVF   xFA,W
00236:  SUBLW  E7
00238:  BC    028E
....................     { 
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui32UnixTimeInSec++; 
0023A:  MOVLW  01
0023C:  MOVLB  0
0023E:  ADDWF  xBD,F
00240:  BTFSC  FD8.0
00242:  INCF   xBE,F
00244:  BTFSC  FD8.2
00246:  INCF   xBF,F
00248:  BTFSC  FD8.2
0024A:  INCF   xC0,F
....................  
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
0024C:  MOVLB  4
0024E:  CLRF   xFB
00250:  CLRF   xFA
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
00252:  INCF   xFC,F
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
00254:  MOVF   xFF,W
00256:  SUBLW  1A
00258:  BNZ   0264
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
0025A:  MOVLB  5
0025C:  INCF   x00,F
0025E:  BTFSC  FD8.2
00260:  INCF   x01,F
00262:  MOVLB  4
....................         } 
....................          
....................                  
....................         // Check for interval timeout to write time-stamp into EEPROM. 
....................         if(++g_ui8TSWriteIntrvlCounter >= TIME_STAMP_WRITE_INTERVAL_TIME) 
00264:  MOVLB  5
00266:  INCF   x02,F
00268:  MOVF   x02,W
0026A:  SUBLW  3B
0026C:  BC    0284
....................         { 
....................             // Reset counter. 
....................             g_ui8TSWriteIntrvlCounter = 0; 
0026E:  CLRF   x02
....................              
....................             // Hook current unix time. 
....................             g_ui32HookedUpTimeStampPerMinute = g_ui32UnixTimeInSec; 
00270:  MOVFF  C0,98
00274:  MOVFF  BF,97
00278:  MOVFF  BE,96
0027C:  MOVFF  BD,95
....................              
....................             // Set flag to save current unix time to EEPROM. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_ON; 
00280:  MOVLW  14
00282:  MOVWF  x03
....................         } 
....................          
....................         // Decrease keep alive monitoring counter at each second. 
....................         // and check if it meets zero level i.e. 180 seconds passed and no data in queue. 
....................         // Time to send Keep Alive to Server. 
....................         if(--g_ui8KeepAliveMonitoringCounter == 0) 
00284:  DECFSZ x04,F
00286:  BRA    028C
....................         { 
....................             // set flag to denote 180 seconds over. 
....................             // Time to send keep alive. 
....................             g_fKeepAliveSendStatus = KEEP_ALIVE_SEND_PROCESS_ON; 
00288:  MOVLW  21
0028A:  MOVWF  x05
0028C:  MOVLB  4
....................         } 
....................     }    
....................      
....................      
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte)  
0028E:  MOVF   3E,W
00290:  SUBLW  28
00292:  BNZ   0298
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
00294:  INCF   3F,F
....................     } 
00296:  BRA    02A4
....................     else if(MODBUS_IS_NOT_VALID_SLAVE_ID == g_fIsValidSlaveID) 
00298:  MOVLB  0
0029A:  MOVF   x8A,W
0029C:  SUBLW  0D
0029E:  BNZ   02A2
....................     { 
....................         // Increase counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter++; 
002A0:  INCF   x8E,F
....................     } 
002A2:  MOVLB  4
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................       
....................     if(g_ui8UnexpectedSlaveIDIgnoreCounter >= ISR_TOTAL_8_BYTE_RECEIVE_TIME) 
002A4:  MOVLB  0
002A6:  MOVF   x8E,W
002A8:  SUBLW  02
002AA:  BC    02B6
....................     { 
....................         // Reset counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter = 0; 
002AC:  CLRF   x8E
....................          
....................         // Update flag status. 
....................         g_fIsValidSlaveID = MODBUS_IS_VALID_SLAVE_ID; 
002AE:  MOVLW  0C
002B0:  MOVWF  x8A
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002B2:  MOVLW  29
002B4:  MOVWF  3E
....................          
....................     }  
....................       
....................     if(g_ui8ISRReceiveByteTimeCounter > g_ui16ISRAllBytesExpectedRcvTime)  
002B6:  MOVF   x8C,F
002B8:  BNZ   02CA
002BA:  MOVF   3F,W
002BC:  SUBWF  x8B,W
002BE:  BC    02CA
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRReceivedByteStatus = ISR_RECEIVED_ALL_BYTES; 
002C0:  MOVLW  15
002C2:  MOVWF  x8D
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002C4:  MOVLW  29
002C6:  MOVWF  3E
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
002C8:  CLRF   3F
....................     }     
....................      
....................     // ############################### Non Critical ############################### 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay Start 
....................     //---------------------------------------------------- 
....................     if (IBU_WAIT_FOR_ACK_TIMEOUT_ON == g_fIBUMsgAckDelayStatus) 
002CA:  MOVLB  4
002CC:  DECFSZ x1D,W
002CE:  BRA    02EC
....................     { 
....................         g_ui16IBUWaitForACKTikCount++; 
002D0:  INCF   x1E,F
002D2:  BTFSC  FD8.2
002D4:  INCF   x1F,F
....................         if (g_ui16IBUWaitForACKTikCount >= DELAY_IBU_MSG_ACK_NOT_RCV) 
002D6:  MOVF   x1F,F
002D8:  BNZ   02E0
002DA:  MOVF   x1E,W
002DC:  SUBLW  1D
002DE:  BC    02EC
....................         { 
....................             g_ui16IBUWaitForACKTikCount = 0; 
002E0:  CLRF   x1F
002E2:  CLRF   x1E
....................              
....................             // Reset flag denoting IBU is free now. 
....................             g_fIBUSendBusy = IBU_SENDING_FREE; 
002E4:  MOVLB  2
002E6:  CLRF   x8F
....................              
....................             g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
002E8:  MOVLB  4
002EA:  CLRF   x1D
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay End 
....................     //---------------------------------------------------- 
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
002EC:  MOVF   xFC,W
002EE:  SUBLW  3B
002F0:  BC    02F4
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
002F2:  CLRF   xFC
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................     } 
....................      
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
002F4:  MOVLB  0
002F6:  MOVF   x92,F
002F8:  BZ    032C
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
002FA:  MOVLB  4
002FC:  INCF   xFD,F
002FE:  BTFSC  FD8.2
00300:  INCF   xFE,F
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
00302:  MOVLB  0
00304:  MOVF   x91,W
00306:  MOVLB  4
00308:  SUBWF  xFE,W
0030A:  BNC   032E
0030C:  BNZ   0318
0030E:  MOVLB  0
00310:  MOVF   x90,W
00312:  MOVLB  4
00314:  SUBWF  xFD,W
00316:  BNC   032E
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
00318:  MOVLW  01
0031A:  MOVLB  0
0031C:  MOVWF  x8F
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
0031E:  CLRF   x92
....................             g_ui16ShouldLookTimerCounter = 0; 
00320:  MOVLB  4
00322:  CLRF   xFE
00324:  CLRF   xFD
....................             g_ui16TimeOutMilliseconds    = 0; 
00326:  MOVLB  0
00328:  CLRF   x91
0032A:  CLRF   x90
0032C:  MOVLB  4
....................         } 
....................     } 
....................          
....................     // Check if data send interval time reached timeout 
....................     if(g_ui16DataSendIntervalTime >= g_ui8DataSendingIntervalTime) 
0032E:  MOVLB  5
00330:  MOVF   x01,F
00332:  BNZ   033E
00334:  MOVLB  4
00336:  MOVF   xE0,W
00338:  MOVLB  5
0033A:  SUBWF  x00,W
0033C:  BNC   034A
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
0033E:  MOVLW  19
00340:  MOVLB  4
00342:  MOVWF  xFF
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
00344:  MOVLB  5
00346:  CLRF   x01
00348:  CLRF   x00
....................     } 
....................          
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
0034A:  BTFSS  FD5.4
0034C:  BRA    0352
0034E:  MOVLW  FD
00350:  MOVWF  FD4
00352:  MOVLW  8F
00354:  MOVWF  FD3
....................     clear_interrupt( INT_TIMER0 );	 
00356:  MOVLB  E
00358:  BCF    x33.5
0035A:  BCF    x33.5
0035C:  MOVLB  0
0035E:  GOTO   008A
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
.................... #include "vmIBCProcessM1.h" 
.................... /*  
....................  * File:   vmIBUProcessM1.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 11, 2018, 3:11 PM 
....................  */ 
....................  
.................... #ifndef VM_IBU_PROCESS_M1_H 
.................... #define	VM_IBU_PROCESS_M1_H 
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... //#include "vmSIM900_GPRSConfig.h" 
.................... //#include "vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
*
01E36:  MOVF   FF2,W
01E38:  MOVWF  00
01E3A:  BCF    FF2.7
01E3C:  MOVFF  BFA,F75
01E40:  MOVFF  BF9,F74
01E44:  MOVFF  BFB,F76
01E48:  BCF    F77.6
01E4A:  BCF    F77.7
01E4C:  BSF    F77.2
01E4E:  MOVLB  F
01E50:  MOVLW  55
01E52:  MOVWF  F78
01E54:  MOVLW  AA
01E56:  MOVWF  F78
01E58:  BSF    F77.1
01E5A:  BTFSC  F77.1
01E5C:  BRA    1E5A
01E5E:  BCF    F77.2
01E60:  BCF    F77.6
01E62:  BSF    F77.7
01E64:  MOVF   00,W
01E66:  IORWF  FF2,F
01E68:  MOVLB  0
01E6A:  RETURN 0
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
*
03C96:  MOVLB  B
03C98:  CLRF   xF8
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
03C9A:  MOVFF  BF7,BF8
....................     write_eeprom(uiAddress,uiTemp); 
03C9E:  MOVF   FF2,W
03CA0:  MOVWF  00
03CA2:  BCF    FF2.7
03CA4:  MOVFF  BF5,F75
03CA8:  MOVFF  BF4,F74
03CAC:  MOVFF  BF8,F76
03CB0:  BCF    F77.6
03CB2:  BCF    F77.7
03CB4:  BSF    F77.2
03CB6:  MOVLB  F
03CB8:  MOVLW  55
03CBA:  MOVWF  F78
03CBC:  MOVLW  AA
03CBE:  MOVWF  F78
03CC0:  BSF    F77.1
03CC2:  BTFSC  F77.1
03CC4:  BRA    3CC2
03CC6:  BCF    F77.2
03CC8:  BCF    F77.6
03CCA:  BSF    F77.7
03CCC:  MOVF   00,W
03CCE:  IORWF  FF2,F
....................     // Increment write address. 
....................     uiAddress++; 
03CD0:  MOVLB  B
03CD2:  INCF   xF4,F
03CD4:  BTFSC  FD8.2
03CD6:  INCF   xF5,F
....................     // Write second byte. 
....................     uiTemp = 0; 
03CD8:  CLRF   xF8
....................     uiTemp = uiValue & 0x00FF; 
03CDA:  MOVFF  BF6,BF8
....................     write_eeprom(uiAddress,uiTemp); 
03CDE:  MOVF   FF2,W
03CE0:  MOVWF  00
03CE2:  BCF    FF2.7
03CE4:  MOVFF  BF5,F75
03CE8:  MOVFF  BF4,F74
03CEC:  MOVFF  BF8,F76
03CF0:  BCF    F77.6
03CF2:  BCF    F77.7
03CF4:  BSF    F77.2
03CF6:  MOVLB  F
03CF8:  MOVLW  55
03CFA:  MOVWF  F78
03CFC:  MOVLW  AA
03CFE:  MOVWF  F78
03D00:  BSF    F77.1
03D02:  BTFSC  F77.1
03D04:  BRA    3D02
03D06:  BCF    F77.2
03D08:  BCF    F77.6
03D0A:  BSF    F77.7
03D0C:  MOVF   00,W
03D0E:  IORWF  FF2,F
03D10:  MOVLB  0
03D12:  RETURN 0
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
*
00708:  MOVLB  B
0070A:  CLRF   xF1
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
0070C:  MOVFF  FF2,BF2
00710:  BCF    FF2.7
00712:  MOVFF  BF0,F75
00716:  MOVFF  BEF,F74
0071A:  BCF    F77.6
0071C:  BCF    F77.7
0071E:  BSF    F77.0
00720:  MOVF   F76,W
00722:  BCF    F77.6
00724:  BSF    F77.7
00726:  BTFSC  xF2.7
00728:  BSF    FF2.7
0072A:  MOVWF  xF1
....................  
....................     return uiValue; 
0072C:  MOVFF  BF1,01
00730:  MOVLB  0
00732:  RETURN 0
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
*
00784:  MOVLB  B
00786:  CLRF   xF7
00788:  CLRF   xF6
0078A:  CLRF   xF9
0078C:  CLRF   xF8
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
0078E:  MOVFF  FF2,BFA
00792:  BCF    FF2.7
00794:  MOVFF  BF5,F75
00798:  MOVFF  BF4,F74
0079C:  BCF    F77.6
0079E:  BCF    F77.7
007A0:  BSF    F77.0
007A2:  MOVF   F76,W
007A4:  BCF    F77.6
007A6:  BSF    F77.7
007A8:  BTFSC  xFA.7
007AA:  BSF    FF2.7
007AC:  CLRF   xF9
007AE:  MOVWF  xF8
....................     uiValue = uiTemp << 8; 
007B0:  MOVFF  BF8,BF7
007B4:  CLRF   xF6
....................     // Increment read address. 
....................     uiAddress++; 
007B6:  INCF   xF4,F
007B8:  BTFSC  FD8.2
007BA:  INCF   xF5,F
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
007BC:  MOVFF  FF2,BFA
007C0:  BCF    FF2.7
007C2:  MOVFF  BF5,F75
007C6:  MOVFF  BF4,F74
007CA:  BCF    F77.6
007CC:  BCF    F77.7
007CE:  BSF    F77.0
007D0:  MOVF   F76,W
007D2:  BCF    F77.6
007D4:  BSF    F77.7
007D6:  BTFSC  xFA.7
007D8:  BSF    FF2.7
007DA:  CLRF   xF9
007DC:  MOVWF  xF8
....................     uiValue = uiValue | uiTemp; 
007DE:  MOVF   xF8,W
007E0:  IORWF  xF6,F
007E2:  MOVF   xF9,W
007E4:  IORWF  xF7,F
....................  
....................     return uiValue; 
007E6:  MOVFF  BF6,01
007EA:  MOVFF  BF7,02
007EE:  MOVLB  0
007F0:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
*
01E6C:  MOVLB  B
01E6E:  CLRF   xFA
01E70:  MOVLW  0A
01E72:  MOVWF  xF9
01E74:  MOVFF  BF8,BFB
01E78:  MOVLB  0
01E7A:  RCALL  1E36
01E7C:  GOTO   38D0 (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
*
00734:  MOVLB  B
00736:  CLRF   xEE
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
00738:  CLRF   xF0
0073A:  MOVLW  0A
0073C:  MOVWF  xEF
0073E:  MOVLB  0
00740:  RCALL  0708
00742:  MOVFF  01,BEE
....................      
....................     return ui8MachineID; 
00746:  MOVLB  B
00748:  MOVFF  BEE,01
0074C:  MOVLB  0
0074E:  GOTO   075A (RETURN)
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
*
01E80:  MOVLB  B
01E82:  CLRF   xFA
01E84:  MOVLW  0C
01E86:  MOVWF  xF9
01E88:  MOVFF  BF8,BFB
01E8C:  MOVLB  0
01E8E:  RCALL  1E36
01E90:  GOTO   38D0 (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
*
00766:  MOVLB  B
00768:  CLRF   xED
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
0076A:  CLRF   xF0
0076C:  MOVLW  0C
0076E:  MOVWF  xEF
00770:  MOVLB  0
00772:  RCALL  0708
00774:  MOVFF  01,BED
....................      
....................     return ui8DataSendInterval; 
00778:  MOVLB  B
0077A:  MOVFF  BED,01
0077E:  MOVLB  0
00780:  GOTO   094A (RETURN)
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
*
03D14:  MOVLB  B
03D16:  CLRF   xF2
03D18:  CLRF   xF1
03D1A:  CLRF   xF3
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
03D1C:  MOVLW  11
03D1E:  MOVWF  xF3
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
03D20:  MOVFF  BEF,BF1
03D24:  MOVFF  BF0,BF2
03D28:  CLRF   03
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03D2A:  CLRF   xF5
03D2C:  MOVFF  BF3,BF4
03D30:  MOVFF  BF2,BF7
03D34:  MOVFF  BF1,BF6
03D38:  MOVLB  0
03D3A:  RCALL  3C96
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
03D3C:  MOVLW  02
03D3E:  MOVLB  B
03D40:  ADDWF  xF3,F
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
03D42:  MOVFF  BED,BF1
03D46:  MOVFF  BEE,BF2
03D4A:  CLRF   03
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03D4C:  CLRF   xF5
03D4E:  MOVFF  BF3,BF4
03D52:  MOVFF  BF2,BF7
03D56:  MOVFF  BF1,BF6
03D5A:  MOVLB  0
03D5C:  RCALL  3C96
03D5E:  GOTO   4652 (RETURN)
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
*
007F2:  MOVLB  B
007F4:  CLRF   xF0
007F6:  CLRF   xEF
007F8:  CLRF   xEE
007FA:  CLRF   xED
007FC:  CLRF   xF2
007FE:  CLRF   xF1
00800:  CLRF   xF3
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
00802:  MOVLW  11
00804:  MOVWF  xF3
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00806:  CLRF   xF5
00808:  MOVFF  BF3,BF4
0080C:  MOVLB  0
0080E:  RCALL  0784
00810:  MOVFF  02,BF2
00814:  MOVFF  01,BF1
....................     ui32StoredUnixTime = ui16Temp; 
00818:  MOVLB  B
0081A:  CLRF   xF0
0081C:  CLRF   xEF
0081E:  MOVFF  BF2,BEE
00822:  MOVFF  BF1,BED
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
00826:  MOVFF  BEE,BF0
0082A:  MOVFF  BED,BEF
0082E:  CLRF   xED
00830:  CLRF   xEE
....................     ui8EEPROMAddress += 2; 
00832:  MOVLW  02
00834:  ADDWF  xF3,F
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00836:  CLRF   xF5
00838:  MOVFF  BF3,BF4
0083C:  MOVLB  0
0083E:  RCALL  0784
00840:  MOVFF  02,BF2
00844:  MOVFF  01,BF1
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
00848:  MOVLB  B
0084A:  CLRF   xF4
0084C:  CLRF   xF5
0084E:  MOVFF  BEF,BF6
00852:  MOVFF  BF0,BF7
00856:  MOVF   xF4,W
00858:  IORWF  xF1,W
0085A:  MOVWF  xED
0085C:  MOVF   xF5,W
0085E:  IORWF  xF2,W
00860:  MOVWF  xEE
00862:  MOVFF  BEF,BEF
00866:  MOVFF  BF0,BF0
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
0086A:  MOVLW  1E
0086C:  ADDWF  xED,F
0086E:  MOVLW  00
00870:  ADDWFC xEE,F
00872:  ADDWFC xEF,F
00874:  ADDWFC xF0,F
....................      
....................     return ui32StoredUnixTime;     
00876:  MOVFF  BED,00
0087A:  MOVFF  BEE,01
0087E:  MOVFF  BEF,02
00882:  MOVFF  BF0,03
00886:  MOVLB  0
00888:  GOTO   0950 (RETURN)
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
*
01E94:  MOVLB  B
01E96:  CLRF   xFA
01E98:  MOVLW  16
01E9A:  MOVWF  xF9
01E9C:  MOVFF  BF8,BFB
01EA0:  MOVLB  0
01EA2:  RCALL  1E36
01EA4:  GOTO   38D0 (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
*
0088C:  MOVLB  B
0088E:  CLRF   xED
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
00890:  CLRF   xF0
00892:  MOVLW  16
00894:  MOVWF  xEF
00896:  MOVLB  0
00898:  RCALL  0708
0089A:  MOVFF  01,BED
....................      
....................     return ui8SIMOperatorID;     
0089E:  MOVLB  B
008A0:  MOVFF  BED,01
008A4:  MOVLB  0
008A6:  GOTO   0962 (RETURN)
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                15             
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_9          9 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int32             m_i32PipeWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... //ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
.................... } 
....................  
.................... //unsigned int8 CountDataSize(unsigned int32 ui32Data) 
.................... //{ 
.................... //    unsigned int8 ui8DataLen = 0; 
.................... //     
.................... //    if(ui32Data <= 9) 
.................... //    { 
.................... //        ui8DataLen = 1; 
.................... //    } 
.................... //    else if(ui32Data <= 99) 
.................... //    { 
.................... //        ui8DataLen = 2; 
.................... //    } 
.................... //    else if(ui32Data <= 999) 
.................... //    { 
.................... //        ui8DataLen = 3; 
.................... //    } 
.................... //    else if(ui32Data <= 9999) 
.................... //    { 
.................... //        ui8DataLen = 4; 
.................... //    } 
.................... //    else if(ui32Data <= 99999) 
.................... //    { 
.................... //        ui8DataLen = 5; 
.................... //    } 
.................... //    else if(ui32Data <= 999999) 
.................... //    { 
.................... //        ui8DataLen = 6; 
.................... //    } 
.................... //    else if(ui32Data <= 9999999) 
.................... //    { 
.................... //        ui8DataLen = 7; 
.................... //    } 
.................... //    else if(ui32Data <= 99999999) 
.................... //    { 
.................... //        ui8DataLen = 8; 
.................... //    } 
.................... //    else if(ui32Data <= 999999999) 
.................... //    { 
.................... //        ui8DataLen = 9; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8DataLen = 10; 
.................... //    } 
.................... // 
.................... //     
.................... //    return ui8DataLen; 
.................... //} 
....................  
.................... //void CheckURLInputByteLength(void) 
.................... //{ 
.................... //    unsigned int8 ui8DataByte = 0; 
.................... //     
.................... //    // Basic byte count is 75 bytes. 
.................... //    // Here the dynamic/ changing variables are considered to count byte length. 
.................... // 
.................... //    // Check for Machine ID. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui8MachineID); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 1. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16BasicMaterialStandard); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 2. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16PipeSpecification); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 3. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MaxWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //        // Check for header parameter - 4. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MinWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //     
.................... //     
.................... //    // Check for TimeStamp. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Sequence number. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Item weight. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Rejection status. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... // 
.................... //} 
....................  
....................  
.................... //void InitializeGPRSMsgQueue(void) 
.................... //{ 
.................... //    // Initialize front and rear of the queue 
.................... //    g_stGPRSMsgSendQueue.m_i8Front = -1; 
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = -1; 
.................... //     
.................... //    // Initialize each queue element 
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
.................... //    } 
....................  
.................... //} 
....................  
.................... //unsigned int8 IsGPRSMsgQueueEmpty(void) 
.................... //{ 
.................... //    unsigned int8 ui8QueueStatus = 0; 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        ui8QueueStatus = 1;  
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8QueueStatus = 0; 
.................... //    } 
.................... //    return ui8QueueStatus; 
.................... //} 
....................  
....................  
.................... //void InsertInGPRSMsgQueue() 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
.................... //    //g_stGPRSMsgSendQueue.m_ui8QArr[g_stGPRSMsgSendQueue.m_ui8Rear] = ui8Element; 
.................... //} 
....................  
.................... //void InsertInGPRSQueue(void) 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = 99; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = 999;     
.................... //} 
....................  
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................      
....................  
....................     // Fetch Machine ID from memory. 
....................     g_ui8MachineID = ReadMachineIDFromEEPROM();     
....................     //g_stGPRSMsgHeader.m_ui8MachineID = g_ui8MachineID;  // Delta 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... //unsigned int8 SetPDPContext(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt(); 
.................... //    // Set AT command for define PDP Context.     
.................... //    if(1 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"airtelgprs.com\"\r", GSM_M66);    // For Airtel SIM. 
.................... //    } 
.................... //    else if (2 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"internet\"\r", GSM_M66);          // For Idea SIM. 
.................... //    } 
.................... //    else if (3 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66);               // For Vodafone SIM. 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    }                                      
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 ActivatePDP(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to activate PDP context. 
.................... //    fputs("AT+CGACT=1,1\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(5); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Restart WDT. 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //}  
....................  
.................... //unsigned int8 ShowActivatedAddress(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound            = 1; 
.................... //    unsigned int8 ui8FirstCharSequenceFound     = 0; 
.................... //    unsigned int8 ui8FirstCharSeqIndex          = 0; 
.................... //    unsigned int8 ui8SecondCharSequenceFound    = 0; 
.................... //    unsigned int8 ui8DoubleQuoteCount           = 0; 
.................... //    
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to Show activated PDP address. 
.................... //    fputs("AT+CGPADDR=1\r",GSM_M66); 
.................... //    mz_delay_ms(2000); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Reset timeout flag. 
.................... //     g_fIsTimedOut = 0; 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Reset variables. 
.................... //        ui8FirstCharSequenceFound  = 0; 
.................... //        ui8FirstCharSeqIndex       = 0; 
.................... //        ui8SecondCharSequenceFound = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence has found. 
.................... //                    ui8FirstCharSequenceFound = 1; 
.................... //                    // Copy the first character sequence index. 
.................... //                    ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for second character sequence set. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
.................... //                { 
.................... //                    // Increment double quote count. 
.................... //                    ui8DoubleQuoteCount++; 
.................... //                    // Check double quote count. 
.................... //                    if(2 == ui8DoubleQuoteCount) 
.................... //                    { 
.................... //                        // Reset double quote count. 
.................... //                        ui8DoubleQuoteCount = 0; 
.................... //                        // loop through to check second quote count. 
.................... //                        for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
.................... //                        { 
.................... //                            // Check for stop count. 
.................... //                            if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
.................... //                            { 
.................... //                                // Increase stop. 
.................... //                                ui8DoubleQuoteCount++; 
.................... //                                // Check limiting stop count. 
.................... //                                if(3 == ui8DoubleQuoteCount) 
.................... //                                { 
.................... //                                    // Set flag denoting second character sequence has found. 
.................... //                                    ui8SecondCharSequenceFound = 1; 
.................... //                                    break; 
.................... //                                } 
.................... //                            }     
.................... //                        } 
.................... //                         
.................... //                         
.................... //                    } 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for OK. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsResponseFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //            } 
.................... //        } 
.................... //         
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //void SendGPRSConnectionQuery(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(3); 
.................... // 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnectionQueryResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //     
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSequenceFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //            { 
.................... //                // Set flag denoting first character sequence found. 
.................... //                ui8IsFirstCharSequenceFound = 1; 
.................... //                // Copy the index of the first character of the sequence. 
.................... //                ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //            } 
.................... //        } 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSequenceFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS not connected. 
.................... //                ui8IsResponseFound = 0; 
.................... //                break; 
.................... //            } 
.................... //            else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS connected. 
.................... //                ui8IsResponseFound = 1; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... //unsigned int8 SetHTTPURL(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsSetURLOk = 1; 
.................... //    unsigned int8 ui8IsConnectionDone = 0; 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 93; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Increment variables. 
.................... //    g_ui16Itm1SequenceNumber += 2; 
.................... //    g_ui16Itm2SequenceNumber += 2; 
.................... //    g_ui16ItemWeight++; 
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //            { 
.................... //                // Set flag denote connection is established. 
.................... //                ui8IsConnectionDone = 1; 
.................... //                break; 
.................... //            }        
.................... //        } 
.................... //         
.................... //        // set URL in buffer. 
.................... //        if(ui8IsConnectionDone) 
.................... //        { 
.................... //            // Set web service URL. 
.................... //            fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
.................... //            delay_ms(300); 
.................... //            // Check for "OK". 
.................... //            for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //                { 
.................... //                    // Set flag denoting Set URL successfully. 
.................... //                    ui8IsSetURLOk = 0; 
.................... //                    break; 
.................... //                } 
.................... //            }     
.................... //        } 
.................... //         
.................... //        
.................... //    } 
.................... //     
.................... //    return ui8IsSetURLOk; 
.................... //     
.................... //} 
....................  
.................... //void SetHTTPURLParameter(void) 
.................... //{ 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 75; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //     
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //     
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(2); 
.................... //} 
....................  
.................... //unsigned int8 SetHTTPURLL(void) 
.................... //{ 
.................... //    unsigned int8  ui8IsSetURLOk       = 1; 
.................... //    unsigned int8  ui8IsConnectionDone = 0; 
.................... //    unsigned int16 ui16ByteCount       = 0; 
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //        { 
.................... //            // Set flag denote connection is established. 
.................... //            ui8IsConnectionDone = 1; 
.................... //            break; 
.................... //        }        
.................... //    } 
.................... //     
.................... //    // set URL in buffer. 
.................... //    if(ui8IsConnectionDone) 
.................... //    { 
.................... // 
.................... //        // Set web service URL. 
.................... //        fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8MachineID, g_stGPRSMsgHeader.m_ui16BasicMaterialStandard, g_stGPRSMsgHeader.m_ui16PipeSpecification,g_stGPRSMsgHeader.m_ui16MaxWeight,g_stGPRSMsgHeader.m_ui16MinWeight, 
.................... //                                                                                                                                 g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... // 
.................... //         
.................... //        //delay_ms(300); 
.................... //        mz_delay_ms(300); 
.................... //        // Check for "OK". 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsSetURLOk = 0; 
.................... //                break; 
.................... //            } 
.................... //        }     
.................... //    } 
.................... // 
.................... //    return ui8IsSetURLOk; 
.................... //} 
....................  
.................... //void SendHTTPGetSessionRequest(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(10); 
.................... //} 
....................  
.................... //unsigned int8 CheckHTTPGETRequestResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    unsigned int8 ui8IsFirstCharSeqFound  = 0; 
.................... //    unsigned int8 ui8IsSecondCharSeqFound = 0; 
.................... //    unsigned int8 ui8CharSeqIndex         = 0; 
.................... //    unsigned int8 ui8CommaCount           = 0; 
.................... //     
.................... //    // Loop through entire receive buffer 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting that first character sequence is found. 
.................... //                ui8IsFirstCharSeqFound = 1; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
.................... //            { 
.................... //                // Set flag denoting that second character sequence has found. 
.................... //                ui8IsSecondCharSeqFound = 1; 
.................... //            }  
.................... // 
.................... //        } 
.................... // 
.................... //        // Check for third character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
.................... //            { 
.................... //                // Increase comma count 
.................... //                ui8CommaCount++; 
.................... //                // Check for comma count level 
.................... //                if(ui8CommaCount == 2) 
.................... //                { 
.................... //                    // Check for success message code. 
.................... //                    if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
.................... //                    { 
.................... //                        // Set flag denoting that success message code found. 
.................... //                        ui8IsOKFound = 0; 
.................... //                        break; 
.................... //                    } 
.................... //                } 
.................... //            }     
.................... //        } 
.................... // 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
*
005EA:  MOVLB  E
005EC:  MOVF   xDC,W
....................     enable_interrupts(INT_RDA5); 
005EE:  BSF    x2D.5
005F0:  MOVLB  0
005F2:  GOTO   45A4 (RETURN)
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
*
00752:  MOVLB  B
00754:  CLRF   xED
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
00756:  MOVLB  0
00758:  BRA    0734
0075A:  MOVFF  01,BED
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
0075E:  MOVFF  BED,99
00762:  GOTO   0948 (RETURN)
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
*
0037E:  MOVLB  0
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
00380:  CLRF   03
00382:  MOVLB  7
00384:  MOVF   x29,W
00386:  ADDLW  15
00388:  MOVWF  FE9
0038A:  MOVLW  07
0038C:  ADDWFC 03,W
0038E:  MOVWF  FEA
00390:  MOVFF  FEA,C2E
00394:  MOVFF  FE9,C2D
00398:  MOVLB  0
0039A:  BRA    0362
0039C:  MOVFF  C2E,FEA
003A0:  MOVFF  C2D,FE9
003A4:  MOVFF  01,FEF
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
003A8:  MOVLB  7
003AA:  INCF   x29,F
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
003AC:  MOVF   x29,W
003AE:  SUBLW  13
003B0:  BC    03B4
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
003B2:  CLRF   x29
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
003B4:  MOVLB  E
003B6:  MOVF   xDC,W
003B8:  BCF    x37.5
003BA:  MOVLB  0
003BC:  GOTO   008A
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
*
005F6:  MOVLB  B
005F8:  SETF   x76
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
005FA:  SETF   x77
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
005FC:  CLRF   xED
005FE:  MOVF   xED,W
00600:  SUBLW  63
00602:  BTFSS  FD8.0
00604:  BRA    0702
00606:  CLRF   19
00608:  BTFSC  FF2.7
0060A:  BSF    19.7
0060C:  BCF    FF2.7
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
0060E:  MOVLB  C
00610:  CLRF   x2D
00612:  MOVFF  BED,C2C
00616:  CLRF   x2F
00618:  MOVLW  0B
0061A:  MOVWF  x2E
0061C:  MOVLB  0
0061E:  RCALL  0426
00620:  BTFSC  19.7
00622:  BSF    FF2.7
00624:  MOVFF  01,BEE
00628:  MOVLW  06
0062A:  MOVLB  B
0062C:  ADDWF  01,W
0062E:  MOVWF  01
00630:  MOVLW  00
00632:  ADDWFC 02,W
00634:  MOVWF  03
00636:  MOVF   01,W
00638:  ADDLW  2A
0063A:  MOVWF  FE9
0063C:  MOVLW  07
0063E:  ADDWFC 03,W
00640:  MOVWF  FEA
00642:  CLRF   FEF
00644:  CLRF   FEC
00646:  CLRF   FEC
00648:  CLRF   FEC
0064A:  CLRF   19
0064C:  BTFSC  FF2.7
0064E:  BSF    19.7
00650:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
00652:  MOVLB  C
00654:  CLRF   x2D
00656:  MOVFF  BED,C2C
0065A:  CLRF   x2F
0065C:  MOVLW  0B
0065E:  MOVWF  x2E
00660:  MOVLB  0
00662:  RCALL  0426
00664:  BTFSC  19.7
00666:  BSF    FF2.7
00668:  MOVFF  01,BEE
0066C:  MOVLW  04
0066E:  MOVLB  B
00670:  ADDWF  01,W
00672:  MOVWF  01
00674:  MOVLW  00
00676:  ADDWFC 02,W
00678:  MOVWF  03
0067A:  MOVF   01,W
0067C:  ADDLW  2A
0067E:  MOVWF  FE9
00680:  MOVLW  07
00682:  ADDWFC 03,W
00684:  MOVWF  FEA
00686:  CLRF   FEC
00688:  MOVF   FED,F
0068A:  CLRF   FEF
0068C:  CLRF   19
0068E:  BTFSC  FF2.7
00690:  BSF    19.7
00692:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
00694:  MOVLB  C
00696:  CLRF   x2D
00698:  MOVFF  BED,C2C
0069C:  CLRF   x2F
0069E:  MOVLW  0B
006A0:  MOVWF  x2E
006A2:  MOVLB  0
006A4:  RCALL  0426
006A6:  BTFSC  19.7
006A8:  BSF    FF2.7
006AA:  MOVLW  2A
006AC:  MOVLB  B
006AE:  ADDWF  01,W
006B0:  MOVWF  FE9
006B2:  MOVLW  07
006B4:  ADDWFC 02,W
006B6:  MOVWF  FEA
006B8:  CLRF   FEF
006BA:  CLRF   FEC
006BC:  CLRF   FEC
006BE:  CLRF   FEC
006C0:  CLRF   19
006C2:  BTFSC  FF2.7
006C4:  BSF    19.7
006C6:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
006C8:  MOVLB  C
006CA:  CLRF   x2D
006CC:  MOVFF  BED,C2C
006D0:  CLRF   x2F
006D2:  MOVLW  0B
006D4:  MOVWF  x2E
006D6:  MOVLB  0
006D8:  RCALL  0426
006DA:  BTFSC  19.7
006DC:  BSF    FF2.7
006DE:  MOVFF  01,BEE
006E2:  MOVLW  0A
006E4:  MOVLB  B
006E6:  ADDWF  01,W
006E8:  MOVWF  01
006EA:  MOVLW  00
006EC:  ADDWFC 02,W
006EE:  MOVWF  03
006F0:  MOVF   01,W
006F2:  ADDLW  2A
006F4:  MOVWF  FE9
006F6:  MOVLW  07
006F8:  ADDWFC 03,W
006FA:  MOVWF  FEA
006FC:  CLRF   FEF
006FE:  INCF   xED,F
00700:  BRA    05FE
....................     } 
00702:  MOVLB  0
00704:  GOTO   0946 (RETURN)
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
*
03D62:  MOVLB  B
03D64:  CLRF   xED
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
03D66:  MOVF   x76,W
03D68:  SUBLW  FF
03D6A:  BNZ   3D72
....................     { 
....................         ui8QueueStatus = 1;  
03D6C:  MOVLW  01
03D6E:  MOVWF  xED
....................     } 
03D70:  BRA    3D74
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
03D72:  CLRF   xED
....................     } 
....................     return ui8QueueStatus; 
03D74:  MOVFF  BED,01
03D78:  MOVLB  0
03D7A:  GOTO   4672 (RETURN)
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
*
01224:  MOVLB  B
01226:  MOVF   x76,W
01228:  SUBLW  FF
0122A:  BNZ   122E
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
0122C:  CLRF   x76
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
0122E:  MOVLW  01
01230:  ADDWF  x77,W
01232:  MOVWF  xFC
01234:  CLRF   19
01236:  BTFSC  FF2.7
01238:  BSF    19.7
0123A:  BCF    FF2.7
0123C:  MOVFF  FE8,C33
01240:  MOVLW  64
01242:  MOVLB  C
01244:  MOVWF  x34
01246:  MOVLB  0
01248:  CALL   0182
0124C:  BTFSC  19.7
0124E:  BSF    FF2.7
01250:  MOVFF  00,B77
01254:  CLRF   19
01256:  BTFSC  FF2.7
01258:  BSF    19.7
0125A:  BCF    FF2.7
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
0125C:  MOVLB  C
0125E:  CLRF   x2D
01260:  MOVFF  B77,C2C
01264:  CLRF   x2F
01266:  MOVLW  0B
01268:  MOVWF  x2E
0126A:  MOVLB  0
0126C:  CALL   0426
01270:  BTFSC  19.7
01272:  BSF    FF2.7
01274:  MOVFF  01,BFB
01278:  MOVLW  04
0127A:  MOVLB  B
0127C:  ADDWF  01,W
0127E:  MOVWF  01
01280:  MOVLW  00
01282:  ADDWFC 02,W
01284:  MOVWF  03
01286:  MOVF   01,W
01288:  ADDLW  2A
0128A:  MOVWF  FE9
0128C:  MOVLW  07
0128E:  ADDWFC 03,W
01290:  MOVWF  FEA
01292:  MOVFF  70D,FEC
01296:  MOVF   FED,F
01298:  MOVFF  70C,FEF
0129C:  CLRF   19
0129E:  BTFSC  FF2.7
012A0:  BSF    19.7
012A2:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
012A4:  MOVLB  C
012A6:  CLRF   x2D
012A8:  MOVFF  B77,C2C
012AC:  CLRF   x2F
012AE:  MOVLW  0B
012B0:  MOVWF  x2E
012B2:  MOVLB  0
012B4:  CALL   0426
012B8:  BTFSC  19.7
012BA:  BSF    FF2.7
012BC:  MOVFF  01,BFB
012C0:  MOVLW  06
012C2:  MOVLB  B
012C4:  ADDWF  01,W
012C6:  MOVWF  01
012C8:  MOVLW  00
012CA:  ADDWFC 02,W
012CC:  MOVWF  03
012CE:  MOVF   01,W
012D0:  ADDLW  2A
012D2:  MOVWF  FE9
012D4:  MOVLW  07
012D6:  ADDWFC 03,W
012D8:  MOVWF  FEA
012DA:  MOVFF  708,FEF
012DE:  MOVFF  709,FEC
012E2:  MOVFF  70A,FEC
012E6:  MOVFF  70B,FEC
012EA:  CLRF   19
012EC:  BTFSC  FF2.7
012EE:  BSF    19.7
012F0:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
012F2:  MOVLB  C
012F4:  CLRF   x2D
012F6:  MOVFF  B77,C2C
012FA:  CLRF   x2F
012FC:  MOVLW  0B
012FE:  MOVWF  x2E
01300:  MOVLB  0
01302:  CALL   0426
01306:  BTFSC  19.7
01308:  BSF    FF2.7
0130A:  MOVFF  01,BFB
0130E:  MOVLW  0A
01310:  MOVLB  B
01312:  ADDWF  01,W
01314:  MOVWF  01
01316:  MOVLW  00
01318:  ADDWFC 02,W
0131A:  MOVWF  03
0131C:  MOVF   01,W
0131E:  ADDLW  2A
01320:  MOVWF  FE9
01322:  MOVLW  07
01324:  ADDWFC 03,W
01326:  MOVWF  FEA
01328:  MOVFF  70E,FEF
0132C:  CLRF   19
0132E:  BTFSC  FF2.7
01330:  BSF    19.7
01332:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
01334:  MOVLB  C
01336:  CLRF   x2D
01338:  MOVFF  B77,C2C
0133C:  CLRF   x2F
0133E:  MOVLW  0B
01340:  MOVWF  x2E
01342:  MOVLB  0
01344:  CALL   0426
01348:  BTFSC  19.7
0134A:  BSF    FF2.7
0134C:  MOVLW  2A
0134E:  MOVLB  B
01350:  ADDWF  01,W
01352:  MOVWF  FE9
01354:  MOVLW  07
01356:  ADDWFC 02,W
01358:  MOVWF  FEA
0135A:  MOVFF  710,FEF
0135E:  MOVFF  711,FEC
01362:  MOVFF  712,FEC
01366:  MOVFF  713,FEC
0136A:  MOVLB  0
0136C:  GOTO   15AA (RETURN)
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
*
04066:  CLRF   19
04068:  BTFSC  FF2.7
0406A:  BSF    19.7
0406C:  BCF    FF2.7
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight, 
....................                                                                                                    g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
0406E:  MOVLB  C
04070:  CLRF   x2D
04072:  MOVFF  B76,C2C
04076:  CLRF   x2F
04078:  MOVLW  0B
0407A:  MOVWF  x2E
0407C:  MOVLB  0
0407E:  CALL   0426
04082:  BTFSC  19.7
04084:  BSF    FF2.7
04086:  MOVFF  02,BEE
0408A:  MOVFF  01,BED
0408E:  MOVLW  2A
04090:  MOVLB  B
04092:  ADDWF  01,W
04094:  MOVWF  FE9
04096:  MOVLW  07
04098:  ADDWFC 02,W
0409A:  MOVWF  FEA
0409C:  MOVFF  FEF,BEF
040A0:  MOVFF  FEC,BF0
040A4:  MOVFF  FEC,BF1
040A8:  MOVFF  FEC,BF2
040AC:  CLRF   19
040AE:  BTFSC  FF2.7
040B0:  BSF    19.7
040B2:  BCF    FF2.7
040B4:  MOVLB  C
040B6:  CLRF   x2D
040B8:  MOVFF  B76,C2C
040BC:  CLRF   x2F
040BE:  MOVLW  0B
040C0:  MOVWF  x2E
040C2:  MOVLB  0
040C4:  CALL   0426
040C8:  BTFSC  19.7
040CA:  BSF    FF2.7
040CC:  MOVFF  01,BF3
040D0:  MOVLW  04
040D2:  MOVLB  B
040D4:  ADDWF  01,W
040D6:  MOVWF  01
040D8:  MOVLW  00
040DA:  ADDWFC 02,W
040DC:  MOVWF  03
040DE:  MOVF   01,W
040E0:  ADDLW  2A
040E2:  MOVWF  FE9
040E4:  MOVLW  07
040E6:  ADDWFC 03,W
040E8:  MOVWF  FEA
040EA:  MOVFF  FEC,BF4
040EE:  MOVF   FED,F
040F0:  MOVFF  FEF,BF3
040F4:  CLRF   19
040F6:  BTFSC  FF2.7
040F8:  BSF    19.7
040FA:  BCF    FF2.7
040FC:  MOVLB  C
040FE:  CLRF   x2D
04100:  MOVFF  B76,C2C
04104:  CLRF   x2F
04106:  MOVLW  0B
04108:  MOVWF  x2E
0410A:  MOVLB  0
0410C:  CALL   0426
04110:  BTFSC  19.7
04112:  BSF    FF2.7
04114:  MOVFF  01,BF5
04118:  MOVLW  06
0411A:  MOVLB  B
0411C:  ADDWF  01,W
0411E:  MOVWF  01
04120:  MOVLW  00
04122:  ADDWFC 02,W
04124:  MOVWF  03
04126:  MOVF   01,W
04128:  ADDLW  2A
0412A:  MOVWF  FE9
0412C:  MOVLW  07
0412E:  ADDWFC 03,W
04130:  MOVWF  FEA
04132:  MOVFF  FEF,BF5
04136:  MOVFF  FEC,BF6
0413A:  MOVFF  FEC,BF7
0413E:  MOVFF  FEC,BF8
04142:  CLRF   19
04144:  BTFSC  FF2.7
04146:  BSF    19.7
04148:  BCF    FF2.7
0414A:  MOVLB  C
0414C:  CLRF   x2D
0414E:  MOVFF  B76,C2C
04152:  CLRF   x2F
04154:  MOVLW  0B
04156:  MOVWF  x2E
04158:  MOVLB  0
0415A:  CALL   0426
0415E:  BTFSC  19.7
04160:  BSF    FF2.7
04162:  MOVFF  01,BF9
04166:  MOVLW  0A
04168:  MOVLB  B
0416A:  ADDWF  01,W
0416C:  MOVWF  01
0416E:  MOVLW  00
04170:  ADDWFC 02,W
04172:  MOVWF  03
04174:  MOVF   01,W
04176:  ADDLW  2A
04178:  MOVWF  FE9
0417A:  MOVLW  07
0417C:  ADDWFC 03,W
0417E:  MOVWF  FEA
04180:  MOVFF  FEF,BF9
04184:  MOVLW  C0
04186:  MOVWF  FF6
04188:  MOVLW  03
0418A:  MOVWF  FF7
0418C:  MOVLW  1F
0418E:  MOVWF  xFA
04190:  MOVLB  0
04192:  RCALL  3D7E
04194:  MOVFF  99,BFA
04198:  MOVLW  1B
0419A:  MOVLB  B
0419C:  MOVWF  xFB
0419E:  MOVLB  0
041A0:  RCALL  3DAA
041A2:  MOVLW  E1
041A4:  MOVWF  FF6
041A6:  MOVLW  03
041A8:  MOVWF  FF7
041AA:  MOVLW  03
041AC:  MOVLB  B
041AE:  MOVWF  xFA
041B0:  MOVLB  0
041B2:  RCALL  3D7E
041B4:  MOVLW  10
041B6:  MOVWF  FE9
041B8:  MOVFF  9B,BFB
041BC:  MOVFF  9A,BFA
041C0:  RCALL  3E4E
041C2:  MOVLW  E7
041C4:  MOVWF  FF6
041C6:  MOVLW  03
041C8:  MOVWF  FF7
041CA:  MOVLW  03
041CC:  MOVLB  B
041CE:  MOVWF  xFA
041D0:  MOVLB  0
041D2:  RCALL  3D7E
041D4:  MOVLW  10
041D6:  MOVWF  FE9
041D8:  MOVFF  9D,BFB
041DC:  MOVFF  9C,BFA
041E0:  RCALL  3E4E
041E2:  MOVLW  ED
041E4:  MOVWF  FF6
041E6:  MOVLW  03
041E8:  MOVWF  FF7
041EA:  MOVLW  03
041EC:  MOVLB  B
041EE:  MOVWF  xFA
041F0:  MOVLB  0
041F2:  RCALL  3D7E
041F4:  MOVLW  41
041F6:  MOVWF  FE9
041F8:  MOVFF  A1,BFD
041FC:  MOVFF  A0,BFC
04200:  MOVFF  9F,BFB
04204:  MOVFF  9E,BFA
04208:  RCALL  3FA6
0420A:  MOVLW  F3
0420C:  MOVWF  FF6
0420E:  MOVLW  03
04210:  MOVWF  FF7
04212:  MOVLW  03
04214:  MOVLB  B
04216:  MOVWF  xFA
04218:  MOVLB  0
0421A:  RCALL  3D7E
0421C:  MOVLW  41
0421E:  MOVWF  FE9
04220:  MOVFF  A5,BFD
04224:  MOVFF  A4,BFC
04228:  MOVFF  A3,BFB
0422C:  MOVFF  A2,BFA
04230:  RCALL  3FA6
04232:  MOVLW  F9
04234:  MOVWF  FF6
04236:  MOVLW  03
04238:  MOVWF  FF7
0423A:  MOVLW  03
0423C:  MOVLB  B
0423E:  MOVWF  xFA
04240:  MOVLB  0
04242:  RCALL  3D7E
04244:  MOVLW  41
04246:  MOVWF  FE9
04248:  MOVFF  BF2,BFD
0424C:  MOVFF  BF1,BFC
04250:  MOVFF  BF0,BFB
04254:  MOVFF  BEF,BFA
04258:  RCALL  3FA6
0425A:  MOVLW  24
0425C:  MOVLB  E
0425E:  BTFSS  x37.4
04260:  BRA    425E
04262:  MOVWF  xDD
04264:  MOVLW  10
04266:  MOVWF  FE9
04268:  MOVFF  BF4,BFB
0426C:  MOVFF  BF3,BFA
04270:  MOVLB  0
04272:  RCALL  3E4E
04274:  MOVLW  24
04276:  MOVLB  E
04278:  BTFSS  x37.4
0427A:  BRA    4278
0427C:  MOVWF  xDD
0427E:  MOVLW  41
04280:  MOVWF  FE9
04282:  MOVFF  BF8,BFD
04286:  MOVFF  BF7,BFC
0428A:  MOVFF  BF6,BFB
0428E:  MOVFF  BF5,BFA
04292:  MOVLB  0
04294:  RCALL  3FA6
04296:  MOVLW  24
04298:  MOVLB  E
0429A:  BTFSS  x37.4
0429C:  BRA    429A
0429E:  MOVWF  xDD
042A0:  MOVFF  BF9,BFA
042A4:  MOVLW  1B
042A6:  MOVLB  B
042A8:  MOVWF  xFB
042AA:  MOVLB  0
042AC:  RCALL  3DAA
042AE:  GOTO   4692 (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
....................             break; 
....................         } 
....................     } 
....................          
....................     return ui8RetVal; 
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
....................  
.................... unsigned int16 g_ui16PrevItemCount = 0; 
.................... unsigned int16 g_ui16ItemCount     = 0; 
....................  
....................  // TESTING  
....................     unsigned int8 ui8Counter = 0; 
....................  
.................... // IBU Received message process proc 
.................... void ProcessIBUMsg() 
*
01370:  MOVLB  B
01372:  CLRF   xFA
.................... {    
....................     ST_IBU_DATA_NODE stIBURcvNode; 
....................     unsigned int8  ui8LoopCount = 0; 
....................  
....................     // Get Node from IBU Receive Message Queue 
....................     DeleteIBUMsgQueue(&g_stIBURcvQueue, &stIBURcvNode); 
01374:  MOVLW  03
01376:  MOVWF  xFC
01378:  MOVLW  55
0137A:  MOVWF  xFB
0137C:  MOVLW  0B
0137E:  MOVWF  xFE
01380:  MOVLW  ED
01382:  MOVWF  xFD
01384:  MOVLB  0
01386:  BRA    113E
....................      
....................     // Valid message present in IBU receive buffer 
....................     // So go for process the data 
....................     switch(stIBURcvNode.g_ui8ArrIBUData[0]) 
01388:  MOVLB  B
0138A:  MOVF   xEF,W
0138C:  XORLW  68
0138E:  MOVLB  0
01390:  BZ    13D0
01392:  XORLW  0E
01394:  BZ    1432
01396:  XORLW  0F
01398:  BZ    1436
0139A:  XORLW  EF
0139C:  BZ    143A
0139E:  XORLW  F6
013A0:  BTFSC  FD8.2
013A2:  BRA    148C
013A4:  XORLW  01
013A6:  BTFSC  FD8.2
013A8:  BRA    1490
013AA:  XORLW  F2
013AC:  BTFSC  FD8.2
013AE:  BRA    1494
013B0:  XORLW  04
013B2:  BTFSC  FD8.2
013B4:  BRA    1498
013B6:  XORLW  03
013B8:  BTFSC  FD8.2
013BA:  BRA    14EA
013BC:  XORLW  13
013BE:  BTFSC  FD8.2
013C0:  BRA    15B6
013C2:  XORLW  0E
013C4:  BTFSC  FD8.2
013C6:  BRA    15C0
013C8:  XORLW  03
013CA:  BTFSC  FD8.2
013CC:  BRA    15CA
013CE:  BRA    15D4
....................     { 
....................         case IBU_CMD_RESET_CALIB_DATA: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
013D0:  MOVLW  01
013D2:  MOVLB  B
013D4:  MOVWF  xFA
013D6:  MOVF   xFA,W
013D8:  SUBLW  08
013DA:  BNC   1410
....................             { 
....................                 g_unIBUResetCalibData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
013DC:  MOVLW  01
013DE:  SUBWF  xFA,W
013E0:  CLRF   03
013E2:  ADDLW  E9
013E4:  MOVWF  01
013E6:  MOVLW  00
013E8:  ADDWFC 03,F
013EA:  MOVFF  03,BFC
013EE:  CLRF   03
013F0:  MOVF   xFA,W
013F2:  ADDLW  EF
013F4:  MOVWF  FE9
013F6:  MOVLW  0B
013F8:  ADDWFC 03,W
013FA:  MOVWF  FEA
013FC:  MOVFF  FEF,BFD
01400:  MOVFF  BFC,FEA
01404:  MOVFF  01,FE9
01408:  MOVFF  BFD,FEF
0140C:  INCF   xFA,F
0140E:  BRA    13D6
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32TareADCValueForCalibration    = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForTare; 
01410:  MOVFF  EC,4B9
01414:  MOVFF  EB,4B8
01418:  MOVFF  EA,4B7
0141C:  MOVFF  E9,4B6
....................             g_ui32gWeightADCValueForCalibration = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForWeight; 
01420:  MOVFF  F0,4BD
01424:  MOVFF  EF,4BC
01428:  MOVFF  EE,4BB
0142C:  MOVFF  ED,4BA
....................             break; 
01430:  BRA    15D6
....................         case IBU_CMD_START_CALIBRATION: 
....................             break; 
01432:  MOVLB  B
01434:  BRA    15D6
....................         case IBU_CMD_RESET_CALIB_POINT:             
....................             break; 
01436:  MOVLB  B
01438:  BRA    15D6
....................         case IBU_CMD_PROD_TARE_DATA: 
....................         { 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0143A:  MOVLW  01
0143C:  MOVLB  B
0143E:  MOVWF  xFA
01440:  MOVF   xFA,W
01442:  SUBLW  08
01444:  BNC   147A
....................             { 
....................                 g_unIBUProdModeTrData.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
01446:  MOVLW  01
01448:  SUBWF  xFA,W
0144A:  CLRF   03
0144C:  ADDLW  D5
0144E:  MOVWF  01
01450:  MOVLW  00
01452:  ADDWFC 03,F
01454:  MOVFF  03,BFC
01458:  CLRF   03
0145A:  MOVF   xFA,W
0145C:  ADDLW  EF
0145E:  MOVWF  FE9
01460:  MOVLW  0B
01462:  ADDWFC 03,W
01464:  MOVWF  FEA
01466:  MOVFF  FEF,BFD
0146A:  MOVFF  BFC,FEA
0146E:  MOVFF  01,FE9
01472:  MOVFF  BFD,FEF
01476:  INCF   xFA,F
01478:  BRA    1440
....................             } 
....................             g_ui32RunningTareValue = (unsigned int16)(g_unIBUProdModeTrData.m_stTareData.m_i32TareData); 
0147A:  MOVLB  4
0147C:  CLRF   xCF
0147E:  CLRF   xCE
01480:  MOVFF  DA,4CD
01484:  MOVFF  D9,4CC
....................         } 
....................              
....................             break; 
01488:  MOVLB  B
0148A:  BRA    15D6
....................         case IBU_CMD_PRE_PROD_AVG_WEIGHT: 
....................             break; 
0148C:  MOVLB  B
0148E:  BRA    15D6
....................         case IBU_CMD_PRE_PROD_TOLERANCE: 
....................             break; 
01490:  MOVLB  B
01492:  BRA    15D6
....................         case IBU_CMD_START_PROD: 
....................             break; 
01494:  MOVLB  B
01496:  BRA    15D6
....................         case IBU_CMD_PROD_AVG_WT_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
01498:  MOVLW  01
0149A:  MOVLB  B
0149C:  MOVWF  xFA
0149E:  MOVF   xFA,W
014A0:  SUBLW  08
014A2:  BNC   14D8
....................                 { 
....................                     g_unIBUProdModeAvg.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
014A4:  MOVLW  01
014A6:  SUBWF  xFA,W
014A8:  CLRF   03
014AA:  ADDLW  F1
014AC:  MOVWF  01
014AE:  MOVLW  00
014B0:  ADDWFC 03,F
014B2:  MOVFF  03,BFC
014B6:  CLRF   03
014B8:  MOVF   xFA,W
014BA:  ADDLW  EF
014BC:  MOVWF  FE9
014BE:  MOVLW  0B
014C0:  ADDWFC 03,W
014C2:  MOVWF  FEA
014C4:  MOVFF  FEF,BFD
014C8:  MOVFF  BFC,FEA
014CC:  MOVFF  01,FE9
014D0:  MOVFF  BFD,FEF
014D4:  INCF   xFA,F
014D6:  BRA    149E
....................                 } 
....................                  
....................                 g_ui32RunningAvgWt = g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg; 
014D8:  MOVFF  F4,4CB
014DC:  MOVFF  F3,4CA
014E0:  MOVFF  F2,4C9
014E4:  MOVFF  F1,4C8
....................             } 
....................             break;             
014E8:  BRA    15D6
....................         case IBU_CMD_PROD_WEIGH_DATA: 
....................             { 
....................                  
....................                 // TESTING. 
....................                 //output_toggle(PIN_OUT_DO_00); 
....................  
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
014EA:  MOVLW  01
014EC:  MOVLB  B
014EE:  MOVWF  xFA
014F0:  MOVF   xFA,W
014F2:  SUBLW  08
014F4:  BNC   152A
....................                 { 
....................                     g_unIBUProdModeWtStsData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
014F6:  MOVLW  01
014F8:  SUBWF  xFA,W
014FA:  CLRF   03
014FC:  ADDLW  CD
014FE:  MOVWF  01
01500:  MOVLW  00
01502:  ADDWFC 03,F
01504:  MOVFF  03,BFC
01508:  CLRF   03
0150A:  MOVF   xFA,W
0150C:  ADDLW  EF
0150E:  MOVWF  FE9
01510:  MOVLW  0B
01512:  ADDWFC 03,W
01514:  MOVWF  FEA
01516:  MOVFF  FEF,BFD
0151A:  MOVFF  BFC,FEA
0151E:  MOVFF  01,FE9
01522:  MOVFF  BFD,FEF
01526:  INCF   xFA,F
01528:  BRA    14F0
....................                 } 
....................                  
....................                 // Update current box weight in register. 
....................                 g_stProdModeCurrBoxData.m_i32PipeWeight = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_i32PipeWeight; 
0152A:  MOVFF  D0,70B
0152E:  MOVFF  CF,70A
01532:  MOVFF  CE,709
01536:  MOVFF  CD,708
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui32CurrentWt = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
0153A:  MOVFF  70B,4C5
0153E:  MOVFF  70A,4C4
01542:  MOVFF  709,4C3
01546:  MOVFF  708,4C2
....................                  
....................                 // Update Current box count in register. 
....................                 //g_ui16PipeCount = g_unIBUProdModeBoxCount.m_stBoxCount.m_ui16BoxCount; 
....................                 g_ui16PipeCount = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PipeCount; 
0154A:  MOVFF  D2,4BF
0154E:  MOVFF  D1,4BE
....................                 g_ui16ItemCount = g_ui16PipeCount; 
01552:  MOVFF  4BF,B7B
01556:  MOVFF  4BE,B7A
....................                  
....................                 // Update last box pass status. 
....................                 g_ui16CurrentPassStatus = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PassStatus; 
0155A:  MOVFF  D4,4C7
0155E:  MOVFF  D3,4C6
....................                  
....................                 // Update HMI Data Trigger Status. 
....................                 //g_ui8HMITriggerStatus = 1; 
....................  
....................                 if(g_ui16ItemCount > 0 && g_ui16PrevItemCount != g_ui16ItemCount) 
01562:  MOVF   x7A,F
01564:  BNZ   156A
01566:  MOVF   x7B,F
01568:  BZ    15B4
0156A:  MOVF   x7A,W
0156C:  SUBWF  x78,W
0156E:  BNZ   1576
01570:  MOVF   x7B,W
01572:  SUBWF  x79,W
01574:  BZ    15B4
....................                 { 
....................                     // Update production mode current box data. 
....................                     g_stProdModeCurrBoxData.m_ui16SequenceNo = g_ui16PipeCount; 
01576:  MOVFF  4BF,70D
0157A:  MOVFF  4BE,70C
....................                     g_stProdModeCurrBoxData.m_i32PipeWeight = g_ui32CurrentWt; 
0157E:  MOVFF  4C5,70B
01582:  MOVFF  4C4,70A
01586:  MOVFF  4C3,709
0158A:  MOVFF  4C2,708
....................                     g_stProdModeCurrBoxData.m_ui16RejectionStatus = g_ui16CurrentPassStatus;  // TODO 
0158E:  MOVFF  4C7,70F
01592:  MOVFF  4C6,70E
....................                     g_stProdModeCurrBoxData.m_ui32TimeStamp = g_ui32UnixTimeInSec; 
01596:  MOVFF  C0,713
0159A:  MOVFF  BF,712
0159E:  MOVFF  BE,711
015A2:  MOVFF  BD,710
....................                     // Insert current box data in GPRS send Message queue. 
....................                     InsertInPipeDataQueue(); 
015A6:  MOVLB  0
015A8:  BRA    1224
....................  
....................                     // update previous item count for next box reference. 
....................                     g_ui16PrevItemCount = g_ui16ItemCount; 
015AA:  MOVFF  B7B,B79
015AE:  MOVFF  B7A,B78
015B2:  MOVLB  B
....................                 } 
....................             } 
....................             break;             
015B4:  BRA    15D6
....................         case IBU_CMD_PRE_PROD_TOL_STORE_ACK: 
....................             // No need to parse data. 
....................             // This is acknowledgement message. Transfer to HMI. 
....................             g_ui8ToleranceStoreAck = 1; 
015B6:  MOVLW  01
015B8:  MOVLB  4
015BA:  MOVWF  xDD
....................             break; 
015BC:  MOVLB  B
015BE:  BRA    15D6
....................         case IBU_CMD_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure below rated alarm occurred. 
....................             // Set flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 1; 
015C0:  MOVLW  01
015C2:  MOVLB  4
015C4:  MOVWF  xEE
....................             break; 
015C6:  MOVLB  B
015C8:  BRA    15D6
....................         case IBU_CMD_RESET_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure recovers. 
....................             // Now it is above rated. 
....................             // Reset flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 0; 
015CA:  MOVLB  4
015CC:  CLRF   xEE
....................             break; 
015CE:  MOVLB  B
015D0:  BRA    15D6
015D2:  MOVLB  0
....................         default : 
....................             break; 
015D4:  MOVLB  B
....................     } 
015D6:  MOVLB  0
015D8:  GOTO   45FC (RETURN)
.................... }    
....................  
....................  
....................  
.................... #endif	/* VM_IBU_PROCESS_M1_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
....................     enable_interrupts(INT_RDA5); 
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
....................     } 
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         ui8QueueStatus = 1;  
....................     } 
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
....................     } 
....................     return ui8QueueStatus; 
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight, 
....................                                                                                                    g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
....................             break; 
....................         } 
....................     } 
....................          
....................     return ui8RetVal; 
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
.................... #include "vmRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "../Common/vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
.................... 		{ 
.................... 			break; 
.................... 		} 
....................  
.................... 		uiByteCount++; 
.................... 		bShiftCount = 0; 
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
.................... 			{ 
.................... 				if (1 == uiByteCount) 
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
.................... 				} 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
....................  
.................... 			if (bShiftCount > 8) 
.................... 			{ 
.................... 				break; 
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
....................  
.................... 			uiCRC = uiCRC >> 1; 
....................  
.................... 			if (1 == bShiftCarry) 
.................... 			{ 
.................... 				continue; 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
.................... 			} 
.................... 		} 
.................... 	} 
....................  
.................... 	return uiCRC; 
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
....................      
....................     return ui8MachineID; 
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
....................      
....................     return ui8DataSendInterval; 
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ui16Temp; 
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
....................     ui8EEPROMAddress += 2; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
....................      
....................     return ui32StoredUnixTime;     
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
....................      
....................     return ui8SIMOperatorID;     
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
....................  
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                                        0x05 
.................... #define ADDRESS_FOR_SELECT_PRODUCTION_TYPE                  0x04 
.................... #define ADDRESS_FOR_SCRAP_ON_MODE                           0x99 
.................... #define ADRESS_FOR_HMI_TIMESTAMP                            0x47 
.................... #define ADDRESS_FOR_MACHINE_ID                              0x90 
....................  
....................  
.................... #define ADDRESS_FOR_SET_LOAD_CELL_FACTOR                    0x282 
.................... #define ADDRESS_FOR_CALIB_TARE_ADC_VALUE                    0x296 
.................... #define ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE                  0x298 
....................  
.................... #define ADDRESS_FOR_CURRENT_CALIBRATION_WT                  0x310 
.................... #define ADDRESS_FOR_START_CALIBRATION                       0x299 
.................... #define ADDRESS_FOR_RUNNING_VAR_PROD_DETAILS                0x420 
.................... #define ADDRESS_FOR_SELECTED_PRODUCT_INDEX                  0x540 
.................... #define ADDRESS_FOR_CURRENT_CBB_PRODUCT_INDEX               0x250  
....................  
.................... // use for production 
.................... #define ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION                 0x560 
.................... #define ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION                0x562 
.................... #define ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION            0x564 // SET 1 for accept 
.................... #define ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION            0x566 
.................... #define ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION                0x568 
.................... #define ADDRESS_FOR_WRITE_TARE_VALUE                        0x570 
.................... #define ADDRESS_FOR_HMI_DATA_UPDATE_TRIGGER                 0x760 
....................  
.................... // use for preproduction 
.................... #define ADDRESS_FOR_PRODUCTION_INDEX_PRE_PRODUCTION         0x500 
.................... #define ADDRESS_FOR_PRODUCTION_AVG_WT_PRE_PRODUCTION        0x550 
.................... #define ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION        0x552 
.................... #define ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION        0x554 
....................  
.................... #define ADDRESS_FOR_CALCULATED_MIN_MAX_WT                   0x50 
.................... #define ADDRESS_FOR_TOL_STORE_SEEKING_ACK                   0x88 
.................... #define ADDRESS_FOR_TOL_STORE_SETTING_ACK                   0x89 
.................... #define ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD         0x190 
.................... #define ADDRESS_FOR_PIPE_SPECIFICATION                      0x193 
.................... #define ADDRESS_FOR_PRE_PROD_MAX_MIN_WT                     0x52 
.................... #define ADDRESS_FOR_AT_OK_TIMER_SETTING                     0x53 
.................... #define ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING          0x54 
.................... #define ADDRESS_FOR_HTTP_GET_SESSION_TIMER_SETTING          0x55 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_TIMER_SETTING      0x56 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_NETWORK_RECONNECTION_HALT_TIME      0x57 
.................... #define ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME                0x58 
.................... #define ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME           0x59 
.................... #define ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME                0x60 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_INTERVAL_TIME      0x61 
.................... #define ADDRESS_FOR_SHIFT_NUMBER                            0x62 
.................... #define ADDRESS_FOR_SHIFT_DURATION                          0x63 
.................... #define ADDRESS_FOR_SELECT_SIM_OPERATOR                     0x64 
.................... #define ADDRESS_FOR_AIR_PRESSURE_ALARM                      0x65 
.................... #define ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY   0x66 
....................  
.................... // use for calibration type set 
.................... #define ADDRESS_FOR_CALIBRATION_TYPE                        0x710 
.................... #define ADDRESS_FOR_AUTO_CALIB_SAMPLE_COUNT                 0x711 
....................  
.................... // RS485 Communication related stuff 
.................... #define SIZE_RS485_RX_BUFF                                  50 
.................... #define SIZE_RS485_TX_BUFF                                  50 
.................... #define ISR_1ST_BYTE_RECEIVED                               0 
.................... #define ISR_1ST_BYTE_PROCESSED                              1 
.................... #define MODBUS_FNCODE_READ_COIL_STATUS                      1 
.................... #define MODBUS_FNCODE_READ_HOLDING_REGISTER                 3 
.................... #define MODBUS_FNCODE_WRITE_SINGLE_REGISTER                 6 
.................... #define MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER               16 
.................... #define MODBUS_SINGLE_REG_READ_WRITE_RX_BYTE_COUNT          8 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_READ                  9 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_WRITE                 10 
.................... #define MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL            0 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define STATUS_ON                                       10 
.................... #define STATUS_OFF                                      11 
....................  
....................  
.................... //#define RS485_RX_BUFF_SIZE 		50 
....................  
.................... //unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
....................  
.................... //ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... //unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
.................... unsigned int8 g_ui8RS485Rxbuffer[SIZE_RS485_RX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485Txbuffer[SIZE_RS485_TX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485RxByteCount                  = 0; 
.................... unsigned int8 g_fModbusMultiRegWriteTimeCountStats   = STATUS_OFF; 
.................... unsigned int8 g_fISRFirstBytesStatus                 = ISR_1ST_BYTE_PROCESSED; 
....................  
.................... unsigned int8 g_ui8Test                  = 0; 
.................... unsigned int16 g_ui16BitFillingTemp      = 0; 
.................... unsigned int32 g_ui32BitFillingTemp      = 0; 
....................  
....................  
.................... // Initialize RS485 receive interrupt. 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable interrupt.  
....................     clear_interrupt(INT_RDA3); 
*
005D2:  MOVLB  E
005D4:  MOVF   xEA,W
.................... 	enable_interrupts(INT_RDA3); 
005D6:  BSF    x2D.1
005D8:  MOVLB  0
005DA:  GOTO   459C (RETURN)
.................... } 
....................  
.................... void ResetRS485RXBuffer(void) 
.................... { 
....................     // clear buffer. 
....................     memset(g_ui8RS485Rxbuffer, 0, SIZE_RS485_RX_BUFF); 
*
01780:  MOVLW  0B
01782:  MOVWF  FEA
01784:  MOVLW  7E
01786:  MOVWF  FE9
01788:  CLRF   00
0178A:  CLRF   02
0178C:  MOVLW  32
0178E:  MOVWF  01
01790:  CALL   09BE
....................     // Reset byte count. 
....................     g_ui8RS485RxByteCount = 0; 
01794:  MOVLB  B
01796:  CLRF   xE2
01798:  MOVLB  0
0179A:  RETURN 0
....................      
.................... } 
....................  
.................... #INT_RDA3 
.................... void RS485_RxByteReady_ISR3(void) 
*
0048E:  MOVLB  0
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte && g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
00490:  MOVF   3E,W
00492:  SUBLW  29
00494:  BNZ   04D6
00496:  MOVF   x8A,W
00498:  SUBLW  0C
0049A:  BNZ   04D6
....................     { 
....................         ++g_ui8Test; 
0049C:  MOVLB  B
0049E:  INCF   xE5,F
....................         g_ui8TempByte = fgetc(RS485); 
004A0:  MOVLB  0
004A2:  RCALL  040C
004A4:  MOVFF  01,B7D
....................          
....................         // Checking for is the request/response for valid slave..i.e. slaveID 
....................         if(SLAVE_ID == g_ui8TempByte) 
004A8:  MOVLB  B
004AA:  DECFSZ x7D,W
004AC:  BRA    04CA
....................         { 
....................             g_fIsReadyToReceiveByte = ISR_IS_READY; 
004AE:  MOVLW  28
004B0:  MOVWF  3E
....................             g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
004B2:  CLRF   03
004B4:  MOVF   xE2,W
004B6:  ADDLW  7E
004B8:  MOVWF  FE9
004BA:  MOVLW  0B
004BC:  ADDWFC 03,W
004BE:  MOVWF  FEA
004C0:  MOVFF  B7D,FEF
....................             g_ui8RS485RxByteCount++; 
004C4:  INCF   xE2,F
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_RECEIVED;             
004C6:  CLRF   xE4
....................         } 
004C8:  BRA    04D2
....................         else 
....................         { 
....................             // change flag status if slave id does not match. 
....................             g_fIsValidSlaveID = MODBUS_IS_NOT_VALID_SLAVE_ID; 
004CA:  MOVLW  0D
004CC:  MOVLB  0
004CE:  MOVWF  x8A
004D0:  MOVLB  B
....................         } 
....................  
....................     } 
004D2:  BRA    0598
004D4:  MOVLB  0
....................     else if(g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
004D6:  MOVF   x8A,W
004D8:  SUBLW  0C
004DA:  BNZ   059A
....................     { 
....................         g_ui8TempByte = fgetc(RS485); 
004DC:  RCALL  040C
004DE:  MOVFF  01,B7D
....................          
....................         // Checking for ISR 2nd received byte i.e. function code. 
....................         if(ISR_1ST_BYTE_RECEIVED == g_fISRFirstBytesStatus) 
004E2:  MOVLB  B
004E4:  MOVF   xE4,F
004E6:  BNZ   050E
....................         { 
....................             // change flag status. 
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_PROCESSED; 
004E8:  MOVLW  01
004EA:  MOVWF  xE4
....................              
....................             // Set ISR all byte expected receive timing. 
....................             if(g_ui8TempByte == MODBUS_FNCODE_READ_HOLDING_REGISTER || g_ui8TempByte == MODBUS_FNCODE_WRITE_SINGLE_REGISTER) 
004EC:  MOVF   x7D,W
004EE:  SUBLW  03
004F0:  BZ    04F8
004F2:  MOVF   x7D,W
004F4:  SUBLW  06
004F6:  BNZ   0504
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_8_BYTE_RECEIVE_TIME; 
004F8:  MOVLB  0
004FA:  CLRF   x8C
004FC:  MOVLW  03
004FE:  MOVWF  x8B
....................             } 
00500:  BRA    0510
00502:  MOVLB  B
....................             else if(g_ui8TempByte == MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER) 
00504:  MOVF   x7D,W
00506:  SUBLW  10
00508:  BNZ   050E
....................             { 
....................                 // Set flag to calculate and  load receive time. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_ON; 
0050A:  MOVLW  0A
0050C:  MOVWF  xE3
....................                  
....................                 // Load the time. 
....................                 //g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_19_BYTE_RECEIVE_TIME; 
....................             } 
0050E:  MOVLB  0
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................         } 
....................          
....................         // Check multi register receive time calculation status.(This will depend upon number of register requested for by master) 
....................         if(STATUS_ON == g_fModbusMultiRegWriteTimeCountStats) 
00510:  MOVLB  B
00512:  MOVF   xE3,W
00514:  SUBLW  0A
00516:  BNZ   057C
....................         { 
....................             // Check byte count. 
....................             if(7 == g_ui8RS485RxByteCount) 
00518:  MOVF   xE2,W
0051A:  SUBLW  07
0051C:  BNZ   057C
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (RS485_9600_1_BYTE_RCV_TIME * (RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT + g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1])); 
0051E:  MOVLW  01
00520:  SUBWF  xE2,W
00522:  CLRF   03
00524:  ADDLW  7E
00526:  MOVWF  FE9
00528:  MOVLW  0B
0052A:  ADDWFC 03,W
0052C:  MOVWF  FEA
0052E:  MOVF   FEF,W
00530:  ADDLW  09
00532:  MOVLB  C
00534:  MOVWF  x2B
00536:  MOVLW  04
00538:  MOVWF  x2D
0053A:  MOVLW  10
0053C:  MOVWF  x2C
0053E:  CLRF   x2F
00540:  MOVFF  C2B,C2E
00544:  MOVLB  0
00546:  RCALL  0426
00548:  MOVFF  02,8C
0054C:  MOVFF  01,8B
....................  
....................                 // Manipulate data. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (g_ui16ISRAllBytesExpectedRcvTime / 1000); 
00550:  MOVFF  8C,C2C
00554:  MOVFF  8B,C2B
00558:  MOVLW  03
0055A:  MOVLB  C
0055C:  MOVWF  x2E
0055E:  MOVLW  E8
00560:  MOVWF  x2D
00562:  MOVLB  0
00564:  RCALL  0448
00566:  MOVFF  02,8C
0056A:  MOVFF  01,8B
....................                 g_ui16ISRAllBytesExpectedRcvTime = g_ui16ISRAllBytesExpectedRcvTime + 2; 
0056E:  MOVLW  02
00570:  ADDWF  x8B,F
00572:  MOVLW  00
00574:  ADDWFC x8C,F
....................  
....................                 // Reset flag status. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_OFF; 
00576:  MOVLW  0B
00578:  MOVLB  B
0057A:  MOVWF  xE3
....................             }             
....................         } 
....................          
....................         // Store the data byte in receive buffer. 
....................         g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
0057C:  CLRF   03
0057E:  MOVF   xE2,W
00580:  ADDLW  7E
00582:  MOVWF  FE9
00584:  MOVLW  0B
00586:  ADDWFC 03,W
00588:  MOVWF  FEA
0058A:  MOVFF  B7D,FEF
....................      
....................         // Increment receive byte count. 
....................         g_ui8RS485RxByteCount++; 
0058E:  INCF   xE2,F
....................          
....................         // Check received byte count with buffer size. 
....................         if(g_ui8RS485RxByteCount >= SIZE_RS485_RX_BUFF) 
00590:  MOVF   xE2,W
00592:  SUBLW  31
00594:  BC    0598
....................         { 
....................             // Reset byte count. 
....................             g_ui8RS485RxByteCount = 0; 
00596:  CLRF   xE2
....................         } 
....................      
....................     } 
00598:  MOVLB  0
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................      
....................     // TESTING 
....................     if(g_ui8RS485RxByteCount == 8) 
0059A:  MOVLB  B
0059C:  MOVF   xE2,W
0059E:  SUBLW  08
005A0:  BNZ   05A6
....................     { 
....................         g_ui8RS485RxByteCount = 8; 
005A2:  MOVLW  08
005A4:  MOVWF  xE2
....................     } 
....................      
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA3); 
005A6:  MOVLB  E
005A8:  MOVF   xEA,W
005AA:  BCF    x37.1
005AC:  MOVLB  0
005AE:  GOTO   008A
.................... } 
....................  
.................... void SetProductSpecificationForServer(void) 
*
02A5C:  MOVLB  B
02A5E:  CLRF   xF9
02A60:  CLRF   xF8
02A62:  CLRF   xFB
02A64:  CLRF   xFA
02A66:  MOVLW  0A
02A68:  MOVWF  xFC
.................... { 
....................     unsigned int16 ui162ndAPIParameter = 0; 
....................     unsigned int16 ui163rdAPIParameter = 0; 
....................     unsigned int8  ui8Multiplier       = 10; 
....................  
....................      
....................     // Accumulate individual data from HMI for server API string. 
....................     // Take basic material and standard of production. 
....................     ui162ndAPIParameter = g_ui8BasicMaterialStandard; 
02A6A:  CLRF   xF9
02A6C:  MOVFF  4F2,BF8
....................      
....................     // Now combine specification of that standard used. 
....................     if(g_ui8StandardSpecification <= 9) 
02A70:  MOVLB  4
02A72:  MOVF   xF3,W
02A74:  SUBLW  09
02A76:  BNC   2A82
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02A78:  MOVLW  0A
02A7A:  MOVLB  B
02A7C:  MOVWF  xFC
....................          
....................     } 
02A7E:  BRA    2A8E
02A80:  MOVLB  4
....................     else if(g_ui8StandardSpecification <= 99) 
02A82:  MOVF   xF3,W
02A84:  SUBLW  63
02A86:  BNC   2A90
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02A88:  MOVLW  64
02A8A:  MOVLB  B
02A8C:  MOVWF  xFC
....................     } 
02A8E:  MOVLB  4
02A90:  CLRF   19
02A92:  BTFSC  FF2.7
02A94:  BSF    19.7
02A96:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................      
....................     // Combine the two specification. 
....................     ui162ndAPIParameter = ui162ndAPIParameter * ui8Multiplier; 
02A98:  MOVFF  BF9,C2D
02A9C:  MOVFF  BF8,C2C
02AA0:  MOVLB  C
02AA2:  CLRF   x2F
02AA4:  MOVFF  BFC,C2E
02AA8:  MOVLB  0
02AAA:  CALL   0426
02AAE:  BTFSC  19.7
02AB0:  BSF    FF2.7
02AB2:  MOVFF  02,BF9
02AB6:  MOVFF  01,BF8
....................     ui162ndAPIParameter = ui162ndAPIParameter + g_ui8StandardSpecification; 
02ABA:  MOVLB  4
02ABC:  MOVF   xF3,W
02ABE:  MOVLB  B
02AC0:  ADDWF  xF8,F
02AC2:  MOVLW  00
02AC4:  ADDWFC xF9,F
....................  
....................     // Now combine Pressure rating specification used for for that standard. 
....................     if(g_ui8PressureRating <= 9) 
02AC6:  MOVLB  4
02AC8:  MOVF   xF4,W
02ACA:  SUBLW  09
02ACC:  BNC   2AD8
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02ACE:  MOVLW  0A
02AD0:  MOVLB  B
02AD2:  MOVWF  xFC
....................          
....................     } 
02AD4:  BRA    2AE4
02AD6:  MOVLB  4
....................     else if(g_ui8PressureRating <= 99) 
02AD8:  MOVF   xF4,W
02ADA:  SUBLW  63
02ADC:  BNC   2AE6
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02ADE:  MOVLW  64
02AE0:  MOVLB  B
02AE2:  MOVWF  xFC
....................     } 
02AE4:  MOVLB  4
02AE6:  CLRF   19
02AE8:  BTFSC  FF2.7
02AEA:  BSF    19.7
02AEC:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     }     
....................      
....................     // Now combine pressure specification of that production. 
....................     ui162ndAPIParameter = ui162ndAPIParameter * ui8Multiplier; 
02AEE:  MOVFF  BF9,C2D
02AF2:  MOVFF  BF8,C2C
02AF6:  MOVLB  C
02AF8:  CLRF   x2F
02AFA:  MOVFF  BFC,C2E
02AFE:  MOVLB  0
02B00:  CALL   0426
02B04:  BTFSC  19.7
02B06:  BSF    FF2.7
02B08:  MOVFF  02,BF9
02B0C:  MOVFF  01,BF8
....................     ui162ndAPIParameter = ui162ndAPIParameter + g_ui8PressureRating; 
02B10:  MOVLB  4
02B12:  MOVF   xF4,W
02B14:  MOVLB  B
02B16:  ADDWF  xF8,F
02B18:  MOVLW  00
02B1A:  ADDWFC xF9,F
....................      
....................     // second parameter of API string is ready. 
....................     // Put it at GPRS message header. 
....................     g_stLANDataHeader.m_ui16BasicMaterialStandard = ui162ndAPIParameter; 
02B1C:  MOVFF  BF9,9B
02B20:  MOVFF  BF8,9A
....................      
....................     // Now make 3rd parameter of API string. 
....................     // Take pipe OD. 
....................     ui163rdAPIParameter = g_ui8PipeOD; 
02B24:  CLRF   xFB
02B26:  MOVFF  4F5,BFA
....................      
....................     // Now combine Pipe length used for for that standard. 
....................     if(g_ui8PipeLength <= 9) 
02B2A:  MOVLB  4
02B2C:  MOVF   xF6,W
02B2E:  SUBLW  09
02B30:  BNC   2B3C
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02B32:  MOVLW  0A
02B34:  MOVLB  B
02B36:  MOVWF  xFC
....................          
....................     } 
02B38:  BRA    2B48
02B3A:  MOVLB  4
....................     else if(g_ui8PipeLength <= 99) 
02B3C:  MOVF   xF6,W
02B3E:  SUBLW  63
02B40:  BNC   2B4A
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02B42:  MOVLW  64
02B44:  MOVLB  B
02B46:  MOVWF  xFC
....................     } 
02B48:  MOVLB  4
02B4A:  CLRF   19
02B4C:  BTFSC  FF2.7
02B4E:  BSF    19.7
02B50:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     }     
....................      
....................     // Now combine pipe length. 
....................     ui163rdAPIParameter = ui163rdAPIParameter * ui8Multiplier; 
02B52:  MOVFF  BFB,C2D
02B56:  MOVFF  BFA,C2C
02B5A:  MOVLB  C
02B5C:  CLRF   x2F
02B5E:  MOVFF  BFC,C2E
02B62:  MOVLB  0
02B64:  CALL   0426
02B68:  BTFSC  19.7
02B6A:  BSF    FF2.7
02B6C:  MOVFF  02,BFB
02B70:  MOVFF  01,BFA
....................     ui163rdAPIParameter = ui163rdAPIParameter + g_ui8PipeLength; 
02B74:  MOVLB  4
02B76:  MOVF   xF6,W
02B78:  MOVLB  B
02B7A:  ADDWF  xFA,F
02B7C:  MOVLW  00
02B7E:  ADDWFC xFB,F
....................      
....................     // Third parameter is ready. 
....................     // Put it in GPRS message header. 
....................     g_stLANDataHeader.m_ui16PipeSpecification = ui163rdAPIParameter; 
02B80:  MOVFF  BFB,9D
02B84:  MOVFF  BFA,9C
02B88:  MOVLB  0
02B8A:  GOTO   3C8C (RETURN)
....................      
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void SendMulResponseToMaster(unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow) 
*
01A90:  MOVLB  B
01A92:  CLRF   xFD
01A94:  CLRF   xFE
01A96:  MOVLB  C
01A98:  CLRF   x00
01A9A:  MOVLB  B
01A9C:  CLRF   xFF
.................... { 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................          
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
01A9E:  CLRF   03
01AA0:  MOVF   xFE,W
01AA2:  ADDLW  B0
01AA4:  MOVWF  FE9
01AA6:  MOVLW  0B
01AA8:  ADDWFC 03,W
01AAA:  MOVWF  FEA
01AAC:  MOVLW  01
01AAE:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AB0:  INCF   xFE,F
....................     // Stuff  the function code. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
01AB2:  CLRF   03
01AB4:  MOVF   xFE,W
01AB6:  ADDLW  B0
01AB8:  MOVWF  FE9
01ABA:  MOVLW  0B
01ABC:  ADDWFC 03,W
01ABE:  MOVWF  FEA
01AC0:  MOVLW  03
01AC2:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AC4:  INCF   xFE,F
....................     // Stuff number of data bytes to follow. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01AC6:  CLRF   03
01AC8:  MOVF   xFE,W
01ACA:  ADDLW  B0
01ACC:  MOVWF  FE9
01ACE:  MOVLW  0B
01AD0:  ADDWFC 03,W
01AD2:  MOVWF  FEA
01AD4:  MOVFF  BFC,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AD8:  INCF   xFE,F
....................  
....................     // For CBB Count. Register-> 560 & 561 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 8) & 0xFF); 
01ADA:  CLRF   03
01ADC:  MOVF   xFE,W
01ADE:  ADDLW  B0
01AE0:  MOVWF  FE9
01AE2:  MOVLW  0B
01AE4:  ADDWFC 03,W
01AE6:  MOVWF  FEA
01AE8:  MOVFF  4BF,00
01AEC:  MOVLB  C
01AEE:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AF2:  MOVLB  B
01AF4:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 0) & 0xFF); 
01AF6:  CLRF   03
01AF8:  MOVF   xFE,W
01AFA:  ADDLW  B0
01AFC:  MOVWF  FE9
01AFE:  MOVLW  0B
01B00:  ADDWFC 03,W
01B02:  MOVWF  FEA
01B04:  MOVFF  4BF,C04
01B08:  MOVFF  4BE,00
01B0C:  MOVLB  C
01B0E:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B12:  MOVLB  B
01B14:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01B16:  CLRF   03
01B18:  MOVF   xFE,W
01B1A:  ADDLW  B0
01B1C:  MOVWF  FE9
01B1E:  MOVLW  0B
01B20:  ADDWFC 03,W
01B22:  MOVWF  FEA
01B24:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B26:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01B28:  CLRF   03
01B2A:  MOVF   xFE,W
01B2C:  ADDLW  B0
01B2E:  MOVWF  FE9
01B30:  MOVLW  0B
01B32:  ADDWFC 03,W
01B34:  MOVWF  FEA
01B36:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B38:  INCF   xFE,F
....................      
....................     // For Current CBB Weight. Register-> 562 & 563 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32CurrentWt << 16) & 0xFFFF0000); 
01B3A:  MOVFF  4C3,BEB
01B3E:  MOVFF  4C2,BEA
01B42:  MOVLB  C
01B44:  CLRF   00
01B46:  CLRF   01
01B48:  MOVFF  01,BE9
01B4C:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01B50:  MOVFF  BEA,BE6
01B54:  MOVFF  BEB,BE7
01B58:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01B5A:  CLRF   03
01B5C:  MOVLB  B
01B5E:  MOVF   xFE,W
01B60:  ADDLW  B0
01B62:  MOVWF  FE9
01B64:  MOVLW  0B
01B66:  ADDWFC 03,W
01B68:  MOVWF  FEA
01B6A:  MOVFF  BE7,00
01B6E:  MOVLB  C
01B70:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B74:  MOVLB  B
01B76:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01B78:  CLRF   03
01B7A:  MOVF   xFE,W
01B7C:  ADDLW  B0
01B7E:  MOVWF  FE9
01B80:  MOVLW  0B
01B82:  ADDWFC 03,W
01B84:  MOVWF  FEA
01B86:  MOVFF  BE7,C04
01B8A:  MOVFF  BE6,00
01B8E:  MOVLB  C
01B90:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B94:  MOVLB  B
01B96:  INCF   xFE,F
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32CurrentWt >> 16) & 0xFFFF); 
01B98:  MOVFF  4C4,BE6
01B9C:  MOVFF  4C5,BE7
01BA0:  MOVLB  C
01BA2:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01BA4:  CLRF   03
01BA6:  MOVLB  B
01BA8:  MOVF   xFE,W
01BAA:  ADDLW  B0
01BAC:  MOVWF  FE9
01BAE:  MOVLW  0B
01BB0:  ADDWFC 03,W
01BB2:  MOVWF  FEA
01BB4:  MOVFF  BE7,00
01BB8:  MOVLB  C
01BBA:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BBE:  MOVLB  B
01BC0:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01BC2:  CLRF   03
01BC4:  MOVF   xFE,W
01BC6:  ADDLW  B0
01BC8:  MOVWF  FE9
01BCA:  MOVLW  0B
01BCC:  ADDWFC 03,W
01BCE:  MOVWF  FEA
01BD0:  MOVFF  BE7,C04
01BD4:  MOVFF  BE6,00
01BD8:  MOVLB  C
01BDA:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BDE:  MOVLB  B
01BE0:  INCF   xFE,F
....................  
....................     // For Pass CBB Status. Register-> 564 & 565 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 8) & 0xFF); 
01BE2:  CLRF   03
01BE4:  MOVF   xFE,W
01BE6:  ADDLW  B0
01BE8:  MOVWF  FE9
01BEA:  MOVLW  0B
01BEC:  ADDWFC 03,W
01BEE:  MOVWF  FEA
01BF0:  MOVFF  4C7,00
01BF4:  MOVLB  C
01BF6:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BFA:  MOVLB  B
01BFC:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 0) & 0xFF); 
01BFE:  CLRF   03
01C00:  MOVF   xFE,W
01C02:  ADDLW  B0
01C04:  MOVWF  FE9
01C06:  MOVLW  0B
01C08:  ADDWFC 03,W
01C0A:  MOVWF  FEA
01C0C:  MOVFF  4C7,C04
01C10:  MOVFF  4C6,00
01C14:  MOVLB  C
01C16:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C1A:  MOVLB  B
01C1C:  INCF   xFE,F
....................      
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01C1E:  CLRF   03
01C20:  MOVF   xFE,W
01C22:  ADDLW  B0
01C24:  MOVWF  FE9
01C26:  MOVLW  0B
01C28:  ADDWFC 03,W
01C2A:  MOVWF  FEA
01C2C:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C2E:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01C30:  CLRF   03
01C32:  MOVF   xFE,W
01C34:  ADDLW  B0
01C36:  MOVWF  FE9
01C38:  MOVLW  0B
01C3A:  ADDWFC 03,W
01C3C:  MOVWF  FEA
01C3E:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01C40:  INCF   xFE,F
....................  
....................     // For Production Running Average. Register-> 566 & 567 
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningAvgWt << 16) & 0xFFFF0000); 
01C42:  MOVFF  4C9,BEB
01C46:  MOVFF  4C8,BEA
01C4A:  MOVLB  C
01C4C:  CLRF   00
01C4E:  CLRF   01
01C50:  MOVFF  01,BE9
01C54:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01C58:  MOVFF  BEA,BE6
01C5C:  MOVFF  BEB,BE7
01C60:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01C62:  CLRF   03
01C64:  MOVLB  B
01C66:  MOVF   xFE,W
01C68:  ADDLW  B0
01C6A:  MOVWF  FE9
01C6C:  MOVLW  0B
01C6E:  ADDWFC 03,W
01C70:  MOVWF  FEA
01C72:  MOVFF  BE7,00
01C76:  MOVLB  C
01C78:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C7C:  MOVLB  B
01C7E:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01C80:  CLRF   03
01C82:  MOVF   xFE,W
01C84:  ADDLW  B0
01C86:  MOVWF  FE9
01C88:  MOVLW  0B
01C8A:  ADDWFC 03,W
01C8C:  MOVWF  FEA
01C8E:  MOVFF  BE7,C04
01C92:  MOVFF  BE6,00
01C96:  MOVLB  C
01C98:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C9C:  MOVLB  B
01C9E:  INCF   xFE,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningAvgWt >> 16) & 0xFFFF); 
01CA0:  MOVFF  4CA,BE6
01CA4:  MOVFF  4CB,BE7
01CA8:  MOVLB  C
01CAA:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01CAC:  CLRF   03
01CAE:  MOVLB  B
01CB0:  MOVF   xFE,W
01CB2:  ADDLW  B0
01CB4:  MOVWF  FE9
01CB6:  MOVLW  0B
01CB8:  ADDWFC 03,W
01CBA:  MOVWF  FEA
01CBC:  MOVFF  BE7,00
01CC0:  MOVLB  C
01CC2:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01CC6:  MOVLB  B
01CC8:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01CCA:  CLRF   03
01CCC:  MOVF   xFE,W
01CCE:  ADDLW  B0
01CD0:  MOVWF  FE9
01CD2:  MOVLW  0B
01CD4:  ADDWFC 03,W
01CD6:  MOVWF  FEA
01CD8:  MOVFF  BE7,C04
01CDC:  MOVFF  BE6,00
01CE0:  MOVLB  C
01CE2:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01CE6:  MOVLB  B
01CE8:  INCF   xFE,F
....................      
....................     // For Running Tare Weight. Register-> 568 & 569 
....................     // Example: If the four bytes are like 1234 then it will be filled as 3412  
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningTareValue << 16) & 0xFFFF0000); 
01CEA:  MOVFF  4CD,BEB
01CEE:  MOVFF  4CC,BEA
01CF2:  MOVLB  C
01CF4:  CLRF   00
01CF6:  CLRF   01
01CF8:  MOVFF  01,BE9
01CFC:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01D00:  MOVFF  BEA,BE6
01D04:  MOVFF  BEB,BE7
01D08:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01D0A:  CLRF   03
01D0C:  MOVLB  B
01D0E:  MOVF   xFE,W
01D10:  ADDLW  B0
01D12:  MOVWF  FE9
01D14:  MOVLW  0B
01D16:  ADDWFC 03,W
01D18:  MOVWF  FEA
01D1A:  MOVFF  BE7,00
01D1E:  MOVLB  C
01D20:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D24:  MOVLB  B
01D26:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01D28:  CLRF   03
01D2A:  MOVF   xFE,W
01D2C:  ADDLW  B0
01D2E:  MOVWF  FE9
01D30:  MOVLW  0B
01D32:  ADDWFC 03,W
01D34:  MOVWF  FEA
01D36:  MOVFF  BE7,C04
01D3A:  MOVFF  BE6,00
01D3E:  MOVLB  C
01D40:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D44:  MOVLB  B
01D46:  INCF   xFE,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningTareValue >> 16) & 0xFFFF); 
01D48:  MOVFF  4CE,BE6
01D4C:  MOVFF  4CF,BE7
01D50:  MOVLB  C
01D52:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF);; 
01D54:  CLRF   03
01D56:  MOVLB  B
01D58:  MOVF   xFE,W
01D5A:  ADDLW  B0
01D5C:  MOVWF  FE9
01D5E:  MOVLW  0B
01D60:  ADDWFC 03,W
01D62:  MOVWF  FEA
01D64:  MOVFF  BE7,00
01D68:  MOVLB  C
01D6A:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D6E:  MOVLB  B
01D70:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF);; 
01D72:  CLRF   03
01D74:  MOVF   xFE,W
01D76:  ADDLW  B0
01D78:  MOVWF  FE9
01D7A:  MOVLW  0B
01D7C:  ADDWFC 03,W
01D7E:  MOVWF  FEA
01D80:  MOVFF  BE7,C04
01D84:  MOVFF  BE6,00
01D88:  MOVLB  C
01D8A:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D8E:  MOVLB  B
01D90:  INCF   xFE,F
....................      
....................     // CRC calculation. 
....................     ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
01D92:  MOVLW  0B
01D94:  MOVLB  C
01D96:  MOVWF  x0C
01D98:  MOVLW  B0
01D9A:  MOVWF  x0B
01D9C:  MOVFF  BFE,C0D
01DA0:  MOVLB  0
01DA2:  CALL   0B30
01DA6:  MOVFF  02,C00
01DAA:  MOVFF  01,BFF
....................  
....................     // Stuff CRC 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
01DAE:  CLRF   03
01DB0:  MOVLB  B
01DB2:  MOVF   xFE,W
01DB4:  ADDLW  B0
01DB6:  MOVWF  FE9
01DB8:  MOVLW  0B
01DBA:  ADDWFC 03,W
01DBC:  MOVWF  FEA
01DBE:  MOVFF  BFF,00
01DC2:  MOVLB  C
01DC4:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;                 
01DC8:  MOVLB  B
01DCA:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01DCC:  CLRF   03
01DCE:  MOVF   xFE,W
01DD0:  ADDLW  B0
01DD2:  MOVWF  FE9
01DD4:  MOVLW  0B
01DD6:  ADDWFC 03,W
01DD8:  MOVWF  FEA
01DDA:  MOVLB  C
01DDC:  MOVFF  C00,00
01DE0:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01DE4:  MOVLB  B
01DE6:  INCF   xFE,F
....................      
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01DE8:  BSF    F7F.0
01DEA:  BCF    F87.0
....................     delay_ms(2); 
01DEC:  MOVLW  02
01DEE:  MOVLB  C
01DF0:  MOVWF  x0B
01DF2:  MOVLB  0
01DF4:  CALL   09F6
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01DF8:  MOVLB  B
01DFA:  CLRF   xFD
01DFC:  MOVF   xFE,W
01DFE:  SUBWF  xFD,W
01E00:  BC    1E22
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01E02:  CLRF   03
01E04:  MOVF   xFD,W
01E06:  ADDLW  B0
01E08:  MOVWF  FE9
01E0A:  MOVLW  0B
01E0C:  ADDWFC 03,W
01E0E:  MOVWF  FEA
01E10:  MOVFF  FEF,C01
01E14:  MOVLB  C
01E16:  MOVF   x01,W
01E18:  MOVLB  0
01E1A:  RCALL  179C
01E1C:  MOVLB  B
01E1E:  INCF   xFD,F
01E20:  BRA    1DFC
....................     } 
....................      
....................     delay_ms(3); 
01E22:  MOVLW  03
01E24:  MOVLB  C
01E26:  MOVWF  x0B
01E28:  MOVLB  0
01E2A:  CALL   09F6
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0);     
01E2E:  BCF    F7F.0
01E30:  BCF    F87.0
01E32:  GOTO   2DCA (RETURN)
....................      
.................... } 
....................  
.................... void SendResponseToMaster(unsigned int8 ui8ResponseType, unsigned int8 ui8FuncCode, unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow, int32 ui32RegData) 
*
017A8:  MOVLB  C
017AA:  CLRF   x04
017AC:  CLRF   x03
017AE:  CLRF   x06
017B0:  CLRF   x05
017B2:  CLRF   x07
017B4:  CLRF   x08
017B6:  CLRF   x0A
017B8:  CLRF   x09
.................... { 
....................     unsigned int16 ui16NoOfRegisterToFollow = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16RegisterData         = 0; 
....................      
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
017BA:  CLRF   03
017BC:  MOVF   x08,W
017BE:  ADDLW  B0
017C0:  MOVWF  FE9
017C2:  MOVLW  0B
017C4:  ADDWFC 03,W
017C6:  MOVWF  FEA
017C8:  MOVLW  01
017CA:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
017CC:  INCF   x08,F
....................      
....................     // Step 1: Parse response type 
....................     if(MODBUS_RESPONSE_TO_MASTER_FOR_READ == ui8ResponseType) 
017CE:  MOVLB  B
017D0:  MOVF   xFA,W
017D2:  SUBLW  09
017D4:  BTFSS  FD8.2
017D6:  BRA    193A
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
017D8:  MOVF   xFB,W
017DA:  XORLW  03
017DC:  MOVLB  0
017DE:  BZ    17E2
017E0:  BRA    1934
....................         { 
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Stuff  the function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
017E2:  CLRF   03
017E4:  MOVLB  C
017E6:  MOVF   x08,W
017E8:  ADDLW  B0
017EA:  MOVWF  FE9
017EC:  MOVLW  0B
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVLW  03
017F4:  MOVWF  FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
017F6:  INCF   x08,F
....................                  
....................                 // Parse the no of registers to response 
....................                 if(2 == ui8DataBytesToFollow) // For WORD. 
017F8:  MOVLB  B
017FA:  MOVF   xFE,W
017FC:  SUBLW  02
017FE:  BNZ   1852
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01800:  CLRF   03
01802:  MOVLB  C
01804:  MOVF   x08,W
01806:  ADDLW  B0
01808:  MOVWF  FE9
0180A:  MOVLW  0B
0180C:  ADDWFC 03,W
0180E:  MOVWF  FEA
01810:  MOVFF  BFE,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
01814:  INCF   x08,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData); 
01816:  MOVFF  C00,C0A
0181A:  MOVFF  BFF,C09
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
0181E:  CLRF   03
01820:  MOVF   x08,W
01822:  ADDLW  B0
01824:  MOVWF  FE9
01826:  MOVLW  0B
01828:  ADDWFC 03,W
0182A:  MOVWF  FEA
0182C:  MOVFF  C0A,00
01830:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
01834:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
01836:  CLRF   03
01838:  MOVF   x08,W
0183A:  ADDLW  B0
0183C:  MOVWF  FE9
0183E:  MOVLW  0B
01840:  ADDWFC 03,W
01842:  MOVWF  FEA
01844:  MOVFF  C09,00
01848:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
0184C:  INCF   x08,F
....................                 } 
0184E:  BRA    18E0
01850:  MOVLB  B
....................                 else if(4 == ui8DataBytesToFollow) // For DOUBLE WORD 
01852:  MOVF   xFE,W
01854:  SUBLW  04
01856:  BNZ   18E2
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01858:  CLRF   03
0185A:  MOVLB  C
0185C:  MOVF   x08,W
0185E:  ADDLW  B0
01860:  MOVWF  FE9
01862:  MOVLW  0B
01864:  ADDWFC 03,W
01866:  MOVWF  FEA
01868:  MOVFF  BFE,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
0186C:  INCF   x08,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData);  // 1st WORD of the DOUBLE WORD 
0186E:  MOVFF  C00,C0A
01872:  MOVFF  BFF,C09
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
01876:  CLRF   03
01878:  MOVF   x08,W
0187A:  ADDLW  B0
0187C:  MOVWF  FE9
0187E:  MOVLW  0B
01880:  ADDWFC 03,W
01882:  MOVWF  FEA
01884:  MOVFF  C0A,00
01888:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
0188C:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
0188E:  CLRF   03
01890:  MOVF   x08,W
01892:  ADDLW  B0
01894:  MOVWF  FE9
01896:  MOVLW  0B
01898:  ADDWFC 03,W
0189A:  MOVWF  FEA
0189C:  MOVFF  C09,00
018A0:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;  
018A4:  INCF   x08,F
....................                     ui16RegisterData = (unsigned int16)(ui32RegData >> 16);  // 2nd WORD of the DOUBLE WORD 
018A6:  MOVFF  C01,C09
018AA:  MOVFF  C02,C0A
018AE:  CLRF   03
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
018B0:  CLRF   03
018B2:  MOVF   x08,W
018B4:  ADDLW  B0
018B6:  MOVWF  FE9
018B8:  MOVLW  0B
018BA:  ADDWFC 03,W
018BC:  MOVWF  FEA
018BE:  MOVFF  C0A,00
018C2:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
018C6:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
018C8:  CLRF   03
018CA:  MOVF   x08,W
018CC:  ADDLW  B0
018CE:  MOVWF  FE9
018D0:  MOVLW  0B
018D2:  ADDWFC 03,W
018D4:  MOVWF  FEA
018D6:  MOVFF  C09,00
018DA:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
018DE:  INCF   x08,F
....................                 } 
018E0:  MOVLB  B
....................                 else 
....................                 { 
....................                     /* Do Nothing */ 
....................                 }  
....................                  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
018E2:  MOVLW  0B
018E4:  MOVLB  C
018E6:  MOVWF  x0C
018E8:  MOVLW  B0
018EA:  MOVWF  x0B
018EC:  MOVFF  C08,C0D
018F0:  MOVLB  0
018F2:  CALL   0B30
018F6:  MOVFF  02,C06
018FA:  MOVFF  01,C05
....................                  
....................                 // Stuff CRC value. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
018FE:  CLRF   03
01900:  MOVLB  C
01902:  MOVF   x08,W
01904:  ADDLW  B0
01906:  MOVWF  FE9
01908:  MOVLW  0B
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVFF  C05,00
01912:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01916:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01918:  CLRF   03
0191A:  MOVF   x08,W
0191C:  ADDLW  B0
0191E:  MOVWF  FE9
01920:  MOVLW  0B
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  MOVFF  C06,00
0192A:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0192E:  INCF   x08,F
....................                 break; 
01930:  BRA    1936
01932:  MOVLB  0
....................             default: 
....................                 break; 
01934:  MOVLB  C
....................         } 
....................     } 
01936:  BRA    1A4A
01938:  MOVLB  B
....................     else // Respond against write. 
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
0193A:  MOVF   xFB,W
0193C:  XORLW  06
0193E:  MOVLB  0
01940:  BZ    1948
01942:  XORLW  16
01944:  BZ    196E
01946:  BRA    1A46
....................         { 
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Stuff reply in RS485 transmit buffer. 
....................                 memcpy(g_ui8RS485Txbuffer, g_ui8RS485Rxbuffer, g_ui8RS485RxByteCount); 
01948:  MOVLW  0B
0194A:  MOVWF  FEA
0194C:  MOVLW  B0
0194E:  MOVWF  FE9
01950:  MOVLW  0B
01952:  MOVWF  FE2
01954:  MOVLW  7E
01956:  MOVWF  FE1
01958:  MOVLB  B
0195A:  MOVF   xE2,W
0195C:  MOVWF  01
0195E:  BZ    1968
01960:  MOVFF  FE6,FEE
01964:  DECFSZ 01,F
01966:  BRA    1960
....................                 ui8DataBytesToSend = g_ui8RS485RxByteCount; 
01968:  MOVFF  BE2,C08
....................                 break; 
0196C:  BRA    1A48
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Stuff function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8FuncCode; 
0196E:  CLRF   03
01970:  MOVLB  C
01972:  MOVF   x08,W
01974:  ADDLW  B0
01976:  MOVWF  FE9
01978:  MOVLW  0B
0197A:  ADDWFC 03,W
0197C:  MOVWF  FEA
0197E:  MOVFF  BFB,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
01982:  INCF   x08,F
....................                  
....................                 // Stuff data address of the first register. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
01984:  CLRF   03
01986:  MOVF   x08,W
01988:  ADDLW  B0
0198A:  MOVWF  FE9
0198C:  MOVLW  0B
0198E:  ADDWFC 03,W
01990:  MOVWF  FEA
01992:  MOVFF  BFD,00
01996:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0199A:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); 
0199C:  CLRF   03
0199E:  MOVF   x08,W
019A0:  ADDLW  B0
019A2:  MOVWF  FE9
019A4:  MOVLW  0B
019A6:  ADDWFC 03,W
019A8:  MOVWF  FEA
019AA:  MOVFF  BFD,C0E
019AE:  MOVFF  BFC,00
019B2:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019B6:  INCF   x08,F
....................  
....................                 // Stuff no of registers written. 
....................                 ui16NoOfRegisterToFollow = (unsigned int16)(ui8DataBytesToFollow / 2); 
019B8:  BCF    FD8.0
019BA:  MOVLB  B
019BC:  RRCF   xFE,W
019BE:  MOVLB  C
019C0:  CLRF   x04
019C2:  MOVWF  x03
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 8) & 0xFF); 
019C4:  CLRF   03
019C6:  MOVF   x08,W
019C8:  ADDLW  B0
019CA:  MOVWF  FE9
019CC:  MOVLW  0B
019CE:  ADDWFC 03,W
019D0:  MOVWF  FEA
019D2:  MOVFF  C04,00
019D6:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019DA:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 0) & 0xFF); 
019DC:  CLRF   03
019DE:  MOVF   x08,W
019E0:  ADDLW  B0
019E2:  MOVWF  FE9
019E4:  MOVLW  0B
019E6:  ADDWFC 03,W
019E8:  MOVWF  FEA
019EA:  MOVFF  C03,00
019EE:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019F2:  INCF   x08,F
....................  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, 6); 
019F4:  MOVLW  0B
019F6:  MOVWF  x0C
019F8:  MOVLW  B0
019FA:  MOVWF  x0B
019FC:  MOVLW  06
019FE:  MOVWF  x0D
01A00:  MOVLB  0
01A02:  CALL   0B30
01A06:  MOVFF  02,C06
01A0A:  MOVFF  01,C05
....................                  
....................                 // Stuff CRC 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
01A0E:  CLRF   03
01A10:  MOVLB  C
01A12:  MOVF   x08,W
01A14:  ADDLW  B0
01A16:  MOVWF  FE9
01A18:  MOVLW  0B
01A1A:  ADDWFC 03,W
01A1C:  MOVWF  FEA
01A1E:  MOVFF  C05,00
01A22:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A26:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01A28:  CLRF   03
01A2A:  MOVF   x08,W
01A2C:  ADDLW  B0
01A2E:  MOVWF  FE9
01A30:  MOVLW  0B
01A32:  ADDWFC 03,W
01A34:  MOVWF  FEA
01A36:  MOVFF  C06,00
01A3A:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A3E:  INCF   x08,F
....................                  
....................                 break; 
01A40:  MOVLB  B
01A42:  BRA    1A48
01A44:  MOVLB  0
....................             default: 
....................                 break; 
01A46:  MOVLB  B
01A48:  MOVLB  C
....................         } 
....................     } 
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01A4A:  BSF    F7F.0
01A4C:  BCF    F87.0
....................     delay_ms(2); 
01A4E:  MOVLW  02
01A50:  MOVWF  x0B
01A52:  MOVLB  0
01A54:  CALL   09F6
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01A58:  MOVLB  C
01A5A:  CLRF   x07
01A5C:  MOVF   x08,W
01A5E:  SUBWF  x07,W
01A60:  BC    1A80
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01A62:  CLRF   03
01A64:  MOVF   x07,W
01A66:  ADDLW  B0
01A68:  MOVWF  FE9
01A6A:  MOVLW  0B
01A6C:  ADDWFC 03,W
01A6E:  MOVWF  FEA
01A70:  MOVFF  FEF,C0B
01A74:  MOVF   x0B,W
01A76:  MOVLB  0
01A78:  RCALL  179C
01A7A:  MOVLB  C
01A7C:  INCF   x07,F
01A7E:  BRA    1A5C
....................     } 
....................      
....................     delay_ms(3); 
01A80:  MOVLW  03
01A82:  MOVWF  x0B
01A84:  MOVLB  0
01A86:  CALL   09F6
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0); 
01A8A:  BCF    F7F.0
01A8C:  BCF    F87.0
01A8E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void ProcessUART2ReceivedData(void) 
*
02B8E:  MOVLB  B
02B90:  CLRF   xEE
02B92:  CLRF   xED
02B94:  CLRF   xEF
02B96:  CLRF   xF1
02B98:  CLRF   xF0
02B9A:  CLRF   xF3
02B9C:  CLRF   xF2
02B9E:  CLRF   xF4
02BA0:  CLRF   xF5
02BA2:  CLRF   xF6
02BA4:  MOVLW  06
02BA6:  MOVWF  xF7
.................... { 
....................     unsigned int16 ui16ModbusCRCvalue       = 0; 
....................     unsigned int8  fIsValidCRC              = 0; 
....................     unsigned int16 ui16StartAddtess         = 0; 
....................     unsigned int16 ui16NoOfRegistersToRead  = 0; 
....................     unsigned int8  ui8LoopCount             = 0; 
....................     unsigned int8  ui8NoOfDataBytesToFollow = 0; 
....................     unsigned int8  ui8NoOfVariety           = 0; 
....................     unsigned int8  ui8WriteMulRegParseByteIndx = 6; 
....................      
....................  
....................     // Calculate CRC for data redundancy check. 
....................     // Calculate CRC with all bytes except last two. 
....................     ui16ModbusCRCvalue = calculateCrc(g_ui8RS485Rxbuffer, (g_ui8RS485RxByteCount - 2));     
02BA8:  MOVLW  02
02BAA:  SUBWF  xE2,W
02BAC:  MOVWF  xF8
02BAE:  MOVLW  0B
02BB0:  MOVLB  C
02BB2:  MOVWF  x0C
02BB4:  MOVLW  7E
02BB6:  MOVWF  x0B
02BB8:  MOVFF  BF8,C0D
02BBC:  MOVLB  0
02BBE:  CALL   0B30
02BC2:  MOVFF  02,BEE
02BC6:  MOVFF  01,BED
....................      
....................     // Validate CRC. 
....................     if(((ui16ModbusCRCvalue >> 8) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1] && 
....................        ((ui16ModbusCRCvalue >> 0) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 2]) 
02BCA:  MOVFF  BEE,BF8
02BCE:  MOVLB  B
02BD0:  CLRF   xF9
02BD2:  MOVLW  01
02BD4:  SUBWF  xE2,W
02BD6:  CLRF   03
02BD8:  ADDLW  7E
02BDA:  MOVWF  FE9
02BDC:  MOVLW  0B
02BDE:  ADDWFC 03,W
02BE0:  MOVWF  FEA
02BE2:  MOVF   FEF,W
02BE4:  SUBWF  xEE,W
02BE6:  BNZ   2C12
02BE8:  MOVF   xF9,F
02BEA:  BNZ   2C12
02BEC:  MOVFF  BED,BF8
02BF0:  CLRF   xF9
02BF2:  MOVLW  02
02BF4:  SUBWF  xE2,W
02BF6:  CLRF   03
02BF8:  ADDLW  7E
02BFA:  MOVWF  FE9
02BFC:  MOVLW  0B
02BFE:  ADDWFC 03,W
02C00:  MOVWF  FEA
02C02:  MOVF   FEF,W
02C04:  SUBWF  xED,W
02C06:  BNZ   2C12
02C08:  MOVF   xF9,F
02C0A:  BNZ   2C12
....................     { 
....................         // Set flag denoting received byte string CRC validation successful. 
....................         fIsValidCRC = 1; 
02C0C:  MOVLW  01
02C0E:  MOVWF  xEF
....................     } 
02C10:  BRA    2C1A
....................     else 
....................     { 
....................         // Error occured in received data bytes 
....................         ResetRS485RXBuffer(); 
02C12:  MOVLB  0
02C14:  CALL   1780
02C18:  MOVLB  B
....................     } 
....................      
....................     // If CRC validation turns out to true. 
....................     if(fIsValidCRC) 
02C1A:  MOVF   xEF,F
02C1C:  BTFSC  FD8.2
02C1E:  GOTO   3C90
....................     { 
....................         // Parse function code and process accordingly. 
....................         switch(g_ui8RS485Rxbuffer[1]) 
02C22:  MOVF   x7F,W
02C24:  XORLW  01
02C26:  MOVLB  0
02C28:  BZ    2C40
02C2A:  XORLW  02
02C2C:  BZ    2C44
02C2E:  XORLW  05
02C30:  BTFSC  FD8.2
02C32:  BRA    2FCC
02C34:  XORLW  16
02C36:  BTFSC  FD8.2
02C38:  GOTO   38D2
02C3C:  GOTO   3C8E
....................         { 
....................             case MODBUS_FNCODE_READ_COIL_STATUS: 
....................                  
....................                 break; 
02C40:  GOTO   3C8E
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02C44:  MOVLB  B
02C46:  CLRF   xF1
02C48:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02C4C:  MOVFF  BF0,BF1
02C50:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02C52:  MOVF   x81,W
02C54:  IORWF  xF0,F
....................  
....................                 // Process the data at that address. 
....................                 switch(ui16StartAddtess) 
02C56:  MOVF   xF0,W
02C58:  MOVWF  00
02C5A:  MOVF   xF1,W
02C5C:  MOVWF  03
02C5E:  MOVLW  02
02C60:  SUBWF  03,W
02C62:  BNZ   2C6E
02C64:  MOVLW  96
02C66:  SUBWF  00,W
02C68:  MOVLB  0
02C6A:  BZ    2CFA
02C6C:  MOVLB  B
02C6E:  MOVLW  02
02C70:  SUBWF  03,W
02C72:  BNZ   2C7E
02C74:  MOVLW  98
02C76:  SUBWF  00,W
02C78:  MOVLB  0
02C7A:  BZ    2D46
02C7C:  MOVLB  B
02C7E:  MOVLW  05
02C80:  SUBWF  03,W
02C82:  BNZ   2C90
02C84:  MOVLW  60
02C86:  SUBWF  00,W
02C88:  MOVLB  0
02C8A:  BTFSC  FD8.2
02C8C:  BRA    2D92
02C8E:  MOVLB  B
02C90:  MOVLW  05
02C92:  SUBWF  03,W
02C94:  BNZ   2CA2
02C96:  MOVLW  62
02C98:  SUBWF  00,W
02C9A:  MOVLB  0
02C9C:  BTFSC  FD8.2
02C9E:  BRA    2E06
02CA0:  MOVLB  B
02CA2:  MOVLW  05
02CA4:  SUBWF  03,W
02CA6:  BNZ   2CB4
02CA8:  MOVLW  66
02CAA:  SUBWF  00,W
02CAC:  MOVLB  0
02CAE:  BTFSC  FD8.2
02CB0:  BRA    2E52
02CB2:  MOVLB  B
02CB4:  MOVLW  05
02CB6:  SUBWF  03,W
02CB8:  BNZ   2CC6
02CBA:  MOVLW  68
02CBC:  SUBWF  00,W
02CBE:  MOVLB  0
02CC0:  BTFSC  FD8.2
02CC2:  BRA    2E9E
02CC4:  MOVLB  B
02CC6:  MOVLW  05
02CC8:  SUBWF  03,W
02CCA:  BNZ   2CD8
02CCC:  MOVLW  64
02CCE:  SUBWF  00,W
02CD0:  MOVLB  0
02CD2:  BTFSC  FD8.2
02CD4:  BRA    2EEA
02CD6:  MOVLB  B
02CD8:  MOVF   03,W
02CDA:  BNZ   2CE8
02CDC:  MOVLW  88
02CDE:  SUBWF  00,W
02CE0:  MOVLB  0
02CE2:  BTFSC  FD8.2
02CE4:  BRA    2F34
02CE6:  MOVLB  B
02CE8:  MOVF   03,W
02CEA:  BNZ   2CF8
02CEC:  MOVLW  65
02CEE:  SUBWF  00,W
02CF0:  MOVLB  0
02CF2:  BTFSC  FD8.2
02CF4:  BRA    2F7C
02CF6:  MOVLB  B
02CF8:  BRA    2FC6
....................                 { 
....................                     case ADDRESS_FOR_CALIB_TARE_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02CFA:  MOVLB  B
02CFC:  CLRF   xF3
02CFE:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D02:  MOVFF  BF2,BF3
02D06:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);   
02D08:  MOVF   x83,W
02D0A:  IORWF  xF2,F
....................  
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32TareADCValueForCalibration); 
02D0C:  BCF    FD8.0
02D0E:  RLCF   xF2,W
02D10:  MOVWF  xF8
02D12:  RLCF   xF3,W
02D14:  MOVWF  xF9
02D16:  MOVLW  09
02D18:  MOVWF  xFA
02D1A:  MOVLW  03
02D1C:  MOVWF  xFB
02D1E:  MOVFF  BF1,BFD
02D22:  MOVFF  BF0,BFC
02D26:  MOVFF  BF8,BFE
02D2A:  MOVFF  4B9,C02
02D2E:  MOVFF  4B8,C01
02D32:  MOVFF  4B7,C00
02D36:  MOVFF  4B6,BFF
02D3A:  MOVLB  0
02D3C:  CALL   17A8
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02D40:  CALL   1780
....................                          
....................                         break; 
02D44:  BRA    2FC8
....................                     case ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02D46:  MOVLB  B
02D48:  CLRF   xF3
02D4A:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D4E:  MOVFF  BF2,BF3
02D52:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02D54:  MOVF   x83,W
02D56:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32gWeightADCValueForCalibration);                         
02D58:  BCF    FD8.0
02D5A:  RLCF   xF2,W
02D5C:  MOVWF  xF8
02D5E:  RLCF   xF3,W
02D60:  MOVWF  xF9
02D62:  MOVLW  09
02D64:  MOVWF  xFA
02D66:  MOVLW  03
02D68:  MOVWF  xFB
02D6A:  MOVFF  BF1,BFD
02D6E:  MOVFF  BF0,BFC
02D72:  MOVFF  BF8,BFE
02D76:  MOVFF  4BD,C02
02D7A:  MOVFF  4BC,C01
02D7E:  MOVFF  4BB,C00
02D82:  MOVFF  4BA,BFF
02D86:  MOVLB  0
02D88:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02D8C:  CALL   1780
....................                          
....................                         break; 
02D90:  BRA    2FC8
....................                     case ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02D92:  MOVLB  B
02D94:  CLRF   xF3
02D96:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D9A:  MOVFF  BF2,BF3
02D9E:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02DA0:  MOVF   x83,W
02DA2:  IORWF  xF2,F
....................  
....................                         // Check for number of registers requested for. 
....................                         if(ui16NoOfRegistersToRead > 1) 
02DA4:  MOVF   xF3,F
02DA6:  BNZ   2DAE
02DA8:  MOVF   xF2,W
02DAA:  SUBLW  01
02DAC:  BC    2DCE
....................                         { 
....................                             // Step 2: Send response to master with requested data. 
....................                             SendMulResponseToMaster(ui16StartAddtess, (ui16NoOfRegistersToRead * 2)); 
02DAE:  BCF    FD8.0
02DB0:  RLCF   xF2,W
02DB2:  MOVWF  xF8
02DB4:  RLCF   xF3,W
02DB6:  MOVWF  xF9
02DB8:  MOVFF  BF1,BFB
02DBC:  MOVFF  BF0,BFA
02DC0:  MOVFF  BF8,BFC
02DC4:  MOVLB  0
02DC6:  GOTO   1A90
....................                         } 
02DCA:  BRA    2E00
02DCC:  MOVLB  B
....................                         else 
....................                         {                         
....................                             // Step 2: Send response to master with requested data. 
....................                             SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16PipeCount);                                                 
02DCE:  BCF    FD8.0
02DD0:  RLCF   xF2,W
02DD2:  MOVWF  xF8
02DD4:  RLCF   xF3,W
02DD6:  MOVWF  xF9
02DD8:  MOVLW  09
02DDA:  MOVWF  xFA
02DDC:  MOVLW  03
02DDE:  MOVWF  xFB
02DE0:  MOVFF  BF1,BFD
02DE4:  MOVFF  BF0,BFC
02DE8:  MOVFF  BF8,BFE
02DEC:  MOVLB  C
02DEE:  CLRF   x02
02DF0:  CLRF   x01
02DF2:  MOVFF  4BF,C00
02DF6:  MOVFF  4BE,BFF
02DFA:  MOVLB  0
02DFC:  CALL   17A8
....................                         } 
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E00:  CALL   1780
....................                          
....................                         break; 
02E04:  BRA    2FC8
....................                     case ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02E06:  MOVLB  B
02E08:  CLRF   xF3
02E0A:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02E0E:  MOVFF  BF2,BF3
02E12:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02E14:  MOVF   x83,W
02E16:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32CurrentWt);                                                                         
02E18:  BCF    FD8.0
02E1A:  RLCF   xF2,W
02E1C:  MOVWF  xF8
02E1E:  RLCF   xF3,W
02E20:  MOVWF  xF9
02E22:  MOVLW  09
02E24:  MOVWF  xFA
02E26:  MOVLW  03
02E28:  MOVWF  xFB
02E2A:  MOVFF  BF1,BFD
02E2E:  MOVFF  BF0,BFC
02E32:  MOVFF  BF8,BFE
02E36:  MOVFF  4C5,C02
02E3A:  MOVFF  4C4,C01
02E3E:  MOVFF  4C3,C00
02E42:  MOVFF  4C2,BFF
02E46:  MOVLB  0
02E48:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E4C:  CALL   1780
....................                          
....................                         break; 
02E50:  BRA    2FC8
....................                     case ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02E52:  MOVLB  B
02E54:  CLRF   xF3
02E56:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02E5A:  MOVFF  BF2,BF3
02E5E:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02E60:  MOVF   x83,W
02E62:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningAvgWt);                                                                         
02E64:  BCF    FD8.0
02E66:  RLCF   xF2,W
02E68:  MOVWF  xF8
02E6A:  RLCF   xF3,W
02E6C:  MOVWF  xF9
02E6E:  MOVLW  09
02E70:  MOVWF  xFA
02E72:  MOVLW  03
02E74:  MOVWF  xFB
02E76:  MOVFF  BF1,BFD
02E7A:  MOVFF  BF0,BFC
02E7E:  MOVFF  BF8,BFE
02E82:  MOVFF  4CB,C02
02E86:  MOVFF  4CA,C01
02E8A:  MOVFF  4C9,C00
02E8E:  MOVFF  4C8,BFF
02E92:  MOVLB  0
02E94:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E98:  CALL   1780
....................                          
....................                         break; 
02E9C:  BRA    2FC8
....................                     case ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02E9E:  MOVLB  B
02EA0:  CLRF   xF3
02EA2:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02EA6:  MOVFF  BF2,BF3
02EAA:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02EAC:  MOVF   x83,W
02EAE:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningTareValue);                                                                         
02EB0:  BCF    FD8.0
02EB2:  RLCF   xF2,W
02EB4:  MOVWF  xF8
02EB6:  RLCF   xF3,W
02EB8:  MOVWF  xF9
02EBA:  MOVLW  09
02EBC:  MOVWF  xFA
02EBE:  MOVLW  03
02EC0:  MOVWF  xFB
02EC2:  MOVFF  BF1,BFD
02EC6:  MOVFF  BF0,BFC
02ECA:  MOVFF  BF8,BFE
02ECE:  MOVFF  4CF,C02
02ED2:  MOVFF  4CE,C01
02ED6:  MOVFF  4CD,C00
02EDA:  MOVFF  4CC,BFF
02EDE:  MOVLB  0
02EE0:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02EE4:  CALL   1780
....................                          
....................                         break; 
02EE8:  BRA    2FC8
....................                     case ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02EEA:  MOVLB  B
02EEC:  CLRF   xF3
02EEE:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02EF2:  MOVFF  BF2,BF3
02EF6:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02EF8:  MOVF   x83,W
02EFA:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16CurrentPassStatus);                                                                         
02EFC:  BCF    FD8.0
02EFE:  RLCF   xF2,W
02F00:  MOVWF  xF8
02F02:  RLCF   xF3,W
02F04:  MOVWF  xF9
02F06:  MOVLW  09
02F08:  MOVWF  xFA
02F0A:  MOVLW  03
02F0C:  MOVWF  xFB
02F0E:  MOVFF  BF1,BFD
02F12:  MOVFF  BF0,BFC
02F16:  MOVFF  BF8,BFE
02F1A:  MOVLB  C
02F1C:  CLRF   x02
02F1E:  CLRF   x01
02F20:  MOVFF  4C7,C00
02F24:  MOVFF  4C6,BFF
02F28:  MOVLB  0
02F2A:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
02F2E:  CALL   1780
....................                         break; 
02F32:  BRA    2FC8
....................                     case ADDRESS_FOR_TOL_STORE_SEEKING_ACK: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02F34:  MOVLB  B
02F36:  CLRF   xF3
02F38:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02F3C:  MOVFF  BF2,BF3
02F40:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);                         
02F42:  MOVF   x83,W
02F44:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8ToleranceStoreAck); 
02F46:  BCF    FD8.0
02F48:  RLCF   xF2,W
02F4A:  MOVWF  xF8
02F4C:  RLCF   xF3,W
02F4E:  MOVWF  xF9
02F50:  MOVLW  09
02F52:  MOVWF  xFA
02F54:  MOVLW  03
02F56:  MOVWF  xFB
02F58:  MOVFF  BF1,BFD
02F5C:  MOVFF  BF0,BFC
02F60:  MOVFF  BF8,BFE
02F64:  MOVLB  C
02F66:  CLRF   x02
02F68:  CLRF   x01
02F6A:  CLRF   x00
02F6C:  MOVFF  4DD,BFF
02F70:  MOVLB  0
02F72:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                          
02F76:  CALL   1780
....................                         break; 
02F7A:  BRA    2FC8
....................                     case ADDRESS_FOR_AIR_PRESSURE_ALARM: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02F7C:  MOVLB  B
02F7E:  CLRF   xF3
02F80:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02F84:  MOVFF  BF2,BF3
02F88:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02F8A:  MOVF   x83,W
02F8C:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8AirPressureAlarm); 
02F8E:  BCF    FD8.0
02F90:  RLCF   xF2,W
02F92:  MOVWF  xF8
02F94:  RLCF   xF3,W
02F96:  MOVWF  xF9
02F98:  MOVLW  09
02F9A:  MOVWF  xFA
02F9C:  MOVLW  03
02F9E:  MOVWF  xFB
02FA0:  MOVFF  BF1,BFD
02FA4:  MOVFF  BF0,BFC
02FA8:  MOVFF  BF8,BFE
02FAC:  MOVLB  C
02FAE:  CLRF   x02
02FB0:  CLRF   x01
02FB2:  CLRF   x00
02FB4:  MOVFF  4EE,BFF
02FB8:  MOVLB  0
02FBA:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02FBE:  CALL   1780
....................                         break;                         
02FC2:  BRA    2FC8
02FC4:  MOVLB  B
....................                     default: 
....................                         break; 
02FC6:  MOVLB  0
....................                 } 
....................                 break; 
02FC8:  GOTO   3C8E
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02FCC:  MOVLB  B
02FCE:  CLRF   xF1
02FD0:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02FD4:  MOVFF  BF0,BF1
02FD8:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02FDA:  MOVF   x81,W
02FDC:  IORWF  xF0,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
02FDE:  MOVF   xF0,W
02FE0:  MOVWF  00
02FE2:  MOVF   xF1,W
02FE4:  MOVWF  03
02FE6:  MOVLW  02
02FE8:  SUBWF  03,W
02FEA:  BNZ   2FF8
02FEC:  MOVLW  82
02FEE:  SUBWF  00,W
02FF0:  MOVLB  0
02FF2:  BTFSC  FD8.2
02FF4:  BRA    30F2
02FF6:  MOVLB  B
02FF8:  MOVF   03,W
02FFA:  BNZ   3008
02FFC:  MOVLW  05
02FFE:  SUBWF  00,W
03000:  MOVLB  0
03002:  BTFSC  FD8.2
03004:  BRA    31A2
03006:  MOVLB  B
03008:  MOVLW  02
0300A:  SUBWF  03,W
0300C:  BNZ   301A
0300E:  MOVLW  99
03010:  SUBWF  00,W
03012:  MOVLB  0
03014:  BTFSC  FD8.2
03016:  BRA    32C6
03018:  MOVLB  B
0301A:  MOVLW  05
0301C:  SUBWF  03,W
0301E:  BNZ   302C
03020:  MOVLW  52
03022:  SUBWF  00,W
03024:  MOVLB  0
03026:  BTFSC  FD8.2
03028:  BRA    3354
0302A:  MOVLB  B
0302C:  MOVLW  05
0302E:  SUBWF  03,W
03030:  BNZ   303E
03032:  MOVLW  54
03034:  SUBWF  00,W
03036:  MOVLB  0
03038:  BTFSC  FD8.2
0303A:  BRA    33A6
0303C:  MOVLB  B
0303E:  MOVF   03,W
03040:  BNZ   304E
03042:  MOVLW  99
03044:  SUBWF  00,W
03046:  MOVLB  0
03048:  BTFSC  FD8.2
0304A:  BRA    3456
0304C:  MOVLB  B
0304E:  MOVF   03,W
03050:  BNZ   305E
03052:  MOVLW  89
03054:  SUBWF  00,W
03056:  MOVLB  0
03058:  BTFSC  FD8.2
0305A:  BRA    34BE
0305C:  MOVLB  B
0305E:  MOVF   03,W
03060:  BNZ   306E
03062:  MOVLW  90
03064:  SUBWF  00,W
03066:  MOVLB  0
03068:  BTFSC  FD8.2
0306A:  BRA    34EE
0306C:  MOVLB  B
0306E:  MOVF   03,W
03070:  BNZ   307E
03072:  MOVLW  54
03074:  SUBWF  00,W
03076:  MOVLB  0
03078:  BTFSC  FD8.2
0307A:  BRA    352A
0307C:  MOVLB  B
0307E:  MOVF   03,W
03080:  BNZ   308E
03082:  MOVLW  58
03084:  SUBWF  00,W
03086:  MOVLB  0
03088:  BTFSC  FD8.2
0308A:  BRA    3562
0308C:  MOVLB  B
0308E:  MOVF   03,W
03090:  BNZ   309E
03092:  MOVLW  59
03094:  SUBWF  00,W
03096:  MOVLB  0
03098:  BTFSC  FD8.2
0309A:  BRA    3610
0309C:  MOVLB  B
0309E:  MOVF   03,W
030A0:  BNZ   30AE
030A2:  MOVLW  60
030A4:  SUBWF  00,W
030A6:  MOVLB  0
030A8:  BTFSC  FD8.2
030AA:  BRA    36C0
030AC:  MOVLB  B
030AE:  MOVF   03,W
030B0:  BNZ   30BE
030B2:  MOVLW  62
030B4:  SUBWF  00,W
030B6:  MOVLB  0
030B8:  BTFSC  FD8.2
030BA:  BRA    3770
030BC:  MOVLB  B
030BE:  MOVF   03,W
030C0:  BNZ   30CE
030C2:  MOVLW  63
030C4:  SUBWF  00,W
030C6:  MOVLB  0
030C8:  BTFSC  FD8.2
030CA:  BRA    37A0
030CC:  MOVLB  B
030CE:  MOVF   03,W
030D0:  BNZ   30DE
030D2:  MOVLW  64
030D4:  SUBWF  00,W
030D6:  MOVLB  0
030D8:  BTFSC  FD8.2
030DA:  BRA    37E6
030DC:  MOVLB  B
030DE:  MOVF   03,W
030E0:  BNZ   30EE
030E2:  MOVLW  66
030E4:  SUBWF  00,W
030E6:  MOVLB  0
030E8:  BTFSC  FD8.2
030EA:  BRA    381E
030EC:  MOVLB  B
030EE:  GOTO   38CE
....................                 { 
....................                     case ADDRESS_FOR_SET_LOAD_CELL_FACTOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrLoadCellFactor = g_ui8RS485Rxbuffer[4]; 
030F2:  MOVLB  4
030F4:  CLRF   xDA
030F6:  MOVFF  B82,4D9
....................                         g_ui16CurrLoadCellFactor = ((g_ui16CurrLoadCellFactor << 8) & 0xFF00); 
030FA:  MOVFF  4D9,4DA
030FE:  MOVLB  4
03100:  CLRF   xD9
03102:  MOVLB  4
....................                         g_ui16CurrLoadCellFactor = (g_ui16CurrLoadCellFactor | g_ui8RS485Rxbuffer[5]); 
03104:  MOVLB  B
03106:  MOVF   x83,W
03108:  MOVLB  4
0310A:  IORWF  xD9,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0310C:  MOVLW  0A
0310E:  MOVLB  B
03110:  MOVWF  xFA
03112:  MOVLW  06
03114:  MOVWF  xFB
03116:  MOVFF  BF1,BFD
0311A:  MOVFF  BF0,BFC
0311E:  CLRF   xFE
03120:  MOVLB  C
03122:  CLRF   x02
03124:  CLRF   x01
03126:  CLRF   x00
03128:  MOVLB  B
0312A:  CLRF   xFF
0312C:  MOVLB  0
0312E:  CALL   17A8
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03132:  CALL   1780
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_SET_LOAD_CELL_FACTOR; 
03136:  MOVLW  6C
03138:  MOVLB  1
0313A:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor = g_ui16CurrLoadCellFactor; 
0313C:  MOVFF  4DA,FA
03140:  MOVFF  4D9,F9
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16Padding = 0; 
03144:  MOVLB  0
03146:  CLRF   xFC
03148:  CLRF   xFB
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0314A:  MOVLW  01
0314C:  MOVLB  B
0314E:  MOVWF  xF4
03150:  MOVF   xF4,W
03152:  SUBLW  08
03154:  BNC   318A
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUCurrLoadCellFactor.m_ui8Arr[ui8LoopCount-1]; 
03156:  CLRF   03
03158:  MOVF   xF4,W
0315A:  ADDLW  FC
0315C:  MOVWF  01
0315E:  MOVLW  01
03160:  ADDWFC 03,F
03162:  MOVFF  03,BF9
03166:  MOVLW  01
03168:  SUBWF  xF4,W
0316A:  CLRF   03
0316C:  ADDLW  F9
0316E:  MOVWF  FE9
03170:  MOVLW  00
03172:  ADDWFC 03,W
03174:  MOVWF  FEA
03176:  MOVFF  FEF,BFA
0317A:  MOVFF  BF9,FEA
0317E:  MOVFF  01,FE9
03182:  MOVFF  BFA,FEF
03186:  INCF   xF4,F
03188:  BRA    3150
....................                         } 
....................      
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
0318A:  MOVLW  02
0318C:  MOVWF  xF9
0318E:  MOVLW  90
03190:  MOVWF  xF8
03192:  MOVLW  01
03194:  MOVWF  xFB
03196:  MOVLW  FA
03198:  MOVWF  xFA
0319A:  MOVLB  0
0319C:  CALL   0C04
....................                         break; 
031A0:  BRA    38D0
....................                     case MODE_ADDRESS: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrentMode = g_ui8RS485Rxbuffer[4]; 
031A2:  MOVLB  4
031A4:  CLRF   xD7
031A6:  MOVFF  B82,4D6
....................                         g_ui16CurrentMode = ((g_ui16CurrentMode << 8) & 0xFF00); 
031AA:  MOVFF  4D6,4D7
031AE:  MOVLB  4
031B0:  CLRF   xD6
031B2:  MOVLB  4
....................                         g_ui16CurrentMode = (g_ui16CurrentMode | g_ui8RS485Rxbuffer[5]);  
031B4:  MOVLB  B
031B6:  MOVF   x83,W
031B8:  MOVLB  4
031BA:  IORWF  xD6,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                         
031BC:  MOVLW  0A
031BE:  MOVLB  B
031C0:  MOVWF  xFA
031C2:  MOVLW  06
031C4:  MOVWF  xFB
031C6:  MOVFF  BF1,BFD
031CA:  MOVFF  BF0,BFC
031CE:  CLRF   xFE
031D0:  MOVLB  C
031D2:  CLRF   x02
031D4:  CLRF   x01
031D6:  CLRF   x00
031D8:  MOVLB  B
031DA:  CLRF   xFF
031DC:  MOVLB  0
031DE:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
031E2:  CALL   1780
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node.                         
....................                         switch(g_ui16CurrentMode) 
031E6:  MOVLB  4
031E8:  MOVF   xD6,W
031EA:  MOVWF  00
031EC:  MOVF   xD7,W
031EE:  MOVWF  03
031F0:  MOVF   03,W
031F2:  BNZ   31FC
031F4:  MOVF   00,F
031F6:  MOVLB  0
031F8:  BZ    3252
031FA:  MOVLB  4
031FC:  MOVF   03,W
031FE:  BNZ   320A
03200:  MOVLW  01
03202:  SUBWF  00,W
03204:  MOVLB  0
03206:  BZ    325A
03208:  MOVLB  4
0320A:  MOVF   03,W
0320C:  BNZ   3218
0320E:  MOVLW  02
03210:  SUBWF  00,W
03212:  MOVLB  0
03214:  BZ    3262
03216:  MOVLB  4
03218:  MOVF   03,W
0321A:  BNZ   3226
0321C:  MOVLW  03
0321E:  SUBWF  00,W
03220:  MOVLB  0
03222:  BZ    326A
03224:  MOVLB  4
03226:  MOVF   03,W
03228:  BNZ   3234
0322A:  MOVLW  06
0322C:  SUBWF  00,W
0322E:  MOVLB  0
03230:  BZ    3272
03232:  MOVLB  4
03234:  MOVF   03,W
03236:  BNZ   3242
03238:  MOVLW  05
0323A:  SUBWF  00,W
0323C:  MOVLB  0
0323E:  BZ    327A
03240:  MOVLB  4
03242:  MOVF   03,W
03244:  BNZ   3250
03246:  MOVLW  04
03248:  SUBWF  00,W
0324A:  MOVLB  0
0324C:  BZ    3282
0324E:  MOVLB  4
03250:  BRA    328C
....................                         { 
....................                             case BOARD_MODE_TYPE_NOTHING: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
03252:  MOVLW  64
03254:  MOVLB  1
03256:  MOVWF  xFC
....................                                  
....................                                 break; 
03258:  BRA    328E
....................                             case BOARD_MODE_TYPE_HOME: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
0325A:  MOVLW  64
0325C:  MOVLB  1
0325E:  MOVWF  xFC
....................                                          
....................                                 break; 
03260:  BRA    328E
....................                             case BOARD_MODE_TYPE_PRE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PRE_PROD; 
03262:  MOVLW  6F
03264:  MOVLB  1
03266:  MOVWF  xFC
....................                                  
....................                                 break; 
03268:  BRA    328E
....................                             case BOARD_MODE_TYPE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PROD; 
0326A:  MOVLW  82
0326C:  MOVLB  1
0326E:  MOVWF  xFC
....................                                  
....................                                 break; 
03270:  BRA    328E
....................                             case BOARD_MODE_TYPE_POST_PROD: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_POST_PROD; 
03272:  MOVLW  96
03274:  MOVLB  1
03276:  MOVWF  xFC
....................                                  
....................                                 break; 
03278:  BRA    328E
....................                             case BOARD_MODE_TYPE_CALIBRATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CALIB; 
0327A:  MOVLW  65
0327C:  MOVLB  1
0327E:  MOVWF  xFC
....................                                  
....................                                 break; 
03280:  BRA    328E
....................                             case BOARD_MODE_TYPE_CONFIGURATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CONFIG; 
03282:  MOVLW  8D
03284:  MOVLB  1
03286:  MOVWF  xFC
....................                                  
....................                                 break; 
03288:  BRA    328E
0328A:  MOVLB  4
....................                             default: 
....................                                 break; 
0328C:  MOVLB  1
....................                         } 
....................                          
....................                         // Stuff remaining padding bytes. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0328E:  MOVLW  01
03290:  MOVLB  B
03292:  MOVWF  xF4
03294:  MOVF   xF4,W
03296:  SUBLW  08
03298:  BNC   32AE
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
0329A:  CLRF   03
0329C:  MOVF   xF4,W
0329E:  ADDLW  FC
032A0:  MOVWF  FE9
032A2:  MOVLW  01
032A4:  ADDWFC 03,W
032A6:  MOVWF  FEA
032A8:  CLRF   FEF
032AA:  INCF   xF4,F
032AC:  BRA    3294
....................                         } 
....................                          
....................                         // Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
032AE:  MOVLW  02
032B0:  MOVWF  xF9
032B2:  MOVLW  90
032B4:  MOVWF  xF8
032B6:  MOVLW  01
032B8:  MOVWF  xFB
032BA:  MOVLW  FA
032BC:  MOVWF  xFA
032BE:  MOVLB  0
032C0:  CALL   0C04
....................                         break; 
032C4:  BRA    38D0
....................                     case  ADDRESS_FOR_START_CALIBRATION: 
....................                         // Step 1: accumulate data. 
....................                         g_fStartCalibration = g_ui8RS485Rxbuffer[4]; 
032C6:  MOVFF  B82,4D8
....................                         g_fStartCalibration = ((g_fStartCalibration << 8) & 0xFF00); 
032CA:  MOVLW  00
032CC:  MOVLB  4
032CE:  CLRF   xD8
....................                         g_fStartCalibration = (g_fStartCalibration | g_ui8RS485Rxbuffer[5]);                          
032D0:  MOVLB  B
032D2:  MOVF   x83,W
032D4:  MOVLB  4
032D6:  IORWF  xD8,F
....................                                  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
032D8:  MOVLW  0A
032DA:  MOVLB  B
032DC:  MOVWF  xFA
032DE:  MOVLW  06
032E0:  MOVWF  xFB
032E2:  MOVFF  BF1,BFD
032E6:  MOVFF  BF0,BFC
032EA:  CLRF   xFE
032EC:  MOVLB  C
032EE:  CLRF   x02
032F0:  CLRF   x01
032F2:  CLRF   x00
032F4:  MOVLB  B
032F6:  CLRF   xFF
032F8:  MOVLB  0
032FA:  CALL   17A8
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
032FE:  CALL   1780
....................                                  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_START_CALIBRATION; 
03302:  MOVLW  66
03304:  MOVLB  1
03306:  MOVWF  xFC
....................  
....................                         // b. Stuff data. 
....................                         // No data need to stuff 
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Remaining all bytes are padding bytes; need to stuff. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03308:  MOVLW  01
0330A:  MOVLB  B
0330C:  MOVWF  xF4
0330E:  MOVF   xF4,W
03310:  SUBLW  08
03312:  BNC   3328
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
03314:  CLRF   03
03316:  MOVF   xF4,W
03318:  ADDLW  FC
0331A:  MOVWF  FE9
0331C:  MOVLW  01
0331E:  ADDWFC 03,W
03320:  MOVWF  FEA
03322:  CLRF   FEF
03324:  INCF   xF4,F
03326:  BRA    330E
....................                         }                         
....................  
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03328:  MOVLW  02
0332A:  MOVWF  xF9
0332C:  MOVLW  90
0332E:  MOVWF  xF8
03330:  MOVLW  01
03332:  MOVWF  xFB
03334:  MOVLW  FA
03336:  MOVWF  xFA
03338:  MOVLB  0
0333A:  CALL   0C04
....................                          
....................                         // Reset Calibration point values; i.e. Tare ADC & Weight ADC values. 
....................                         g_ui32TareADCValueForCalibration = 0; 
0333E:  MOVLB  4
03340:  CLRF   xB9
03342:  CLRF   xB8
03344:  CLRF   xB7
03346:  CLRF   xB6
....................                         g_ui32gWeightADCValueForCalibration = 0; 
03348:  CLRF   xBD
0334A:  CLRF   xBC
0334C:  CLRF   xBB
0334E:  CLRF   xBA
....................                         break; 
03350:  MOVLB  0
03352:  BRA    38D0
....................                     case ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdPvTol = g_ui8RS485Rxbuffer[4]; 
03354:  MOVLB  4
03356:  CLRF   xD3
03358:  MOVFF  B82,4D2
....................                         g_ui16CurrProdPvTol = ((g_ui16CurrProdPvTol << 8) & 0xFF00); 
0335C:  MOVFF  4D2,4D3
03360:  MOVLB  4
03362:  CLRF   xD2
03364:  MOVLB  4
....................                         g_ui16CurrProdPvTol = (g_ui16CurrProdPvTol | g_ui8RS485Rxbuffer[5]);                          
03366:  MOVLB  B
03368:  MOVF   x83,W
0336A:  MOVLB  4
0336C:  IORWF  xD2,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);   
0336E:  MOVLW  0A
03370:  MOVLB  B
03372:  MOVWF  xFA
03374:  MOVLW  06
03376:  MOVWF  xFB
03378:  MOVFF  BF1,BFD
0337C:  MOVFF  BF0,BFC
03380:  CLRF   xFE
03382:  MOVLB  C
03384:  CLRF   x02
03386:  CLRF   x01
03388:  CLRF   x00
0338A:  MOVLB  B
0338C:  CLRF   xFF
0338E:  MOVLB  0
03390:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03394:  CALL   1780
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         //g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (int16)g_ui16CurrProdPvTol; 
03398:  CLRF   xE0
0339A:  CLRF   xDF
0339C:  MOVFF  4D3,DE
033A0:  MOVFF  4D2,DD
....................                          
....................                         // ##################################################### 
....................                         // Positive tolerance will be sent to MCU0 after negative 
....................                         // tolerance will arrive so that can be sent accumulately. 
....................                         // ##################################################### 
....................                          
.................... //                        // c. Stuff padding bytes; if needed. 
.................... //                        g_unIBUAvgNode.m_stIBUAvgNode.m_i16Padding = 0; 
.................... //                        for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
.................... //                        { 
.................... //                            g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUAvgNode.m_ui8Arr[ui8LoopCount - 1]; 
.................... //                        }                         
.................... //                         
.................... //                        // d. Insert in IBU sent message queue. 
.................... //                        InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
....................                         break; 
033A4:  BRA    38D0
....................                     case ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdNvTol = g_ui8RS485Rxbuffer[4]; 
033A6:  MOVLB  4
033A8:  CLRF   xD5
033AA:  MOVFF  B82,4D4
....................                         g_ui16CurrProdNvTol = ((g_ui16CurrProdNvTol << 8) & 0xFF00); 
033AE:  MOVFF  4D4,4D5
033B2:  MOVLB  4
033B4:  CLRF   xD4
033B6:  MOVLB  4
....................                         g_ui16CurrProdNvTol = (g_ui16CurrProdNvTol | g_ui8RS485Rxbuffer[5]);  
033B8:  MOVLB  B
033BA:  MOVF   x83,W
033BC:  MOVLB  4
033BE:  IORWF  xD4,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
033C0:  MOVLW  0A
033C2:  MOVLB  B
033C4:  MOVWF  xFA
033C6:  MOVLW  06
033C8:  MOVWF  xFB
033CA:  MOVFF  BF1,BFD
033CE:  MOVFF  BF0,BFC
033D2:  CLRF   xFE
033D4:  MOVLB  C
033D6:  CLRF   x02
033D8:  CLRF   x01
033DA:  CLRF   x00
033DC:  MOVLB  B
033DE:  CLRF   xFF
033E0:  MOVLB  0
033E2:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
033E6:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE;   
033EA:  MOVLW  71
033EC:  MOVLB  1
033EE:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (int16)g_ui16CurrProdNvTol; 
033F0:  MOVLB  0
033F2:  CLRF   xE4
033F4:  CLRF   xE3
033F6:  MOVFF  4D5,E2
033FA:  MOVFF  4D4,E1
....................                          
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Not Needed. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
033FE:  MOVLW  01
03400:  MOVLB  B
03402:  MOVWF  xF4
03404:  MOVF   xF4,W
03406:  SUBLW  08
03408:  BNC   343E
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
0340A:  CLRF   03
0340C:  MOVF   xF4,W
0340E:  ADDLW  FC
03410:  MOVWF  01
03412:  MOVLW  01
03414:  ADDWFC 03,F
03416:  MOVFF  03,BF9
0341A:  MOVLW  01
0341C:  SUBWF  xF4,W
0341E:  CLRF   03
03420:  ADDLW  DD
03422:  MOVWF  FE9
03424:  MOVLW  00
03426:  ADDWFC 03,W
03428:  MOVWF  FEA
0342A:  MOVFF  FEF,BFA
0342E:  MOVFF  BF9,FEA
03432:  MOVFF  01,FE9
03436:  MOVFF  BFA,FEF
0343A:  INCF   xF4,F
0343C:  BRA    3404
....................                         }  
....................                          
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
0343E:  MOVLW  02
03440:  MOVWF  xF9
03442:  MOVLW  90
03444:  MOVWF  xF8
03446:  MOVLW  01
03448:  MOVWF  xFB
0344A:  MOVLW  FA
0344C:  MOVWF  xFA
0344E:  MOVLB  0
03450:  CALL   0C04
....................                         break; 
03454:  BRA    38D0
....................                     case ADDRESS_FOR_SCRAP_ON_MODE: 
....................                         // Step 1: No data to parse..just send the mode to MCU0 for mode setting. 
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
03456:  MOVLW  0A
03458:  MOVLB  B
0345A:  MOVWF  xFA
0345C:  MOVLW  06
0345E:  MOVWF  xFB
03460:  MOVFF  BF1,BFD
03464:  MOVFF  BF0,BFC
03468:  CLRF   xFE
0346A:  MOVLB  C
0346C:  CLRF   x02
0346E:  CLRF   x01
03470:  CLRF   x00
03472:  MOVLB  B
03474:  CLRF   xFF
03476:  MOVLB  0
03478:  CALL   17A8
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0347C:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_SCRAP_MODE; 
03480:  MOVLW  76
03482:  MOVLB  1
03484:  MOVWF  xFC
....................                          
....................                         // b. Stuff padding data. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03486:  MOVLW  01
03488:  MOVLB  B
0348A:  MOVWF  xF4
0348C:  MOVF   xF4,W
0348E:  SUBLW  08
03490:  BNC   34A6
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
03492:  CLRF   03
03494:  MOVF   xF4,W
03496:  ADDLW  FC
03498:  MOVWF  FE9
0349A:  MOVLW  01
0349C:  ADDWFC 03,W
0349E:  MOVWF  FEA
034A0:  CLRF   FEF
034A2:  INCF   xF4,F
034A4:  BRA    348C
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
034A6:  MOVLW  02
034A8:  MOVWF  xF9
034AA:  MOVLW  90
034AC:  MOVWF  xF8
034AE:  MOVLW  01
034B0:  MOVWF  xFB
034B2:  MOVLW  FA
034B4:  MOVWF  xFA
034B6:  MOVLB  0
034B8:  CALL   0C04
....................                         break; 
034BC:  BRA    38D0
....................                     case ADDRESS_FOR_TOL_STORE_SETTING_ACK: 
....................                         // No data to parse. 
....................                         // Ack confirmation message. 
....................                         // Reset ack register. 
....................                         g_ui8ToleranceStoreAck = 0; 
034BE:  MOVLB  4
034C0:  CLRF   xDD
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
034C2:  MOVLW  0A
034C4:  MOVLB  B
034C6:  MOVWF  xFA
034C8:  MOVLW  06
034CA:  MOVWF  xFB
034CC:  MOVFF  BF1,BFD
034D0:  MOVFF  BF0,BFC
034D4:  CLRF   xFE
034D6:  MOVLB  C
034D8:  CLRF   x02
034DA:  CLRF   x01
034DC:  CLRF   x00
034DE:  MOVLB  B
034E0:  CLRF   xFF
034E2:  MOVLB  0
034E4:  CALL   17A8
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
034E8:  CALL   1780
....................                         break; 
034EC:  BRA    38D0
....................                     case ADDRESS_FOR_MACHINE_ID: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8MachineID = g_ui8RS485Rxbuffer[5]; 
034EE:  MOVFF  B83,4DE
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);    
034F2:  MOVLW  0A
034F4:  MOVLB  B
034F6:  MOVWF  xFA
034F8:  MOVLW  06
034FA:  MOVWF  xFB
034FC:  MOVFF  BF1,BFD
03500:  MOVFF  BF0,BFC
03504:  CLRF   xFE
03506:  MOVLB  C
03508:  CLRF   x02
0350A:  CLRF   x01
0350C:  CLRF   x00
0350E:  MOVLB  B
03510:  CLRF   xFF
03512:  MOVLB  0
03514:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03518:  CALL   1780
....................                          
....................                         // Step 4: Set data. 
....................                         g_stLANDataHeader.m_ui8MachineID = g_ui8MachineID; 
0351C:  MOVFF  4DE,99
....................                         
....................                         // Step 5: Store data in EEPROM. 
....................                         WriteMachineIDToEEPROM(g_ui8MachineID);                         
03520:  MOVFF  4DE,BF8
03524:  GOTO   1E6C
....................                         break; 
03528:  BRA    38D0
....................                     case ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8DataSendingIntervalTime = g_ui8RS485Rxbuffer[5]; 
0352A:  MOVFF  B83,4E0
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0352E:  MOVLW  0A
03530:  MOVLB  B
03532:  MOVWF  xFA
03534:  MOVLW  06
03536:  MOVWF  xFB
03538:  MOVFF  BF1,BFD
0353C:  MOVFF  BF0,BFC
03540:  CLRF   xFE
03542:  MOVLB  C
03544:  CLRF   x02
03546:  CLRF   x01
03548:  CLRF   x00
0354A:  MOVLB  B
0354C:  CLRF   xFF
0354E:  MOVLB  0
03550:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03554:  CALL   1780
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteIntervalToEEPROM(g_ui8DataSendingIntervalTime); 
03558:  MOVFF  4E0,BF8
0355C:  GOTO   1E80
....................                         break;                                 
03560:  BRA    38D0
....................                     case ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipePresenceDelayTime = g_ui8RS485Rxbuffer[4]; 
03562:  MOVLB  4
03564:  CLRF   xE5
03566:  MOVFF  B82,4E4
....................                         g_ui16PipePresenceDelayTime = ((g_ui16PipePresenceDelayTime << 8) & 0xFF00); 
0356A:  MOVFF  4E4,4E5
0356E:  MOVLB  4
03570:  CLRF   xE4
03572:  MOVLB  4
....................                         g_ui16PipePresenceDelayTime = (g_ui16PipePresenceDelayTime | g_ui8RS485Rxbuffer[5]); 
03574:  MOVLB  B
03576:  MOVF   x83,W
03578:  MOVLB  4
0357A:  IORWF  xE4,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0357C:  MOVLW  0A
0357E:  MOVLB  B
03580:  MOVWF  xFA
03582:  MOVLW  06
03584:  MOVWF  xFB
03586:  MOVFF  BF1,BFD
0358A:  MOVFF  BF0,BFC
0358E:  CLRF   xFE
03590:  MOVLB  C
03592:  CLRF   x02
03594:  CLRF   x01
03596:  CLRF   x00
03598:  MOVLB  B
0359A:  CLRF   xFF
0359C:  MOVLB  0
0359E:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
035A2:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
035A6:  MOVLW  98
035A8:  MOVLB  1
035AA:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipePresenceDelayTime; 
035AC:  MOVFF  4E5,103
035B0:  MOVFF  4E4,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_PRESENCE_DELAY; // Means pipe presence delay time. 
035B4:  MOVLW  01
035B6:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
035B8:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
035BA:  MOVLB  B
035BC:  MOVWF  xF4
035BE:  MOVF   xF4,W
035C0:  SUBLW  08
035C2:  BNC   35F8
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
035C4:  CLRF   03
035C6:  MOVF   xF4,W
035C8:  ADDLW  FC
035CA:  MOVWF  01
035CC:  MOVLW  01
035CE:  ADDWFC 03,F
035D0:  MOVFF  03,BF9
035D4:  MOVLW  01
035D6:  SUBWF  xF4,W
035D8:  CLRF   03
035DA:  ADDLW  01
035DC:  MOVWF  FE9
035DE:  MOVLW  01
035E0:  ADDWFC 03,W
035E2:  MOVWF  FEA
035E4:  MOVFF  FEF,BFA
035E8:  MOVFF  BF9,FEA
035EC:  MOVFF  01,FE9
035F0:  MOVFF  BFA,FEF
035F4:  INCF   xF4,F
035F6:  BRA    35BE
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
035F8:  MOVLW  02
035FA:  MOVWF  xF9
035FC:  MOVLW  90
035FE:  MOVWF  xF8
03600:  MOVLW  01
03602:  MOVWF  xFB
03604:  MOVLW  FA
03606:  MOVWF  xFA
03608:  MOVLB  0
0360A:  CALL   0C04
....................                         break; 
0360E:  BRA    38D0
....................                     case ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeStabilizationDelayTime = g_ui8RS485Rxbuffer[4]; 
03610:  MOVLB  4
03612:  CLRF   xE7
03614:  MOVFF  B82,4E6
....................                         g_ui16PipeStabilizationDelayTime = ((g_ui16PipeStabilizationDelayTime << 8) & 0xFF00); 
03618:  MOVFF  4E6,4E7
0361C:  MOVLB  4
0361E:  CLRF   xE6
03620:  MOVLB  4
....................                         g_ui16PipeStabilizationDelayTime = (g_ui16PipeStabilizationDelayTime | g_ui8RS485Rxbuffer[5]); 
03622:  MOVLB  B
03624:  MOVF   x83,W
03626:  MOVLB  4
03628:  IORWF  xE6,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0362A:  MOVLW  0A
0362C:  MOVLB  B
0362E:  MOVWF  xFA
03630:  MOVLW  06
03632:  MOVWF  xFB
03634:  MOVFF  BF1,BFD
03638:  MOVFF  BF0,BFC
0363C:  CLRF   xFE
0363E:  MOVLB  C
03640:  CLRF   x02
03642:  CLRF   x01
03644:  CLRF   x00
03646:  MOVLB  B
03648:  CLRF   xFF
0364A:  MOVLB  0
0364C:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03650:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
03654:  MOVLW  98
03656:  MOVLB  1
03658:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeStabilizationDelayTime; 
0365A:  MOVFF  4E7,103
0365E:  MOVFF  4E6,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_STABILIZATION_DELAY; // Means pipe stabilization delay time. 
03662:  MOVLW  02
03664:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
03666:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03668:  MOVLW  01
0366A:  MOVLB  B
0366C:  MOVWF  xF4
0366E:  MOVF   xF4,W
03670:  SUBLW  08
03672:  BNC   36A8
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
03674:  CLRF   03
03676:  MOVF   xF4,W
03678:  ADDLW  FC
0367A:  MOVWF  01
0367C:  MOVLW  01
0367E:  ADDWFC 03,F
03680:  MOVFF  03,BF9
03684:  MOVLW  01
03686:  SUBWF  xF4,W
03688:  CLRF   03
0368A:  ADDLW  01
0368C:  MOVWF  FE9
0368E:  MOVLW  01
03690:  ADDWFC 03,W
03692:  MOVWF  FEA
03694:  MOVFF  FEF,BFA
03698:  MOVFF  BF9,FEA
0369C:  MOVFF  01,FE9
036A0:  MOVFF  BFA,FEF
036A4:  INCF   xF4,F
036A6:  BRA    366E
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
036A8:  MOVLW  02
036AA:  MOVWF  xF9
036AC:  MOVLW  90
036AE:  MOVWF  xF8
036B0:  MOVLW  01
036B2:  MOVWF  xFB
036B4:  MOVLW  FA
036B6:  MOVWF  xFA
036B8:  MOVLB  0
036BA:  CALL   0C04
....................                         break; 
036BE:  BRA    38D0
....................                     case ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeTransferDelayTime = g_ui8RS485Rxbuffer[4]; 
036C0:  MOVLB  4
036C2:  CLRF   xE9
036C4:  MOVFF  B82,4E8
....................                         g_ui16PipeTransferDelayTime = ((g_ui16PipeTransferDelayTime << 8) & 0xFF00); 
036C8:  MOVFF  4E8,4E9
036CC:  MOVLB  4
036CE:  CLRF   xE8
036D0:  MOVLB  4
....................                         g_ui16PipeTransferDelayTime = (g_ui16PipeTransferDelayTime | g_ui8RS485Rxbuffer[5]); 
036D2:  MOVLB  B
036D4:  MOVF   x83,W
036D6:  MOVLB  4
036D8:  IORWF  xE8,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
036DA:  MOVLW  0A
036DC:  MOVLB  B
036DE:  MOVWF  xFA
036E0:  MOVLW  06
036E2:  MOVWF  xFB
036E4:  MOVFF  BF1,BFD
036E8:  MOVFF  BF0,BFC
036EC:  CLRF   xFE
036EE:  MOVLB  C
036F0:  CLRF   x02
036F2:  CLRF   x01
036F4:  CLRF   x00
036F6:  MOVLB  B
036F8:  CLRF   xFF
036FA:  MOVLB  0
036FC:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03700:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
03704:  MOVLW  98
03706:  MOVLB  1
03708:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeTransferDelayTime; 
0370A:  MOVFF  4E9,103
0370E:  MOVFF  4E8,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_TRANSFER_DELAY; // Means pipe transfer delay time. 
03712:  MOVLW  03
03714:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
03716:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03718:  MOVLW  01
0371A:  MOVLB  B
0371C:  MOVWF  xF4
0371E:  MOVF   xF4,W
03720:  SUBLW  08
03722:  BNC   3758
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
03724:  CLRF   03
03726:  MOVF   xF4,W
03728:  ADDLW  FC
0372A:  MOVWF  01
0372C:  MOVLW  01
0372E:  ADDWFC 03,F
03730:  MOVFF  03,BF9
03734:  MOVLW  01
03736:  SUBWF  xF4,W
03738:  CLRF   03
0373A:  ADDLW  01
0373C:  MOVWF  FE9
0373E:  MOVLW  01
03740:  ADDWFC 03,W
03742:  MOVWF  FEA
03744:  MOVFF  FEF,BFA
03748:  MOVFF  BF9,FEA
0374C:  MOVFF  01,FE9
03750:  MOVFF  BFA,FEF
03754:  INCF   xF4,F
03756:  BRA    371E
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03758:  MOVLW  02
0375A:  MOVWF  xF9
0375C:  MOVLW  90
0375E:  MOVWF  xF8
03760:  MOVLW  01
03762:  MOVWF  xFB
03764:  MOVLW  FA
03766:  MOVWF  xFA
03768:  MOVLB  0
0376A:  CALL   0C04
....................                         break; 
0376E:  BRA    38D0
....................                     case ADDRESS_FOR_SHIFT_NUMBER: 
....................                         // Step 1: accumulate data.                         
....................                         g_ui8ShiftNumber = g_ui8RS485Rxbuffer[5]; 
03770:  MOVFF  B83,4EB
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03774:  MOVLW  0A
03776:  MOVLB  B
03778:  MOVWF  xFA
0377A:  MOVLW  06
0377C:  MOVWF  xFB
0377E:  MOVFF  BF1,BFD
03782:  MOVFF  BF0,BFC
03786:  CLRF   xFE
03788:  MOVLB  C
0378A:  CLRF   x02
0378C:  CLRF   x01
0378E:  CLRF   x00
03790:  MOVLB  B
03792:  CLRF   xFF
03794:  MOVLB  0
03796:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
0379A:  CALL   1780
....................                         break; 
0379E:  BRA    38D0
....................                     case ADDRESS_FOR_SHIFT_DURATION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16TotalMachineUpTime = g_ui8RS485Rxbuffer[4]; 
037A0:  MOVLB  4
037A2:  CLRF   xED
037A4:  MOVFF  B82,4EC
....................                         g_ui16TotalMachineUpTime = ((g_ui16TotalMachineUpTime << 8) & 0xFF00); 
037A8:  MOVFF  4EC,4ED
037AC:  MOVLB  4
037AE:  CLRF   xEC
037B0:  MOVLB  4
....................                         g_ui16TotalMachineUpTime = (g_ui16TotalMachineUpTime | g_ui8RS485Rxbuffer[5]); 
037B2:  MOVLB  B
037B4:  MOVF   x83,W
037B6:  MOVLB  4
037B8:  IORWF  xEC,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
037BA:  MOVLW  0A
037BC:  MOVLB  B
037BE:  MOVWF  xFA
037C0:  MOVLW  06
037C2:  MOVWF  xFB
037C4:  MOVFF  BF1,BFD
037C8:  MOVFF  BF0,BFC
037CC:  CLRF   xFE
037CE:  MOVLB  C
037D0:  CLRF   x02
037D2:  CLRF   x01
037D4:  CLRF   x00
037D6:  MOVLB  B
037D8:  CLRF   xFF
037DA:  MOVLB  0
037DC:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
037E0:  CALL   1780
....................                          
....................                         // Send the shift related data to server for report generation. 
....................                         // Insert data in GPRS message queue. 
....................                         //InsertInGPRSQueue(); 
....................                         break; 
037E4:  BRA    38D0
....................                     case ADDRESS_FOR_SELECT_SIM_OPERATOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8SIMOperatorID = g_ui8RS485Rxbuffer[5]; 
037E6:  MOVFF  B83,4EF
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
037EA:  MOVLW  0A
037EC:  MOVLB  B
037EE:  MOVWF  xFA
037F0:  MOVLW  06
037F2:  MOVWF  xFB
037F4:  MOVFF  BF1,BFD
037F8:  MOVFF  BF0,BFC
037FC:  CLRF   xFE
037FE:  MOVLB  C
03800:  CLRF   x02
03802:  CLRF   x01
03804:  CLRF   x00
03806:  MOVLB  B
03808:  CLRF   xFF
0380A:  MOVLB  0
0380C:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03810:  CALL   1780
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteSIMOperatorIDToEEPROM(g_ui8SIMOperatorID);                         
03814:  MOVFF  4EF,BF8
03818:  GOTO   1E94
....................                         break;  
0381C:  BRA    38D0
....................                     case ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16WeighingCylinderUpActivationDelay = g_ui8RS485Rxbuffer[4]; 
0381E:  MOVLB  4
03820:  CLRF   xF1
03822:  MOVFF  B82,4F0
....................                         g_ui16WeighingCylinderUpActivationDelay = ((g_ui16WeighingCylinderUpActivationDelay << 8) & 0xFF00); 
03826:  MOVFF  4F0,4F1
0382A:  MOVLB  4
0382C:  CLRF   xF0
0382E:  MOVLB  4
....................                         g_ui16WeighingCylinderUpActivationDelay = (g_ui16WeighingCylinderUpActivationDelay | g_ui8RS485Rxbuffer[5]); 
03830:  MOVLB  B
03832:  MOVF   x83,W
03834:  MOVLB  4
03836:  IORWF  xF0,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03838:  MOVLW  0A
0383A:  MOVLB  B
0383C:  MOVWF  xFA
0383E:  MOVLW  06
03840:  MOVWF  xFB
03842:  MOVFF  BF1,BFD
03846:  MOVFF  BF0,BFC
0384A:  CLRF   xFE
0384C:  MOVLB  C
0384E:  CLRF   x02
03850:  CLRF   x01
03852:  CLRF   x00
03854:  MOVLB  B
03856:  CLRF   xFF
03858:  MOVLB  0
0385A:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0385E:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY; 
03862:  MOVLW  9B
03864:  MOVLB  1
03866:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16DelayTime = g_ui16WeighingCylinderUpActivationDelay; 
03868:  MOVFF  4F1,106
0386C:  MOVFF  4F0,105
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16Spare = 0; 
03870:  CLRF   x08
03872:  CLRF   x07
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03874:  MOVLW  01
03876:  MOVLB  B
03878:  MOVWF  xF4
0387A:  MOVF   xF4,W
0387C:  SUBLW  08
0387E:  BNC   38B4
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unWeighingCylinderUpActivationDelay.m_ui8Arr[ui8LoopCount - 1]; 
03880:  CLRF   03
03882:  MOVF   xF4,W
03884:  ADDLW  FC
03886:  MOVWF  01
03888:  MOVLW  01
0388A:  ADDWFC 03,F
0388C:  MOVFF  03,BF9
03890:  MOVLW  01
03892:  SUBWF  xF4,W
03894:  CLRF   03
03896:  ADDLW  05
03898:  MOVWF  FE9
0389A:  MOVLW  01
0389C:  ADDWFC 03,W
0389E:  MOVWF  FEA
038A0:  MOVFF  FEF,BFA
038A4:  MOVFF  BF9,FEA
038A8:  MOVFF  01,FE9
038AC:  MOVFF  BFA,FEF
038B0:  INCF   xF4,F
038B2:  BRA    387A
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
038B4:  MOVLW  02
038B6:  MOVWF  xF9
038B8:  MOVLW  90
038BA:  MOVWF  xF8
038BC:  MOVLW  01
038BE:  MOVWF  xFB
038C0:  MOVLW  FA
038C2:  MOVWF  xFA
038C4:  MOVLB  0
038C6:  CALL   0C04
....................                         break;                         
038CA:  BRA    38D0
038CC:  MOVLB  B
....................                     default: 
....................                         break; 
038CE:  MOVLB  0
....................    
....................                 } 
....................  
....................                 break; 
038D0:  BRA    3C8E
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Accumulate first register address to start write. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
038D2:  MOVLB  B
038D4:  CLRF   xF1
038D6:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
038DA:  MOVFF  BF0,BF1
038DE:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
038E0:  MOVF   x81,W
038E2:  IORWF  xF0,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
038E4:  MOVF   xF0,W
038E6:  MOVWF  00
038E8:  MOVF   xF1,W
038EA:  MOVWF  03
038EC:  MOVF   03,W
038EE:  BNZ   38FA
038F0:  MOVLW  47
038F2:  SUBWF  00,W
038F4:  MOVLB  0
038F6:  BZ    393E
038F8:  MOVLB  B
038FA:  MOVF   03,W
038FC:  BNZ   3908
038FE:  MOVLW  50
03900:  SUBWF  00,W
03902:  MOVLB  0
03904:  BZ    39DA
03906:  MOVLB  B
03908:  MOVF   03,W
0390A:  BNZ   3918
0390C:  MOVLW  52
0390E:  SUBWF  00,W
03910:  MOVLB  0
03912:  BTFSC  FD8.2
03914:  BRA    3B20
03916:  MOVLB  B
03918:  MOVLW  01
0391A:  SUBWF  03,W
0391C:  BNZ   392A
0391E:  MOVLW  90
03920:  SUBWF  00,W
03922:  MOVLB  0
03924:  BTFSC  FD8.2
03926:  BRA    3C0A
03928:  MOVLB  B
0392A:  MOVLW  01
0392C:  SUBWF  03,W
0392E:  BNZ   393C
03930:  MOVLW  93
03932:  SUBWF  00,W
03934:  MOVLB  0
03936:  BTFSC  FD8.2
03938:  BRA    3C48
0393A:  MOVLB  B
0393C:  BRA    3C8A
....................                 { 
....................                     case ADRESS_FOR_HMI_TIMESTAMP: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];                         
0393E:  MOVFF  B84,BF5
....................  
....................                         // Year 
....................                         g_stHMITime.tm_year = g_ui8RS485Rxbuffer[7]; 
03942:  CLRF   xAD
03944:  MOVFF  B85,AC
....................                         g_stHMITime.tm_year = ((g_stHMITime.tm_year << 8) & 0xFF00); 
03948:  MOVFF  AC,AD
0394C:  MOVLB  0
0394E:  CLRF   xAC
03950:  MOVLB  0
....................                         g_stHMITime.tm_year = (g_stHMITime.tm_year | g_ui8RS485Rxbuffer[8]); 
03952:  MOVLB  B
03954:  MOVF   x86,W
03956:  MOVLB  0
03958:  IORWF  xAC,F
....................                         // Month 
....................                         g_stHMITime.tm_mon = g_ui8RS485Rxbuffer[10] - 1; 
0395A:  MOVLW  01
0395C:  MOVLB  B
0395E:  SUBWF  x88,W
03960:  MOVLB  0
03962:  MOVWF  xAB
....................                         // Day 
....................                         g_stHMITime.tm_mday = g_ui8RS485Rxbuffer[12]; 
03964:  MOVFF  B8A,AA
....................                         // Week Day 
....................                         g_stHMITime.tm_wday = g_ui8RS485Rxbuffer[14]; 
03968:  MOVFF  B8C,AE
....................                         // Hour 
....................                         g_stHMITime.tm_hour = g_ui8RS485Rxbuffer[16]; 
0396C:  MOVFF  B8E,A9
....................                         // Minute 
....................                         g_stHMITime.tm_min = g_ui8RS485Rxbuffer[18]; 
03970:  MOVFF  B90,A8
....................                         // Second 
....................                         g_stHMITime.tm_sec = g_ui8RS485Rxbuffer[20]; 
03974:  MOVFF  B92,A7
....................                          
....................                         // Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03978:  MOVLW  0A
0397A:  MOVLB  B
0397C:  MOVWF  xFA
0397E:  MOVLW  10
03980:  MOVWF  xFB
03982:  MOVFF  BF1,BFD
03986:  MOVFF  BF0,BFC
0398A:  MOVFF  BF5,BFE
0398E:  MOVLB  C
03990:  CLRF   x02
03992:  CLRF   x01
03994:  CLRF   x00
03996:  MOVLB  B
03998:  CLRF   xFF
0399A:  MOVLB  0
0399C:  CALL   17A8
....................  
....................                         g_ui32UnixTimeInSec = mktime(&g_stHMITime); 
039A0:  MOVLB  B
039A2:  CLRF   xF9
039A4:  MOVLW  A7
039A6:  MOVWF  xF8
039A8:  MOVLB  0
039AA:  GOTO   20FC
039AE:  MOVFF  03,C0
039B2:  MOVFF  02,BF
039B6:  MOVFF  01,BE
039BA:  MOVFF  00,BD
....................                          
....................                         g_pstHMITimeTemp = localtime(&g_ui32UnixTimeInSec); 
039BE:  MOVLB  B
039C0:  CLRF   xF9
039C2:  MOVLW  BD
039C4:  MOVWF  xF8
039C6:  MOVLB  0
039C8:  GOTO   2648
039CC:  MOVFF  02,BC
039D0:  MOVFF  01,BB
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
039D4:  CALL   1780
....................                         break; 
039D8:  BRA    3C8C
....................                     case ADDRESS_FOR_CALCULATED_MIN_MAX_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
039DA:  MOVFF  B84,BF5
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
039DE:  CLRF   xE0
039E0:  CLRF   xDF
039E2:  CLRF   xDE
039E4:  MOVFF  B87,DD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039E8:  MOVFF  DF,E0
039EC:  MOVFF  DE,DF
039F0:  MOVFF  DD,DE
039F4:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
039F6:  MOVLB  B
039F8:  MOVF   x88,W
039FA:  MOVLB  0
039FC:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039FE:  MOVFF  DF,E0
03A02:  MOVFF  DE,DF
03A06:  MOVFF  DD,DE
03A0A:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
03A0C:  MOVLB  B
03A0E:  MOVF   x85,W
03A10:  MOVLB  0
03A12:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03A14:  MOVFF  DF,E0
03A18:  MOVFF  DE,DF
03A1C:  MOVFF  DD,DE
03A20:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
03A22:  MOVLB  B
03A24:  MOVF   x86,W
03A26:  MOVLB  0
03A28:  IORWF  xDD,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
03A2A:  CLRF   xE4
03A2C:  CLRF   xE3
03A2E:  CLRF   xE2
03A30:  MOVFF  B8B,E1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A34:  MOVFF  E3,E4
03A38:  MOVFF  E2,E3
03A3C:  MOVFF  E1,E2
03A40:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
03A42:  MOVLB  B
03A44:  MOVF   x8C,W
03A46:  MOVLB  0
03A48:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A4A:  MOVFF  E3,E4
03A4E:  MOVFF  E2,E3
03A52:  MOVFF  E1,E2
03A56:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
03A58:  MOVLB  B
03A5A:  MOVF   x89,W
03A5C:  MOVLB  0
03A5E:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A60:  MOVFF  E3,E4
03A64:  MOVFF  E2,E3
03A68:  MOVFF  E1,E2
03A6C:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
03A6E:  MOVLB  B
03A70:  MOVF   x8A,W
03A72:  MOVLB  0
03A74:  IORWF  xE1,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03A76:  MOVLW  0A
03A78:  MOVLB  B
03A7A:  MOVWF  xFA
03A7C:  MOVLW  10
03A7E:  MOVWF  xFB
03A80:  MOVFF  BF1,BFD
03A84:  MOVFF  BF0,BFC
03A88:  MOVFF  BF5,BFE
03A8C:  MOVLB  C
03A8E:  CLRF   x02
03A90:  CLRF   x01
03A92:  CLRF   x00
03A94:  MOVLB  B
03A96:  CLRF   xFF
03A98:  MOVLB  0
03A9A:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03A9E:  CALL   1780
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU data node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
03AA2:  MOVLW  71
03AA4:  MOVLB  1
03AA6:  MOVWF  xFC
....................                          
....................                         // b. stuff data in node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03AA8:  MOVLW  01
03AAA:  MOVLB  B
03AAC:  MOVWF  xF4
03AAE:  MOVF   xF4,W
03AB0:  SUBLW  08
03AB2:  BNC   3AE8
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
03AB4:  CLRF   03
03AB6:  MOVF   xF4,W
03AB8:  ADDLW  FC
03ABA:  MOVWF  01
03ABC:  MOVLW  01
03ABE:  ADDWFC 03,F
03AC0:  MOVFF  03,BF9
03AC4:  MOVLW  01
03AC6:  SUBWF  xF4,W
03AC8:  CLRF   03
03ACA:  ADDLW  DD
03ACC:  MOVWF  FE9
03ACE:  MOVLW  00
03AD0:  ADDWFC 03,W
03AD2:  MOVWF  FEA
03AD4:  MOVFF  FEF,BFA
03AD8:  MOVFF  BF9,FEA
03ADC:  MOVFF  01,FE9
03AE0:  MOVFF  BFA,FEF
03AE4:  INCF   xF4,F
03AE6:  BRA    3AAE
....................                         } 
....................  
....................                         // c. Insert in IBU message send queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03AE8:  MOVLW  02
03AEA:  MOVWF  xF9
03AEC:  MOVLW  90
03AEE:  MOVWF  xF8
03AF0:  MOVLW  01
03AF2:  MOVWF  xFB
03AF4:  MOVLW  FA
03AF6:  MOVWF  xFA
03AF8:  MOVLB  0
03AFA:  CALL   0C04
....................  
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03AFE:  MOVFF  E0,A1
03B02:  MOVFF  DF,A0
03B06:  MOVFF  DE,9F
03B0A:  MOVFF  DD,9E
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt; 
03B0E:  MOVFF  E4,A5
03B12:  MOVFF  E3,A4
03B16:  MOVFF  E2,A3
03B1A:  MOVFF  E1,A2
....................                         break; 
03B1E:  BRA    3C8C
....................                     case ADDRESS_FOR_PRE_PROD_MAX_MIN_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
03B20:  MOVFF  B84,BF5
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
03B24:  CLRF   xE0
03B26:  CLRF   xDF
03B28:  CLRF   xDE
03B2A:  MOVFF  B87,DD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B2E:  MOVFF  DF,E0
03B32:  MOVFF  DE,DF
03B36:  MOVFF  DD,DE
03B3A:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
03B3C:  MOVLB  B
03B3E:  MOVF   x88,W
03B40:  MOVLB  0
03B42:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B44:  MOVFF  DF,E0
03B48:  MOVFF  DE,DF
03B4C:  MOVFF  DD,DE
03B50:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
03B52:  MOVLB  B
03B54:  MOVF   x85,W
03B56:  MOVLB  0
03B58:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B5A:  MOVFF  DF,E0
03B5E:  MOVFF  DE,DF
03B62:  MOVFF  DD,DE
03B66:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
03B68:  MOVLB  B
03B6A:  MOVF   x86,W
03B6C:  MOVLB  0
03B6E:  IORWF  xDD,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
03B70:  CLRF   xE4
03B72:  CLRF   xE3
03B74:  CLRF   xE2
03B76:  MOVFF  B8B,E1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03B7A:  MOVFF  E3,E4
03B7E:  MOVFF  E2,E3
03B82:  MOVFF  E1,E2
03B86:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
03B88:  MOVLB  B
03B8A:  MOVF   x8C,W
03B8C:  MOVLB  0
03B8E:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03B90:  MOVFF  E3,E4
03B94:  MOVFF  E2,E3
03B98:  MOVFF  E1,E2
03B9C:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
03B9E:  MOVLB  B
03BA0:  MOVF   x89,W
03BA2:  MOVLB  0
03BA4:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03BA6:  MOVFF  E3,E4
03BAA:  MOVFF  E2,E3
03BAE:  MOVFF  E1,E2
03BB2:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
03BB4:  MOVLB  B
03BB6:  MOVF   x8A,W
03BB8:  MOVLB  0
03BBA:  IORWF  xE1,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03BBC:  MOVLW  0A
03BBE:  MOVLB  B
03BC0:  MOVWF  xFA
03BC2:  MOVLW  10
03BC4:  MOVWF  xFB
03BC6:  MOVFF  BF1,BFD
03BCA:  MOVFF  BF0,BFC
03BCE:  MOVFF  BF5,BFE
03BD2:  MOVLB  C
03BD4:  CLRF   x02
03BD6:  CLRF   x01
03BD8:  CLRF   x00
03BDA:  MOVLB  B
03BDC:  CLRF   xFF
03BDE:  MOVLB  0
03BE0:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();  
03BE4:  CALL   1780
....................                          
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03BE8:  MOVFF  E0,A1
03BEC:  MOVFF  DF,A0
03BF0:  MOVFF  DE,9F
03BF4:  MOVFF  DD,9E
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt;                         
03BF8:  MOVFF  E4,A5
03BFC:  MOVFF  E3,A4
03C00:  MOVFF  E2,A3
03C04:  MOVFF  E1,A2
....................                         break; 
03C08:  BRA    3C8C
....................                     case ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03C0A:  MOVFF  B84,BF5
....................                          
....................                         // Basic material and standard Specification and pressure rating of pipe has arrived. 
....................                         // 1. First register(2 bytes) contains basic material and standard 
....................                         // 2. Second register(2 bytes) contains standard specification. 
....................                         // 3. Third register (2 bytes) contains pressure rating / type. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8BasicMaterialStandard = g_ui8RS485Rxbuffer[8]; 
03C0E:  MOVFF  B86,4F2
....................                         g_ui8StandardSpecification = g_ui8RS485Rxbuffer[10]; 
03C12:  MOVFF  B88,4F3
....................                         g_ui8PressureRating        = g_ui8RS485Rxbuffer[12]; 
03C16:  MOVFF  B8A,4F4
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03C1A:  MOVLW  0A
03C1C:  MOVLB  B
03C1E:  MOVWF  xFA
03C20:  MOVLW  10
03C22:  MOVWF  xFB
03C24:  MOVFF  BF1,BFD
03C28:  MOVFF  BF0,BFC
03C2C:  MOVFF  BF5,BFE
03C30:  MOVLB  C
03C32:  CLRF   x02
03C34:  CLRF   x01
03C36:  CLRF   x00
03C38:  MOVLB  B
03C3A:  CLRF   xFF
03C3C:  MOVLB  0
03C3E:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
03C42:  CALL   1780
....................                         break; 
03C46:  BRA    3C8C
....................                     case ADDRESS_FOR_PIPE_SPECIFICATION: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03C48:  MOVFF  B84,BF5
....................  
....................                         // Pipe specification has arrived. 
....................                         // 1. First register(2 bytes) contains pipe's outer diameter(OD). 
....................                         // 2. Second register(2 bytes) contains pipe's length. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8PipeOD = g_ui8RS485Rxbuffer[8]; 
03C4C:  MOVFF  B86,4F5
....................                         g_ui8PipeLength = g_ui8RS485Rxbuffer[10]; 
03C50:  MOVFF  B88,4F6
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03C54:  MOVLW  0A
03C56:  MOVLB  B
03C58:  MOVWF  xFA
03C5A:  MOVLW  10
03C5C:  MOVWF  xFB
03C5E:  MOVFF  BF1,BFD
03C62:  MOVFF  BF0,BFC
03C66:  MOVFF  BF5,BFE
03C6A:  MOVLB  C
03C6C:  CLRF   x02
03C6E:  CLRF   x01
03C70:  CLRF   x00
03C72:  MOVLB  B
03C74:  CLRF   xFF
03C76:  MOVLB  0
03C78:  CALL   17A8
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03C7C:  CALL   1780
....................  
....................                         // Set all product specification in GPRS message header. 
....................                         SetProductSpecificationForServer(); 
03C80:  GOTO   2A5C
....................                         break; 
03C84:  MOVLB  0
03C86:  BRA    3C8C
03C88:  MOVLB  B
....................                     default: 
....................                         break; 
03C8A:  MOVLB  0
....................                 } 
....................                 break; 
03C8C:  BRA    3C8E
....................  
....................             default: 
....................                 break; 
03C8E:  MOVLB  B
....................                  
....................         } 
....................     } 
03C90:  MOVLB  0
03C92:  GOTO   4630 (RETURN)
.................... } 
....................  
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... void Initialize(void) 
.................... { 
....................      
....................     // Set RS485 Transmit Inactive. 
....................     output_bit(PIN_RS485_RTS,0); 
*
0093C:  BCF    F7F.0
0093E:  BCF    F87.0
....................  
....................      
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL); 
00940:  MOVLW  C0
00942:  IORWF  FF2,F
....................      
....................  
....................     // Initialize for GPRS message queue. 
....................     InitializePipeDataQueue(); 
00944:  BRA    05F6
....................     InitializeLANMsgHeader(); 
00946:  BRA    0752
....................  
....................      
....................     // Read set of Timer values from EEPROM.  
....................     g_ui8DataSendingIntervalTime = ReadIntervalFromEEPROM(); 
00948:  BRA    0766
0094A:  MOVFF  01,4E0
....................     g_ui32UnixTimeInSec = ReadStoredUnixTimeFromEEPROM(); 
0094E:  BRA    07F2
00950:  MOVFF  03,C0
00954:  MOVFF  02,BF
00958:  MOVFF  01,BE
0095C:  MOVFF  00,BD
....................     g_ui8SIMOperatorID  = ReadSIMOPeratorIDFromEEPROM(); 
00960:  BRA    088C
00962:  MOVFF  01,4EF
....................      
....................     // Initialize the sending queue to M0 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBURcvQueue);  
00966:  MOVLW  03
00968:  MOVLB  B
0096A:  MOVWF  xEE
0096C:  MOVLW  55
0096E:  MOVWF  xED
00970:  MOVLB  0
00972:  RCALL  08AA
....................     InitializeDataQueue(&g_stIBUSendQueue); 
00974:  MOVLW  02
00976:  MOVLB  B
00978:  MOVWF  xEE
0097A:  MOVLW  90
0097C:  MOVWF  xED
0097E:  MOVLB  0
00980:  RCALL  08AA
....................      
....................     // Initialize global variables for RS485 communication.     
....................     g_ui16PipeCount =  0; 
00982:  MOVLB  4
00984:  CLRF   xBF
00986:  CLRF   xBE
....................     g_ui16PipeCountPrev = 0; 
00988:  CLRF   xC1
0098A:  CLRF   xC0
....................     g_ui32CurrentWt = 0; 
0098C:  CLRF   xC5
0098E:  CLRF   xC4
00990:  CLRF   xC3
00992:  CLRF   xC2
....................     g_ui16CurrentPassStatus = 0; 
00994:  CLRF   xC7
00996:  CLRF   xC6
....................     g_ui32RunningAvgWt = 0; 
00998:  CLRF   xCB
0099A:  CLRF   xCA
0099C:  CLRF   xC9
0099E:  CLRF   xC8
....................     g_ui32RunningTareValue = 0; 
009A0:  CLRF   xCF
009A2:  CLRF   xCE
009A4:  CLRF   xCD
009A6:  CLRF   xCC
....................     //g_ui16ServerStatus = 0; 
....................     g_ui16CurrentMode = 0; 
009A8:  CLRF   xD7
009AA:  CLRF   xD6
....................          
....................     g_stIBURcvData.g_ui8ArrIBUData[0] = 0; 
009AC:  MOVLB  1
009AE:  CLRF   xEF
....................     g_stIBURcvData.g_ui8ArrIBUData[1] = 0; 
009B0:  CLRF   xF0
....................     g_stIBURcvData.g_ui8ArrIBUData[2] = 0; 
009B2:  CLRF   xF1
....................     g_stIBURcvData.g_ui8ArrIBUData[3] = 0; 
009B4:  CLRF   xF2
....................     g_stIBURcvData.g_ui8ArrIBUData[4] = 0; 
009B6:  CLRF   xF3
009B8:  MOVLB  0
009BA:  GOTO   45A8 (RETURN)
....................      
....................      
.................... }	 
....................  
.................... void main() 
*
042E2:  BSF    F77.7
042E4:  BCF    F77.6
042E6:  CLRF   FF8
042E8:  MOVLB  E
042EA:  BCF    x1F.5
042EC:  BSF    x22.5
042EE:  BCF    x23.1
042F0:  BCF    x23.5
042F2:  BSF    FF2.5
042F4:  BSF    07.7
042F6:  MOVLW  55
042F8:  MOVLB  D
042FA:  MOVWF  xEF
042FC:  MOVLW  AA
042FE:  MOVWF  xEF
04300:  BCF    xEF.0
04302:  MOVLW  17
04304:  MOVLB  E
04306:  MOVWF  x0F
04308:  MOVLW  21
0430A:  MOVWF  x13
0430C:  MOVLW  23
0430E:  MOVWF  x17
04310:  MOVLW  0C
04312:  MOVWF  x68
04314:  MOVLW  10
04316:  MOVWF  x72
04318:  MOVLW  14
0431A:  MOVWF  x74
0431C:  MOVLW  55
0431E:  MOVLB  D
04320:  MOVWF  xEF
04322:  MOVLW  AA
04324:  MOVWF  xEF
04326:  BSF    xEF.0
04328:  CLRF   2F
0432A:  MOVLB  E
0432C:  BSF    xF0.3
0432E:  MOVLW  81
04330:  MOVWF  xEC
04332:  MOVLW  00
04334:  MOVWF  xED
04336:  MOVLW  A6
04338:  MOVWF  xEF
0433A:  MOVLW  90
0433C:  MOVWF  xEE
0433E:  BCF    F9E.3
04340:  MOVLW  40
04342:  MOVWF  F9A
04344:  MOVLW  A6
04346:  MOVWF  F9D
04348:  MOVLW  90
0434A:  MOVWF  F9C
0434C:  BSF    xE2.3
0434E:  MOVLW  2A
04350:  MOVWF  xDE
04352:  MOVLW  00
04354:  MOVWF  xDF
04356:  MOVLW  A6
04358:  MOVWF  xE1
0435A:  MOVLW  90
0435C:  MOVWF  xE0
0435E:  CLRF   33
04360:  CLRF   32
04362:  MOVLW  29
04364:  MOVWF  3E
04366:  CLRF   3F
04368:  MOVLW  16
0436A:  MOVWF  40
0436C:  MOVLB  0
0436E:  CLRF   x87
04370:  CLRF   x88
04372:  MOVLW  03
04374:  MOVWF  x89
04376:  MOVLW  0C
04378:  MOVWF  x8A
0437A:  CLRF   x8C
0437C:  MOVLW  FA
0437E:  MOVWF  x8B
04380:  MOVLW  16
04382:  MOVWF  x8D
04384:  CLRF   x8E
04386:  CLRF   x8F
04388:  CLRF   x91
0438A:  CLRF   x90
0438C:  CLRF   x92
0438E:  CLRF   x93
04390:  CLRF   x94
04392:  CLRF   x98
04394:  CLRF   x97
04396:  CLRF   x96
04398:  CLRF   x95
0439A:  CLRF   xA6
0439C:  CLRF   xBC
0439E:  MOVLW  B1
043A0:  MOVWF  xBB
043A2:  CLRF   xC0
043A4:  CLRF   xBF
043A6:  CLRF   xBE
043A8:  CLRF   xBD
043AA:  CLRF   xCA
043AC:  CLRF   xCB
043AE:  CLRF   xCC
043B0:  MOVLB  1
043B2:  CLRF   xD3
043B4:  CLRF   xE8
043B6:  CLRF   xE9
043B8:  CLRF   xEA
043BA:  MOVLW  A5
043BC:  MOVWF  xEB
043BE:  CLRF   xEC
043C0:  MOVLB  2
043C2:  CLRF   x8E
043C4:  CLRF   x8F
043C6:  MOVLW  01
043C8:  MOVLB  4
043CA:  MOVWF  x1A
043CC:  CLRF   x1B
043CE:  CLRF   x1C
043D0:  CLRF   x1D
043D2:  CLRF   x1F
043D4:  CLRF   x1E
043D6:  CLRF   x2D
043D8:  CLRF   x3C
043DA:  CLRF   x3B
043DC:  CLRF   x3D
043DE:  CLRF   xA4
043E0:  CLRF   xA5
043E2:  CLRF   xA6
043E4:  CLRF   xA7
043E6:  MOVWF  xB5
043E8:  CLRF   xB9
043EA:  CLRF   xB8
043EC:  CLRF   xB7
043EE:  CLRF   xB6
043F0:  CLRF   xBD
043F2:  CLRF   xBC
043F4:  CLRF   xBB
043F6:  CLRF   xBA
043F8:  CLRF   xBF
043FA:  CLRF   xBE
043FC:  CLRF   xC5
043FE:  CLRF   xC4
04400:  CLRF   xC3
04402:  CLRF   xC2
04404:  CLRF   xC7
04406:  CLRF   xC6
04408:  CLRF   xCB
0440A:  CLRF   xCA
0440C:  CLRF   xC9
0440E:  CLRF   xC8
04410:  CLRF   xCF
04412:  CLRF   xCE
04414:  CLRF   xCD
04416:  CLRF   xCC
04418:  CLRF   xD1
0441A:  CLRF   xD0
0441C:  CLRF   xD3
0441E:  CLRF   xD2
04420:  CLRF   xD5
04422:  CLRF   xD4
04424:  CLRF   xD7
04426:  CLRF   xD6
04428:  CLRF   xD8
0442A:  CLRF   xDA
0442C:  CLRF   xD9
0442E:  CLRF   xDC
04430:  CLRF   xDB
04432:  CLRF   xDD
04434:  CLRF   xDE
04436:  CLRF   xDF
04438:  CLRF   xE0
0443A:  CLRF   xE1
0443C:  CLRF   xE2
0443E:  CLRF   xE3
04440:  CLRF   xE5
04442:  CLRF   xE4
04444:  CLRF   xE7
04446:  CLRF   xE6
04448:  CLRF   xE9
0444A:  CLRF   xE8
0444C:  CLRF   xEA
0444E:  CLRF   xEB
04450:  CLRF   xED
04452:  CLRF   xEC
04454:  CLRF   xEE
04456:  CLRF   xEF
04458:  CLRF   xF1
0445A:  CLRF   xF0
0445C:  CLRF   xF2
0445E:  CLRF   xF3
04460:  CLRF   xF4
04462:  CLRF   xF5
04464:  CLRF   xF6
04466:  CLRF   xF8
04468:  CLRF   xF7
0446A:  MOVLW  0C
0446C:  MOVWF  xF9
0446E:  CLRF   xFB
04470:  CLRF   xFA
04472:  CLRF   xFC
04474:  CLRF   xFE
04476:  CLRF   xFD
04478:  MOVLW  1A
0447A:  MOVWF  xFF
0447C:  MOVLB  5
0447E:  CLRF   x01
04480:  CLRF   x00
04482:  CLRF   x02
04484:  MOVLW  15
04486:  MOVWF  x03
04488:  MOVLW  B4
0448A:  MOVWF  x04
0448C:  MOVLW  2C
0448E:  MOVWF  x05
04490:  MOVLW  2E
04492:  MOVWF  x06
04494:  MOVLB  6
04496:  CLRF   xFC
04498:  CLRF   xFB
0449A:  CLRF   xFD
0449C:  CLRF   xFE
0449E:  MOVLB  7
044A0:  CLRF   x00
044A2:  MOVLW  01
044A4:  MOVLB  6
044A6:  MOVWF  xFF
044A8:  MOVLB  7
044AA:  CLRF   x02
044AC:  MOVLW  02
044AE:  MOVWF  x01
044B0:  MOVLW  07
044B2:  MOVWF  x04
044B4:  MOVLW  CF
044B6:  MOVWF  x03
044B8:  CLRF   x05
044BA:  CLRF   x06
044BC:  CLRF   x07
044BE:  CLRF   x14
044C0:  CLRF   x29
044C2:  MOVLB  B
044C4:  CLRF   x79
044C6:  CLRF   x78
044C8:  CLRF   x7B
044CA:  CLRF   x7A
044CC:  CLRF   x7C
044CE:  CLRF   x7D
044D0:  CLRF   xE2
044D2:  MOVLW  0B
044D4:  MOVWF  xE3
044D6:  MOVLW  01
044D8:  MOVWF  xE4
044DA:  CLRF   xE5
044DC:  CLRF   xE7
044DE:  CLRF   xE6
044E0:  CLRF   xEB
044E2:  CLRF   xEA
044E4:  CLRF   xE9
044E6:  CLRF   xE8
044E8:  MOVLB  E
044EA:  CLRF   x92
044EC:  CLRF   x9A
044EE:  CLRF   xA7
044F0:  CLRF   xAF
044F2:  CLRF   xB4
044F4:  CLRF   xBC
044F6:  CLRF   xD2
044F8:  CLRF   xD3
044FA:  CLRF   xD1
044FC:  CLRF   xD0
044FE:  MOVLW  0C
04500:  MOVWF  31
04502:  MOVLW  36
04504:  MOVWF  30
04506:  MOVLW  01
04508:  MOVLB  C
0450A:  MOVWF  x37
0450C:  MOVLW  B0
0450E:  MOVWF  x36
04510:  CLRF   x39
04512:  CLRF   x38
04514:  MOVLB  0
04516:  BRA    4540
04518:  DATA 46,40
0451A:  DATA 41,00
0451C:  DATA 14,41
0451E:  DATA D4,00
04520:  DATA 87,42
04522:  DATA 07,00
04524:  DATA 0D,44
04526:  DATA 2E,00
04528:  DATA 66,44
0452A:  DATA 3E,00
0452C:  DATA 0D,44
0452E:  DATA A8,00
04530:  DATA FF,45
04532:  DATA 07,00
04534:  DATA F5,C0
04536:  DATA 00,14
04538:  DATA 47,15
0453A:  DATA 00,64
0453C:  DATA 4B,7E
0453E:  DATA 00,00
04540:  MOVLW  00
04542:  MOVWF  FF8
04544:  MOVLW  45
04546:  MOVWF  FF7
04548:  MOVLW  18
0454A:  MOVWF  FF6
0454C:  TBLRD*+
0454E:  MOVF   FF5,W
04550:  MOVWF  00
04552:  XORLW  00
04554:  BZ    457C
04556:  TBLRD*+
04558:  MOVF   FF5,W
0455A:  MOVWF  01
0455C:  BTFSC  FE8.7
0455E:  BRA    456A
04560:  ANDLW  3F
04562:  MOVWF  FEA
04564:  TBLRD*+
04566:  MOVF   FF5,W
04568:  MOVWF  FE9
0456A:  BTFSC  01.6
0456C:  TBLRD*+
0456E:  BTFSS  01.6
04570:  TBLRD*+
04572:  MOVF   FF5,W
04574:  MOVWF  FEE
04576:  DCFSNZ 00,F
04578:  BRA    454C
0457A:  BRA    456E
0457C:  CLRF   FF8
0457E:  MOVLB  B
04580:  CLRF   xEC
.................... { 
....................     unsigned int8 ui8RetVal                         = 0; 
....................     g_fDataSendingSequence                          = LAN_DATA_SENDING_SEQUENCE_1; 
04582:  MOVLW  01
04584:  MOVLB  7
04586:  MOVWF  x14
....................      
.................... 	// Set Watch Dog Timer ON. 
....................     setup_wdt(WDT_4S | WDT_WINDOW_100_PERCENT); 
04588:  MOVLW  07
0458A:  MOVLB  E
0458C:  MOVWF  x3E
0458E:  MOVLW  19
04590:  MOVWF  x3D
....................      
.................... 	//Initialize 1 millisecond timer. 
.................... 	Init1MSTimer(); 
04592:  MOVLB  0
04594:  GOTO   05B2
....................     	 
.................... 	//Initialize RS485 Receive interrupt. 
.................... 	InitRS485RxInterrupt(); 
04598:  GOTO   05D2
.................... 	 
.................... 	//Initialize UART2UART Receive interrupt. 
....................     InitIBURxInterrupt(); 
0459C:  GOTO   05DE
....................      
....................     // Initialize GPRS Module;EC20 Receive interrupt. 
....................     //InitM66RxInterrupt(); 
....................      
....................     // Initialize LAN Module; USR_K3 receive interrupt. 
....................     InitLANCommRxInterrupt(); 
045A0:  GOTO   05EA
....................  
.................... 	// Initialize Main Global variables  
.................... 	Initialize(); 
045A4:  GOTO   093C
....................      
....................     // Initialize Receive Queue 
....................     InitializeRcvQ(); 
045A8:  GOTO   09D8
....................      
....................     // Set GSM modem ready 
....................     delay_ms(3000); 
045AC:  MOVLW  0C
045AE:  MOVLB  B
045B0:  MOVWF  xED
045B2:  MOVLW  FA
045B4:  MOVLB  C
045B6:  MOVWF  x0B
045B8:  MOVLB  0
045BA:  CALL   09F6
045BE:  MOVLB  B
045C0:  DECFSZ xED,F
045C2:  BRA    45B2
....................      
....................  
.................... 	// Reset WDT. 
.................... 	restart_wdt(); 
045C4:  MOVLB  E
045C6:  MOVF   x3D,W
045C8:  CLRWDT
....................  
.................... 	for(;;) 
.................... 	{  
....................         // step 1: Check if there is any message received in IBU through UART 
....................         g_ui8ElementInQ = ElementsInQ(); 
045CA:  MOVLB  0
045CC:  GOTO   0A26
045D0:  MOVFF  01,1D3
....................         if (g_ui8ElementInQ >= SIZE_IBU_COMPLETE_SEND_MSG) 
045D4:  MOVLB  1
045D6:  MOVF   xD3,W
045D8:  SUBLW  11
045DA:  BC    45E4
....................         { 
....................             // Hopefully a Complete Message Received 
....................             CheckIBUReceiveQ(); 
045DC:  MOVLB  0
045DE:  GOTO   0DE6
045E2:  MOVLB  1
....................         } 
....................  
....................         // step 2: Check if there is any message in IBC Receive Queue 
....................         if (IsMSGInIBUQueue(&g_stIBURcvQueue)) 
045E4:  MOVLW  03
045E6:  MOVLB  B
045E8:  MOVWF  xEE
045EA:  MOVLW  55
045EC:  MOVWF  xED
045EE:  MOVLB  0
045F0:  CALL   1118
045F4:  MOVF   01,F
045F6:  BZ    45FC
....................         { 
....................             // Process IBC  
....................             ProcessIBUMsg(); 
045F8:  GOTO   1370
....................         }  
....................          
....................         // Step 3: check if there is any message in IBU send queue. 
....................         // If available then process to send to UART. 
....................         if(IsMSGInIBUQueue(&g_stIBUSendQueue) &&  
....................           (IBU_SENDING_FREE == g_fIBUSendBusy)) 
045FC:  MOVLW  02
045FE:  MOVLB  B
04600:  MOVWF  xEE
04602:  MOVLW  90
04604:  MOVWF  xED
04606:  MOVLB  0
04608:  CALL   1118
0460C:  MOVF   01,F
0460E:  BZ    4626
04610:  MOVLB  2
04612:  MOVF   x8F,F
04614:  BTFSC  FD8.2
04616:  BRA    461C
04618:  MOVLB  0
0461A:  BRA    4626
....................         { 
....................             // Set flag to denote IBU is busy in sending data. 
....................             g_fIBUSendBusy = IBU_SENDING_BUSY; 
0461C:  MOVLW  01
0461E:  MOVWF  x8F
....................              
....................             // Send data from queue. 
....................             SendIBUMSGFromQ(); 
04620:  MOVLB  0
04622:  GOTO   1654
....................         }         
....................   
....................         // Step 5: Check if a byte received in Modbus..then process data. 
....................         if(ISR_RECEIVED_ALL_BYTES == g_fISRReceivedByteStatus) 
04626:  MOVF   x8D,W
04628:  SUBLW  15
0462A:  BNZ   4634
....................         {  
....................             // Process received data. 
....................             ProcessUART2ReceivedData(); 
0462C:  GOTO   2B8E
....................  
....................             // Reset flag. 
....................             g_fISRReceivedByteStatus = ISR_PROCESSED_ALL_BYTES; 
04630:  MOVLW  16
04632:  MOVWF  x8D
....................         } 
....................          
....................         // Step 6: Check for unix time write to EEPROM signal. 
....................         if(TIME_STAMP_SIGNAL_ON == g_fTSWriteToEEPROMSignal) 
04634:  MOVLB  5
04636:  MOVF   x03,W
04638:  SUBLW  14
0463A:  BNZ   4658
....................         { 
....................             // Write data to EEPROM. 
....................             WriteCurrentUnixTimeToEEPROM(g_ui32HookedUpTimeStampPerMinute); 
0463C:  MOVFF  98,BF0
04640:  MOVFF  97,BEF
04644:  MOVFF  96,BEE
04648:  MOVFF  95,BED
0464C:  MOVLB  0
0464E:  GOTO   3D14
....................              
....................             // Reset flag state. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_COMPLETE; 
04652:  MOVLW  15
04654:  MOVLB  5
04656:  MOVWF  x03
....................         } 
....................          
.................... //        // Step 7: Check if keep alive send status is active. 
.................... //        if(KEEP_ALIVE_SEND_PROCESS_ON == g_fKeepAliveSendStatus) 
.................... //        { 
.................... //            // Check if GPRS data queue is empty. 
.................... //            if(-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //            { 
.................... //                // Queue is empty. 
.................... //                // Stuff keep alive data in queue. 
.................... //                InsertInGPRSQueue(); 
.................... //            } 
.................... //             
.................... //            // Reset keep alive monitoring counter. 
.................... //            g_ui8KeepAliveMonitoringCounter = 180; 
.................... //             
.................... //            // Reset flag status. 
.................... //            g_fKeepAliveSendStatus = KEEP_ALIVE_SEND_PROCESS_OFF; 
.................... //             
.................... //            // Set flag to check query on time. 
.................... //            g_fKeepAliveQueryCheck = CHECK_FOR_QUERY_START; 
.................... //            
.................... //        } 
....................          
....................         // Here, pipe current weight or pipe data will be sent through LAN. 
....................         // By modular data sending process we can uninterruptedly run peripheral 
....................         // process along with data sending in parallel. 
....................          
....................  // ################ Below steps are for GPRS modular data sending ###################### 
....................          
....................         // Step 1: Check modular data sending time interval & data sending sequence 
....................         //         are allowing to initiate data sending process. 
....................         if(SHOULD_SEND_DATA == g_fShouldSendData && 
....................            LAN_DATA_SENDING_SEQUENCE_1 == g_fDataSendingSequence) 
04658:  MOVLB  4
0465A:  MOVF   xFF,W
0465C:  SUBLW  19
0465E:  BNZ   4686
04660:  MOVLB  7
04662:  DECFSZ x14,W
04664:  BRA    4668
04666:  BRA    466C
04668:  MOVLB  4
0466A:  BRA    4686
....................         { 
....................             // Check if new data available in data queue. 
....................             ui8RetVal = IsPipeDataQueueEmpty(); 
0466C:  MOVLB  0
0466E:  GOTO   3D62
04672:  MOVFF  01,BEC
....................              
....................             if(0 == ui8RetVal)  // Queue is not empty. 
04676:  MOVLB  B
04678:  MOVF   xEC,F
0467A:  BNZ   4684
....................             { 
....................                 // Update sequence flag of sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_2; 
0467C:  MOVLW  02
0467E:  MOVLB  7
04680:  MOVWF  x14
....................             } 
04682:  MOVLB  B
....................             else    // Queue is empty. 
....................             { 
....................                 /* Do Nothing; Wait until new data available */ 
....................             } 
....................         } 
04684:  BRA    4758
....................          
....................         // Step 2: If data present in queue then fetch according to queue front 
....................         //         and send. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_2 == g_fDataSendingSequence) 
04686:  MOVLB  7
04688:  MOVF   x14,W
0468A:  SUBLW  02
0468C:  BNZ   46A6
....................         { 
....................             // Send data from queue. 
....................             SendDataFromQ(); 
0468E:  MOVLB  0
04690:  BRA    4066
....................              
....................             // Set a timeout to receive success code. 
....................             g_fIsTimedOut = 0; 
04692:  CLRF   x8F
....................             SetTimeout(SERVER_RESPONSE_RECEIVE_TIMEOUT); 
04694:  MOVLW  03
04696:  MOVLB  B
04698:  MOVWF  xED
0469A:  MOVLB  0
0469C:  RCALL  42B2
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_3; 
0469E:  MOVLW  03
046A0:  MOVLB  7
046A2:  MOVWF  x14
....................         } 
046A4:  BRA    4756
....................          
....................         // Step 3: check for return code from server upto set time. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 0) 
046A6:  MOVF   x14,W
046A8:  SUBLW  03
046AA:  BNZ   46CC
046AC:  MOVLB  0
046AE:  MOVF   x8F,F
046B0:  BTFSC  FD8.2
046B2:  BRA    46B8
046B4:  MOVLB  7
046B6:  BRA    46CC
....................         { 
....................             // Check for server response. 
....................             //ui8RetVal = CheckServerResponse(); 
....................             ui8RetVal = 0; 
046B8:  MOVLB  B
046BA:  CLRF   xEC
....................              
....................             // Check return value. 
....................             if(ui8RetVal == 0)  // Server response received. 
046BC:  MOVF   xEC,F
046BE:  BNZ   46C8
....................             { 
....................                 // Update sequence flag for data sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_4; 
046C0:  MOVLW  04
046C2:  MOVLB  7
046C4:  MOVWF  x14
....................             } 
046C6:  MOVLB  B
....................             else  // No response received after parsing. 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................                 
....................         }  
046C8:  BRA    4758
046CA:  MOVLB  7
....................          
....................         // Step 4: check if set timeout for arriving server response; is over. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 1) 
046CC:  MOVF   x14,W
046CE:  SUBLW  03
046D0:  BNZ   46F2
046D2:  MOVLB  0
046D4:  DECFSZ x8F,W
046D6:  BRA    46DA
046D8:  BRA    46DE
046DA:  MOVLB  7
046DC:  BRA    46F2
....................         { 
....................             // No response received during set time interval for expected arrival. 
....................             // Set a time interval to wait & try Once. 
....................             g_fIsTimedOut = 0; 
046DE:  CLRF   x8F
....................             SetTimeout(DATA_RESEND_INTERVAL_TIMEOUT); 
046E0:  MOVLW  0A
046E2:  MOVLB  B
046E4:  MOVWF  xED
046E6:  MOVLB  0
046E8:  RCALL  42B2
....................  
....................             // Update sequence flag. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_5; 
046EA:  MOVLW  05
046EC:  MOVLB  7
046EE:  MOVWF  x14
....................         } 
046F0:  BRA    4756
....................          
....................         // Step 5: If server response code received & parsed successfully. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_4 == g_fDataSendingSequence) 
046F2:  MOVF   x14,W
046F4:  SUBLW  04
046F6:  BNZ   473E
....................         { 
....................             // Data from queue successfully sent to server and server response 
....................             // is also received.  
....................             // Update flags upon successful data send. 
....................              
....................             // Update data sending interval flag for next interval counting start. 
....................             g_fShouldSendData = SHOULD_NOT_SEND_DATA; 
046F8:  MOVLW  1A
046FA:  MOVLB  4
046FC:  MOVWF  xFF
....................              
....................             // Handle queue front. 
....................             if (g_stPipeDataSendQueue.m_i8Front == g_stPipeDataSendQueue.m_i8Rear) 
046FE:  MOVLB  B
04700:  MOVF   x77,W
04702:  SUBWF  x76,W
04704:  BNZ   470E
....................             { 
....................                 // Queue is empty 
....................                 g_stPipeDataSendQueue.m_i8Front = g_stPipeDataSendQueue.m_i8Rear = -1; 
04706:  SETF   x77
04708:  MOVFF  B77,B76
....................             } 
0470C:  BRA    4736
....................             else // Queue is not empty 
....................             { 
....................                 g_stPipeDataSendQueue.m_i8Front = (g_stPipeDataSendQueue.m_i8Front + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
0470E:  MOVLW  01
04710:  ADDWF  x76,W
04712:  MOVWF  xEE
04714:  CLRF   19
04716:  BTFSC  FF2.7
04718:  BSF    19.7
0471A:  BCF    FF2.7
0471C:  MOVFF  FE8,C33
04720:  MOVLW  64
04722:  MOVLB  C
04724:  MOVWF  x34
04726:  MOVLB  0
04728:  CALL   0182
0472C:  BTFSC  19.7
0472E:  BSF    FF2.7
04730:  MOVFF  00,B76
04734:  MOVLB  B
....................             }  
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
04736:  MOVLW  01
04738:  MOVLB  7
0473A:  MOVWF  x14
....................         } 
0473C:  BRA    4756
....................          
....................         // Step 6: If proper response is not received; after waiting for some time 
....................         //          resend data. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_5 == g_fDataSendingSequence && 
....................                 1 == g_fIsTimedOut) 
0473E:  MOVF   x14,W
04740:  SUBLW  05
04742:  BNZ   4756
04744:  MOVLB  0
04746:  DECFSZ x8F,W
04748:  BRA    474C
0474A:  BRA    4750
0474C:  MOVLB  7
0474E:  BRA    4756
....................         { 
....................             // Update sequence flag to resend data. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
04750:  MOVLW  01
04752:  MOVLB  7
04754:  MOVWF  x14
....................         } 
04756:  MOVLB  B
....................         else 
....................         { 
....................             /* Do Nothing */ 
....................         } 
....................              
.................... 		// Reset WDT. 
....................         restart_wdt();                 
04758:  MOVLB  E
0475A:  MOVF   x3D,W
0475C:  CLRWDT
0475E:  BRA    45CA
.................... 	}	 
.................... } 
....................     	 
04760:  BRA    4760
....................  
....................  
....................  
....................  
....................  
.................... 	 

Configuration Fuses:
   Word  1: DFFF   ECH RSTOSC_EXT NOCLKOUT CKS NOFCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV24 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 01 02 03 04                                        ....
