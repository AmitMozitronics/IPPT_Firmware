CCS PCH C Compiler, Version 5.083, 13314               09-Mar-21 13:08

               Filename:   D:\Work\Projects\PWT\01_Code\PWT-V3.2.2\M1_Comm_Module\M1_Comm_Module.X\build\default\production\_ext\1472\vmIMW_MCU1.lst

               ROM used:   18398 bytes (28%)
                           Largest free fragment is 47134
               RAM used:   3055 (86%) at main() level
                           3126 (88%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   4376
*
00008:  GOTO   00DA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  MOVLB  E
00066:  BTFSS  x2D.5
00068:  GOTO   0072
0006C:  BTFSC  x37.5
0006E:  GOTO   037E
00072:  BTFSS  x2D.1
00074:  GOTO   007E
00078:  BTFSC  x37.1
0007A:  GOTO   048E
0007E:  BTFSS  x29.5
00080:  GOTO   008A
00084:  BTFSC  x33.5
00086:  GOTO   0220
0008A:  MOVFF  0E,00
0008E:  MOVFF  0F,01
00092:  MOVFF  10,02
00096:  MOVFF  11,03
0009A:  MOVFF  0C,FE9
0009E:  MOVFF  07,FEA
000A2:  BSF    07.7
000A4:  MOVFF  08,FE1
000A8:  MOVFF  09,FE2
000AC:  MOVFF  0A,FD9
000B0:  MOVFF  0B,FDA
000B4:  MOVFF  12,FF3
000B8:  MOVFF  13,FF4
000BC:  MOVFF  14,FFA
000C0:  MOVFF  15,FF5
000C4:  MOVFF  16,FF6
000C8:  MOVFF  17,FF7
000CC:  MOVF   04,W
000CE:  MOVFF  06,FE0
000D2:  MOVFF  05,FD8
000D6:  RETFIE 0
000D8:  MOVLB  0
000DA:  MOVWF  1A
000DC:  MOVFF  FD8,1B
000E0:  MOVFF  FE0,1C
000E4:  MOVLB  0
000E6:  MOVFF  FE9,22
000EA:  MOVFF  FEA,1D
000EE:  MOVFF  FE1,1E
000F2:  MOVFF  FE2,1F
000F6:  MOVFF  FD9,20
000FA:  MOVFF  FDA,21
000FE:  MOVFF  FF3,28
00102:  MOVFF  FF4,29
00106:  MOVFF  FFA,2A
0010A:  MOVFF  FF5,2B
0010E:  MOVFF  FF6,2C
00112:  MOVFF  FF7,2D
00116:  MOVFF  00,24
0011A:  MOVFF  01,25
0011E:  MOVFF  02,26
00122:  MOVFF  03,27
00126:  MOVLB  E
00128:  BTFSS  x2C.5
0012A:  GOTO   0134
0012E:  BTFSC  x36.5
00130:  GOTO   01CA
00134:  MOVFF  24,00
00138:  MOVFF  25,01
0013C:  MOVFF  26,02
00140:  MOVFF  27,03
00144:  MOVFF  22,FE9
00148:  MOVFF  1D,FEA
0014C:  BSF    1D.7
0014E:  MOVFF  1E,FE1
00152:  MOVFF  1F,FE2
00156:  MOVFF  20,FD9
0015A:  MOVFF  21,FDA
0015E:  MOVFF  28,FF3
00162:  MOVFF  29,FF4
00166:  MOVFF  2A,FFA
0016A:  MOVFF  2B,FF5
0016E:  MOVFF  2C,FF6
00172:  MOVFF  2D,FF7
00176:  MOVF   1A,W
00178:  MOVFF  1C,FE0
0017C:  MOVFF  1B,FD8
00180:  RETFIE 0
.................... #include "vmSystemConfig.h" 
.................... #ifndef _VM_SYSTEM_CONFIG_H_ 
.................... #define _VM_SYSTEM_CONFIG_H_ 
....................  
.................... //****************** Inclusion Files *************************** 
.................... #include "18F66K40.h" 
.................... //////////// Standard Header file for the PIC18F66K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F66K40 
00182:  MOVLB  C
00184:  MOVF   x34,W
00186:  CLRF   01
00188:  SUBWF  x33,W
0018A:  BC    0192
0018C:  MOVFF  C33,00
00190:  BRA    01AA
00192:  CLRF   00
00194:  MOVLW  08
00196:  MOVWF  x35
00198:  RLCF   x33,F
0019A:  RLCF   00,F
0019C:  MOVF   x34,W
0019E:  SUBWF  00,W
001A0:  BTFSC  FD8.0
001A2:  MOVWF  00
001A4:  RLCF   01,F
001A6:  DECFSZ x35,F
001A8:  BRA    0198
001AA:  MOVLB  0
001AC:  RETURN 0
*
003C0:  DATA 2F,61
003C2:  DATA 70,69
003C4:  DATA 2F,54
003C6:  DATA 65,73
003C8:  DATA 74,2F
003CA:  DATA 47,65
003CC:  DATA 74,53
003CE:  DATA 74,72
003D0:  DATA 69,6E
003D2:  DATA 67,47
003D4:  DATA 65,74
003D6:  DATA 4D,65
003D8:  DATA 74,68
003DA:  DATA 6F,64
003DC:  DATA 3F,61
003DE:  DATA 3D,25
003E0:  DATA 75,26
003E2:  DATA 62,3D
003E4:  DATA 25,4C
003E6:  DATA 75,26
003E8:  DATA 63,3D
003EA:  DATA 25,4C
003EC:  DATA 75,26
003EE:  DATA 64,3D
003F0:  DATA 25,4C
003F2:  DATA 75,26
003F4:  DATA 65,3D
003F6:  DATA 25,4C
003F8:  DATA 75,26
003FA:  DATA 6D,3D
003FC:  DATA 25,4C
003FE:  DATA 75,24
00400:  DATA 25,4C
00402:  DATA 75,24
00404:  DATA 25,4C
00406:  DATA 75,24
00408:  DATA 25,75
0040A:  DATA 00,00
*
00426:  MOVLB  C
00428:  MOVF   x2C,W
0042A:  MULWF  x2E
0042C:  MOVFF  FF3,01
00430:  MOVFF  FF4,00
00434:  MULWF  x2F
00436:  MOVF   FF3,W
00438:  ADDWF  00,F
0043A:  MOVF   x2D,W
0043C:  MULWF  x2E
0043E:  MOVF   FF3,W
00440:  ADDWFC 00,W
00442:  MOVWF  02
00444:  MOVLB  0
00446:  RETURN 0
00448:  CLRF   01
0044A:  CLRF   02
0044C:  CLRF   00
0044E:  CLRF   03
00450:  MOVLB  C
00452:  MOVF   x2E,W
00454:  BNZ   045A
00456:  MOVF   x2D,W
00458:  BZ    048A
0045A:  MOVLW  10
0045C:  MOVWF  x2F
0045E:  BCF    FD8.0
00460:  RLCF   x2B,F
00462:  RLCF   x2C,F
00464:  RLCF   00,F
00466:  RLCF   03,F
00468:  MOVF   x2E,W
0046A:  SUBWF  03,W
0046C:  BNZ   0472
0046E:  MOVF   x2D,W
00470:  SUBWF  00,W
00472:  BNC   0482
00474:  MOVF   x2D,W
00476:  SUBWF  00,F
00478:  BTFSS  FD8.0
0047A:  DECF   03,F
0047C:  MOVF   x2E,W
0047E:  SUBWF  03,F
00480:  BSF    FD8.0
00482:  RLCF   01,F
00484:  RLCF   02,F
00486:  DECFSZ x2F,F
00488:  BRA    045E
0048A:  MOVLB  0
0048C:  RETURN 0
*
009BE:  TSTFSZ 01
009C0:  BRA    09C8
009C2:  TSTFSZ 02
009C4:  BRA    09CA
009C6:  BRA    09D6
009C8:  INCF   02,F
009CA:  MOVFF  00,FEE
009CE:  DECFSZ 01,F
009D0:  BRA    09CA
009D2:  DECFSZ 02,F
009D4:  BRA    09CA
009D6:  RETURN 0
*
01EA0:  MOVLB  C
01EA2:  CLRF   x17
01EA4:  CLRF   x18
01EA6:  MOVLW  01
01EA8:  MOVWF  x19
01EAA:  CLRF   FDA
01EAC:  CLRF   FD9
01EAE:  MOVLW  0C
01EB0:  MOVWF  x1C
01EB2:  MOVLW  0F
01EB4:  MOVWF  x1B
01EB6:  MOVLW  0C
01EB8:  MOVWF  FEA
01EBA:  MOVLW  13
01EBC:  MOVWF  FE9
01EBE:  MOVFF  C1C,FE2
01EC2:  MOVFF  C1B,FE1
01EC6:  MOVFF  C19,C1A
01ECA:  BCF    FD8.0
01ECC:  MOVF   FE5,W
01ECE:  MULWF  FEE
01ED0:  MOVF   FF3,W
01ED2:  ADDWFC x17,F
01ED4:  MOVF   FF4,W
01ED6:  ADDWFC x18,F
01ED8:  DECFSZ x1A,F
01EDA:  BRA    1ECA
01EDC:  MOVFF  C17,FDE
01EE0:  MOVFF  C18,C17
01EE4:  CLRF   x18
01EE6:  BTFSC  FD8.0
01EE8:  INCF   x18,F
01EEA:  INCF   x1B,F
01EEC:  BTFSC  FD8.2
01EEE:  INCF   x1C,F
01EF0:  INCF   x19,F
01EF2:  MOVF   x19,W
01EF4:  SUBLW  05
01EF6:  BNZ   1EB6
01EF8:  MOVLB  0
01EFA:  RETURN 0
*
0200A:  BTFSC  FD8.1
0200C:  BRA    2016
0200E:  MOVLW  0C
02010:  MOVWF  FEA
02012:  MOVLW  1F
02014:  MOVWF  FE9
02016:  MOVLB  C
02018:  MOVF   x1A,W
0201A:  XORWF  x1E,W
0201C:  ANDLW  80
0201E:  MOVWF  x24
02020:  BTFSS  x1A.7
02022:  BRA    203A
02024:  COMF   x17,F
02026:  COMF   x18,F
02028:  COMF   x19,F
0202A:  COMF   x1A,F
0202C:  INCF   x17,F
0202E:  BTFSC  FD8.2
02030:  INCF   x18,F
02032:  BTFSC  FD8.2
02034:  INCF   x19,F
02036:  BTFSC  FD8.2
02038:  INCF   x1A,F
0203A:  BTFSS  x1E.7
0203C:  BRA    2054
0203E:  COMF   x1B,F
02040:  COMF   x1C,F
02042:  COMF   x1D,F
02044:  COMF   x1E,F
02046:  INCF   x1B,F
02048:  BTFSC  FD8.2
0204A:  INCF   x1C,F
0204C:  BTFSC  FD8.2
0204E:  INCF   x1D,F
02050:  BTFSC  FD8.2
02052:  INCF   x1E,F
02054:  CLRF   00
02056:  CLRF   01
02058:  CLRF   02
0205A:  CLRF   03
0205C:  CLRF   x1F
0205E:  CLRF   x20
02060:  CLRF   x21
02062:  CLRF   x22
02064:  MOVF   x1E,W
02066:  IORWF  x1D,W
02068:  IORWF  x1C,W
0206A:  IORWF  x1B,W
0206C:  BZ    20C6
0206E:  MOVLW  20
02070:  MOVWF  x23
02072:  BCF    FD8.0
02074:  RLCF   x17,F
02076:  RLCF   x18,F
02078:  RLCF   x19,F
0207A:  RLCF   x1A,F
0207C:  RLCF   x1F,F
0207E:  RLCF   x20,F
02080:  RLCF   x21,F
02082:  RLCF   x22,F
02084:  MOVF   x1E,W
02086:  SUBWF  x22,W
02088:  BNZ   209A
0208A:  MOVF   x1D,W
0208C:  SUBWF  x21,W
0208E:  BNZ   209A
02090:  MOVF   x1C,W
02092:  SUBWF  x20,W
02094:  BNZ   209A
02096:  MOVF   x1B,W
02098:  SUBWF  x1F,W
0209A:  BNC   20BA
0209C:  MOVF   x1B,W
0209E:  SUBWF  x1F,F
020A0:  MOVF   x1C,W
020A2:  BTFSS  FD8.0
020A4:  INCFSZ x1C,W
020A6:  SUBWF  x20,F
020A8:  MOVF   x1D,W
020AA:  BTFSS  FD8.0
020AC:  INCFSZ x1D,W
020AE:  SUBWF  x21,F
020B0:  MOVF   x1E,W
020B2:  BTFSS  FD8.0
020B4:  INCFSZ x1E,W
020B6:  SUBWF  x22,F
020B8:  BSF    FD8.0
020BA:  RLCF   00,F
020BC:  RLCF   01,F
020BE:  RLCF   02,F
020C0:  RLCF   03,F
020C2:  DECFSZ x23,F
020C4:  BRA    2072
020C6:  BTFSS  x24.7
020C8:  BRA    20E0
020CA:  COMF   00,F
020CC:  COMF   01,F
020CE:  COMF   02,F
020D0:  COMF   03,F
020D2:  INCF   00,F
020D4:  BTFSC  FD8.2
020D6:  INCF   01,F
020D8:  BTFSC  FD8.2
020DA:  INCF   02,F
020DC:  BTFSC  FD8.2
020DE:  INCF   03,F
020E0:  MOVFF  C1F,FEF
020E4:  MOVFF  C20,FEC
020E8:  MOVFF  C21,FEC
020EC:  MOVFF  C22,FEC
020F0:  MOVLB  0
020F2:  RETURN 0
*
03D76:  TBLRD*+
03D78:  MOVFF  FF6,BFB
03D7C:  MOVFF  FF7,BFC
03D80:  MOVF   FF5,W
03D82:  MOVLB  E
03D84:  BTFSS  x37.4
03D86:  BRA    3D84
03D88:  MOVWF  xDD
03D8A:  MOVFF  BFB,FF6
03D8E:  MOVFF  BFC,FF7
03D92:  MOVLB  B
03D94:  DECFSZ xFA,F
03D96:  BRA    3D9A
03D98:  BRA    3D9E
03D9A:  MOVLB  0
03D9C:  BRA    3D76
03D9E:  MOVLB  0
03DA0:  RETURN 0
03DA2:  MOVF   01,W
03DA4:  CLRF   19
03DA6:  BTFSC  FF2.7
03DA8:  BSF    19.7
03DAA:  BCF    FF2.7
03DAC:  MOVFF  BFA,C33
03DB0:  MOVLW  64
03DB2:  MOVLB  C
03DB4:  MOVWF  x34
03DB6:  MOVLB  0
03DB8:  CALL   0182
03DBC:  BTFSC  19.7
03DBE:  BSF    FF2.7
03DC0:  MOVFF  00,BFA
03DC4:  MOVF   01,W
03DC6:  MOVLW  30
03DC8:  BNZ   3DDA
03DCA:  MOVLB  B
03DCC:  BTFSS  xFB.1
03DCE:  BRA    3DF0
03DD0:  BTFSC  xFB.3
03DD2:  BRA    3DF0
03DD4:  BTFSC  xFB.4
03DD6:  MOVLW  20
03DD8:  BRA    3DE2
03DDA:  MOVLB  B
03DDC:  BCF    xFB.3
03DDE:  BCF    xFB.4
03DE0:  BSF    xFB.0
03DE2:  ADDWF  01,F
03DE4:  MOVF   01,W
03DE6:  MOVLB  E
03DE8:  BTFSS  x37.4
03DEA:  BRA    3DE8
03DEC:  MOVWF  xDD
03DEE:  MOVLB  B
03DF0:  CLRF   19
03DF2:  BTFSC  FF2.7
03DF4:  BSF    19.7
03DF6:  BCF    FF2.7
03DF8:  MOVFF  BFA,C33
03DFC:  MOVLW  0A
03DFE:  MOVLB  C
03E00:  MOVWF  x34
03E02:  MOVLB  0
03E04:  CALL   0182
03E08:  BTFSC  19.7
03E0A:  BSF    FF2.7
03E0C:  MOVFF  00,BFA
03E10:  MOVF   01,W
03E12:  MOVLW  30
03E14:  BNZ   3E26
03E16:  MOVLB  B
03E18:  BTFSC  xFB.3
03E1A:  BRA    3E34
03E1C:  BTFSS  xFB.0
03E1E:  BRA    3E34
03E20:  BTFSC  xFB.4
03E22:  MOVLW  20
03E24:  MOVLB  0
03E26:  ADDWF  01,F
03E28:  MOVF   01,W
03E2A:  MOVLB  E
03E2C:  BTFSS  x37.4
03E2E:  BRA    3E2C
03E30:  MOVWF  xDD
03E32:  MOVLB  B
03E34:  MOVLW  30
03E36:  ADDWF  xFA,F
03E38:  MOVF   xFA,W
03E3A:  MOVLB  E
03E3C:  BTFSS  x37.4
03E3E:  BRA    3E3C
03E40:  MOVWF  xDD
03E42:  MOVLB  0
03E44:  RETURN 0
03E46:  MOVFF  FEA,C06
03E4A:  MOVFF  FE9,C05
03E4E:  MOVLB  B
03E50:  SWAPF  xFB,W
03E52:  IORLW  F0
03E54:  MOVLB  C
03E56:  MOVWF  x01
03E58:  ADDWF  x01,F
03E5A:  ADDLW  E2
03E5C:  MOVWF  x02
03E5E:  ADDLW  32
03E60:  MOVWF  x04
03E62:  MOVLB  B
03E64:  MOVF   xFB,W
03E66:  ANDLW  0F
03E68:  MOVLB  C
03E6A:  ADDWF  x02,F
03E6C:  ADDWF  x02,F
03E6E:  ADDWF  x04,F
03E70:  ADDLW  E9
03E72:  MOVWF  x03
03E74:  ADDWF  x03,F
03E76:  ADDWF  x03,F
03E78:  MOVLB  B
03E7A:  SWAPF  xFA,W
03E7C:  ANDLW  0F
03E7E:  MOVLB  C
03E80:  ADDWF  x03,F
03E82:  ADDWF  x04,F
03E84:  RLCF   x03,F
03E86:  RLCF   x04,F
03E88:  COMF   x04,F
03E8A:  RLCF   x04,F
03E8C:  MOVLB  B
03E8E:  MOVF   xFA,W
03E90:  ANDLW  0F
03E92:  MOVLB  C
03E94:  ADDWF  x04,F
03E96:  RLCF   x01,F
03E98:  MOVLW  07
03E9A:  MOVWF  x00
03E9C:  MOVLW  0A
03E9E:  DECF   x03,F
03EA0:  ADDWF  x04,F
03EA2:  BNC   3E9E
03EA4:  DECF   x02,F
03EA6:  ADDWF  x03,F
03EA8:  BNC   3EA4
03EAA:  DECF   x01,F
03EAC:  ADDWF  x02,F
03EAE:  BNC   3EAA
03EB0:  DECF   x00,F
03EB2:  ADDWF  x01,F
03EB4:  BNC   3EB0
03EB6:  MOVLW  0C
03EB8:  MOVWF  FEA
03EBA:  CLRF   FE9
03EBC:  MOVLW  07
03EBE:  ANDWF  x05,W
03EC0:  BCF    x05.6
03EC2:  ADDWF  FE9,F
03EC4:  MOVLW  00
03EC6:  ADDWFC FEA,F
03EC8:  MOVF   FE9,W
03ECA:  SUBLW  04
03ECC:  BNZ   3ED6
03ECE:  MOVF   FEA,W
03ED0:  SUBLW  0C
03ED2:  BNZ   3ED6
03ED4:  BSF    x05.6
03ED6:  MOVF   FEF,W
03ED8:  MOVWF  00
03EDA:  BNZ   3EEC
03EDC:  BTFSC  x05.6
03EDE:  BRA    3EEC
03EE0:  BTFSC  x05.4
03EE2:  BRA    3F00
03EE4:  BTFSC  x05.3
03EE6:  BRA    3EEC
03EE8:  MOVLW  20
03EEA:  BRA    3EF2
03EEC:  BSF    x05.3
03EEE:  BCF    x05.4
03EF0:  MOVLW  30
03EF2:  ADDWF  00,F
03EF4:  MOVF   00,W
03EF6:  MOVLB  E
03EF8:  BTFSS  x37.4
03EFA:  BRA    3EF8
03EFC:  MOVWF  xDD
03EFE:  MOVLB  C
03F00:  MOVF   FEE,W
03F02:  BTFSS  x05.6
03F04:  BRA    3EC8
03F06:  MOVLB  0
03F08:  RETURN 0
03F0A:  BTFSC  FD8.1
03F0C:  BRA    3F16
03F0E:  MOVLW  0C
03F10:  MOVWF  FEA
03F12:  MOVLW  14
03F14:  MOVWF  FE9
03F16:  CLRF   00
03F18:  CLRF   01
03F1A:  CLRF   02
03F1C:  CLRF   03
03F1E:  MOVLB  C
03F20:  CLRF   x14
03F22:  CLRF   x15
03F24:  CLRF   x16
03F26:  CLRF   x17
03F28:  MOVF   x13,W
03F2A:  IORWF  x12,W
03F2C:  IORWF  x11,W
03F2E:  IORWF  x10,W
03F30:  BZ    3F8A
03F32:  MOVLW  20
03F34:  MOVWF  x18
03F36:  BCF    FD8.0
03F38:  RLCF   x0C,F
03F3A:  RLCF   x0D,F
03F3C:  RLCF   x0E,F
03F3E:  RLCF   x0F,F
03F40:  RLCF   x14,F
03F42:  RLCF   x15,F
03F44:  RLCF   x16,F
03F46:  RLCF   x17,F
03F48:  MOVF   x13,W
03F4A:  SUBWF  x17,W
03F4C:  BNZ   3F5E
03F4E:  MOVF   x12,W
03F50:  SUBWF  x16,W
03F52:  BNZ   3F5E
03F54:  MOVF   x11,W
03F56:  SUBWF  x15,W
03F58:  BNZ   3F5E
03F5A:  MOVF   x10,W
03F5C:  SUBWF  x14,W
03F5E:  BNC   3F7E
03F60:  MOVF   x10,W
03F62:  SUBWF  x14,F
03F64:  MOVF   x11,W
03F66:  BTFSS  FD8.0
03F68:  INCFSZ x11,W
03F6A:  SUBWF  x15,F
03F6C:  MOVF   x12,W
03F6E:  BTFSS  FD8.0
03F70:  INCFSZ x12,W
03F72:  SUBWF  x16,F
03F74:  MOVF   x13,W
03F76:  BTFSS  FD8.0
03F78:  INCFSZ x13,W
03F7A:  SUBWF  x17,F
03F7C:  BSF    FD8.0
03F7E:  RLCF   00,F
03F80:  RLCF   01,F
03F82:  RLCF   02,F
03F84:  RLCF   03,F
03F86:  DECFSZ x18,F
03F88:  BRA    3F36
03F8A:  MOVFF  C14,FEF
03F8E:  MOVFF  C15,FEC
03F92:  MOVFF  C16,FEC
03F96:  MOVFF  C17,FEC
03F9A:  MOVLB  0
03F9C:  RETURN 0
03F9E:  MOVF   FE9,W
03FA0:  MOVLB  C
03FA2:  MOVWF  x00
03FA4:  MOVLW  3B
03FA6:  MOVWF  x07
03FA8:  MOVLW  9A
03FAA:  MOVWF  x06
03FAC:  MOVLW  CA
03FAE:  MOVWF  x05
03FB0:  CLRF   x04
03FB2:  MOVLW  0A
03FB4:  MOVWF  x02
03FB6:  BSF    FD8.1
03FB8:  MOVLW  0B
03FBA:  MOVWF  FEA
03FBC:  MOVLW  FA
03FBE:  MOVWF  FE9
03FC0:  MOVFF  BFD,C0F
03FC4:  MOVFF  BFC,C0E
03FC8:  MOVFF  BFB,C0D
03FCC:  MOVFF  BFA,C0C
03FD0:  MOVFF  C07,C13
03FD4:  MOVFF  C06,C12
03FD8:  MOVFF  C05,C11
03FDC:  MOVFF  C04,C10
03FE0:  MOVLB  0
03FE2:  RCALL  3F0A
03FE4:  MOVF   01,W
03FE6:  MOVF   00,F
03FE8:  BNZ   4010
03FEA:  MOVLB  C
03FEC:  MOVF   x02,W
03FEE:  XORLW  01
03FF0:  BTFSS  FD8.2
03FF2:  BRA    3FF8
03FF4:  MOVLB  0
03FF6:  BRA    4010
03FF8:  MOVF   x00,W
03FFA:  BZ    4014
03FFC:  ANDLW  0F
03FFE:  SUBWF  x02,W
04000:  BZ    4004
04002:  BC    4024
04004:  BTFSC  x00.7
04006:  BRA    4024
04008:  BTFSC  x00.6
0400A:  BRA    4014
0400C:  MOVLW  20
0400E:  BRA    4016
04010:  MOVLB  C
04012:  CLRF   x00
04014:  MOVLW  30
04016:  ADDWF  00,F
04018:  MOVF   00,W
0401A:  MOVLB  E
0401C:  BTFSS  x37.4
0401E:  BRA    401C
04020:  MOVWF  xDD
04022:  MOVLB  C
04024:  BCF    FD8.1
04026:  MOVFF  C07,C0F
0402A:  MOVFF  C06,C0E
0402E:  MOVFF  C05,C0D
04032:  MOVFF  C04,C0C
04036:  CLRF   x13
04038:  CLRF   x12
0403A:  CLRF   x11
0403C:  MOVLW  0A
0403E:  MOVWF  x10
04040:  MOVLB  0
04042:  RCALL  3F0A
04044:  MOVFF  03,C07
04048:  MOVFF  02,C06
0404C:  MOVFF  01,C05
04050:  MOVFF  00,C04
04054:  MOVLB  C
04056:  DECFSZ x02,F
04058:  BRA    3FB6
0405A:  MOVLB  0
0405C:  RETURN 0
....................  
.................... #list 
....................  
.................... #include "vmPINConfig.h" 
.................... #ifndef _VM_PIN_CONFIG_H_ 
.................... #define _VM_PIN_CONFIG_H_ 
....................  
.................... //#include "18F46K80.h" 
....................  
.................... // RS485 Communication Pin Mapping. 
.................... #define PIN_RS485_XMIT              PIN_E0 
.................... #define PIN_RS485_RCV               PIN_E1 
.................... #define PIN_RS485_RTS               PIN_G0			 
....................  
.................... // GPSR Communication PIN Mapping; SIM900/SIM800/Quectel. 
.................... #define PIN_GPRS_COMM_XMIT          PIN_G1 
.................... #define PIN_GPRS_COMM_RCV           PIN_G2 
....................  
.................... // UART -><- UART(IBU) Communication PIN Mapping. 
.................... #define PIN_IBU_RCV                 PIN_C7 
.................... #define PIN_IBU_XMIT                PIN_C6 
....................  
.................... // Extra UART PIN Mapping.(For Spare Purpose) 
.................... #define PIN_EXT_UART_XMIT           PIN_C0 
.................... #define PIN_EXT_UART_RCV            PIN_C1 
....................  
.................... // Digital Input(DI) PIN Mapping. 
.................... #define PIN_INPUT_DI_00             PIN_C2 
.................... #define PIN_INPUT_DI_01             PIN_C3 
....................  
.................... // Digital Output PIN Mapping. 
.................... #define PIN_OUT_DO_00               PIN_E5 
.................... #define PIN_OUT_DO_01               PIN_E4 
....................  
.................... // Spare Serial Clock and Serial Data PIN Mapping. 
.................... #define PIN_MCU1_SCLK               PIN_D6 
.................... #define PIN_MCU1_SDA                PIN_D5 
....................    
....................  
.................... #endif /* _VM_PIN_CONFIG_H_ */ 
....................  
....................  
.................... //****************** Component Configuration ******************** 
....................  
....................  
.................... //********* CPU Settings ******************************************* 
.................... #pragma device HIGH_INTS=TRUE 
....................  
.................... #pragma fuses ECH,WDT,NOPROTECT,NOBROWNOUT,NOFCMEN,NOPUT  
.................... #pragma use delay(clock=20000000,restart_wdt) 
*
0176C:  MOVLW  0C
0176E:  MOVWF  FEA
01770:  MOVLW  0B
01772:  MOVWF  FE9
01774:  MOVF   FEF,W
01776:  BZ    179A
01778:  MOVLW  06
0177A:  MOVWF  01
0177C:  MOVLW  BF
0177E:  MOVWF  00
01780:  CLRWDT
01782:  DECFSZ 00,F
01784:  BRA    1780
01786:  DECFSZ 01,F
01788:  BRA    177C
0178A:  MOVLW  7A
0178C:  MOVWF  00
0178E:  DECFSZ 00,F
01790:  BRA    178E
01792:  BRA    1794
01794:  CLRWDT
01796:  DECFSZ FEF,F
01798:  BRA    1778
0179A:  RETURN 0
....................  
.................... //******** Serial Interface ************ 
.................... //#pragma use rs232(stream=GSM_M66, xmit=PIN_GPRS_COMM_XMIT, rcv=PIN_GPRS_COMM_RCV, baud=9600, bits=8, parity=N, stop=1, restart_wdt) 
....................  
.................... // ############### Using UART3 -> Configure for RS485 ########################## 
.................... #PIN_SELECT U3RX=PIN_E1 
.................... #PIN_SELECT U3TX=PIN_E0 
.................... #use rs232(baud=38400,UART3,stream=RS485,ERRORS) 
*
0040C:  MOVLB  E
0040E:  BTFSS  x37.1
00410:  BRA    040E
00412:  MOVFF  EEE,2F
00416:  MOVFF  EEA,01
0041A:  BTFSS  2F.1
0041C:  BRA    0422
0041E:  BCF    xEE.4
00420:  BSF    xEE.4
00422:  MOVLB  0
00424:  RETURN 0
*
0179C:  MOVLB  E
0179E:  BTFSS  x37.0
017A0:  BRA    179E
017A2:  MOVWF  xEB
017A4:  MOVLB  0
017A6:  RETURN 0
....................  
.................... // ############### Using UART1 -> Configure for UART 2 UART #################### 
.................... #PIN_SELECT U1RX=PIN_C7 
.................... #PIN_SELECT U1TX=PIN_C6 
.................... #use rs232(baud=19200,UART1,stream=UART,ERRORS) 
*
001AE:  MOVLB  E
001B0:  BTFSS  x36.5
001B2:  BRA    01B0
001B4:  MOVFF  F9C,2F
001B8:  MOVFF  F98,01
001BC:  BTFSS  2F.1
001BE:  BRA    01C4
001C0:  BCF    F9C.4
001C2:  BSF    F9C.4
001C4:  MOVLB  0
001C6:  GOTO   0208 (RETURN)
*
00DAA:  MOVLB  E
00DAC:  BTFSS  x36.4
00DAE:  BRA    0DAC
00DB0:  MOVWF  F99
00DB2:  MOVLB  0
00DB4:  RETURN 0
....................  
.................... //// ############### Using UART2 -> Configure for GPRS Module;EC20 ############### 
.................... //#PIN_SELECT U2RX=PIN_G2 
.................... //#PIN_SELECT U2TX=PIN_G1 
.................... //#use rs232(baud=115200,UART2,stream=GSM_M66,ERRORS) 
....................  
.................... // ################# Using UART2 -> Configure for LAN Module; USR_K3 ########### 
.................... #PIN_SELECT U5RX=PIN_E3 
.................... #PIN_SELECT U5TX=PIN_E2 
.................... #use rs232(baud=115200,UART5,stream=LAN_USR,ERRORS) 
*
00362:  MOVLB  E
00364:  BTFSS  x37.5
00366:  BRA    0364
00368:  MOVFF  EE0,2F
0036C:  MOVFF  EDC,01
00370:  BTFSS  2F.1
00372:  BRA    0378
00374:  BCF    xE0.4
00376:  BSF    xE0.4
00378:  MOVLB  0
0037A:  GOTO   039C (RETURN)
....................  
.................... #pragma priority INT_RDA,INT_RDA5,INT_RDA3 
....................  
.................... #ifndef M1_COMM_MODULE 
.................... #define M1_COMM_MODULE  1 
.................... #endif 
....................  
.................... #endif /* _VM_SYSTEM_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                          time.c                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
*
01FA2:  MOVLB  C
01FA4:  CLRF   x10
.................... { 
....................     unsigned int8 ui8ReturnValue = 0; 
....................     switch(month) 
01FA6:  MOVF   x0E,W
01FA8:  XORLW  00
01FAA:  MOVLB  0
01FAC:  BZ    1FDC
01FAE:  XORLW  02
01FB0:  BZ    1FDC
01FB2:  XORLW  06
01FB4:  BZ    1FDC
01FB6:  XORLW  02
01FB8:  BZ    1FDC
01FBA:  XORLW  01
01FBC:  BZ    1FDC
01FBE:  XORLW  0E
01FC0:  BZ    1FDC
01FC2:  XORLW  02
01FC4:  BZ    1FDC
01FC6:  XORLW  0A
01FC8:  BZ    1FE4
01FCA:  XORLW  02
01FCC:  BZ    1FF6
01FCE:  XORLW  06
01FD0:  BZ    1FF6
01FD2:  XORLW  0D
01FD4:  BZ    1FF6
01FD6:  XORLW  02
01FD8:  BZ    1FF6
01FDA:  BRA    2000
....................     { 
....................        case JANUARY: 
....................        case MARCH: 
....................        case MAY: 
....................        case JULY: 
....................        case AUGUST: 
....................        case OCTOBER: 
....................        case DECEMBER: 
....................            ui8ReturnValue = 31; 
01FDC:  MOVLW  1F
01FDE:  MOVLB  C
01FE0:  MOVWF  x10
....................            break; 
01FE2:  BRA    2002
....................        case FEBRUARY: 
....................             if(IsLeapYear) 
01FE4:  MOVLB  C
01FE6:  MOVF   x0F,F
01FE8:  BZ    1FF0
....................             { 
....................                 ui8ReturnValue = 29; 
01FEA:  MOVLW  1D
01FEC:  MOVWF  x10
....................             } 
01FEE:  BRA    1FF4
....................             else 
....................             { 
....................                 ui8ReturnValue = 28; 
01FF0:  MOVLW  1C
01FF2:  MOVWF  x10
....................             } 
....................             break; 
01FF4:  BRA    2002
....................        case APRIL: 
....................        case JUNE: 
....................        case SEPTEMBER: 
....................        case NOVEMBER: 
....................           ui8ReturnValue = 30; 
01FF6:  MOVLW  1E
01FF8:  MOVLB  C
01FFA:  MOVWF  x10
....................           break; 
01FFC:  BRA    2002
01FFE:  MOVLB  0
....................        // error 
....................        default: 
....................            break; 
02000:  MOVLB  C
....................     } 
....................      
....................     return ui8ReturnValue; 
02002:  MOVFF  C10,01
02006:  MOVLB  0
02008:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... int1 LeapYear(unsigned int16 year) 
.................... { 
....................     if( ((year + 1900) % 400 == 0) ||  
....................         (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
01EFC:  MOVLW  6C
01EFE:  MOVLB  C
01F00:  ADDWF  x0B,W
01F02:  MOVWF  x0D
01F04:  MOVLW  07
01F06:  ADDWFC x0C,W
01F08:  MOVWF  x0E
01F0A:  CLRF   19
01F0C:  BTFSC  FF2.7
01F0E:  BSF    19.7
01F10:  BCF    FF2.7
01F12:  MOVWF  x2C
01F14:  MOVFF  C0D,C2B
01F18:  MOVLW  01
01F1A:  MOVWF  x2E
01F1C:  MOVLW  90
01F1E:  MOVWF  x2D
01F20:  MOVLB  0
01F22:  CALL   0448
01F26:  BTFSC  19.7
01F28:  BSF    FF2.7
01F2A:  MOVFF  00,C0D
01F2E:  MOVLB  C
01F30:  MOVFF  03,C0E
01F34:  MOVF   x0D,F
01F36:  BNZ   1F3C
01F38:  MOVF   x0E,F
01F3A:  BZ    1F92
01F3C:  MOVLW  6C
01F3E:  ADDWF  x0B,W
01F40:  MOVWF  x0D
01F42:  MOVLW  07
01F44:  ADDWFC x0C,W
01F46:  MOVWF  x0E
01F48:  MOVLW  03
01F4A:  ANDWF  x0D,F
01F4C:  CLRF   x0E
01F4E:  MOVF   x0D,F
01F50:  BNZ   1F9A
01F52:  MOVF   x0E,F
01F54:  BNZ   1F9A
01F56:  MOVLW  6C
01F58:  ADDWF  x0B,W
01F5A:  MOVWF  x0D
01F5C:  MOVLW  07
01F5E:  ADDWFC x0C,W
01F60:  MOVWF  x0E
01F62:  CLRF   19
01F64:  BTFSC  FF2.7
01F66:  BSF    19.7
01F68:  BCF    FF2.7
01F6A:  MOVWF  x2C
01F6C:  MOVFF  C0D,C2B
01F70:  CLRF   x2E
01F72:  MOVLW  64
01F74:  MOVWF  x2D
01F76:  MOVLB  0
01F78:  CALL   0448
01F7C:  BTFSC  19.7
01F7E:  BSF    FF2.7
01F80:  MOVFF  00,C0D
01F84:  MOVLB  C
01F86:  MOVFF  03,C0E
01F8A:  MOVF   x0D,F
01F8C:  BNZ   1F92
01F8E:  MOVF   x0E,F
01F90:  BZ    1F9A
....................     { 
....................        return TRUE; 
01F92:  MOVLW  01
01F94:  MOVWF  01
01F96:  BRA    1F9E
....................     } 
01F98:  BRA    1F9E
....................     else 
....................     { 
....................         return FALSE; 
01F9A:  MOVLW  00
01F9C:  MOVWF  01
....................     } 
01F9E:  MOVLB  0
01FA0:  RETURN 0
.................... } 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT) 
*
020F4:  MOVLB  B
020F6:  CLRF   xFD
020F8:  CLRF   xFC
020FA:  CLRF   xFB
020FC:  CLRF   xFA
020FE:  BCF    xFE.0
02100:  MOVLB  C
02102:  CLRF   x00
02104:  MOVLB  B
02106:  CLRF   xFF
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
02108:  MOVF   xF8,F
0210A:  BNZ   2112
0210C:  MOVF   xF9,F
0210E:  BTFSC  FD8.2
02110:  BRA    262A
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
02112:  MOVFF  BF8,FE9
02116:  MOVFF  BF9,FEA
0211A:  MOVF   FEF,W
0211C:  ADDWF  xFA,F
0211E:  MOVLW  00
02120:  ADDWFC xFB,F
02122:  ADDWFC xFC,F
02124:  ADDWFC xFD,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
02126:  MOVLW  01
02128:  ADDWF  xF8,W
0212A:  MOVWF  FE9
0212C:  MOVLW  00
0212E:  ADDWFC xF9,W
02130:  MOVWF  FEA
02132:  MOVF   FEF,W
02134:  MOVLB  C
02136:  CLRF   x04
02138:  CLRF   x03
0213A:  CLRF   x02
0213C:  MOVWF  x01
0213E:  MOVFF  FEA,C06
02142:  MOVFF  FE9,C05
02146:  MOVFF  C04,C12
0214A:  MOVFF  C03,C11
0214E:  MOVFF  C02,C10
02152:  MOVWF  x0F
02154:  CLRF   x16
02156:  CLRF   x15
02158:  CLRF   x14
0215A:  MOVLW  3C
0215C:  MOVWF  x13
0215E:  MOVLB  0
02160:  RCALL  1EA0
02162:  MOVFF  C06,FEA
02166:  MOVFF  C05,FE9
0216A:  MOVF   00,W
0216C:  MOVLB  B
0216E:  ADDWF  xFA,F
02170:  MOVF   01,W
02172:  ADDWFC xFB,F
02174:  MOVF   02,W
02176:  ADDWFC xFC,F
02178:  MOVF   03,W
0217A:  ADDWFC xFD,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
0217C:  MOVLW  02
0217E:  ADDWF  xF8,W
02180:  MOVWF  FE9
02182:  MOVLW  00
02184:  ADDWFC xF9,W
02186:  MOVWF  FEA
02188:  MOVF   FEF,W
0218A:  MOVLB  C
0218C:  CLRF   x04
0218E:  CLRF   x03
02190:  CLRF   x02
02192:  MOVWF  x01
02194:  MOVFF  FEA,C06
02198:  MOVFF  FE9,C05
0219C:  MOVFF  C04,C12
021A0:  MOVFF  C03,C11
021A4:  MOVFF  C02,C10
021A8:  MOVWF  x0F
021AA:  CLRF   x16
021AC:  CLRF   x15
021AE:  MOVLW  0E
021B0:  MOVWF  x14
021B2:  MOVLW  10
021B4:  MOVWF  x13
021B6:  MOVLB  0
021B8:  RCALL  1EA0
021BA:  MOVFF  C06,FEA
021BE:  MOVFF  C05,FE9
021C2:  MOVF   00,W
021C4:  MOVLB  B
021C6:  ADDWF  xFA,F
021C8:  MOVF   01,W
021CA:  ADDWFC xFB,F
021CC:  MOVF   02,W
021CE:  ADDWFC xFC,F
021D0:  MOVF   03,W
021D2:  ADDWFC xFD,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
021D4:  MOVLW  05
021D6:  ADDWF  xF8,W
021D8:  MOVWF  FE9
021DA:  MOVLW  00
021DC:  ADDWFC xF9,W
021DE:  MOVWF  FEA
021E0:  MOVFF  FEC,C0C
021E4:  MOVF   FED,F
021E6:  MOVFF  FEF,C0B
021EA:  MOVLB  0
021EC:  RCALL  1EFC
021EE:  MOVLB  B
021F0:  BCF    xFE.0
021F2:  BTFSC  01.0
021F4:  BSF    xFE.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
021F6:  MOVLW  04
021F8:  ADDWF  xF8,W
021FA:  MOVWF  FE9
021FC:  MOVLW  00
021FE:  ADDWFC xF9,W
02200:  MOVWF  FEA
02202:  CLRF   19
02204:  BTFSC  FF2.7
02206:  BSF    19.7
02208:  BCF    FF2.7
0220A:  MOVFF  FEF,C33
0220E:  MOVLW  0C
02210:  MOVLB  C
02212:  MOVWF  x34
02214:  MOVLB  0
02216:  CALL   0182
0221A:  BTFSC  19.7
0221C:  BSF    FF2.7
0221E:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
02222:  MOVLB  C
02224:  CLRF   x00
02226:  MOVLW  01
02228:  MOVLB  B
0222A:  MOVWF  xFF
0222C:  MOVLW  04
0222E:  ADDWF  xF8,W
02230:  MOVWF  FE9
02232:  MOVLW  00
02234:  ADDWFC xF9,W
02236:  MOVWF  FEA
02238:  MOVF   FEF,W
0223A:  MOVLB  C
0223C:  MOVF   x00,F
0223E:  BNZ   22C2
02240:  MOVLB  B
02242:  SUBWF  xFF,W
02244:  BZ    224E
02246:  BTFSS  FD8.0
02248:  BRA    224E
0224A:  MOVLB  C
0224C:  BRA    22C2
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
0224E:  MOVLW  01
02250:  SUBWF  xFF,W
02252:  MOVLB  C
02254:  MOVWF  x01
02256:  MOVLW  00
02258:  SUBWFB x00,W
0225A:  MOVWF  x02
0225C:  MOVLW  00
0225E:  MOVLB  B
02260:  BTFSC  xFE.0
02262:  MOVLW  01
02264:  MOVLB  C
02266:  MOVWF  x03
02268:  MOVFF  C01,C0E
0226C:  MOVWF  x0F
0226E:  MOVLB  0
02270:  RCALL  1FA2
02272:  MOVFF  FEA,C03
02276:  MOVFF  FE9,C02
0227A:  MOVLB  C
0227C:  CLRF   x12
0227E:  CLRF   x11
02280:  CLRF   x10
02282:  MOVFF  01,C0F
02286:  CLRF   x16
02288:  MOVLW  01
0228A:  MOVWF  x15
0228C:  MOVLW  51
0228E:  MOVWF  x14
02290:  MOVLW  80
02292:  MOVWF  x13
02294:  MOVLB  0
02296:  RCALL  1EA0
02298:  MOVFF  C03,FEA
0229C:  MOVFF  C02,FE9
022A0:  MOVF   00,W
022A2:  MOVLB  B
022A4:  ADDWF  xFA,F
022A6:  MOVF   01,W
022A8:  ADDWFC xFB,F
022AA:  MOVF   02,W
022AC:  ADDWFC xFC,F
022AE:  MOVF   03,W
022B0:  ADDWFC xFD,F
022B2:  INCF   xFF,F
022B4:  BTFSS  FD8.2
022B6:  BRA    22BE
022B8:  MOVLB  C
022BA:  INCF   x00,F
022BC:  MOVLB  B
022BE:  BRA    222C
022C0:  MOVLB  C
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
022C2:  MOVLW  03
022C4:  MOVLB  B
022C6:  ADDWF  xF8,W
022C8:  MOVWF  01
022CA:  MOVLW  00
022CC:  ADDWFC xF9,W
022CE:  MOVWF  03
022D0:  MOVFF  01,C01
022D4:  MOVLB  C
022D6:  MOVWF  x02
022D8:  MOVWF  FEA
022DA:  MOVFF  01,FE9
022DE:  MOVFF  FEF,C03
022E2:  MOVLW  04
022E4:  MOVLB  B
022E6:  ADDWF  xF8,W
022E8:  MOVWF  FE9
022EA:  MOVLW  00
022EC:  ADDWFC xF9,W
022EE:  MOVWF  FEA
022F0:  MOVFF  FEF,C0E
022F4:  MOVLW  00
022F6:  BTFSC  xFE.0
022F8:  MOVLW  01
022FA:  MOVLB  C
022FC:  MOVWF  x05
022FE:  MOVWF  x0F
02300:  MOVLB  0
02302:  RCALL  1FA2
02304:  CLRF   19
02306:  BTFSC  FF2.7
02308:  BSF    19.7
0230A:  BCF    FF2.7
0230C:  MOVFF  C03,C33
02310:  MOVFF  01,C34
02314:  CALL   0182
02318:  BTFSC  19.7
0231A:  BSF    FF2.7
0231C:  MOVLB  C
0231E:  MOVFF  C02,FEA
02322:  MOVFF  C01,FE9
02326:  MOVFF  00,FEF
....................       unixTime += (timeT->tm_mday) * 86400; 
0232A:  MOVLW  03
0232C:  MOVLB  B
0232E:  ADDWF  xF8,W
02330:  MOVWF  FE9
02332:  MOVLW  00
02334:  ADDWFC xF9,W
02336:  MOVWF  FEA
02338:  MOVFF  FEA,C03
0233C:  MOVFF  FE9,C02
02340:  MOVLB  C
02342:  CLRF   x12
02344:  CLRF   x11
02346:  CLRF   x10
02348:  MOVFF  FEF,C0F
0234C:  CLRF   x16
0234E:  MOVLW  01
02350:  MOVWF  x15
02352:  MOVLW  51
02354:  MOVWF  x14
02356:  MOVLW  80
02358:  MOVWF  x13
0235A:  MOVLB  0
0235C:  RCALL  1EA0
0235E:  MOVFF  C03,FEA
02362:  MOVFF  C02,FE9
02366:  MOVF   00,W
02368:  MOVLB  B
0236A:  ADDWF  xFA,F
0236C:  MOVF   01,W
0236E:  ADDWFC xFB,F
02370:  MOVF   02,W
02372:  ADDWFC xFC,F
02374:  MOVF   03,W
02376:  ADDWFC xFD,F
....................        
....................       if(isLeapYear) 
02378:  BTFSS  xFE.0
0237A:  BRA    2426
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
0237C:  MOVLW  08
0237E:  ADDWF  xF8,W
02380:  MOVWF  01
02382:  MOVLW  00
02384:  ADDWFC xF9,W
02386:  MOVWF  03
02388:  MOVFF  01,C01
0238C:  MOVLB  C
0238E:  MOVWF  x02
02390:  MOVFF  FEA,C04
02394:  MOVFF  FE9,C03
02398:  BCF    FD8.1
0239A:  MOVFF  BFD,C1A
0239E:  MOVFF  BFC,C19
023A2:  MOVFF  BFB,C18
023A6:  MOVFF  BFA,C17
023AA:  CLRF   x1E
023AC:  MOVLW  01
023AE:  MOVWF  x1D
023B0:  MOVLW  51
023B2:  MOVWF  x1C
023B4:  MOVLW  80
023B6:  MOVWF  x1B
023B8:  MOVLB  0
023BA:  RCALL  200A
023BC:  MOVFF  C04,FEA
023C0:  MOVFF  C03,FE9
023C4:  MOVFF  03,C08
023C8:  MOVFF  02,C07
023CC:  MOVFF  01,C06
023D0:  MOVFF  00,C05
023D4:  BSF    FD8.1
023D6:  MOVLW  0C
023D8:  MOVWF  FEA
023DA:  MOVLW  0B
023DC:  MOVWF  FE9
023DE:  MOVFF  03,C1A
023E2:  MOVFF  02,C19
023E6:  MOVFF  01,C18
023EA:  MOVFF  00,C17
023EE:  MOVLB  C
023F0:  CLRF   x1E
023F2:  CLRF   x1D
023F4:  MOVLW  01
023F6:  MOVWF  x1C
023F8:  MOVLW  6E
023FA:  MOVWF  x1B
023FC:  MOVLB  0
023FE:  RCALL  200A
02400:  MOVFF  C0B,00
02404:  MOVFF  C0C,01
02408:  MOVFF  C0D,02
0240C:  MOVFF  C0E,03
02410:  MOVFF  C02,FEA
02414:  MOVFF  C01,FE9
02418:  MOVFF  01,FEC
0241C:  MOVF   FED,F
0241E:  MOVFF  00,FEF
....................       } 
02422:  BRA    24CC
02424:  MOVLB  B
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
02426:  MOVLW  08
02428:  ADDWF  xF8,W
0242A:  MOVWF  01
0242C:  MOVLW  00
0242E:  ADDWFC xF9,W
02430:  MOVWF  03
02432:  MOVFF  01,C01
02436:  MOVLB  C
02438:  MOVWF  x02
0243A:  MOVFF  FEA,C04
0243E:  MOVFF  FE9,C03
02442:  BCF    FD8.1
02444:  MOVFF  BFD,C1A
02448:  MOVFF  BFC,C19
0244C:  MOVFF  BFB,C18
02450:  MOVFF  BFA,C17
02454:  CLRF   x1E
02456:  MOVLW  01
02458:  MOVWF  x1D
0245A:  MOVLW  51
0245C:  MOVWF  x1C
0245E:  MOVLW  80
02460:  MOVWF  x1B
02462:  MOVLB  0
02464:  RCALL  200A
02466:  MOVFF  C04,FEA
0246A:  MOVFF  C03,FE9
0246E:  MOVFF  03,C08
02472:  MOVFF  02,C07
02476:  MOVFF  01,C06
0247A:  MOVFF  00,C05
0247E:  BSF    FD8.1
02480:  MOVLW  0C
02482:  MOVWF  FEA
02484:  MOVLW  0B
02486:  MOVWF  FE9
02488:  MOVFF  03,C1A
0248C:  MOVFF  02,C19
02490:  MOVFF  01,C18
02494:  MOVFF  00,C17
02498:  MOVLB  C
0249A:  CLRF   x1E
0249C:  CLRF   x1D
0249E:  MOVLW  01
024A0:  MOVWF  x1C
024A2:  MOVLW  6D
024A4:  MOVWF  x1B
024A6:  MOVLB  0
024A8:  RCALL  200A
024AA:  MOVFF  C0B,00
024AE:  MOVFF  C0C,01
024B2:  MOVFF  C0D,02
024B6:  MOVFF  C0E,03
024BA:  MOVFF  C02,FEA
024BE:  MOVFF  C01,FE9
024C2:  MOVFF  01,FEC
024C6:  MOVF   FED,F
024C8:  MOVFF  00,FEF
....................       } 
....................        
....................       i = 1970;  // Change done by Amit, initially it was i = 70; 
024CC:  MOVLW  07
024CE:  MOVLB  C
024D0:  MOVWF  x00
024D2:  MOVLW  B2
024D4:  MOVLB  B
024D6:  MOVWF  xFF
....................       if(timeT->tm_year - 1970 >= 0) 
024D8:  MOVLW  05
024DA:  ADDWF  xF8,W
024DC:  MOVWF  FE9
024DE:  MOVLW  00
024E0:  ADDWFC xF9,W
024E2:  MOVWF  FEA
024E4:  MOVFF  FEC,C02
024E8:  MOVF   FED,F
024EA:  MOVFF  FEF,C01
024EE:  MOVLW  B2
024F0:  MOVLB  C
024F2:  SUBWF  x01,F
024F4:  MOVLW  07
024F6:  SUBWFB x02,F
....................       { 
....................          while(i < (timeT->tm_year)) 
024F8:  MOVLW  05
024FA:  MOVLB  B
024FC:  ADDWF  xF8,W
024FE:  MOVWF  FE9
02500:  MOVLW  00
02502:  ADDWFC xF9,W
02504:  MOVWF  FEA
02506:  MOVFF  FEC,03
0250A:  MOVF   FED,F
0250C:  MOVFF  FEF,01
02510:  MOVLB  C
02512:  MOVF   x00,W
02514:  SUBWF  03,W
02516:  BNC   256E
02518:  BNZ   252A
0251A:  MOVF   01,W
0251C:  MOVLB  B
0251E:  SUBWF  xFF,W
02520:  BTFSS  FD8.0
02522:  BRA    2528
02524:  MOVLB  C
02526:  BRA    256E
02528:  MOVLB  C
....................          { 
....................             isLeapYear = LeapYear(i); 
0252A:  MOVFF  C00,C0C
0252E:  MOVFF  BFF,C0B
02532:  MOVLB  0
02534:  RCALL  1EFC
02536:  MOVLB  B
02538:  BCF    xFE.0
0253A:  BTFSC  01.0
0253C:  BSF    xFE.0
....................             if(isLeapYear) 
0253E:  BTFSS  xFE.0
02540:  BRA    2550
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
02542:  MOVLW  85
02544:  ADDWF  xFB,F
02546:  MOVLW  E2
02548:  ADDWFC xFC,F
0254A:  MOVLW  01
0254C:  ADDWFC xFD,F
....................             } 
0254E:  BRA    2560
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
02550:  MOVLW  80
02552:  ADDWF  xFA,F
02554:  MOVLW  33
02556:  ADDWFC xFB,F
02558:  MOVLW  E1
0255A:  ADDWFC xFC,F
0255C:  MOVLW  01
0255E:  ADDWFC xFD,F
....................             } 
....................             i++; 
02560:  INCF   xFF,F
02562:  BTFSS  FD8.2
02564:  BRA    256A
02566:  MOVLB  C
02568:  INCF   x00,F
0256A:  MOVLB  C
0256C:  BRA    24F8
....................          } 
....................       } 
....................       // To match GMT to IST we have to adjust 5hrs 30 mints.. 
....................       unixTime = unixTime - 19800;  // 19800 is the  
0256E:  MOVLW  58
02570:  MOVLB  B
02572:  SUBWF  xFA,F
02574:  MOVLW  4D
02576:  SUBWFB xFB,F
02578:  MOVLW  00
0257A:  SUBWFB xFC,F
0257C:  SUBWFB xFD,F
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
0257E:  MOVLW  07
02580:  ADDWF  xF8,W
02582:  MOVWF  01
02584:  MOVLW  00
02586:  ADDWFC xF9,W
02588:  MOVWF  03
0258A:  MOVFF  01,C01
0258E:  MOVLB  C
02590:  MOVWF  x02
02592:  MOVFF  FEA,C04
02596:  MOVFF  FE9,C03
0259A:  BCF    FD8.1
0259C:  MOVFF  BFD,C1A
025A0:  MOVFF  BFC,C19
025A4:  MOVFF  BFB,C18
025A8:  MOVFF  BFA,C17
025AC:  CLRF   x1E
025AE:  MOVLW  01
025B0:  MOVWF  x1D
025B2:  MOVLW  51
025B4:  MOVWF  x1C
025B6:  MOVLW  80
025B8:  MOVWF  x1B
025BA:  MOVLB  0
025BC:  RCALL  200A
025BE:  MOVFF  C04,FEA
025C2:  MOVFF  C03,FE9
025C6:  MOVFF  03,C08
025CA:  MOVFF  02,C07
025CE:  MOVFF  01,C06
025D2:  MOVFF  00,C05
025D6:  MOVLW  04
025D8:  MOVLB  C
025DA:  ADDWF  x05,F
025DC:  MOVLW  00
025DE:  ADDWFC x06,F
025E0:  ADDWFC x07,F
025E2:  ADDWFC x08,F
025E4:  BSF    FD8.1
025E6:  MOVLW  0C
025E8:  MOVWF  FEA
025EA:  MOVLW  0B
025EC:  MOVWF  FE9
025EE:  MOVFF  C08,C1A
025F2:  MOVFF  C07,C19
025F6:  MOVFF  C06,C18
025FA:  MOVFF  C05,C17
025FE:  CLRF   x1E
02600:  CLRF   x1D
02602:  CLRF   x1C
02604:  MOVLW  07
02606:  MOVWF  x1B
02608:  MOVLB  0
0260A:  RCALL  200A
0260C:  MOVFF  C0B,00
02610:  MOVFF  C0C,01
02614:  MOVFF  C0D,02
02618:  MOVFF  C0E,03
0261C:  MOVFF  C02,FEA
02620:  MOVFF  C01,FE9
02624:  MOVFF  00,FEF
02628:  MOVLB  B
....................    } 
....................  
....................    return unixTime; 
0262A:  MOVFF  BFA,00
0262E:  MOVFF  BFB,01
02632:  MOVFF  BFC,02
02636:  MOVFF  BFD,03
0263A:  MOVLB  0
0263C:  GOTO   39A6 (RETURN)
.................... } 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime ( struct_tm * timeptr, char * szTime) 
.................... { 
....................    char szDay[8]; 
....................    char szMon[8]; 
....................     
....................    WeekdayAbbreviations(timeptr->tm_wday, szDay); 
....................    MonthAbbreviations(timeptr->tm_mon, szMon); 
....................     
....................    sprintf(szTime,"%s %s %d %02d:%02d:%02d %04Lu", 
....................       szDay, 
....................       szMon, 
....................       timeptr->tm_mday + 1, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + 1900)); 
....................        
....................    return szTime; 
.................... } 
....................  
.................... /* Converts the given calendar time (in seconds) to local time  
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime ( time_t * timer, char *szTime ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime(time_t * timer) 
02640:  MOVLB  B
02642:  BCF    xFE.0
02644:  BCF    xFE.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;//1970 is not a leap year 
....................  
....................    if(timer != NULL) 
02646:  MOVF   xF8,F
02648:  BNZ   2650
0264A:  MOVF   xF9,F
0264C:  BTFSC  FD8.2
0264E:  BRA    2A46
....................    { 
....................       timeCounter = *timer; 
02650:  MOVFF  BF9,03
02654:  MOVFF  BF8,FE9
02658:  MOVFF  03,FEA
0265C:  MOVFF  FEF,BFA
02660:  MOVFF  FEC,BFB
02664:  MOVFF  FEC,BFC
02668:  MOVFF  FEC,BFD
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
0266C:  BCF    FD8.1
0266E:  MOVFF  BFD,C1A
02672:  MOVFF  BFC,C19
02676:  MOVFF  BFB,C18
0267A:  MOVFF  BFA,C17
0267E:  MOVLB  C
02680:  CLRF   x1E
02682:  MOVLW  01
02684:  MOVWF  x1D
02686:  MOVLW  51
02688:  MOVWF  x1C
0268A:  MOVLW  80
0268C:  MOVWF  x1B
0268E:  MOVLB  0
02690:  RCALL  200A
02692:  MOVFF  03,C02
02696:  MOVFF  02,C01
0269A:  MOVFF  01,C00
0269E:  MOVFF  00,BFF
026A2:  MOVLW  04
026A4:  MOVLB  B
026A6:  ADDWF  xFF,F
026A8:  MOVLW  00
026AA:  MOVLB  C
026AC:  ADDWFC x00,F
026AE:  ADDWFC x01,F
026B0:  ADDWFC x02,F
026B2:  BSF    FD8.1
026B4:  MOVLW  0C
026B6:  MOVWF  FEA
026B8:  MOVLW  03
026BA:  MOVWF  FE9
026BC:  MOVFF  C02,C1A
026C0:  MOVFF  C01,C19
026C4:  MOVFF  C00,C18
026C8:  MOVFF  BFF,C17
026CC:  CLRF   x1E
026CE:  CLRF   x1D
026D0:  CLRF   x1C
026D2:  MOVLW  07
026D4:  MOVWF  x1B
026D6:  MOVLB  0
026D8:  RCALL  200A
026DA:  MOVFF  C03,3B
026DE:  MOVFF  C04,01
026E2:  MOVFF  C05,02
026E6:  MOVFF  C06,03
....................       g_lTime.tm_year = 70;//we are starting in 1970 
026EA:  CLRF   3A
026EC:  MOVLW  46
026EE:  MOVWF  39
....................        
....................       while(!done) 
026F0:  MOVLB  B
026F2:  BTFSC  xFE.0
026F4:  BRA    27E0
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
026F6:  BTFSC  xFD.7
026F8:  BRA    2710
026FA:  MOVF   xFD,W
026FC:  SUBLW  01
026FE:  BNC   2748
02700:  BNZ   2710
02702:  MOVF   xFC,W
02704:  SUBLW  E2
02706:  BNC   2748
02708:  BNZ   2710
0270A:  MOVF   xFB,W
0270C:  SUBLW  84
0270E:  BNC   2748
02710:  BTFSS  xFE.1
02712:  BRA    2748
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02714:  BCF    FD8.1
02716:  MOVFF  BFD,C1A
0271A:  MOVFF  BFC,C19
0271E:  MOVFF  BFB,C18
02722:  MOVFF  BFA,C17
02726:  MOVLB  C
02728:  CLRF   x1E
0272A:  MOVLW  01
0272C:  MOVWF  x1D
0272E:  MOVLW  51
02730:  MOVWF  x1C
02732:  MOVLW  80
02734:  MOVWF  x1B
02736:  MOVLB  0
02738:  RCALL  200A
0273A:  MOVFF  01,3D
0273E:  MOVFF  00,3C
....................             break; 
02742:  MOVLB  B
02744:  BRA    27E0
....................          } 
02746:  BRA    279C
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
02748:  BTFSC  xFD.7
0274A:  BRA    276A
0274C:  MOVF   xFD,W
0274E:  SUBLW  01
02750:  BNC   279C
02752:  BNZ   276A
02754:  MOVF   xFC,W
02756:  SUBLW  E1
02758:  BNC   279C
0275A:  BNZ   276A
0275C:  MOVF   xFB,W
0275E:  SUBLW  33
02760:  BNC   279C
02762:  BNZ   276A
02764:  MOVF   xFA,W
02766:  SUBLW  7F
02768:  BNC   279C
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
0276A:  BCF    FD8.1
0276C:  MOVFF  BFD,C1A
02770:  MOVFF  BFC,C19
02774:  MOVFF  BFB,C18
02778:  MOVFF  BFA,C17
0277C:  MOVLB  C
0277E:  CLRF   x1E
02780:  MOVLW  01
02782:  MOVWF  x1D
02784:  MOVLW  51
02786:  MOVWF  x1C
02788:  MOVLW  80
0278A:  MOVWF  x1B
0278C:  MOVLB  0
0278E:  RCALL  200A
02790:  MOVFF  01,3D
02794:  MOVFF  00,3C
....................             break; 
02798:  MOVLB  B
0279A:  BRA    27E0
....................          } 
....................           
....................          if(isLeapYear) 
0279C:  BTFSS  xFE.1
0279E:  BRA    27B2
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
027A0:  MOVLW  00
027A2:  SUBWF  xFA,F
027A4:  MOVLW  85
027A6:  SUBWFB xFB,F
027A8:  MOVLW  E2
027AA:  SUBWFB xFC,F
027AC:  MOVLW  01
027AE:  SUBWFB xFD,F
....................          } 
027B0:  BRA    27C2
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
027B2:  MOVLW  80
027B4:  SUBWF  xFA,F
027B6:  MOVLW  33
027B8:  SUBWFB xFB,F
027BA:  MOVLW  E1
027BC:  SUBWFB xFC,F
027BE:  MOVLW  01
027C0:  SUBWFB xFD,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
027C2:  INCF   39,F
027C4:  BTFSC  FD8.2
027C6:  INCF   3A,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
027C8:  MOVFF  3A,C0C
027CC:  MOVFF  39,C0B
027D0:  MOVLB  0
027D2:  CALL   1EFC
027D6:  MOVLB  B
027D8:  BCF    xFE.1
027DA:  BTFSC  01.0
027DC:  BSF    xFE.1
027DE:  BRA    26F2
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
027E0:  CLRF   38
....................       while(!done) 
027E2:  BTFSC  xFE.0
027E4:  BRA    291A
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
027E6:  MOVLW  00
027E8:  BTFSC  xFE.1
027EA:  MOVLW  01
027EC:  MOVWF  xFF
027EE:  MOVFF  38,C0E
027F2:  MOVFF  FE8,C0F
027F6:  MOVLB  0
027F8:  CALL   1FA2
027FC:  MOVFF  FEA,C01
02800:  MOVFF  FE9,C00
02804:  MOVLB  C
02806:  CLRF   x12
02808:  CLRF   x11
0280A:  CLRF   x10
0280C:  MOVFF  01,C0F
02810:  CLRF   x16
02812:  MOVLW  01
02814:  MOVWF  x15
02816:  MOVLW  51
02818:  MOVWF  x14
0281A:  MOVLW  80
0281C:  MOVWF  x13
0281E:  MOVLB  0
02820:  CALL   1EA0
02824:  MOVFF  C01,FEA
02828:  MOVFF  C00,FE9
0282C:  MOVLB  B
0282E:  BTFSC  xFD.7
02830:  BRA    2850
02832:  MOVF   xFD,W
02834:  SUBWF  03,W
02836:  BNC   2854
02838:  BNZ   2850
0283A:  MOVF   xFC,W
0283C:  SUBWF  02,W
0283E:  BNC   2854
02840:  BNZ   2850
02842:  MOVF   xFB,W
02844:  SUBWF  01,W
02846:  BNC   2854
02848:  BNZ   2850
0284A:  MOVF   00,W
0284C:  SUBWF  xFA,W
0284E:  BC    2854
....................          { 
....................             break; 
02850:  BRA    291A
....................          } 
02852:  BRA    2918
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
02854:  MOVLW  00
02856:  BTFSC  xFE.1
02858:  MOVLW  01
0285A:  MOVWF  xFF
0285C:  MOVFF  38,C0E
02860:  MOVFF  FE8,C0F
02864:  MOVLB  0
02866:  CALL   1FA2
0286A:  MOVFF  FEA,C01
0286E:  MOVFF  FE9,C00
02872:  MOVLB  C
02874:  CLRF   x12
02876:  CLRF   x11
02878:  CLRF   x10
0287A:  MOVFF  01,C0F
0287E:  CLRF   x16
02880:  MOVLW  01
02882:  MOVWF  x15
02884:  MOVLW  51
02886:  MOVWF  x14
02888:  MOVLW  80
0288A:  MOVWF  x13
0288C:  MOVLB  0
0288E:  CALL   1EA0
02892:  MOVFF  C01,FEA
02896:  MOVFF  C00,FE9
0289A:  MOVLB  B
0289C:  BTFSC  xFD.7
0289E:  BRA    2918
028A0:  MOVF   03,W
028A2:  SUBWF  xFD,W
028A4:  BNC   2918
028A6:  BNZ   28BE
028A8:  MOVF   02,W
028AA:  SUBWF  xFC,W
028AC:  BNC   2918
028AE:  BNZ   28BE
028B0:  MOVF   01,W
028B2:  SUBWF  xFB,W
028B4:  BNC   2918
028B6:  BNZ   28BE
028B8:  MOVF   00,W
028BA:  SUBWF  xFA,W
028BC:  BNC   2918
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
028BE:  MOVLW  00
028C0:  BTFSC  xFE.1
028C2:  MOVLW  01
028C4:  MOVWF  xFF
028C6:  MOVFF  38,C0E
028CA:  MOVFF  FE8,C0F
028CE:  MOVLB  0
028D0:  CALL   1FA2
028D4:  MOVFF  FEA,C01
028D8:  MOVFF  FE9,C00
028DC:  MOVLB  C
028DE:  CLRF   x12
028E0:  CLRF   x11
028E2:  CLRF   x10
028E4:  MOVFF  01,C0F
028E8:  CLRF   x16
028EA:  MOVLW  01
028EC:  MOVWF  x15
028EE:  MOVLW  51
028F0:  MOVWF  x14
028F2:  MOVLW  80
028F4:  MOVWF  x13
028F6:  MOVLB  0
028F8:  CALL   1EA0
028FC:  MOVFF  C01,FEA
02900:  MOVFF  C00,FE9
02904:  MOVF   00,W
02906:  MOVLB  B
02908:  SUBWF  xFA,F
0290A:  MOVF   01,W
0290C:  SUBWFB xFB,F
0290E:  MOVF   02,W
02910:  SUBWFB xFC,F
02912:  MOVF   03,W
02914:  SUBWFB xFD,F
....................             g_lTime.tm_mon++; 
02916:  INCF   38,F
....................          } 
02918:  BRA    27E2
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
0291A:  BCF    FD8.1
0291C:  MOVFF  BFD,C1A
02920:  MOVFF  BFC,C19
02924:  MOVFF  BFB,C18
02928:  MOVFF  BFA,C17
0292C:  MOVLB  C
0292E:  CLRF   x1E
02930:  MOVLW  01
02932:  MOVWF  x1D
02934:  MOVLW  51
02936:  MOVWF  x1C
02938:  MOVLW  80
0293A:  MOVWF  x1B
0293C:  MOVLB  0
0293E:  CALL   200A
02942:  MOVFF  00,37
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
02946:  MOVLB  C
02948:  CLRF   x12
0294A:  CLRF   x11
0294C:  CLRF   x10
0294E:  MOVFF  37,C0F
02952:  CLRF   x16
02954:  MOVLW  01
02956:  MOVWF  x15
02958:  MOVLW  51
0295A:  MOVWF  x14
0295C:  MOVLW  80
0295E:  MOVWF  x13
02960:  MOVLB  0
02962:  CALL   1EA0
02966:  MOVF   00,W
02968:  MOVLB  B
0296A:  SUBWF  xFA,F
0296C:  MOVF   01,W
0296E:  SUBWFB xFB,F
02970:  MOVF   02,W
02972:  SUBWFB xFC,F
02974:  MOVF   03,W
02976:  SUBWFB xFD,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
02978:  BCF    FD8.1
0297A:  MOVFF  BFD,C1A
0297E:  MOVFF  BFC,C19
02982:  MOVFF  BFB,C18
02986:  MOVFF  BFA,C17
0298A:  MOVLB  C
0298C:  CLRF   x1E
0298E:  CLRF   x1D
02990:  MOVLW  0E
02992:  MOVWF  x1C
02994:  MOVLW  10
02996:  MOVWF  x1B
02998:  MOVLB  0
0299A:  CALL   200A
0299E:  MOVFF  00,36
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
029A2:  MOVLB  C
029A4:  CLRF   x02
029A6:  CLRF   x01
029A8:  CLRF   x00
029AA:  MOVFF  36,BFF
029AE:  MOVFF  C02,C12
029B2:  MOVFF  C01,C11
029B6:  MOVFF  C00,C10
029BA:  MOVFF  36,C0F
029BE:  CLRF   x16
029C0:  CLRF   x15
029C2:  MOVLW  0E
029C4:  MOVWF  x14
029C6:  MOVLW  10
029C8:  MOVWF  x13
029CA:  MOVLB  0
029CC:  CALL   1EA0
029D0:  MOVF   00,W
029D2:  MOVLB  B
029D4:  SUBWF  xFA,F
029D6:  MOVF   01,W
029D8:  SUBWFB xFB,F
029DA:  MOVF   02,W
029DC:  SUBWFB xFC,F
029DE:  MOVF   03,W
029E0:  SUBWFB xFD,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
029E2:  BCF    FD8.1
029E4:  MOVFF  BFD,C1A
029E8:  MOVFF  BFC,C19
029EC:  MOVFF  BFB,C18
029F0:  MOVFF  BFA,C17
029F4:  MOVLB  C
029F6:  CLRF   x1E
029F8:  CLRF   x1D
029FA:  CLRF   x1C
029FC:  MOVLW  3C
029FE:  MOVWF  x1B
02A00:  MOVLB  0
02A02:  CALL   200A
02A06:  MOVFF  00,35
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
02A0A:  MOVLB  C
02A0C:  CLRF   x00
02A0E:  MOVFF  35,BFF
02A12:  CLRF   19
02A14:  BTFSC  FF2.7
02A16:  BSF    19.7
02A18:  BCF    FF2.7
02A1A:  MOVFF  C00,C2D
02A1E:  MOVFF  35,C2C
02A22:  CLRF   x2F
02A24:  MOVLW  3C
02A26:  MOVWF  x2E
02A28:  MOVLB  0
02A2A:  CALL   0426
02A2E:  BTFSC  19.7
02A30:  BSF    FF2.7
02A32:  MOVF   01,W
02A34:  MOVLB  B
02A36:  SUBWF  xFA,F
02A38:  MOVF   02,W
02A3A:  SUBWFB xFB,F
02A3C:  MOVLW  00
02A3E:  SUBWFB xFC,F
02A40:  SUBWFB xFD,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
02A42:  MOVFF  BFA,34
....................    } 
....................     
....................    return &g_lTime; 
02A46:  MOVLW  34
02A48:  MOVWF  01
02A4A:  MOVLW  00
02A4C:  MOVWF  02
02A4E:  MOVLB  0
02A50:  GOTO   39C4 (RETURN)
.................... } 
.................... #endif 
....................  
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
*
042AA:  CLRF   19
042AC:  BTFSC  FF2.7
042AE:  BSF    19.7
042B0:  BCF    FF2.7
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
042B2:  MOVLB  C
042B4:  CLRF   x2D
042B6:  MOVFF  BED,C2C
042BA:  MOVLW  03
042BC:  MOVWF  x2F
042BE:  MOVLW  E8
042C0:  MOVWF  x2E
042C2:  MOVLB  0
042C4:  CALL   0426
042C8:  BTFSC  19.7
042CA:  BSF    FF2.7
042CC:  MOVFF  02,91
042D0:  MOVFF  01,90
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
042D4:  MOVLW  01
042D6:  MOVWF  x92
042D8:  RETURN 0
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmTimerConfig.h" 
.................... #ifndef _VM_TIMER_CONFIG_H_ 
.................... #define _VM_TIMER_CONFIG_H_ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
*
00B00:  MOVLB  C
00B02:  CLRF   x0F
00B04:  CLRF   x0E
00B06:  SETF   x11
00B08:  SETF   x10
00B0A:  MOVLW  A0
00B0C:  MOVWF  x13
00B0E:  MOVLW  01
00B10:  MOVWF  x12
00B12:  CLRF   x14
00B14:  CLRF   x15
00B16:  CLRF   x16
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
00B18:  MOVF   x0D,W
00B1A:  SUBWF  x14,W
00B1C:  BNZ   0B20
.................... 		{ 
.................... 			break; 
00B1E:  BRA    0B88
.................... 		} 
....................  
.................... 		uiByteCount++; 
00B20:  INCF   x14,F
.................... 		bShiftCount = 0; 
00B22:  CLRF   x15
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
00B24:  MOVF   x15,F
00B26:  BNZ   0B5A
.................... 			{ 
.................... 				if (1 == uiByteCount) 
00B28:  DECFSZ x14,W
00B2A:  BRA    0B46
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
00B2C:  MOVLW  01
00B2E:  SUBWF  x14,W
00B30:  ADDWF  x0B,W
00B32:  MOVWF  FE9
00B34:  MOVLW  00
00B36:  ADDWFC x0C,W
00B38:  MOVWF  FEA
00B3A:  MOVF   FEF,W
00B3C:  XORWF  x10,W
00B3E:  MOVWF  x0E
00B40:  MOVFF  C11,C0F
.................... 				} 
00B44:  BRA    0B58
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
00B46:  MOVLW  01
00B48:  SUBWF  x14,W
00B4A:  ADDWF  x0B,W
00B4C:  MOVWF  FE9
00B4E:  MOVLW  00
00B50:  ADDWFC x0C,W
00B52:  MOVWF  FEA
00B54:  MOVF   FEF,W
00B56:  XORWF  x0E,F
.................... 				} 
.................... 			} 
00B58:  BRA    0B62
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
00B5A:  MOVF   x12,W
00B5C:  XORWF  x0E,F
00B5E:  MOVF   x13,W
00B60:  XORWF  x0F,F
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
00B62:  MOVLB  C
00B64:  INCF   x15,F
....................  
.................... 			if (bShiftCount > 8) 
00B66:  MOVF   x15,W
00B68:  SUBLW  08
00B6A:  BC    0B6E
.................... 			{ 
.................... 				break; 
00B6C:  BRA    0B86
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
00B6E:  MOVF   x0E,W
00B70:  ANDLW  01
00B72:  MOVWF  x16
....................  
.................... 			uiCRC = uiCRC >> 1; 
00B74:  BCF    FD8.0
00B76:  RRCF   x0F,F
00B78:  RRCF   x0E,F
....................  
.................... 			if (1 == bShiftCarry) 
00B7A:  DECFSZ x16,W
00B7C:  BRA    0B82
.................... 			{ 
.................... 				continue; 
00B7E:  BRA    0B24
.................... 			} 
00B80:  BRA    0B84
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
00B82:  BRA    0B62
.................... 			} 
00B84:  BRA    0B24
.................... 		} 
00B86:  BRA    0B18
.................... 	} 
....................  
.................... 	return uiCRC; 
00B88:  MOVFF  C0E,01
00B8C:  MOVFF  C0F,02
00B90:  MOVLB  0
00B92:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
.................... #include "vmCircularQ.h" 
.................... /*  
....................  * File:   vmCircularQ.h 
....................  * Author: AmitDP 
....................  * 
....................  * Created on February 26, 2020, 2:17 PM 
....................  */ 
....................  
.................... #ifndef VM_CIRCULAR_Q_H 
.................... #define	VM_CIRCULAR_Q_H 
....................  
....................  
.................... #define SIZE_RCV_QUEUE 200 
....................  
.................... typedef struct _ST_RCV_QUEUE 
.................... { 
....................     int8 m_ui8QArr[SIZE_RCV_QUEUE]; 
....................     int8 m_ui8Front; 
....................     int8 m_ui8Rear; 
.................... } ST_RCV_QUEUE; 
....................  
.................... ST_RCV_QUEUE g_stRcvQueue; 
.................... unsigned int8 g_ui8ElementInQ = 0; 
....................  
.................... void InitializeRcvQ() 
.................... { 
....................     memset(g_stRcvQueue.m_ui8QArr, SIZE_RCV_QUEUE, 0); 
*
009D8:  MOVLW  01
009DA:  MOVWF  FEA
009DC:  MOVLW  09
009DE:  MOVWF  FE9
009E0:  MOVLW  C8
009E2:  MOVWF  00
009E4:  CLRF   02
009E6:  CLRF   01
009E8:  RCALL  09BE
....................     g_stRcvQueue.m_ui8Front = -1; 
009EA:  MOVLB  1
009EC:  SETF   xD1
....................     g_stRcvQueue.m_ui8Rear  = -1; 
009EE:  SETF   xD2
009F0:  MOVLB  0
009F2:  GOTO   4640 (RETURN)
.................... } 
....................  
.................... //int isFull() 
.................... //{ 
.................... //    if( (front == rear + 1) || (front == 0 && rear == SIZE_RCV_QUEUE-1)) return 1; 
.................... //    return 0; 
.................... //} 
.................... // 
.................... //int8 items[SIZE_RCV_QUEUE]; 
.................... //int front = -1, rear =-1; 
.................... unsigned int8 ElementsInQ(void) 
009F6:  MOVLW  0A
009F8:  MOVLB  B
009FA:  MOVWF  xED
.................... { 
....................     unsigned int8 ui8Retval = 10; 
....................      
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
009FC:  MOVLB  1
009FE:  MOVF   xD1,W
00A00:  SUBLW  FF
00A02:  BNZ   0A10
....................     { 
....................         //return = 0; 
....................         ui8Retval = 0; 
00A04:  MOVLB  B
00A06:  CLRF   xED
....................         return ui8Retval; 
00A08:  MOVFF  BED,01
00A0C:  BRA    0A36
00A0E:  MOVLB  1
....................     } 
....................      
....................      
....................     if (g_stRcvQueue.m_ui8Front > g_stRcvQueue.m_ui8Rear) 
00A10:  MOVF   xD1,W
00A12:  SUBWF  xD2,W
00A14:  BC    0A28
....................     { 
....................         //return = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
....................         ui8Retval = (SIZE_RCV_QUEUE - g_stRcvQueue.m_ui8Front + g_stRcvQueue.m_ui8Rear + 1); 
00A16:  MOVLW  C8
00A18:  BSF    FD8.0
00A1A:  SUBFWB xD1,W
00A1C:  ADDWF  xD2,W
00A1E:  ADDLW  01
00A20:  MOVLB  B
00A22:  MOVWF  xED
....................     } 
00A24:  BRA    0A32
00A26:  MOVLB  1
....................     else 
....................     { 
....................         //return = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
....................         ui8Retval = (g_stRcvQueue.m_ui8Rear - g_stRcvQueue.m_ui8Front + 1); 
00A28:  MOVF   xD1,W
00A2A:  SUBWF  xD2,W
00A2C:  ADDLW  01
00A2E:  MOVLB  B
00A30:  MOVWF  xED
....................     } 
....................      
....................     return ui8Retval; 
00A32:  MOVFF  BED,01
00A36:  MOVLB  0
00A38:  GOTO   464C (RETURN)
.................... } 
....................  
.................... unsigned int8 IsQFull(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if( (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear + 1) || 
....................         (g_stRcvQueue.m_ui8Front == 0 && g_stRcvQueue.m_ui8Rear == SIZE_RCV_QUEUE - 1)) 
....................     { 
....................         // Queue is Full 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     }    
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int isEmpty() 
.................... //{ 
.................... //    if(front == -1) return 1; 
.................... //    return 0; 
.................... //} 
....................  
.................... unsigned int8 IsQEmpty(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 10; 
....................      
....................     if(g_stRcvQueue.m_ui8Front == -1) 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     return ui8RetVal; 
.................... } 
....................  
.................... //void enQueue(int element) 
.................... //{ 
.................... //    if(isFull()) printf("\n Queue is full!! \n"); 
.................... //    else 
.................... //    { 
.................... //        if(front == -1) front = 0; 
.................... //        rear = (rear + 1) % SIZE_RCV_QUEUE; 
.................... //        items[rear] = element; 
.................... //        printf("\n Inserted -> %d", element); 
.................... //    } 
.................... //} 
....................  
.................... void EnQueue(unsigned int8 ui8Element) 
.................... { 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = ui8Element; 
.................... } 
....................  
.................... unsigned int8 DeQueue(void) 
.................... { 
....................     unsigned int8 ui8Element = 0; 
....................     unsigned int8 ui8RetVal  = 0; 
....................      
....................     ui8RetVal = IsQEmpty(); 
....................     if(ui8RetVal) 
....................     { 
....................         ui8RetVal = 0; 
....................         //return 0; //?? 
....................     } 
....................     else 
....................     { 
....................         ui8Element = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         if (g_stRcvQueue.m_ui8Front == g_stRcvQueue.m_ui8Rear) 
....................         { 
....................             g_stRcvQueue.m_ui8Front = -1; 
....................             g_stRcvQueue.m_ui8Rear  = -1; 
....................         } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
....................         else 
....................         { 
....................             g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         } 
....................         //printf("\n Deleted element -> %d \n", ui8Element); 
....................         ui8RetVal = ui8Element; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... //int deQueue() 
.................... //{ 
.................... //    int element; 
.................... //    if(isEmpty()) { 
.................... //        printf("\n Queue is empty !! \n"); 
.................... //        return(-1); 
.................... //    } else { 
.................... //        element = items[front]; 
.................... //        if (front == rear){ 
.................... //            front = -1; 
.................... //            rear = -1; 
.................... //        } /* Q has only one element, so we reset the queue after dequeing it. ? */ 
.................... //        else { 
.................... //            front = (front + 1) % SIZE_RCV_QUEUE; 
.................... //             
.................... //        } 
.................... //        printf("\n Deleted element -> %d \n", element); 
.................... //        return(element); 
.................... //    } 
.................... //} 
....................  
....................  
.................... #endif	/* VM_CIRCULAR_Q_H */ 
....................  
....................  
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
*
005DE:  MOVF   F98,W
.................... 	enable_interrupts(INT_RDA); 
005E0:  MOVLB  E
005E2:  BSF    x2C.5
005E4:  MOVLB  0
005E6:  GOTO   4634 (RETURN)
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
008AA:  MOVLB  B
008AC:  CLRF   xEF
008AE:  CLRF   xF0
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
008B0:  MOVLW  C3
008B2:  ADDWF  xED,W
008B4:  MOVWF  01
008B6:  MOVLW  00
008B8:  ADDWFC xEE,W
008BA:  MOVWF  03
008BC:  MOVLW  C4
008BE:  ADDWF  xED,W
008C0:  MOVWF  FE9
008C2:  MOVLW  00
008C4:  ADDWFC xEE,W
008C6:  MOVWF  FEA
008C8:  SETF   FEF
008CA:  MOVLW  FF
008CC:  MOVFF  03,FEA
008D0:  MOVFF  01,FE9
008D4:  MOVWF  FEF
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
008D6:  CLRF   xEF
008D8:  MOVF   xEF,W
008DA:  SUBLW  0E
008DC:  BNC   0938
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
008DE:  CLRF   xF0
008E0:  MOVF   xF0,W
008E2:  SUBLW  08
008E4:  BNC   0934
008E6:  CLRF   19
008E8:  BTFSC  FF2.7
008EA:  BSF    19.7
008EC:  BCF    FF2.7
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
008EE:  MOVLB  C
008F0:  CLRF   x2D
008F2:  MOVFF  BEF,C2C
008F6:  CLRF   x2F
008F8:  MOVLW  0D
008FA:  MOVWF  x2E
008FC:  MOVLB  0
008FE:  RCALL  0426
00900:  BTFSC  19.7
00902:  BSF    FF2.7
00904:  MOVFF  02,BF2
00908:  MOVFF  01,BF1
0090C:  MOVLW  02
0090E:  MOVLB  B
00910:  ADDWF  xF1,F
00912:  MOVLW  00
00914:  ADDWFC xF2,F
00916:  MOVF   xF0,W
00918:  ADDWF  xF1,W
0091A:  MOVWF  01
0091C:  MOVLW  00
0091E:  ADDWFC xF2,W
00920:  MOVWF  03
00922:  MOVF   01,W
00924:  ADDWF  xED,W
00926:  MOVWF  FE9
00928:  MOVF   xEE,W
0092A:  ADDWFC 03,W
0092C:  MOVWF  FEA
0092E:  CLRF   FEF
00930:  INCF   xF0,F
00932:  BRA    08E0
....................         } 
00934:  INCF   xEF,F
00936:  BRA    08D8
....................     } 
00938:  MOVLB  0
0093A:  RETURN 0
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
*
00B94:  MOVLB  C
00B96:  CLRF   x05
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
00B98:  CLRF   x05
00B9A:  MOVF   x05,W
00B9C:  SUBLW  08
00B9E:  BNC   0BD0
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
00BA0:  MOVLW  02
00BA2:  ADDWF  x05,W
00BA4:  ADDWF  x03,W
00BA6:  MOVWF  01
00BA8:  MOVLW  00
00BAA:  ADDWFC x04,W
00BAC:  MOVWF  03
00BAE:  MOVLW  02
00BB0:  ADDWF  x05,W
00BB2:  ADDWF  x01,W
00BB4:  MOVWF  FE9
00BB6:  MOVLW  00
00BB8:  ADDWFC x02,W
00BBA:  MOVWF  FEA
00BBC:  MOVFF  FEF,C08
00BC0:  MOVFF  03,FEA
00BC4:  MOVFF  01,FE9
00BC8:  MOVFF  C08,FEF
00BCC:  INCF   x05,F
00BCE:  BRA    0B9A
....................     } 
00BD0:  MOVLB  0
00BD2:  RETURN 0
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
00BD4:  MOVLB  B
00BD6:  MOVF   xFA,W
00BD8:  IORWF  xFB,W
00BDA:  BNZ   0BDE
....................     { 
....................         return; 
00BDC:  BRA    0DA6
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
00BDE:  MOVLW  C3
00BE0:  ADDWF  xF8,W
00BE2:  MOVWF  FE9
00BE4:  MOVLW  00
00BE6:  ADDWFC xF9,W
00BE8:  MOVWF  FEA
00BEA:  MOVF   FEF,F
00BEC:  BNZ   0C00
00BEE:  MOVLW  C4
00BF0:  ADDWF  xF8,W
00BF2:  MOVWF  FE9
00BF4:  MOVLW  00
00BF6:  ADDWFC xF9,W
00BF8:  MOVWF  FEA
00BFA:  MOVF   FEF,W
00BFC:  SUBLW  0E
00BFE:  BZ    0C24
00C00:  MOVLW  C4
00C02:  ADDWF  xF8,W
00C04:  MOVWF  FE9
00C06:  MOVLW  00
00C08:  ADDWFC xF9,W
00C0A:  MOVWF  FEA
00C0C:  MOVFF  FEF,BFC
00C10:  MOVLW  C3
00C12:  ADDWF  xF8,W
00C14:  MOVWF  FE9
00C16:  MOVLW  00
00C18:  ADDWFC xF9,W
00C1A:  MOVWF  FEA
00C1C:  MOVLW  01
00C1E:  SUBWF  FEF,W
00C20:  SUBWF  xFC,W
00C22:  BNZ   0C28
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
00C24:  BRA    0DA6
....................     }     
00C26:  BRA    0DA6
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
00C28:  MOVLW  C3
00C2A:  ADDWF  xF8,W
00C2C:  MOVWF  FE9
00C2E:  MOVLW  00
00C30:  ADDWFC xF9,W
00C32:  MOVWF  FEA
00C34:  MOVF   FEF,W
00C36:  SUBLW  FF
00C38:  BNZ   0CB2
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
00C3A:  MOVLW  C3
00C3C:  ADDWF  xF8,W
00C3E:  MOVWF  FE9
00C40:  MOVLW  00
00C42:  ADDWFC xF9,W
00C44:  MOVWF  FEA
00C46:  CLRF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
00C48:  MOVLW  C4
00C4A:  ADDWF  xF8,W
00C4C:  MOVWF  FE9
00C4E:  MOVLW  00
00C50:  ADDWFC xF9,W
00C52:  MOVWF  FEA
00C54:  CLRF   FEF
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00C56:  MOVLW  C4
00C58:  ADDWF  xF8,W
00C5A:  MOVWF  FE9
00C5C:  MOVLW  00
00C5E:  ADDWFC xF9,W
00C60:  MOVWF  FEA
00C62:  CLRF   19
00C64:  BTFSC  FF2.7
00C66:  BSF    19.7
00C68:  BCF    FF2.7
00C6A:  MOVLB  C
00C6C:  CLRF   x2D
00C6E:  MOVFF  FEF,C2C
00C72:  CLRF   x2F
00C74:  MOVLW  0D
00C76:  MOVWF  x2E
00C78:  MOVLB  0
00C7A:  CALL   0426
00C7E:  BTFSC  19.7
00C80:  BSF    FF2.7
00C82:  MOVFF  02,03
00C86:  MOVF   01,W
00C88:  MOVLB  B
00C8A:  ADDWF  xF8,W
00C8C:  MOVWF  01
00C8E:  MOVF   xF9,W
00C90:  ADDWFC 03,F
00C92:  MOVFF  01,BFC
00C96:  MOVFF  03,BFD
00C9A:  MOVFF  BFB,C02
00C9E:  MOVFF  BFA,C01
00CA2:  MOVFF  03,C04
00CA6:  MOVFF  01,C03
00CAA:  MOVLB  0
00CAC:  RCALL  0B94
....................     }  
00CAE:  BRA    0DA4
00CB0:  MOVLB  B
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
00CB2:  MOVLW  C4
00CB4:  ADDWF  xF8,W
00CB6:  MOVWF  FE9
00CB8:  MOVLW  00
00CBA:  ADDWFC xF9,W
00CBC:  MOVWF  FEA
00CBE:  MOVF   FEF,W
00CC0:  SUBLW  0E
00CC2:  BNZ   0D3E
00CC4:  MOVLW  C3
00CC6:  ADDWF  xF8,W
00CC8:  MOVWF  FE9
00CCA:  MOVLW  00
00CCC:  ADDWFC xF9,W
00CCE:  MOVWF  FEA
00CD0:  MOVF   FEF,F
00CD2:  BZ    0D3E
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
00CD4:  MOVLW  C4
00CD6:  ADDWF  xF8,W
00CD8:  MOVWF  FE9
00CDA:  MOVLW  00
00CDC:  ADDWFC xF9,W
00CDE:  MOVWF  FEA
00CE0:  CLRF   FEF
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00CE2:  MOVLW  C4
00CE4:  ADDWF  xF8,W
00CE6:  MOVWF  FE9
00CE8:  MOVLW  00
00CEA:  ADDWFC xF9,W
00CEC:  MOVWF  FEA
00CEE:  CLRF   19
00CF0:  BTFSC  FF2.7
00CF2:  BSF    19.7
00CF4:  BCF    FF2.7
00CF6:  MOVLB  C
00CF8:  CLRF   x2D
00CFA:  MOVFF  FEF,C2C
00CFE:  CLRF   x2F
00D00:  MOVLW  0D
00D02:  MOVWF  x2E
00D04:  MOVLB  0
00D06:  CALL   0426
00D0A:  BTFSC  19.7
00D0C:  BSF    FF2.7
00D0E:  MOVFF  02,03
00D12:  MOVF   01,W
00D14:  MOVLB  B
00D16:  ADDWF  xF8,W
00D18:  MOVWF  01
00D1A:  MOVF   xF9,W
00D1C:  ADDWFC 03,F
00D1E:  MOVFF  01,BFC
00D22:  MOVFF  03,BFD
00D26:  MOVFF  BFB,C02
00D2A:  MOVFF  BFA,C01
00D2E:  MOVFF  03,C04
00D32:  MOVFF  01,C03
00D36:  MOVLB  0
00D38:  RCALL  0B94
....................     }  
00D3A:  BRA    0DA4
00D3C:  MOVLB  B
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
00D3E:  MOVLW  C4
00D40:  ADDWF  xF8,W
00D42:  MOVWF  FE9
00D44:  MOVLW  00
00D46:  ADDWFC xF9,W
00D48:  MOVWF  FEA
00D4A:  INCF   FEF,F
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
00D4C:  MOVLW  C4
00D4E:  ADDWF  xF8,W
00D50:  MOVWF  FE9
00D52:  MOVLW  00
00D54:  ADDWFC xF9,W
00D56:  MOVWF  FEA
00D58:  CLRF   19
00D5A:  BTFSC  FF2.7
00D5C:  BSF    19.7
00D5E:  BCF    FF2.7
00D60:  MOVLB  C
00D62:  CLRF   x2D
00D64:  MOVFF  FEF,C2C
00D68:  CLRF   x2F
00D6A:  MOVLW  0D
00D6C:  MOVWF  x2E
00D6E:  MOVLB  0
00D70:  CALL   0426
00D74:  BTFSC  19.7
00D76:  BSF    FF2.7
00D78:  MOVFF  02,03
00D7C:  MOVF   01,W
00D7E:  MOVLB  B
00D80:  ADDWF  xF8,W
00D82:  MOVWF  01
00D84:  MOVF   xF9,W
00D86:  ADDWFC 03,F
00D88:  MOVFF  01,BFC
00D8C:  MOVFF  03,BFD
00D90:  MOVFF  BFB,C02
00D94:  MOVFF  BFA,C01
00D98:  MOVFF  03,C04
00D9C:  MOVFF  01,C03
00DA0:  MOVLB  0
00DA2:  RCALL  0B94
00DA4:  MOVLB  B
....................     } 
00DA6:  MOVLB  0
00DA8:  RETURN 0
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
0110E:  MOVLW  C3
01110:  MOVLB  B
01112:  ADDWF  xFB,W
01114:  MOVWF  FE9
01116:  MOVLW  00
01118:  ADDWFC xFC,W
0111A:  MOVWF  FEA
0111C:  MOVF   FEF,W
0111E:  SUBLW  FF
01120:  BNZ   1124
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
01122:  BRA    11EE
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
01124:  MOVLW  C3
01126:  ADDWF  xFB,W
01128:  MOVWF  FE9
0112A:  MOVLW  00
0112C:  ADDWFC xFC,W
0112E:  MOVWF  FEA
01130:  CLRF   19
01132:  BTFSC  FF2.7
01134:  BSF    19.7
01136:  BCF    FF2.7
01138:  MOVLB  C
0113A:  CLRF   x2D
0113C:  MOVFF  FEF,C2C
01140:  CLRF   x2F
01142:  MOVLW  0D
01144:  MOVWF  x2E
01146:  MOVLB  0
01148:  CALL   0426
0114C:  BTFSC  19.7
0114E:  BSF    FF2.7
01150:  MOVFF  02,03
01154:  MOVF   01,W
01156:  MOVLB  B
01158:  ADDWF  xFB,W
0115A:  MOVWF  01
0115C:  MOVF   xFC,W
0115E:  ADDWFC 03,F
01160:  MOVFF  01,BFF
01164:  MOVFF  03,C00
01168:  MOVFF  03,C02
0116C:  MOVFF  01,C01
01170:  MOVFF  BFE,C04
01174:  MOVFF  BFD,C03
01178:  MOVLB  0
0117A:  RCALL  0B94
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
0117C:  MOVLW  C3
0117E:  MOVLB  B
01180:  ADDWF  xFB,W
01182:  MOVWF  FE9
01184:  MOVLW  00
01186:  ADDWFC xFC,W
01188:  MOVWF  FEA
0118A:  MOVFF  FEF,BFF
0118E:  MOVLW  C4
01190:  ADDWF  xFB,W
01192:  MOVWF  FE9
01194:  MOVLW  00
01196:  ADDWFC xFC,W
01198:  MOVWF  FEA
0119A:  MOVF   FEF,W
0119C:  SUBWF  xFF,W
0119E:  BNZ   11BE
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
011A0:  MOVLW  C3
011A2:  ADDWF  xFB,W
011A4:  MOVWF  FE9
011A6:  MOVLW  00
011A8:  ADDWFC xFC,W
011AA:  MOVWF  FEA
011AC:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
011AE:  MOVLW  C4
011B0:  ADDWF  xFB,W
011B2:  MOVWF  FE9
011B4:  MOVLW  00
011B6:  ADDWFC xFC,W
011B8:  MOVWF  FEA
011BA:  SETF   FEF
....................     }  
011BC:  BRA    11EE
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
011BE:  MOVLW  C3
011C0:  ADDWF  xFB,W
011C2:  MOVWF  FE9
011C4:  MOVLW  00
011C6:  ADDWFC xFC,W
011C8:  MOVWF  FEA
011CA:  MOVF   FEF,W
011CC:  SUBLW  0E
011CE:  BNZ   11E0
....................         pstIBUMSGQueue->m_i8Front = 0;  
011D0:  MOVLW  C3
011D2:  ADDWF  xFB,W
011D4:  MOVWF  FE9
011D6:  MOVLW  00
011D8:  ADDWFC xFC,W
011DA:  MOVWF  FEA
011DC:  CLRF   FEF
011DE:  BRA    11EE
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
011E0:  MOVLW  C3
011E2:  ADDWF  xFB,W
011E4:  MOVWF  FE9
011E6:  MOVLW  00
011E8:  ADDWFC xFC,W
011EA:  MOVWF  FEA
011EC:  INCF   FEF,F
....................    
....................     return; 
011EE:  MOVLB  0
011F0:  GOTO   1358 (RETURN)
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
015AC:  MOVLW  C3
015AE:  MOVLB  B
015B0:  ADDWF  xEE,W
015B2:  MOVWF  FE9
015B4:  MOVLW  00
015B6:  ADDWFC xEF,W
015B8:  MOVWF  FEA
015BA:  MOVF   FEF,W
015BC:  SUBLW  FF
015BE:  BNZ   15C2
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
015C0:  BRA    161E
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
015C2:  MOVLW  C3
015C4:  ADDWF  xEE,W
015C6:  MOVWF  FE9
015C8:  MOVLW  00
015CA:  ADDWFC xEF,W
015CC:  MOVWF  FEA
015CE:  CLRF   19
015D0:  BTFSC  FF2.7
015D2:  BSF    19.7
015D4:  BCF    FF2.7
015D6:  MOVLB  C
015D8:  CLRF   x2D
015DA:  MOVFF  FEF,C2C
015DE:  CLRF   x2F
015E0:  MOVLW  0D
015E2:  MOVWF  x2E
015E4:  MOVLB  0
015E6:  CALL   0426
015EA:  BTFSC  19.7
015EC:  BSF    FF2.7
015EE:  MOVFF  02,03
015F2:  MOVF   01,W
015F4:  MOVLB  B
015F6:  ADDWF  xEE,W
015F8:  MOVWF  01
015FA:  MOVF   xEF,W
015FC:  ADDWFC 03,F
015FE:  MOVFF  01,BF2
01602:  MOVFF  03,BF3
01606:  MOVFF  03,C02
0160A:  MOVFF  01,C01
0160E:  MOVFF  BF1,C04
01612:  MOVFF  BF0,C03
01616:  MOVLB  0
01618:  CALL   0B94
0161C:  MOVLB  B
0161E:  MOVLB  0
01620:  GOTO   167E (RETURN)
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
*
00A3C:  MOVLW  C3
00A3E:  MOVLB  B
00A40:  ADDWF  xF2,W
00A42:  MOVWF  FE9
00A44:  MOVLW  00
00A46:  ADDWFC xF3,W
00A48:  MOVWF  FEA
00A4A:  MOVF   FEF,W
00A4C:  SUBLW  FF
00A4E:  BNZ   0A52
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
00A50:  BRA    0AC2
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
00A52:  MOVLW  C3
00A54:  ADDWF  xF2,W
00A56:  MOVWF  FE9
00A58:  MOVLW  00
00A5A:  ADDWFC xF3,W
00A5C:  MOVWF  FEA
00A5E:  MOVFF  FEF,BF4
00A62:  MOVLW  C4
00A64:  ADDWF  xF2,W
00A66:  MOVWF  FE9
00A68:  MOVLW  00
00A6A:  ADDWFC xF3,W
00A6C:  MOVWF  FEA
00A6E:  MOVF   FEF,W
00A70:  SUBWF  xF4,W
00A72:  BNZ   0A92
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
00A74:  MOVLW  C3
00A76:  ADDWF  xF2,W
00A78:  MOVWF  FE9
00A7A:  MOVLW  00
00A7C:  ADDWFC xF3,W
00A7E:  MOVWF  FEA
00A80:  SETF   FEF
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
00A82:  MOVLW  C4
00A84:  ADDWF  xF2,W
00A86:  MOVWF  FE9
00A88:  MOVLW  00
00A8A:  ADDWFC xF3,W
00A8C:  MOVWF  FEA
00A8E:  SETF   FEF
....................     }  
00A90:  BRA    0AC2
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
00A92:  MOVLW  C3
00A94:  ADDWF  xF2,W
00A96:  MOVWF  FE9
00A98:  MOVLW  00
00A9A:  ADDWFC xF3,W
00A9C:  MOVWF  FEA
00A9E:  MOVF   FEF,W
00AA0:  SUBLW  0E
00AA2:  BNZ   0AB4
....................         pstIBUMSGQueue->m_i8Front = 0;  
00AA4:  MOVLW  C3
00AA6:  ADDWF  xF2,W
00AA8:  MOVWF  FE9
00AAA:  MOVLW  00
00AAC:  ADDWFC xF3,W
00AAE:  MOVWF  FEA
00AB0:  CLRF   FEF
00AB2:  BRA    0AC2
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
00AB4:  MOVLW  C3
00AB6:  ADDWF  xF2,W
00AB8:  MOVWF  FE9
00ABA:  MOVLW  00
00ABC:  ADDWFC xF3,W
00ABE:  MOVWF  FEA
00AC0:  INCF   FEF,F
00AC2:  MOVLB  0
00AC4:  RETURN 0
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
*
010E8:  MOVLB  B
010EA:  CLRF   xEF
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
010EC:  MOVLW  C3
010EE:  ADDWF  xED,W
010F0:  MOVWF  FE9
010F2:  MOVLW  00
010F4:  ADDWFC xEE,W
010F6:  MOVWF  FEA
010F8:  MOVF   FEF,W
010FA:  SUBLW  FF
010FC:  BNZ   1102
....................     { 
....................         ui8RetVal = 0; 
010FE:  CLRF   xEF
....................     } 
01100:  BRA    1106
....................     else 
....................     { 
....................         ui8RetVal = 1; 
01102:  MOVLW  01
01104:  MOVWF  xEF
....................     } 
....................      
....................     return ui8RetVal; 
01106:  MOVFF  BEF,01
0110A:  MOVLB  0
0110C:  RETURN 0
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
*
01624:  MOVLB  B
01626:  CLRF   xED
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
01628:  MOVLB  4
0162A:  MOVF   x3D,W
0162C:  SUBLW  09
0162E:  BC    164A
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
01630:  CLRF   x3D
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
01632:  MOVLW  02
01634:  MOVLB  B
01636:  MOVWF  xF3
01638:  MOVLW  90
0163A:  MOVWF  xF2
0163C:  MOVLB  0
0163E:  CALL   0A3C
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
01642:  MOVLB  2
01644:  CLRF   x8F
....................         return; 
01646:  BRA    174A
01648:  MOVLB  4
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
0164A:  INCF   x3D,F
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
0164C:  MOVLB  B
0164E:  CLRF   xED
01650:  MOVF   xED,W
01652:  SUBLW  08
01654:  BNC   166A
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
01656:  CLRF   03
01658:  MOVF   xED,W
0165A:  ADDLW  FC
0165C:  MOVWF  FE9
0165E:  MOVLW  01
01660:  ADDWFC 03,W
01662:  MOVWF  FEA
01664:  CLRF   FEF
01666:  INCF   xED,F
01668:  BRA    1650
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0166A:  MOVLW  02
0166C:  MOVWF  xEF
0166E:  MOVLW  90
01670:  MOVWF  xEE
01672:  MOVLW  01
01674:  MOVWF  xF1
01676:  MOVLW  FA
01678:  MOVWF  xF0
0167A:  MOVLB  0
0167C:  BRA    15AC
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
0167E:  MOVLB  4
01680:  DECFSZ x3D,W
01682:  BRA    168E
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
01684:  INCFSZ x2D,W
01686:  BRA    168C
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
01688:  CLRF   x2D
....................         } 
0168A:  BRA    168E
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
0168C:  INCF   x2D,F
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
0168E:  MOVFF  42D,1FA
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
01692:  MOVFF  42D,42E
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
01696:  MOVLW  21
01698:  MOVWF  x2F
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
0169A:  MOVFF  1FC,430
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
0169E:  MOVFF  1FD,431
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
016A2:  MOVFF  1FE,432
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
016A6:  MOVFF  1FF,433
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
016AA:  MOVFF  200,434
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
016AE:  MOVFF  201,435
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
016B2:  MOVFF  202,436
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
016B6:  MOVFF  203,437
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
016BA:  MOVFF  204,438
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
016BE:  MOVLW  04
016C0:  MOVLB  C
016C2:  MOVWF  x0C
016C4:  MOVLW  2E
016C6:  MOVWF  x0B
016C8:  MOVLW  0B
016CA:  MOVWF  x0D
016CC:  MOVLB  0
016CE:  CALL   0B00
016D2:  MOVFF  02,43C
016D6:  MOVFF  01,43B
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
016DA:  MOVFF  43C,BEF
016DE:  MOVFF  43B,439
016E2:  MOVLB  4
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
016E4:  MOVFF  43C,43A
016E8:  MOVLB  4
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
016EA:  MOVLW  A5
016EC:  MOVLB  0
016EE:  CALL   0DAA
....................     fputc(STX, UART); 
016F2:  MOVLW  A5
016F4:  CALL   0DAA
....................     fputc(STX, UART); 
016F8:  MOVLW  A5
016FA:  CALL   0DAA
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
016FE:  MOVLB  B
01700:  CLRF   xED
01702:  MOVF   xED,W
01704:  SUBLW  0C
01706:  BNC   1728
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
01708:  CLRF   03
0170A:  MOVF   xED,W
0170C:  ADDLW  2E
0170E:  MOVWF  FE9
01710:  MOVLW  04
01712:  ADDWFC 03,W
01714:  MOVWF  FEA
01716:  MOVFF  FEF,BEE
0171A:  MOVF   xEE,W
0171C:  MOVLB  0
0171E:  CALL   0DAA
01722:  MOVLB  B
01724:  INCF   xED,F
01726:  BRA    1702
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
01728:  MOVLW  B5
0172A:  MOVLB  0
0172C:  CALL   0DAA
....................     fputc(ETX, UART); 
01730:  MOVLW  B5
01732:  CALL   0DAA
....................     delay_us(5); 
01736:  CLRWDT
01738:  MOVLW  07
0173A:  MOVWF  00
0173C:  DECFSZ 00,F
0173E:  BRA    173C
01740:  BRA    1742
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
01742:  MOVLW  01
01744:  MOVLB  4
01746:  MOVWF  x1D
01748:  MOVLB  2
0174A:  MOVLB  0
0174C:  GOTO   46A2 (RETURN)
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
*
00AC6:  MOVLB  B
00AC8:  MOVF   xF1,W
00ACA:  MOVLB  4
00ACC:  SUBWF  x2D,W
00ACE:  BNZ   0AF0
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
00AD0:  MOVLW  02
00AD2:  MOVLB  B
00AD4:  MOVWF  xF3
00AD6:  MOVLW  90
00AD8:  MOVWF  xF2
00ADA:  MOVLB  0
00ADC:  RCALL  0A3C
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
00ADE:  MOVLB  4
00AE0:  CLRF   x3D
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00AE2:  CLRF   x1D
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00AE4:  CLRF   x1F
00AE6:  CLRF   x1E
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00AE8:  MOVLB  2
00AEA:  CLRF   x8F
....................     } 
00AEC:  BRA    0AFA
00AEE:  MOVLB  4
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
00AF0:  CLRF   x1D
....................         g_ui16IBUWaitForACKTikCount  = 0; 
00AF2:  CLRF   x1F
00AF4:  CLRF   x1E
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
00AF6:  MOVLB  2
00AF8:  CLRF   x8F
....................     } 
00AFA:  MOVLB  0
00AFC:  GOTO   100A (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
*
00DB6:  MOVFF  1D1,BED
00DBA:  MOVLB  B
00DBC:  CLRF   xEE
00DBE:  MOVFF  1D1,BEF
00DC2:  CLRF   xF0
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
00DC4:  MOVFF  1D1,4A4
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
00DC8:  MOVFF  1D2,4A5
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
00DCC:  MOVLB  4
00DCE:  CLRF   xA7
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
00DD0:  CLRF   xA6
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
00DD2:  MOVLB  1
00DD4:  MOVF   xD3,F
00DD6:  BZ    0E40
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00DD8:  MOVLW  01
00DDA:  ADDWF  xD1,W
00DDC:  MOVLB  B
00DDE:  MOVWF  xF2
00DE0:  CLRF   19
00DE2:  BTFSC  FF2.7
00DE4:  BSF    19.7
00DE6:  BCF    FF2.7
00DE8:  MOVFF  FE8,C33
00DEC:  MOVLW  C8
00DEE:  MOVLB  C
00DF0:  MOVWF  x34
00DF2:  MOVLB  0
00DF4:  CALL   0182
00DF8:  BTFSC  19.7
00DFA:  BSF    FF2.7
00DFC:  MOVFF  00,BEF
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
00E00:  CLRF   03
00E02:  MOVLB  1
00E04:  MOVF   xD1,W
00E06:  ADDLW  09
00E08:  MOVWF  FE9
00E0A:  MOVLW  01
00E0C:  ADDWFC 03,W
00E0E:  MOVWF  FEA
00E10:  MOVF   FEF,W
00E12:  SUBLW  A5
00E14:  BNZ   0E38
00E16:  CLRF   03
00E18:  MOVLB  B
00E1A:  MOVF   xEF,W
00E1C:  ADDLW  09
00E1E:  MOVWF  FE9
00E20:  MOVLW  01
00E22:  ADDWFC 03,W
00E24:  MOVWF  FEA
00E26:  MOVF   FEF,W
00E28:  SUBLW  A5
00E2A:  BTFSC  FD8.2
00E2C:  BRA    0E32
00E2E:  MOVLB  1
00E30:  BRA    0E38
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
00E32:  MOVLB  1
00E34:  BRA    0E40
....................         } 
00E36:  BRA    0E3E
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
00E38:  MOVFF  BEF,1D1
....................             g_ui8ElementInQ--; 
00E3C:  DECF   xD3,F
....................         } 
00E3E:  BRA    0DD4
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
00E40:  MOVF   xD3,F
00E42:  BNZ   0E46
....................     { 
....................         // The message exhausted 
....................         return; 
00E44:  BRA    10E2
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
00E46:  MOVF   xD3,W
00E48:  SUBLW  0D
00E4A:  BC    0EDC
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
00E4C:  MOVLW  0E
00E4E:  ADDWF  xD1,W
00E50:  MOVLB  B
00E52:  MOVWF  xF2
00E54:  CLRF   19
00E56:  BTFSC  FF2.7
00E58:  BSF    19.7
00E5A:  BCF    FF2.7
00E5C:  MOVFF  FE8,C33
00E60:  MOVLW  C8
00E62:  MOVLB  C
00E64:  MOVWF  x34
00E66:  MOVLB  0
00E68:  CALL   0182
00E6C:  BTFSC  19.7
00E6E:  BSF    FF2.7
00E70:  MOVFF  00,BF0
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00E74:  CLRF   03
00E76:  MOVLB  1
00E78:  MOVF   xD1,W
00E7A:  ADDLW  09
00E7C:  MOVWF  FE9
00E7E:  MOVLW  01
00E80:  ADDWFC 03,W
00E82:  MOVWF  FEA
00E84:  MOVF   FEF,W
00E86:  SUBLW  A5
00E88:  BNZ   0ED8
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
00E8A:  CLRF   03
00E8C:  MOVLB  B
00E8E:  MOVF   xF0,W
00E90:  ADDLW  09
00E92:  MOVWF  FE9
00E94:  MOVLW  01
00E96:  ADDWFC 03,W
00E98:  MOVWF  FEA
00E9A:  MOVF   FEF,W
00E9C:  SUBLW  B5
00E9E:  BNZ   0EA8
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
00EA0:  MOVLB  1
00EA2:  BRA    0EDC
....................             } 
00EA4:  BRA    0ED6
00EA6:  MOVLB  B
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00EA8:  MOVLW  01
00EAA:  MOVLB  1
00EAC:  ADDWF  xD1,W
00EAE:  MOVLB  B
00EB0:  MOVWF  xF2
00EB2:  CLRF   19
00EB4:  BTFSC  FF2.7
00EB6:  BSF    19.7
00EB8:  BCF    FF2.7
00EBA:  MOVFF  FE8,C33
00EBE:  MOVLW  C8
00EC0:  MOVLB  C
00EC2:  MOVWF  x34
00EC4:  MOVLB  0
00EC6:  CALL   0182
00ECA:  BTFSC  19.7
00ECC:  BSF    FF2.7
00ECE:  MOVFF  00,1D1
....................                 g_ui8ElementInQ--; 
00ED2:  MOVLB  1
00ED4:  DECF   xD3,F
....................             } 
....................         } 
00ED6:  BRA    0EDA
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
00ED8:  BRA    10E2
....................         } 
00EDA:  BRA    0E46
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00EDC:  MOVLW  01
00EDE:  ADDWF  xD1,W
00EE0:  MOVLB  B
00EE2:  MOVWF  xF2
00EE4:  CLRF   19
00EE6:  BTFSC  FF2.7
00EE8:  BSF    19.7
00EEA:  BCF    FF2.7
00EEC:  MOVFF  FE8,C33
00EF0:  MOVLW  C8
00EF2:  MOVLB  C
00EF4:  MOVWF  x34
00EF6:  MOVLB  0
00EF8:  CALL   0182
00EFC:  BTFSC  19.7
00EFE:  BSF    FF2.7
00F00:  MOVFF  00,1D1
....................     g_ui8ElementInQ--; 
00F04:  MOVLB  1
00F06:  DECF   xD3,F
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
00F08:  MOVLB  B
00F0A:  CLRF   xEE
00F0C:  MOVF   xEE,W
00F0E:  SUBLW  0C
00F10:  BNC   0F78
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
00F12:  CLRF   03
00F14:  MOVF   xEE,W
00F16:  ADDLW  20
00F18:  MOVWF  01
00F1A:  MOVLW  04
00F1C:  ADDWFC 03,F
00F1E:  MOVFF  03,BF2
00F22:  CLRF   03
00F24:  MOVLB  1
00F26:  MOVF   xD1,W
00F28:  ADDLW  09
00F2A:  MOVWF  FE9
00F2C:  MOVLW  01
00F2E:  ADDWFC 03,W
00F30:  MOVWF  FEA
00F32:  MOVFF  FEF,BF3
00F36:  MOVLB  B
00F38:  MOVFF  BF2,FEA
00F3C:  MOVFF  01,FE9
00F40:  MOVFF  BF3,FEF
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F44:  MOVLW  01
00F46:  MOVLB  1
00F48:  ADDWF  xD1,W
00F4A:  MOVLB  B
00F4C:  MOVWF  xF2
00F4E:  CLRF   19
00F50:  BTFSC  FF2.7
00F52:  BSF    19.7
00F54:  BCF    FF2.7
00F56:  MOVFF  FE8,C33
00F5A:  MOVLW  C8
00F5C:  MOVLB  C
00F5E:  MOVWF  x34
00F60:  MOVLB  0
00F62:  CALL   0182
00F66:  BTFSC  19.7
00F68:  BSF    FF2.7
00F6A:  MOVFF  00,1D1
....................         g_ui8ElementInQ--; 
00F6E:  MOVLB  1
00F70:  DECF   xD3,F
00F72:  MOVLB  B
00F74:  INCF   xEE,F
00F76:  BRA    0F0C
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
00F78:  MOVLB  1
00F7A:  MOVF   xD3,F
00F7C:  BZ    0FC2
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
00F7E:  CLRF   03
00F80:  MOVF   xD1,W
00F82:  ADDLW  09
00F84:  MOVWF  FE9
00F86:  MOVLW  01
00F88:  ADDWFC 03,W
00F8A:  MOVWF  FEA
00F8C:  MOVF   FEF,W
00F8E:  SUBLW  A5
00F90:  BNZ   0F94
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
00F92:  BRA    0FC2
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
00F94:  MOVLW  01
00F96:  ADDWF  xD1,W
00F98:  MOVLB  B
00F9A:  MOVWF  xF2
00F9C:  CLRF   19
00F9E:  BTFSC  FF2.7
00FA0:  BSF    19.7
00FA2:  BCF    FF2.7
00FA4:  MOVFF  FE8,C33
00FA8:  MOVLW  C8
00FAA:  MOVLB  C
00FAC:  MOVWF  x34
00FAE:  MOVLB  0
00FB0:  CALL   0182
00FB4:  BTFSC  19.7
00FB6:  BSF    FF2.7
00FB8:  MOVFF  00,1D1
....................         g_ui8ElementInQ--; 
00FBC:  MOVLB  1
00FBE:  DECF   xD3,F
00FC0:  BRA    0F7A
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
00FC2:  MOVLW  01
00FC4:  ADDWF  xD2,W
00FC6:  MOVLB  B
00FC8:  MOVWF  xF2
00FCA:  CLRF   19
00FCC:  BTFSC  FF2.7
00FCE:  BSF    19.7
00FD0:  BCF    FF2.7
00FD2:  MOVFF  FE8,C33
00FD6:  MOVLW  C8
00FD8:  MOVLB  C
00FDA:  MOVWF  x34
00FDC:  MOVLB  0
00FDE:  CALL   0182
00FE2:  BTFSC  19.7
00FE4:  BSF    FF2.7
00FE6:  MOVFF  00,BEF
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
00FEA:  MOVLB  B
00FEC:  MOVF   xEF,W
00FEE:  MOVLB  1
00FF0:  SUBWF  xD1,W
00FF2:  BNZ   0FFA
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
00FF4:  SETF   xD2
00FF6:  MOVFF  1D2,1D1
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
00FFA:  MOVLB  4
00FFC:  MOVF   x21,W
00FFE:  SUBLW  2C
01000:  BNZ   1010
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
01002:  MOVFF  420,BF1
01006:  MOVLB  0
01008:  BRA    0AC6
....................         return; 
0100A:  MOVLB  1
0100C:  BRA    10E2
0100E:  MOVLB  4
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
01010:  MOVF   x21,W
01012:  SUBLW  21
01014:  BNZ   10E0
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
01016:  MOVLW  04
01018:  MOVLB  C
0101A:  MOVWF  x0C
0101C:  MOVLW  20
0101E:  MOVWF  x0B
01020:  MOVLW  0B
01022:  MOVWF  x0D
01024:  MOVLB  0
01026:  RCALL  0B00
01028:  MOVFF  02,43C
0102C:  MOVFF  01,43B
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
01030:  MOVFF  43C,BF1
01034:  MOVLB  B
01036:  CLRF   xF2
01038:  MOVLB  4
0103A:  MOVF   x2C,W
0103C:  MOVLB  B
0103E:  SUBWF  xF1,W
01040:  BNZ   10DE
01042:  MOVF   xF2,F
01044:  BNZ   10DE
01046:  MOVFF  43C,BF2
0104A:  MOVFF  43B,BF1
0104E:  CLRF   xF2
01050:  MOVLB  4
01052:  MOVF   x2B,W
01054:  MOVLB  B
01056:  SUBWF  xF1,W
01058:  BNZ   10DE
0105A:  MOVF   xF2,F
0105C:  BNZ   10DE
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
0105E:  MOVFF  422,1EF
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
01062:  MOVFF  423,1F0
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
01066:  MOVFF  424,1F1
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
0106A:  MOVFF  425,1F2
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
0106E:  MOVFF  426,1F3
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
01072:  MOVFF  427,1F4
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
01076:  MOVFF  428,1F5
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
0107A:  MOVFF  429,1F6
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
0107E:  MOVFF  42A,1F7
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
01082:  MOVLW  03
01084:  MOVWF  xF9
01086:  MOVLW  55
01088:  MOVWF  xF8
0108A:  MOVLW  01
0108C:  MOVWF  xFB
0108E:  MOVLW  ED
01090:  MOVWF  xFA
01092:  MOVLB  0
01094:  RCALL  0BD4
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
01096:  MOVLW  2C
01098:  MOVLB  4
0109A:  MOVWF  x21
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
0109C:  MOVLW  A5
0109E:  MOVLB  0
010A0:  RCALL  0DAA
....................             fputc(STX, UART); 
010A2:  MOVLW  A5
010A4:  RCALL  0DAA
....................             fputc(STX, UART); 
010A6:  MOVLW  A5
010A8:  RCALL  0DAA
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
010AA:  MOVLB  B
010AC:  CLRF   xEE
010AE:  MOVF   xEE,W
010B0:  SUBLW  0C
010B2:  BNC   10D2
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
010B4:  CLRF   03
010B6:  MOVF   xEE,W
010B8:  ADDLW  20
010BA:  MOVWF  FE9
010BC:  MOVLW  04
010BE:  ADDWFC 03,W
010C0:  MOVWF  FEA
010C2:  MOVFF  FEF,BF1
010C6:  MOVF   xF1,W
010C8:  MOVLB  0
010CA:  RCALL  0DAA
010CC:  MOVLB  B
010CE:  INCF   xEE,F
010D0:  BRA    10AE
....................             } 
....................             fputc(ETX, UART); 
010D2:  MOVLW  B5
010D4:  MOVLB  0
010D6:  RCALL  0DAA
....................             fputc(ETX, UART); 
010D8:  MOVLW  B5
010DA:  RCALL  0DAA
010DC:  MOVLB  B
....................         } 
....................     } 
010DE:  MOVLB  4
010E0:  MOVLB  1
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
010E2:  MOVLB  0
010E4:  GOTO   465E (RETURN)
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
*
001CA:  MOVLB  0
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
001CC:  MOVLB  1
001CE:  MOVF   xD1,W
001D0:  SUBLW  FF
001D2:  BNZ   01D6
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
001D4:  CLRF   xD1
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
001D6:  MOVLW  01
001D8:  ADDWF  xD2,W
001DA:  MOVLB  C
001DC:  MOVWF  x32
001DE:  MOVWF  x33
001E0:  MOVLW  C8
001E2:  MOVWF  x34
001E4:  MOVLB  0
001E6:  RCALL  0182
001E8:  MOVFF  00,1D2
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
001EC:  CLRF   03
001EE:  MOVLB  1
001F0:  MOVF   xD2,W
001F2:  ADDLW  09
001F4:  MOVWF  FE9
001F6:  MOVLW  01
001F8:  ADDWFC 03,W
001FA:  MOVWF  FEA
001FC:  MOVFF  FEA,C34
00200:  MOVFF  FE9,C33
00204:  MOVLB  0
00206:  BRA    01AE
00208:  MOVFF  C34,FEA
0020C:  MOVFF  C33,FE9
00210:  MOVFF  01,FEF
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
00214:  MOVF   F98,W
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
.................... #ifndef _VM_IBU_GOBAL_H_ 
.................... #define _VM_IBU_GOBAL_H_ 
....................  
.................... //#include "vmModbusGlobal.h" 
....................  
.................... #define IBU_SEND_LOCK                   1 
.................... #define IBU_SEND_UNLOCK                 0 
....................  
.................... #define STX                             0xA5     
.................... #define ETX                             0xB5 
.................... #define MULTI_PROD_MAX_VARIETY          4 
....................  
.................... #define PIPE_PRESENCE_DELAY             1 
.................... #define PIPE_STABILIZATION_DELAY        2 
.................... #define PIPE_TRANSFER_DELAY             3 
....................  
.................... typedef enum _EN_IBU_COMMANDS 
.................... { 
....................     IBU_CMD_MODE_HOME                   = 100, 
....................     // Calibration Mode 
....................     IBU_CMD_MODE_CALIB                  = 101, 
....................     IBU_CMD_START_CALIBRATION           = 102, 
.................... //    IBU_CMD_RESET_CALIB_POINT_TARE      = 103, 
....................     IBU_CMD_RESET_CALIB_DATA            = 104, 
....................     IBU_CMD_RESET_CALIB_POINT           = 105, 
.................... //    IBU_CMD_RESET_CALIB_POINT_WEIGHT    = 106,  
....................     IBU_CMD_TARE_REQUEST                = 107, 
....................     IBU_CMD_SET_LOAD_CELL_FACTOR        = 108, 
....................  
....................     // Pre-Production Mode 
....................     IBU_CMD_MODE_PRE_PROD               = 111, 
....................     IBU_CMD_PRE_PROD_AVG_WEIGHT         = 112, 
....................     IBU_CMD_PRE_PROD_TOLERANCE          = 113, 
....................     IBU_CMD_MODE_AUTO_CALIB             = 114, 
....................     IBU_CMD_MODE_FIXED_CALIB            = 115, 
....................     IBU_CMD_SELEC_PROD_TYPE             = 116, 
....................     IBU_CMD_CUR_BATCH_PROD_INDEX        = 117, 
....................     IBU_CMD_PRE_PROD_SCRAP_MODE         = 118, 
....................   
....................     // Production Mode 
....................     IBU_CMD_MODE_PROD                   = 130, 
....................     IBU_CMD_START_PROD                  = 131, 
....................     IBU_CMD_PROD_WEIGH_DATA             = 132, 
....................     IBU_CMD_PROD_BOX_COUNT              = 133, 
....................  
....................     IBU_CMD_PROD_TARE_DATA              = 134, 
....................     IBU_CMD_PROD_AVG_WT_DATA            = 135, 
....................              
....................     IBU_CMD_PROD_INTMD_DATA             = 140, 
....................     IBU_CMD_MODE_CONFIG                 = 141, 
....................     IBU_CMD_VAR_1_AVG_WT                = 142, 
....................     IBU_CMD_VAR_1_TOL_NODE              = 143, 
....................     IBU_CMD_VAR_2_AVG_WT                = 144, 
....................     IBU_CMD_VAR_2_TOL_NODE              = 145, 
....................     IBU_CMD_VAR_3_AVG_WT                = 146, 
....................     IBU_CMD_VAR_3_TOL_NODE              = 147, 
....................     IBU_CMD_VAR_4_AVG_WT                = 148, 
....................     IBU_CMD_VAR_4_TOL_NODE              = 149, 
....................              
....................     IBU_CMD_MODE_POST_PROD              = 150, 
....................     IBU_CMD_PRE_PROD_TOL_STORE_ACK      = 151, 
....................     IBU_CMD_STORE_PROD_DELAY_TIMERS     = 152, 
....................     IBU_CMD_AIR_PRESSURE_ALARM          = 153, 
....................     IBU_CMD_RESET_AIR_PRESSURE_ALARM    = 154, 
....................     IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY   = 155 
....................              
....................              
.................... } EN_IBU_COMMANDS; 
....................  
.................... // Mode type 
.................... enum boardModeType 
.................... { 
....................     BOARD_MODE_TYPE_NOTHING         = 0, 
....................     BOARD_MODE_TYPE_HOME            = 1, 
....................     BOARD_MODE_TYPE_PRE_PRODUCTION  = 2, 
.................... 	BOARD_MODE_TYPE_PRODUCTION      = 3, 
....................     BOARD_MODE_TYPE_CONFIGURATION   = 4, 
....................     BOARD_MODE_TYPE_CALIBRATION     = 5, 
....................     BOARD_MODE_TYPE_POST_PROD       = 6 
.................... }; 
....................  
....................  
....................  
.................... //typedef struct _ST_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    int16 m_i16BoxWeight; 
.................... //} ST_IBU_PROD_M_WEIGHT_DATA; 
.................... // 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_WEIGHT_DATA 
.................... //{ 
.................... //    ST_IBU_PROD_M_WEIGHT_DATA m_stWeighingData; 
.................... //    unsigned int8             m_ui8Arr[4]; 
.................... //} UN_IBU_PROD_M_WEIGHT_DATA; 
....................  
.................... //typedef struct _ST_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    unsigned int16 m_ui16BoxCount; 
.................... //    unsigned int16 m_ui16Padding; 
.................... //}ST_IBU_PROD_M_BOX_COUNT; 
.................... // 
.................... //typedef union _UN_IBU_PROD_M_BOX_COUNT 
.................... //{ 
.................... //    ST_IBU_PROD_M_BOX_COUNT m_stBoxCount; 
.................... //    unsigned int8           m_ui8Arr[4]; 
.................... //}UN_IBU_PROD_M_BOX_COUNT; 
....................  
.................... typedef struct _ST_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     int32           m_i32PipeWeight; 
....................     unsigned int16  m_ui16PipeCount; 
....................     unsigned int16  m_ui16PassStatus; 
.................... }ST_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_WEIGHING_STATUS_DATA 
.................... { 
....................     ST_IBU_PROD_M_WEIGHING_STATUS_DATA m_stWeighingStatusData; 
....................     unsigned int8                      m_ui8Arr[8]; 
.................... }UN_IBU_PROD_M_WEIGHING_STATUS_DATA; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_M_TARE_DATA 
.................... { 
....................     int32 m_i32Padding; 
....................     int32 m_i32TareData; 
.................... } ST_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef union _UN_IBU_PROD_M_TARE_DATA 
.................... { 
....................     ST_IBU_PROD_M_TARE_DATA m_stTareData; 
....................     unsigned int8           m_ui8Arr[8]; 
.................... } UN_IBU_PROD_M_TARE_DATA; 
....................  
.................... typedef struct _ST_IBU_TOL_NODE 
.................... { 
....................     int32 m_i32MaxWt; 
....................     int32 m_i32MinWt; 
.................... } ST_IBU_TOL_NODE; 
....................  
.................... typedef union _UN_IBU_TOLERANCE_NODE 
.................... { 
....................     ST_IBU_TOL_NODE m_stIBUTolNode; 
....................     unsigned int8   m_ui8Arr[8]; 
.................... }UN_IBU_TOLERANCE_NODE; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT 
.................... { 
....................     int16         m_i16CalibPoint; 
....................     int16         m_i16CurrCalibPoint; 
.................... } ST_IBU_RESET_CALIB_POINT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT m_stIBUResetCalibPoint; 
....................     unsigned int8            m_ui8Arr[4]; 
.................... } UN_IBU_RESET_CALIB_POINT; 
....................  
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_DATA 
.................... { 
....................     unsigned int32 m_ui32CalibADCForTare; 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... } ST_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_DATA 
.................... { 
....................     ST_IBU_RESET_CALIB_DATA    m_stIBUResetCalibData; 
....................     unsigned int8              m_ui8Arr[8]; 
.................... } UN_IBU_RESET_CALIB_DATA; 
....................  
.................... typedef struct _ST_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     unsigned int32 m_ui32CalibADCForWeight; 
.................... }ST_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... typedef union _UN_IBU_RESET_CALIB_POINT_WEIGHT 
.................... { 
....................     ST_IBU_RESET_CALIB_POINT_WEIGHT m_stIBUResetCalibWeight; 
....................     unsigned int8                 m_ui8Arr[4]; 
.................... }UN_IBU_RESET_CALIB_POINT_WEIGHT; 
....................  
.................... // Send Current Average Weight from MCU0 to MCU1, for IBU_CMD_PROD_AVG_WT_DATA 
.................... typedef struct _ST_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     int32 m_i32CurAvg; 
....................     int32 m_i32Padding; 
.................... } ST_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef union _UN_IBU_PROD_MODE_CUR_AVG 
.................... { 
....................     ST_IBU_PROD_MODE_CUR_AVG m_stAvgData; 
....................     unsigned int8            m_ui8Arr[8]; 
.................... } UN_IBU_PROD_MODE_CUR_AVG; 
....................  
.................... typedef struct _ST_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     unsigned int16 m_ui16CurrLoadCellFactor; 
....................     unsigned int16 m_ui16Padding; 
....................      
.................... }ST_IBU_LOAD_CELL_FACTOR; 
....................  
.................... typedef union _UN_IBU_LOAD_CELL_FACTOR 
.................... { 
....................     ST_IBU_LOAD_CELL_FACTOR     m_stLoadCellFactor; 
....................     unsigned int8               m_ui8Arr[4]; 
.................... }UN_IBU_LOAD_CELL_FACTOR; 
....................  
....................  
.................... typedef struct _ST_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     unsigned int8  m_ui8MessageHeader; 
....................     unsigned int16 m_ui16DelayTimer; 
....................     unsigned int8  m_ui8Spare; 
....................      
.................... }ST_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef union _UN_IBU_PROD_DELAY_TIMERS 
.................... { 
....................     ST_IBU_PROD_DELAY_TIMERS  m_stProdDelayTimers; 
....................     unsigned int8             m_ui8Arr[4]; 
.................... }UN_IBU_PROD_DELAY_TIMERS; 
....................  
.................... typedef struct _ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     unsigned int16     m_ui16DelayTime; 
....................     unsigned int16     m_ui16Spare; 
.................... }ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
.................... typedef union _UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY 
.................... { 
....................     ST_IBU_WEGHNG_CYLDR_UP_ACT_DELAY   m_stWeighingCylinderUpActivationDelay; 
....................     unsigned int8                      m_ui8Arr[4]; 
.................... }UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY; 
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //*****************************************************************************  
.................... boardModeType           g_boardModeType; 
.................... boardModeType           g_boardModeTypePre; 
.................... unsigned int16          g_ui16DIStatus; 
.................... unsigned int16          g_ui16DOStatus; 
.................... unsigned int16          g_ui16ErrorStatus; 
.................... unsigned int8           g_ui8IncrementIndex; 
.................... int8                    g_fIBUSendLockStatus = IBU_SEND_UNLOCK; 
.................... unsigned int8           g_ui8IBUTempByte = 0; 
.................... unsigned int8           g_fDataReady  = 0; 
....................  
....................  
.................... UN_IBU_PROD_M_WEIGHING_STATUS_DATA  g_unIBUProdModeWtStsData; 
.................... UN_IBU_PROD_M_TARE_DATA             g_unIBUProdModeTrData; 
.................... UN_IBU_TOLERANCE_NODE               g_unIBUTolNode; 
.................... UN_IBU_RESET_CALIB_POINT            g_unIBUResetCalib; 
.................... UN_IBU_RESET_CALIB_DATA             g_unIBUResetCalibData; 
.................... UN_IBU_PROD_MODE_CUR_AVG            g_unIBUProdModeAvg; 
.................... UN_IBU_LOAD_CELL_FACTOR             g_unIBUCurrLoadCellFactor; 
.................... UN_IBU_RESET_CALIB_POINT_WEIGHT     g_unIBUResetCalibWeight; 
.................... UN_IBU_PROD_DELAY_TIMERS            g_unProdDelayTimers; 
.................... UN_IBU_WEGHNG_CYLDR_UP_ACT_DELAY    g_unWeighingCylinderUpActivationDelay; 
....................  
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... #endif /* _VM_IBU_GOBAL_H_ */ 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
00216:  MOVLB  E
00218:  BCF    x36.5
0021A:  MOVLB  0
0021C:  GOTO   0134
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
....................  
....................  
.................... #define T0_DIV_PRESCALE                     T0_DIV_8  
.................... #define TIMER_0_VALUE_LOAD_FOR_1MS          0xFD8F 
.................... #define ALL_TIMER_TEST_VAL_FOR_100_US       (0xFFFF - 0x003F + 1) 
.................... #define ALL_TIMER_TEST_VAL_FOR_70_US        (0xFFFF - 0x002C + 1) 
....................  
....................  
.................... #define FLAG_DI_STATE_CHANGED                   11 
.................... #define FLAG_DI_STATE_NOT_CHANGED               12 
....................  
.................... //#define CHECK_FOR_AT_RESPONSE                   15 
.................... //#define DO_NOT_CHECK_FOR_AT_RESPONSE            16 
.................... //#define AT_RESPONSE_CHECK_INTRVL_TIMEOUT        10 // In Minutes. 
....................  
.................... #define MILLISECOND_TIMEOUT                     1000 
.................... #define SECOND_TIMEOUT                          60 
....................  
.................... #define SHOULD_SEND_DATA                        25 
.................... #define SHOULD_NOT_SEND_DATA                    26 
.................... #define DATA_SEND_INTERVAL_TIMEOUT              40 // In Seconds. 
....................  
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_START      80 
.................... #define  GPRS_QUEUE_EMPTY_TIME_COUNT_STOP       81 
.................... #define  GPRS_QUEUE_EMPTY_TIMEOUT               15 // In Minutes. 
....................  
.................... #define  SHOULD_CHECK_GPRS_CONNECTIVITY         55 
.................... #define  SHOULD_NOT_CHECK_GPRS_CONNECTIVITY     56 
....................  
.................... #define  GPRS_CONNECTION_QUERY_TIMEOUT          3  // In seconds. 
.................... #define  HTTP_URL_PARAMETER_SET_TIMEOUT         2 
.................... #define  HTTP_GET_SESSION_TIMEOUT               18 
.................... #define  DATA_RESEND_INTRVL_TIMEOUT             10 
....................  
.................... #define  RESET_TIME_INTERVAL_COUNTING           20 
.................... #define  POWER_CUT_TIME_COUNTING                21 
.................... #define  NETWORK_RECONNECT_HALT_TIME_COUNTING   22 
.................... #define  MODEM_RESET_PROCESS_ON                 24 
.................... #define  MODEM_RESET_PROCESS_OFF                25 
.................... #define  PERIODIC_MODEM_RESET_TIMEOUT           30 // In minutes. 
....................  
.................... #define  TIME_STAMP_WRITE_INTERVAL_TIME         60 // In seconds. 
.................... #define  TIME_STAMP_SIGNAL_ON                   20 
.................... #define  TIME_STAMP_SIGNAL_COMPLETE             21 
....................  
.................... #define  KEEP_ALIVE_SEND_PROCESS_ON             33 
.................... #define  KEEP_ALIVE_SEND_PROCESS_OFF            44 
....................  
.................... #define  CHECK_FOR_QUERY_START                  45 
.................... #define  CHECK_FOR_QUERY_END                    46 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... unsigned int16 g_ui16StackerEmptyDelayCount           = 0; 
.................... unsigned int8  g_fDIChangeState                       = FLAG_DI_STATE_NOT_CHANGED; 
.................... unsigned int16 g_ui16MillisecondToSecondCounter       = 0; 
.................... unsigned int8  g_ui8SecondToMinuteCounter             = 0; 
.................... unsigned int16 g_ui16ShouldLookTimerCounter           = 0; 
.................... unsigned int8  g_fShouldSendData                      = SHOULD_NOT_SEND_DATA; 
.................... unsigned int16 g_ui16DataSendIntervalTime             = 0; 
.................... unsigned int8  g_ui8TSWriteIntrvlCounter              = 0; 
.................... unsigned int8  g_fTSWriteToEEPROMSignal               = TIME_STAMP_SIGNAL_COMPLETE; 
.................... unsigned int8  g_ui8KeepAliveMonitoringCounter        = 180; 
.................... unsigned int8  g_fKeepAliveSendStatus                 = KEEP_ALIVE_SEND_PROCESS_OFF; 
.................... unsigned int8  g_fKeepAliveQueryCheck                 = CHECK_FOR_QUERY_END; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Below -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
.................... //Initialize 1MS Timer. 
.................... void Init1MSTimer(void) 
.................... { 
.................... 	//setup timer0 for 1MS time. 
.................... 	setup_timer_0( T0_INTERNAL | T0_DIV_PRESCALE ); 
*
005B2:  MOVLW  90
005B4:  MOVWF  FD5
005B6:  MOVLW  43
005B8:  MOVWF  FD6
.................... 	set_timer0(TIMER_0_VALUE_LOAD_FOR_1MS); 
005BA:  BTFSS  FD5.4
005BC:  BRA    05C2
005BE:  MOVLW  FD
005C0:  MOVWF  FD4
005C2:  MOVLW  8F
005C4:  MOVWF  FD3
....................  
.................... 	//Enable timer0 
.................... 	clear_interrupt( INT_TIMER0 ); 
005C6:  MOVLB  E
005C8:  BCF    x33.5
.................... 	enable_interrupts( INT_TIMER0 ); 
005CA:  BSF    x29.5
005CC:  MOVLB  0
005CE:  GOTO   462C (RETURN)
.................... } 
....................  
.................... #INT_TIMER0 
.................... void timer0_isr(void) 
*
00220:  MOVLB  0
.................... {    
....................      
.................... 	// Increase millisecond counter at each millisecond. 
....................     g_ui16MillisecondToSecondCounter++;   
00222:  MOVLB  4
00224:  INCF   xFA,F
00226:  BTFSC  FD8.2
00228:  INCF   xFB,F
....................      
....................      
....................      // Check if millisecond counter overflows 
....................     if(g_ui16MillisecondToSecondCounter >= MILLISECOND_TIMEOUT)   
0022A:  MOVF   xFB,W
0022C:  SUBLW  02
0022E:  BC    028E
00230:  XORLW  FF
00232:  BNZ   023A
00234:  MOVF   xFA,W
00236:  SUBLW  E7
00238:  BC    028E
....................     { 
....................         // Increment counter to Sync with HMI Time to get proper timestamp. 
....................         g_ui32UnixTimeInSec++; 
0023A:  MOVLW  01
0023C:  MOVLB  0
0023E:  ADDWF  xBD,F
00240:  BTFSC  FD8.0
00242:  INCF   xBE,F
00244:  BTFSC  FD8.2
00246:  INCF   xBF,F
00248:  BTFSC  FD8.2
0024A:  INCF   xC0,F
....................  
....................         // Reset counter. 
....................         g_ui16MillisecondToSecondCounter = 0; 
0024C:  MOVLB  4
0024E:  CLRF   xFB
00250:  CLRF   xFA
....................          
....................         // 1000MS i.e. 1second completed.. put stuff here that repeats after every second. 
....................          
....................         // Increase each second counter 
....................         g_ui8SecondToMinuteCounter++; 
00252:  INCF   xFC,F
....................          
....................         // If data should not send through GPRS then count data send interval time 
....................         if(SHOULD_NOT_SEND_DATA == g_fShouldSendData) 
00254:  MOVF   xFF,W
00256:  SUBLW  1A
00258:  BNZ   0264
....................         { 
....................             // Increase data send interval time. 
....................             g_ui16DataSendIntervalTime++; 
0025A:  MOVLB  5
0025C:  INCF   x00,F
0025E:  BTFSC  FD8.2
00260:  INCF   x01,F
00262:  MOVLB  4
....................         } 
....................          
....................                  
....................         // Check for interval timeout to write time-stamp into EEPROM. 
....................         if(++g_ui8TSWriteIntrvlCounter >= TIME_STAMP_WRITE_INTERVAL_TIME) 
00264:  MOVLB  5
00266:  INCF   x02,F
00268:  MOVF   x02,W
0026A:  SUBLW  3B
0026C:  BC    0284
....................         { 
....................             // Reset counter. 
....................             g_ui8TSWriteIntrvlCounter = 0; 
0026E:  CLRF   x02
....................              
....................             // Hook current unix time. 
....................             g_ui32HookedUpTimeStampPerMinute = g_ui32UnixTimeInSec; 
00270:  MOVFF  C0,98
00274:  MOVFF  BF,97
00278:  MOVFF  BE,96
0027C:  MOVFF  BD,95
....................              
....................             // Set flag to save current unix time to EEPROM. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_ON; 
00280:  MOVLW  14
00282:  MOVWF  x03
....................         } 
....................          
....................         // Decrease keep alive monitoring counter at each second. 
....................         // and check if it meets zero level i.e. 180 seconds passed and no data in queue. 
....................         // Time to send Keep Alive to Server. 
....................         if(--g_ui8KeepAliveMonitoringCounter == 0) 
00284:  DECFSZ x04,F
00286:  BRA    028C
....................         { 
....................             // set flag to denote 180 seconds over. 
....................             // Time to send keep alive. 
....................             g_fKeepAliveSendStatus = KEEP_ALIVE_SEND_PROCESS_ON; 
00288:  MOVLW  21
0028A:  MOVWF  x05
0028C:  MOVLB  4
....................         } 
....................     }    
....................      
....................      
....................     // Checking ISR received byte flag. 
....................     if(ISR_IS_READY == g_fIsReadyToReceiveByte)  
0028E:  MOVF   3E,W
00290:  SUBLW  28
00292:  BNZ   0298
....................     { 
....................         // Increase the counter. 
....................         g_ui8ISRReceiveByteTimeCounter++; 
00294:  INCF   3F,F
....................     } 
00296:  BRA    02A4
....................     else if(MODBUS_IS_NOT_VALID_SLAVE_ID == g_fIsValidSlaveID) 
00298:  MOVLB  0
0029A:  MOVF   x8A,W
0029C:  SUBLW  0D
0029E:  BNZ   02A2
....................     { 
....................         // Increase counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter++; 
002A0:  INCF   x8E,F
....................     } 
002A2:  MOVLB  4
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................       
....................     if(g_ui8UnexpectedSlaveIDIgnoreCounter >= ISR_TOTAL_8_BYTE_RECEIVE_TIME) 
002A4:  MOVLB  0
002A6:  MOVF   x8E,W
002A8:  SUBLW  02
002AA:  BC    02B6
....................     { 
....................         // Reset counter. 
....................         g_ui8UnexpectedSlaveIDIgnoreCounter = 0; 
002AC:  CLRF   x8E
....................          
....................         // Update flag status. 
....................         g_fIsValidSlaveID = MODBUS_IS_VALID_SLAVE_ID; 
002AE:  MOVLW  0C
002B0:  MOVWF  x8A
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002B2:  MOVLW  29
002B4:  MOVWF  3E
....................          
....................     }  
....................       
....................     if(g_ui8ISRReceiveByteTimeCounter > g_ui16ISRAllBytesExpectedRcvTime)  
002B6:  MOVF   x8C,F
002B8:  BNZ   02CA
002BA:  MOVF   3F,W
002BC:  SUBWF  x8B,W
002BE:  BC    02CA
....................     { 
....................         // Update all received byte flag. 
....................         g_fISRReceivedByteStatus = ISR_RECEIVED_ALL_BYTES; 
002C0:  MOVLW  15
002C2:  MOVWF  x8D
....................          
....................         // Update Is received byte flag.  
....................         g_fIsReadyToReceiveByte =  ISR_IS_NOT_READY; 
002C4:  MOVLW  29
002C6:  MOVWF  3E
....................          
....................         // Reset Counter 
....................         g_ui8ISRReceiveByteTimeCounter = 0; 
002C8:  CLRF   3F
....................     }     
....................      
....................     // ############################### Non Critical ############################### 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay Start 
....................     //---------------------------------------------------- 
....................     if (IBU_WAIT_FOR_ACK_TIMEOUT_ON == g_fIBUMsgAckDelayStatus) 
002CA:  MOVLB  4
002CC:  DECFSZ x1D,W
002CE:  BRA    02EC
....................     { 
....................         g_ui16IBUWaitForACKTikCount++; 
002D0:  INCF   x1E,F
002D2:  BTFSC  FD8.2
002D4:  INCF   x1F,F
....................         if (g_ui16IBUWaitForACKTikCount >= DELAY_IBU_MSG_ACK_NOT_RCV) 
002D6:  MOVF   x1F,F
002D8:  BNZ   02E0
002DA:  MOVF   x1E,W
002DC:  SUBLW  1D
002DE:  BC    02EC
....................         { 
....................             g_ui16IBUWaitForACKTikCount = 0; 
002E0:  CLRF   x1F
002E2:  CLRF   x1E
....................              
....................             // Reset flag denoting IBU is free now. 
....................             g_fIBUSendBusy = IBU_SENDING_FREE; 
002E4:  MOVLB  2
002E6:  CLRF   x8F
....................              
....................             g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
002E8:  MOVLB  4
002EA:  CLRF   x1D
....................         } 
....................     } 
....................     //---------------------------------------------------- 
....................     // IBU MSG ACK Receive Delay End 
....................     //---------------------------------------------------- 
....................      
....................     // Check if second counter overflows 
....................     if(g_ui8SecondToMinuteCounter >= SECOND_TIMEOUT) 
002EC:  MOVF   xFC,W
002EE:  SUBLW  3B
002F0:  BC    02F4
....................     { 
....................         // Reset counter 
....................         g_ui8SecondToMinuteCounter = 0; 
002F2:  CLRF   xFC
....................          
....................         // 60Seconds i.e. 1 Minute completed.. put stuff here that repeats after every minute. 
....................          
....................     } 
....................      
....................      
....................     // Check if timer should look for timeout 
....................     if(g_fShouldLookForTimeOut) 
002F4:  MOVLB  0
002F6:  MOVF   x92,F
002F8:  BZ    032C
....................     { 
....................         // Increase timer counter 
....................         g_ui16ShouldLookTimerCounter++; 
002FA:  MOVLB  4
002FC:  INCF   xFD,F
002FE:  BTFSC  FD8.2
00300:  INCF   xFE,F
....................          
....................         // Check if timer counter reached timeout value 
....................         if(g_ui16ShouldLookTimerCounter >= g_ui16TimeOutMilliseconds) 
00302:  MOVLB  0
00304:  MOVF   x91,W
00306:  MOVLB  4
00308:  SUBWF  xFE,W
0030A:  BNC   032E
0030C:  BNZ   0318
0030E:  MOVLB  0
00310:  MOVF   x90,W
00312:  MOVLB  4
00314:  SUBWF  xFD,W
00316:  BNC   032E
....................         { 
....................             // Set flag denoting that timer declares set time is timed out 
....................             g_fIsTimedOut = 1; 
00318:  MOVLW  01
0031A:  MOVLB  0
0031C:  MOVWF  x8F
....................              
....................             // Reset variables 
....................             g_fShouldLookForTimeOut      = 0; 
0031E:  CLRF   x92
....................             g_ui16ShouldLookTimerCounter = 0; 
00320:  MOVLB  4
00322:  CLRF   xFE
00324:  CLRF   xFD
....................             g_ui16TimeOutMilliseconds    = 0; 
00326:  MOVLB  0
00328:  CLRF   x91
0032A:  CLRF   x90
0032C:  MOVLB  4
....................         } 
....................     } 
....................          
....................     // Check if data send interval time reached timeout 
....................     if(g_ui16DataSendIntervalTime >= g_ui8DataSendingIntervalTime) 
0032E:  MOVLB  5
00330:  MOVF   x01,F
00332:  BNZ   033E
00334:  MOVLB  4
00336:  MOVF   xE0,W
00338:  MOVLB  5
0033A:  SUBWF  x00,W
0033C:  BNC   034A
....................     { 
....................         // Update should send data flag 
....................         g_fShouldSendData = SHOULD_SEND_DATA; 
0033E:  MOVLW  19
00340:  MOVLB  4
00342:  MOVWF  xFF
....................          
....................         // Reset variable 
....................         g_ui16DataSendIntervalTime = 0; 
00344:  MOVLB  5
00346:  CLRF   x01
00348:  CLRF   x00
....................     } 
....................          
.................... 	// Reset Timer0. 
....................     set_timer0( TIMER_0_VALUE_LOAD_FOR_1MS ); 
0034A:  BTFSS  FD5.4
0034C:  BRA    0352
0034E:  MOVLW  FD
00350:  MOVWF  FD4
00352:  MOVLW  8F
00354:  MOVWF  FD3
....................     clear_interrupt( INT_TIMER0 );	 
00356:  MOVLB  E
00358:  BCF    x33.5
0035A:  BCF    x33.5
0035C:  MOVLB  0
0035E:  GOTO   008A
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //**************** Above -> Timer Initialization Function ********************** 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... void ExecuteALLDOs(void) 
.................... { 
.................... //    delay_us(10); 
.................... //    output_bit(PIN_OUT_DO_00, g_unDOState.m_stAllDOBits.m_ui1HWDOCn00); // Solenoid opeartion. 
.................... //    //output_bit(PIN_OUT_DO_01, g_unDOState.m_stAllDOBits.m_ui1HWDOCn01); // Shipper rejection RED LED. 
.................... //    //output_bit(PIN_OUT_DO_02, g_unDOState.m_stAllDOBits.m_ui1HWDOCn02); 
.................... //    output_bit(PIN_OUT_DO_03, g_unDOState.m_stAllDOBits.m_ui1HWDOCn03); // Ready To Feed. 
.................... //    //output_bit(PIN_OUT_DO_04, g_unDOState.m_stAllDOBits.m_ui1HWDOCn04); 
.................... //    //output_bit(PIN_OUT_DO_05, g_unDOState.m_stAllDOBits.m_ui1HWDOCn05); 
.................... //    //output_bit(PIN_OUT_DO_06, g_unDOState.m_stAllDOBits.m_ui1HWDOCn06); 
.................... //    //output_bit(PIN_OUT_DO_07, g_unDOState.m_stAllDOBits.m_ui1HWDOCn07);    
.................... } 
....................  
.................... #endif /* _VM_TIMER_CONFIG_H_ */ 
....................  
.................... #include "vmIBCProcessM1.h" 
.................... /*  
....................  * File:   vmIBUProcessM1.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on December 11, 2018, 3:11 PM 
....................  */ 
....................  
.................... #ifndef VM_IBU_PROCESS_M1_H 
.................... #define	VM_IBU_PROCESS_M1_H 
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "vmGSMM66_GPRSConfig.h" 
.................... /*  
....................  * File:   vmGSMM66_GPRSConfig.h 
....................  * Author: Mrinmoy 
....................  * 
....................  * Created on January 22, 2019, 6:50 PM 
....................  */ 
....................  
.................... #ifndef VM_GSMM66_GPRS_CONFIG_H 
.................... #define	VM_GSMM66_GPRS_CONFIG_H 
....................  
.................... //#include "vmSIM900_GPRSConfig.h" 
.................... //#include "vmRS485Config.h" 
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
.................... #ifndef _VM_EEPROM_CONFIG_H_ 
.................... #define _VM_EEPROM_CONFIG_H_ 
....................  
.................... #rom int 0xf00000={1,2,3,4} 
....................  
.................... void WriteEEPROMInt8( unsigned int16 uiAddress, unsigned int8 uiValue ) 
.................... { 
....................     write_eeprom(uiAddress,uiValue); 
*
01E2E:  MOVF   FF2,W
01E30:  MOVWF  00
01E32:  BCF    FF2.7
01E34:  MOVFF  BFA,F75
01E38:  MOVFF  BF9,F74
01E3C:  MOVFF  BFB,F76
01E40:  BCF    F77.6
01E42:  BCF    F77.7
01E44:  BSF    F77.2
01E46:  MOVLB  F
01E48:  MOVLW  55
01E4A:  MOVWF  F78
01E4C:  MOVLW  AA
01E4E:  MOVWF  F78
01E50:  BSF    F77.1
01E52:  BTFSC  F77.1
01E54:  BRA    1E52
01E56:  BCF    F77.2
01E58:  BCF    F77.6
01E5A:  BSF    F77.7
01E5C:  MOVF   00,W
01E5E:  IORWF  FF2,F
01E60:  MOVLB  0
01E62:  RETURN 0
.................... } 
....................  
.................... void WriteEEPROMInt16( unsigned int16 uiAddress, unsigned int16 uiValue ) 
*
03C8E:  MOVLB  B
03C90:  CLRF   xF8
.................... { 
....................     unsigned int8 uiTemp = 0; 
....................  
....................     // Write first byte. 
....................     uiTemp = uiValue>>8; 
03C92:  MOVFF  BF7,BF8
....................     write_eeprom(uiAddress,uiTemp); 
03C96:  MOVF   FF2,W
03C98:  MOVWF  00
03C9A:  BCF    FF2.7
03C9C:  MOVFF  BF5,F75
03CA0:  MOVFF  BF4,F74
03CA4:  MOVFF  BF8,F76
03CA8:  BCF    F77.6
03CAA:  BCF    F77.7
03CAC:  BSF    F77.2
03CAE:  MOVLB  F
03CB0:  MOVLW  55
03CB2:  MOVWF  F78
03CB4:  MOVLW  AA
03CB6:  MOVWF  F78
03CB8:  BSF    F77.1
03CBA:  BTFSC  F77.1
03CBC:  BRA    3CBA
03CBE:  BCF    F77.2
03CC0:  BCF    F77.6
03CC2:  BSF    F77.7
03CC4:  MOVF   00,W
03CC6:  IORWF  FF2,F
....................     // Increment write address. 
....................     uiAddress++; 
03CC8:  MOVLB  B
03CCA:  INCF   xF4,F
03CCC:  BTFSC  FD8.2
03CCE:  INCF   xF5,F
....................     // Write second byte. 
....................     uiTemp = 0; 
03CD0:  CLRF   xF8
....................     uiTemp = uiValue & 0x00FF; 
03CD2:  MOVFF  BF6,BF8
....................     write_eeprom(uiAddress,uiTemp); 
03CD6:  MOVF   FF2,W
03CD8:  MOVWF  00
03CDA:  BCF    FF2.7
03CDC:  MOVFF  BF5,F75
03CE0:  MOVFF  BF4,F74
03CE4:  MOVFF  BF8,F76
03CE8:  BCF    F77.6
03CEA:  BCF    F77.7
03CEC:  BSF    F77.2
03CEE:  MOVLB  F
03CF0:  MOVLW  55
03CF2:  MOVWF  F78
03CF4:  MOVLW  AA
03CF6:  MOVWF  F78
03CF8:  BSF    F77.1
03CFA:  BTFSC  F77.1
03CFC:  BRA    3CFA
03CFE:  BCF    F77.2
03D00:  BCF    F77.6
03D02:  BSF    F77.7
03D04:  MOVF   00,W
03D06:  IORWF  FF2,F
03D08:  MOVLB  0
03D0A:  RETURN 0
.................... } 
....................  
.................... unsigned int8 ReadEEPROMInt8( unsigned int16 uiAddress ) 
*
00708:  MOVLB  B
0070A:  CLRF   xF1
.................... { 
....................     unsigned int8 uiValue = 0; 
....................  
....................     uiValue = read_eeprom(uiAddress); 
0070C:  MOVFF  FF2,BF2
00710:  BCF    FF2.7
00712:  MOVFF  BF0,F75
00716:  MOVFF  BEF,F74
0071A:  BCF    F77.6
0071C:  BCF    F77.7
0071E:  BSF    F77.0
00720:  MOVF   F76,W
00722:  BCF    F77.6
00724:  BSF    F77.7
00726:  BTFSC  xF2.7
00728:  BSF    FF2.7
0072A:  MOVWF  xF1
....................  
....................     return uiValue; 
0072C:  MOVFF  BF1,01
00730:  MOVLB  0
00732:  RETURN 0
.................... } 
....................  
.................... unsigned int16 ReadEEPROMInt16( unsigned int16 uiAddress ) 
*
00784:  MOVLB  B
00786:  CLRF   xF7
00788:  CLRF   xF6
0078A:  CLRF   xF9
0078C:  CLRF   xF8
.................... { 
....................     unsigned int16 uiValue = 0; 
....................     unsigned int16 uiTemp  = 0; 
....................  
....................     // Read first byte. 
....................     uiTemp = read_eeprom(uiAddress); 
0078E:  MOVFF  FF2,BFA
00792:  BCF    FF2.7
00794:  MOVFF  BF5,F75
00798:  MOVFF  BF4,F74
0079C:  BCF    F77.6
0079E:  BCF    F77.7
007A0:  BSF    F77.0
007A2:  MOVF   F76,W
007A4:  BCF    F77.6
007A6:  BSF    F77.7
007A8:  BTFSC  xFA.7
007AA:  BSF    FF2.7
007AC:  CLRF   xF9
007AE:  MOVWF  xF8
....................     uiValue = uiTemp << 8; 
007B0:  MOVFF  BF8,BF7
007B4:  CLRF   xF6
....................     // Increment read address. 
....................     uiAddress++; 
007B6:  INCF   xF4,F
007B8:  BTFSC  FD8.2
007BA:  INCF   xF5,F
....................     // Read second byte. 
....................     uiTemp = read_eeprom(uiAddress); 
007BC:  MOVFF  FF2,BFA
007C0:  BCF    FF2.7
007C2:  MOVFF  BF5,F75
007C6:  MOVFF  BF4,F74
007CA:  BCF    F77.6
007CC:  BCF    F77.7
007CE:  BSF    F77.0
007D0:  MOVF   F76,W
007D2:  BCF    F77.6
007D4:  BSF    F77.7
007D6:  BTFSC  xFA.7
007D8:  BSF    FF2.7
007DA:  CLRF   xF9
007DC:  MOVWF  xF8
....................     uiValue = uiValue | uiTemp; 
007DE:  MOVF   xF8,W
007E0:  IORWF  xF6,F
007E2:  MOVF   xF9,W
007E4:  IORWF  xF7,F
....................  
....................     return uiValue; 
007E6:  MOVFF  BF6,01
007EA:  MOVFF  BF7,02
007EE:  MOVLB  0
007F0:  RETURN 0
.................... } 
....................  
.................... #endif /* _VM_EEPROM_CONFIG_H_ */ 
....................  
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
*
01E64:  MOVLB  B
01E66:  CLRF   xFA
01E68:  MOVLW  0A
01E6A:  MOVWF  xF9
01E6C:  MOVFF  BF8,BFB
01E70:  MOVLB  0
01E72:  RCALL  1E2E
01E74:  GOTO   38C8 (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
*
00734:  MOVLB  B
00736:  CLRF   xEE
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
00738:  CLRF   xF0
0073A:  MOVLW  0A
0073C:  MOVWF  xEF
0073E:  MOVLB  0
00740:  RCALL  0708
00742:  MOVFF  01,BEE
....................      
....................     return ui8MachineID; 
00746:  MOVLB  B
00748:  MOVFF  BEE,01
0074C:  MOVLB  0
0074E:  GOTO   075A (RETURN)
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
*
01E78:  MOVLB  B
01E7A:  CLRF   xFA
01E7C:  MOVLW  0C
01E7E:  MOVWF  xF9
01E80:  MOVFF  BF8,BFB
01E84:  MOVLB  0
01E86:  RCALL  1E2E
01E88:  GOTO   38C8 (RETURN)
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
*
00766:  MOVLB  B
00768:  CLRF   xED
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
0076A:  CLRF   xF0
0076C:  MOVLW  0C
0076E:  MOVWF  xEF
00770:  MOVLB  0
00772:  RCALL  0708
00774:  MOVFF  01,BED
....................      
....................     return ui8DataSendInterval; 
00778:  MOVLB  B
0077A:  MOVFF  BED,01
0077E:  MOVLB  0
00780:  GOTO   094A (RETURN)
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
*
03D0C:  MOVLB  B
03D0E:  CLRF   xF2
03D10:  CLRF   xF1
03D12:  CLRF   xF3
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
03D14:  MOVLW  11
03D16:  MOVWF  xF3
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
03D18:  MOVFF  BEF,BF1
03D1C:  MOVFF  BF0,BF2
03D20:  CLRF   03
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03D22:  CLRF   xF5
03D24:  MOVFF  BF3,BF4
03D28:  MOVFF  BF2,BF7
03D2C:  MOVFF  BF1,BF6
03D30:  MOVLB  0
03D32:  RCALL  3C8E
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
03D34:  MOVLW  02
03D36:  MOVLB  B
03D38:  ADDWF  xF3,F
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
03D3A:  MOVFF  BED,BF1
03D3E:  MOVFF  BEE,BF2
03D42:  CLRF   03
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
03D44:  CLRF   xF5
03D46:  MOVFF  BF3,BF4
03D4A:  MOVFF  BF2,BF7
03D4E:  MOVFF  BF1,BF6
03D52:  MOVLB  0
03D54:  RCALL  3C8E
03D56:  GOTO   46CE (RETURN)
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
*
007F2:  MOVLB  B
007F4:  CLRF   xF0
007F6:  CLRF   xEF
007F8:  CLRF   xEE
007FA:  CLRF   xED
007FC:  CLRF   xF2
007FE:  CLRF   xF1
00800:  CLRF   xF3
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
00802:  MOVLW  11
00804:  MOVWF  xF3
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00806:  CLRF   xF5
00808:  MOVFF  BF3,BF4
0080C:  MOVLB  0
0080E:  RCALL  0784
00810:  MOVFF  02,BF2
00814:  MOVFF  01,BF1
....................     ui32StoredUnixTime = ui16Temp; 
00818:  MOVLB  B
0081A:  CLRF   xF0
0081C:  CLRF   xEF
0081E:  MOVFF  BF2,BEE
00822:  MOVFF  BF1,BED
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
00826:  MOVFF  BEE,BF0
0082A:  MOVFF  BED,BEF
0082E:  CLRF   xED
00830:  CLRF   xEE
....................     ui8EEPROMAddress += 2; 
00832:  MOVLW  02
00834:  ADDWF  xF3,F
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
00836:  CLRF   xF5
00838:  MOVFF  BF3,BF4
0083C:  MOVLB  0
0083E:  RCALL  0784
00840:  MOVFF  02,BF2
00844:  MOVFF  01,BF1
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
00848:  MOVLB  B
0084A:  CLRF   xF4
0084C:  CLRF   xF5
0084E:  MOVFF  BEF,BF6
00852:  MOVFF  BF0,BF7
00856:  MOVF   xF4,W
00858:  IORWF  xF1,W
0085A:  MOVWF  xED
0085C:  MOVF   xF5,W
0085E:  IORWF  xF2,W
00860:  MOVWF  xEE
00862:  MOVFF  BEF,BEF
00866:  MOVFF  BF0,BF0
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
0086A:  MOVLW  1E
0086C:  ADDWF  xED,F
0086E:  MOVLW  00
00870:  ADDWFC xEE,F
00872:  ADDWFC xEF,F
00874:  ADDWFC xF0,F
....................      
....................     return ui32StoredUnixTime;     
00876:  MOVFF  BED,00
0087A:  MOVFF  BEE,01
0087E:  MOVFF  BEF,02
00882:  MOVFF  BF0,03
00886:  MOVLB  0
00888:  GOTO   0950 (RETURN)
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
*
01E8C:  MOVLB  B
01E8E:  CLRF   xFA
01E90:  MOVLW  16
01E92:  MOVWF  xF9
01E94:  MOVFF  BF8,BFB
01E98:  MOVLB  0
01E9A:  RCALL  1E2E
01E9C:  GOTO   38C8 (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
*
0088C:  MOVLB  B
0088E:  CLRF   xED
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
00890:  CLRF   xF0
00892:  MOVLW  16
00894:  MOVWF  xEF
00896:  MOVLB  0
00898:  RCALL  0708
0089A:  MOVFF  01,BED
....................      
....................     return ui8SIMOperatorID;     
0089E:  MOVLB  B
008A0:  MOVFF  BED,01
008A4:  MOVLB  0
008A6:  GOTO   0962 (RETURN)
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
.................... // Stuff Machine ID and Variety type in GPRS Message header. 
.................... // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
.................... // Delta Foods Machine ID - 4 
.................... // Super Snacks Machine ID - 5 
.................... #define  MACHINE_ID                15             
....................      
.................... #define   SIZE_GSMM66_RX_BUFFER                 500 
.................... #define   SIZE_GPRS_DATA_NODE_QUEUE             100 
....................  
.................... #define   GPRS_DATA_SENDING_SEQUENCE_1          1 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_2          2 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_3          3 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_4          4 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_5          5 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_6          6 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_7          7 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_8          8 
.................... #define   GPRS_DATA_SENDING_SEQUENCE_9          9 
....................  
....................  
.................... typedef struct _ST_GPRS_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_GPRS_DATA_NODE; 
....................  
.................... typedef struct _ST_GPRS_MSG_SEND_QUEUE 
.................... { 
....................     ST_GPRS_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_GPRS_MSG_SEND_QUEUE; 
....................  
.................... typedef struct _ST_PROD_M_CURR_BOX_DATA 
.................... { 
....................     int32             m_i32PipeWeight; 
....................     unsigned int16    m_ui16SequenceNo; 
....................     unsigned int16    m_ui16RejectionStatus; 
....................     unsigned int32    m_ui32TimeStamp; 
.................... } ST_PROD_M_CURR_BOX_DATA; 
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8       g_ui8M66RxBuffer[SIZE_GSMM66_RX_BUFFER]               = {0}; 
.................... unsigned int16      g_ui16M66RxByteCount                                  = 0; 
.................... unsigned int8       g_ui8URLInputByteLength                               = 0; 
.................... unsigned int8       g_ui8URLInputTime                                     = 0; 
.................... unsigned int16      g_ui16Itm1SequenceNumber                              = 1; 
.................... unsigned int16      g_ui16Itm2SequenceNumber                              = 2; 
.................... unsigned int16      g_ui16ItemWeight                                      = 1999; 
.................... unsigned int8       g_ui8DataQueueLen                                     = 0; 
.................... unsigned int8       g_fGPRSSequence                                       = 0; 
.................... unsigned int8       g_fGPRSFailureBit                                     = 0; 
....................  
.................... //ST_GPRS_MSG_SEND_QUEUE   g_stGPRSMsgSendQueue; 
.................... ST_PROD_M_CURR_BOX_DATA  g_stProdModeCurrBoxData; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
.................... void ResetGSMM66RxBuffer(void) 
.................... { 
....................     // Reset whole buffer. 
....................     memset(g_ui8M66RxBuffer, 0, SIZE_GSMM66_RX_BUFFER); 
....................      
....................     // Reset byte count 
....................     g_ui16M66RxByteCount = 0; 
.................... } 
....................  
.................... //unsigned int8 CountDataSize(unsigned int32 ui32Data) 
.................... //{ 
.................... //    unsigned int8 ui8DataLen = 0; 
.................... //     
.................... //    if(ui32Data <= 9) 
.................... //    { 
.................... //        ui8DataLen = 1; 
.................... //    } 
.................... //    else if(ui32Data <= 99) 
.................... //    { 
.................... //        ui8DataLen = 2; 
.................... //    } 
.................... //    else if(ui32Data <= 999) 
.................... //    { 
.................... //        ui8DataLen = 3; 
.................... //    } 
.................... //    else if(ui32Data <= 9999) 
.................... //    { 
.................... //        ui8DataLen = 4; 
.................... //    } 
.................... //    else if(ui32Data <= 99999) 
.................... //    { 
.................... //        ui8DataLen = 5; 
.................... //    } 
.................... //    else if(ui32Data <= 999999) 
.................... //    { 
.................... //        ui8DataLen = 6; 
.................... //    } 
.................... //    else if(ui32Data <= 9999999) 
.................... //    { 
.................... //        ui8DataLen = 7; 
.................... //    } 
.................... //    else if(ui32Data <= 99999999) 
.................... //    { 
.................... //        ui8DataLen = 8; 
.................... //    } 
.................... //    else if(ui32Data <= 999999999) 
.................... //    { 
.................... //        ui8DataLen = 9; 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8DataLen = 10; 
.................... //    } 
.................... // 
.................... //     
.................... //    return ui8DataLen; 
.................... //} 
....................  
.................... //void CheckURLInputByteLength(void) 
.................... //{ 
.................... //    unsigned int8 ui8DataByte = 0; 
.................... //     
.................... //    // Basic byte count is 75 bytes. 
.................... //    // Here the dynamic/ changing variables are considered to count byte length. 
.................... // 
.................... //    // Check for Machine ID. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui8MachineID); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 1. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16BasicMaterialStandard); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 2. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16PipeSpecification); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for header parameter - 3. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MaxWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //        // Check for header parameter - 4. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgHeader.m_ui16MinWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //     
.................... //     
.................... //    // Check for TimeStamp. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Sequence number. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front ].m_ui16SequenceNo); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Item weight. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... //    // Check for Rejection status. 
.................... //    ui8DataByte = CountDataSize(g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... //    // Add up data byte. 
.................... //    g_ui8URLInputByteLength = g_ui8URLInputByteLength + ui8DataByte; 
.................... // 
.................... //} 
....................  
....................  
.................... //void InitializeGPRSMsgQueue(void) 
.................... //{ 
.................... //    // Initialize front and rear of the queue 
.................... //    g_stGPRSMsgSendQueue.m_i8Front = -1; 
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = -1; 
.................... //     
.................... //    // Initialize each queue element 
.................... //    for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
.................... //        g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
.................... //    } 
....................  
.................... //} 
....................  
.................... //unsigned int8 IsGPRSMsgQueueEmpty(void) 
.................... //{ 
.................... //    unsigned int8 ui8QueueStatus = 0; 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        ui8QueueStatus = 1;  
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        ui8QueueStatus = 0; 
.................... //    } 
.................... //    return ui8QueueStatus; 
.................... //} 
....................  
....................  
.................... //void InsertInGPRSMsgQueue() 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp; 
.................... //    //g_stGPRSMsgSendQueue.m_ui8QArr[g_stGPRSMsgSendQueue.m_ui8Rear] = ui8Element; 
.................... //} 
....................  
.................... //void InsertInGPRSQueue(void) 
.................... //{ 
.................... //    if (-1 == g_stGPRSMsgSendQueue.m_i8Front) 
.................... //    { 
.................... //        g_stGPRSMsgSendQueue.m_i8Front = 0; 
.................... //    } 
.................... //     
.................... //    g_stGPRSMsgSendQueue.m_i8Rear = (g_stGPRSMsgSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
.................... //     
.................... //    // Insert Data 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui16SequenceNo = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32ItemWeight = 999; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui8RejectionStatus = 99; 
.................... //    g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Rear].m_ui32TimeStamp = 999;     
.................... //} 
....................  
....................  
.................... void InitializeGPRSMsgHeader(void) 
.................... { 
....................     // Stuff Machine ID and Variety type in GPRS Message header. 
....................     // Amta plant(Line 2) -> Machine ID - 2 and Marie Gold variety Type - 3. 
....................     // Delta Foods Machine ID - 4 
....................     // Super Snacks Machine ID - 5 
....................      
....................  
....................     // Fetch Machine ID from memory. 
....................     g_ui8MachineID = ReadMachineIDFromEEPROM();     
....................     //g_stGPRSMsgHeader.m_ui8MachineID = g_ui8MachineID;  // Delta 
.................... } 
....................  
....................  
....................  
.................... // ################################################################# Below GPRS Connection Driver ############################################################# 
....................  
.................... //unsigned int8 SetPDPContext(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt(); 
.................... //    // Set AT command for define PDP Context.     
.................... //    if(1 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"airtelgprs.com\"\r", GSM_M66);    // For Airtel SIM. 
.................... //    } 
.................... //    else if (2 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"internet\"\r", GSM_M66);          // For Idea SIM. 
.................... //    } 
.................... //    else if (3 == g_ui8SIMOperatorID) 
.................... //    { 
.................... //        fputs("AT+CGDCONT=1,\"IP\",\"www\"\r", GSM_M66);               // For Vodafone SIM. 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    }                                      
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 ActivatePDP(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to activate PDP context. 
.................... //    fputs("AT+CGACT=1,1\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(5); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Restart WDT. 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for "OK". 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsOKFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //}  
....................  
.................... //unsigned int8 ShowActivatedAddress(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound            = 1; 
.................... //    unsigned int8 ui8FirstCharSequenceFound     = 0; 
.................... //    unsigned int8 ui8FirstCharSeqIndex          = 0; 
.................... //    unsigned int8 ui8SecondCharSequenceFound    = 0; 
.................... //    unsigned int8 ui8DoubleQuoteCount           = 0; 
.................... //    
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Restart WDT. 
.................... //    restart_wdt();     
.................... //    // Set AT command to Show activated PDP address. 
.................... //    fputs("AT+CGPADDR=1\r",GSM_M66); 
.................... //    mz_delay_ms(2000); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Reset timeout flag. 
.................... //     g_fIsTimedOut = 0; 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Reset variables. 
.................... //        ui8FirstCharSequenceFound  = 0; 
.................... //        ui8FirstCharSeqIndex       = 0; 
.................... //        ui8SecondCharSequenceFound = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount <= g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8FirstCharSequenceFound == 0 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'R' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'D' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'A' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'P' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'G' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'C' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 8)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence has found. 
.................... //                    ui8FirstCharSequenceFound = 1; 
.................... //                    // Copy the first character sequence index. 
.................... //                    ui8FirstCharSeqIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for second character sequence set. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '"') 
.................... //                { 
.................... //                    // Increment double quote count. 
.................... //                    ui8DoubleQuoteCount++; 
.................... //                    // Check double quote count. 
.................... //                    if(2 == ui8DoubleQuoteCount) 
.................... //                    { 
.................... //                        // Reset double quote count. 
.................... //                        ui8DoubleQuoteCount = 0; 
.................... //                        // loop through to check second quote count. 
.................... //                        for(unsigned int8 ui8LoopCount = ui8FirstCharSeqIndex; ui8LoopCount < (ui16ByteCount - 0); ui8LoopCount++) 
.................... //                        { 
.................... //                            // Check for stop count. 
.................... //                            if(g_ui8M66RxBuffer[(ui8LoopCount - 0)] == '.') 
.................... //                            { 
.................... //                                // Increase stop. 
.................... //                                ui8DoubleQuoteCount++; 
.................... //                                // Check limiting stop count. 
.................... //                                if(3 == ui8DoubleQuoteCount) 
.................... //                                { 
.................... //                                    // Set flag denoting second character sequence has found. 
.................... //                                    ui8SecondCharSequenceFound = 1; 
.................... //                                    break; 
.................... //                                } 
.................... //                            }     
.................... //                        } 
.................... //                         
.................... //                         
.................... //                    } 
.................... //                } 
.................... //            } 
.................... //             
.................... //            // Check for OK. 
.................... //            else if(ui8FirstCharSequenceFound == 1 && ui8SecondCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //               { 
.................... //                   // Set flag denoting 'OK' is found. 
.................... //                   ui8IsResponseFound = 0; 
.................... //                   break; 
.................... //               } 
.................... //            } 
.................... //        } 
.................... //         
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //void SendGPRSConnectionQuery(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(3); 
.................... // 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnection(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Check GPRS Connection. 
.................... //    fputs("AT+CGACT?\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsResponseFound == 5) 
.................... //    { 
.................... //        // Reset variables. 
.................... //        ui8IsFirstCharSequenceFound = 0; 
.................... //        ui8FirstCharSequenceIndex = 0; 
.................... //         
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            // Check for first character sequence. 
.................... //            if(ui8IsFirstCharSequenceFound == 0) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //                { 
.................... //                    // Set flag denoting first character sequence found. 
.................... //                    ui8IsFirstCharSequenceFound = 1; 
.................... //                    // Copy the index of the first character of the sequence. 
.................... //                    ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //                } 
.................... //            } 
.................... //            // Check for second character sequence. 
.................... //            else if(ui8IsFirstCharSequenceFound == 1) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS not connected. 
.................... //                    ui8IsResponseFound = 0; 
.................... //                    break; 
.................... //                } 
.................... //                else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                        g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //                { 
.................... //                    // Set flag denoting particular response found. 
.................... //                    // and the response says GPRS connected. 
.................... //                    ui8IsResponseFound = 1; 
.................... //                    break; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... //unsigned int8 CheckGPRSConnectionQueryResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsResponseFound = 5; 
.................... //    unsigned int8 ui8IsFirstCharSequenceFound = 0; 
.................... //    unsigned int8 ui8FirstCharSequenceIndex = 0; 
.................... //     
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSequenceFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount-  2)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'A'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'G'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'C'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == '+') 
.................... //            { 
.................... //                // Set flag denoting first character sequence found. 
.................... //                ui8IsFirstCharSequenceFound = 1; 
.................... //                // Copy the index of the first character of the sequence. 
.................... //                ui8FirstCharSequenceIndex = (ui16ByteCount - 0); 
.................... //            } 
.................... //        } 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSequenceFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '0'&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS not connected. 
.................... //                ui8IsResponseFound = 0; 
.................... //                break; 
.................... //            } 
.................... //            else if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == '1'&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 1)] == ','&& 
.................... //                    g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '1') 
.................... //            { 
.................... //                // Set flag denoting particular response found. 
.................... //                // and the response says GPRS connected. 
.................... //                ui8IsResponseFound = 1; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsResponseFound; 
.................... //} 
....................  
.................... // ########################################################## Above GPRS Connection Driver ############################################################### 
....................  
.................... // ########################################################## Below HTTP Application Driver ############################################################## 
....................  
.................... //unsigned int8 SetHTTPURL(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsSetURLOk = 1; 
.................... //    unsigned int8 ui8IsConnectionDone = 0; 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 93; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Increment variables. 
.................... //    g_ui16Itm1SequenceNumber += 2; 
.................... //    g_ui16Itm2SequenceNumber += 2; 
.................... //    g_ui16ItemWeight++; 
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    SetTimeout(2); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsSetURLOk == 1) 
.................... //    { 
.................... //        // Loop through entire receive buffer. 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //            { 
.................... //                // Set flag denote connection is established. 
.................... //                ui8IsConnectionDone = 1; 
.................... //                break; 
.................... //            }        
.................... //        } 
.................... //         
.................... //        // set URL in buffer. 
.................... //        if(ui8IsConnectionDone) 
.................... //        { 
.................... //            // Set web service URL. 
.................... //            fprintf(GSM_M66, "http://mwm.itsinindia.com/api/Test/GetStringGetMethod?a=2&b=1&c=5&m=1000$%Lu$%Lu$1|1500$%Lu$%Lu$1", g_ui16Itm1SequenceNumber, g_ui16ItemWeight, g_ui16Itm2SequenceNumber, ++g_ui16ItemWeight); 
.................... //            delay_ms(300); 
.................... //            // Check for "OK". 
.................... //            for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //            { 
.................... //                if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //                   g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //                { 
.................... //                    // Set flag denoting Set URL successfully. 
.................... //                    ui8IsSetURLOk = 0; 
.................... //                    break; 
.................... //                } 
.................... //            }     
.................... //        } 
.................... //         
.................... //        
.................... //    } 
.................... //     
.................... //    return ui8IsSetURLOk; 
.................... //     
.................... //} 
....................  
.................... //void SetHTTPURLParameter(void) 
.................... //{ 
.................... //    g_ui8URLInputTime           = 60; 
.................... //    g_ui8URLInputByteLength     = 75; 
.................... //    g_fIsTimedOut               = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //     
.................... //    // Check URL input byte length. 
.................... //    CheckURLInputByteLength(); 
.................... //     
.................... //    // Set AT Commands to define web service URL. 
.................... //    fprintf(GSM_M66, "AT+QHTTPURL=%u,%u\r", g_ui8URLInputByteLength, g_ui8URLInputTime); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(2); 
.................... //} 
....................  
.................... //unsigned int8 SetHTTPURLL(void) 
.................... //{ 
.................... //    unsigned int8  ui8IsSetURLOk       = 1; 
.................... //    unsigned int8  ui8IsConnectionDone = 0; 
.................... //    unsigned int16 ui16ByteCount       = 0; 
.................... //     
.................... //    // Loop through entire receive buffer. 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 'T' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'C' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'N' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'O' && 
.................... //           g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'C') 
.................... //        { 
.................... //            // Set flag denote connection is established. 
.................... //            ui8IsConnectionDone = 1; 
.................... //            break; 
.................... //        }        
.................... //    } 
.................... //     
.................... //    // set URL in buffer. 
.................... //    if(ui8IsConnectionDone) 
.................... //    { 
.................... // 
.................... //        // Set web service URL. 
.................... //        fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stGPRSMsgHeader.m_ui8MachineID, g_stGPRSMsgHeader.m_ui16BasicMaterialStandard, g_stGPRSMsgHeader.m_ui16PipeSpecification,g_stGPRSMsgHeader.m_ui16MaxWeight,g_stGPRSMsgHeader.m_ui16MinWeight, 
.................... //                                                                                                                                 g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32TimeStamp, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui16SequenceNo, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui32ItemWeight, g_stGPRSMsgSendQueue.m_stArrGPRSDataNode[g_stGPRSMsgSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... // 
.................... //         
.................... //        //delay_ms(300); 
.................... //        mz_delay_ms(300); 
.................... //        // Check for "OK". 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsSetURLOk = 0; 
.................... //                break; 
.................... //            } 
.................... //        }     
.................... //    } 
.................... // 
.................... //    return ui8IsSetURLOk; 
.................... //} 
....................  
.................... //void SendHTTPGetSessionRequest(void) 
.................... //{ 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    //SetTimeout(10); 
.................... //} 
....................  
.................... //unsigned int8 CheckHTTPGETRequestResponse(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    unsigned int8 ui8IsFirstCharSeqFound  = 0; 
.................... //    unsigned int8 ui8IsSecondCharSeqFound = 0; 
.................... //    unsigned int8 ui8CharSeqIndex         = 0; 
.................... //    unsigned int8 ui8CommaCount           = 0; 
.................... //     
.................... //    // Loop through entire receive buffer 
.................... //    for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //    { 
.................... //        // Check for first character sequence. 
.................... //        if(ui8IsFirstCharSeqFound == 0 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting that first character sequence is found. 
.................... //                ui8IsFirstCharSeqFound = 1; 
.................... //            } 
.................... //        } 
.................... // 
.................... //        // Check for second character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 0) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ':' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'E' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'G' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 4)] == 'P' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 5)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 6)] == 'T' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 7)] == 'H' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 8)] == 'Q' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 9)] == '+' ) 
.................... //            { 
.................... //                // Set flag denoting that second character sequence has found. 
.................... //                ui8IsSecondCharSeqFound = 1; 
.................... //            }  
.................... // 
.................... //        } 
.................... // 
.................... //        // Check for third character sequence. 
.................... //        else if(ui8IsFirstCharSeqFound == 1 && ui8IsSecondCharSeqFound == 1) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == ',') 
.................... //            { 
.................... //                // Increase comma count 
.................... //                ui8CommaCount++; 
.................... //                // Check for comma count level 
.................... //                if(ui8CommaCount == 2) 
.................... //                { 
.................... //                    // Check for success message code. 
.................... //                    if(g_ui8M66RxBuffer[(ui16ByteCount - 1)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 2)] == '0' && 
.................... //                       g_ui8M66RxBuffer[(ui16ByteCount - 3)] == '2') 
.................... //                    { 
.................... //                        // Set flag denoting that success message code found. 
.................... //                        ui8IsOKFound = 0; 
.................... //                        break; 
.................... //                    } 
.................... //                } 
.................... //            }     
.................... //        } 
.................... // 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
.................... //unsigned int8 StartHTTPGETSession(void) 
.................... //{ 
.................... //    unsigned int8 ui8IsOKFound = 1; 
.................... //    g_fIsTimedOut = 0; 
.................... //     
.................... //    // Reset Rx buffer. 
.................... //    ResetGSMM66RxBuffer(); 
.................... //    // Set AT Command to start web service action. 
.................... //    fputs("AT+QHTTPGET=120\r", GSM_M66); 
.................... //    // Set timeout. 
.................... //    SetTimeout(20); 
.................... //    // Wait for response. 
.................... //    while(g_fIsTimedOut == 0 && ui8IsOKFound == 1) 
.................... //    { 
.................... //        // Reset WDT 
.................... //        restart_wdt(); 
.................... //        // Loop through entire receive buffer 
.................... //        for(unsigned int16 ui16ByteCount = 0; ui16ByteCount < g_ui16M66RxByteCount; ui16ByteCount++) 
.................... //        { 
.................... //            if(g_ui8M66RxBuffer[(ui16ByteCount - 0)] == 0x0A && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 1)] == 0x0D && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 2)] == 'K' && 
.................... //               g_ui8M66RxBuffer[(ui16ByteCount - 3)] == 'O') 
.................... //            { 
.................... //                // Set flag denoting Set URL successfully. 
.................... //                ui8IsOKFound = 0; 
.................... //                break; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //     
.................... //    return ui8IsOKFound; 
.................... //} 
....................  
....................  
.................... // ############################################################# Above HTTP Application driver ########################################################## 
.................... #endif	/* VM_GSMM66_GPRS_CONFIG_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
*
005EA:  MOVLB  E
005EC:  MOVF   xDC,W
....................     enable_interrupts(INT_RDA5); 
005EE:  BSF    x2D.5
005F0:  MOVLB  0
005F2:  GOTO   4638 (RETURN)
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
*
042DA:  MOVLW  07
042DC:  MOVWF  FEA
042DE:  MOVLW  15
042E0:  MOVWF  FE9
042E2:  CLRF   00
042E4:  CLRF   02
042E6:  MOVLW  14
042E8:  MOVWF  01
042EA:  CALL   09BE
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
042EE:  MOVLB  7
042F0:  CLRF   x29
042F2:  MOVLB  0
042F4:  GOTO   4364 (RETURN)
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
*
00752:  MOVLB  B
00754:  CLRF   xED
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
00756:  MOVLB  0
00758:  BRA    0734
0075A:  MOVFF  01,BED
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
0075E:  MOVFF  BED,99
00762:  GOTO   0948 (RETURN)
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
*
0037E:  MOVLB  0
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
00380:  CLRF   03
00382:  MOVLB  7
00384:  MOVF   x29,W
00386:  ADDLW  15
00388:  MOVWF  FE9
0038A:  MOVLW  07
0038C:  ADDWFC 03,W
0038E:  MOVWF  FEA
00390:  MOVFF  FEA,C2E
00394:  MOVFF  FE9,C2D
00398:  MOVLB  0
0039A:  BRA    0362
0039C:  MOVFF  C2E,FEA
003A0:  MOVFF  C2D,FE9
003A4:  MOVFF  01,FEF
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
003A8:  MOVLB  7
003AA:  INCF   x29,F
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
003AC:  MOVF   x29,W
003AE:  SUBLW  13
003B0:  BC    03B4
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
003B2:  CLRF   x29
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
003B4:  MOVLB  E
003B6:  MOVF   xDC,W
003B8:  BCF    x37.5
003BA:  MOVLB  0
003BC:  GOTO   008A
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
*
005F6:  MOVLB  B
005F8:  SETF   x76
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
005FA:  SETF   x77
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
005FC:  CLRF   xED
005FE:  MOVF   xED,W
00600:  SUBLW  63
00602:  BTFSS  FD8.0
00604:  BRA    0702
00606:  CLRF   19
00608:  BTFSC  FF2.7
0060A:  BSF    19.7
0060C:  BCF    FF2.7
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
0060E:  MOVLB  C
00610:  CLRF   x2D
00612:  MOVFF  BED,C2C
00616:  CLRF   x2F
00618:  MOVLW  0B
0061A:  MOVWF  x2E
0061C:  MOVLB  0
0061E:  RCALL  0426
00620:  BTFSC  19.7
00622:  BSF    FF2.7
00624:  MOVFF  01,BEE
00628:  MOVLW  06
0062A:  MOVLB  B
0062C:  ADDWF  01,W
0062E:  MOVWF  01
00630:  MOVLW  00
00632:  ADDWFC 02,W
00634:  MOVWF  03
00636:  MOVF   01,W
00638:  ADDLW  2A
0063A:  MOVWF  FE9
0063C:  MOVLW  07
0063E:  ADDWFC 03,W
00640:  MOVWF  FEA
00642:  CLRF   FEF
00644:  CLRF   FEC
00646:  CLRF   FEC
00648:  CLRF   FEC
0064A:  CLRF   19
0064C:  BTFSC  FF2.7
0064E:  BSF    19.7
00650:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
00652:  MOVLB  C
00654:  CLRF   x2D
00656:  MOVFF  BED,C2C
0065A:  CLRF   x2F
0065C:  MOVLW  0B
0065E:  MOVWF  x2E
00660:  MOVLB  0
00662:  RCALL  0426
00664:  BTFSC  19.7
00666:  BSF    FF2.7
00668:  MOVFF  01,BEE
0066C:  MOVLW  04
0066E:  MOVLB  B
00670:  ADDWF  01,W
00672:  MOVWF  01
00674:  MOVLW  00
00676:  ADDWFC 02,W
00678:  MOVWF  03
0067A:  MOVF   01,W
0067C:  ADDLW  2A
0067E:  MOVWF  FE9
00680:  MOVLW  07
00682:  ADDWFC 03,W
00684:  MOVWF  FEA
00686:  CLRF   FEC
00688:  MOVF   FED,F
0068A:  CLRF   FEF
0068C:  CLRF   19
0068E:  BTFSC  FF2.7
00690:  BSF    19.7
00692:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
00694:  MOVLB  C
00696:  CLRF   x2D
00698:  MOVFF  BED,C2C
0069C:  CLRF   x2F
0069E:  MOVLW  0B
006A0:  MOVWF  x2E
006A2:  MOVLB  0
006A4:  RCALL  0426
006A6:  BTFSC  19.7
006A8:  BSF    FF2.7
006AA:  MOVLW  2A
006AC:  MOVLB  B
006AE:  ADDWF  01,W
006B0:  MOVWF  FE9
006B2:  MOVLW  07
006B4:  ADDWFC 02,W
006B6:  MOVWF  FEA
006B8:  CLRF   FEF
006BA:  CLRF   FEC
006BC:  CLRF   FEC
006BE:  CLRF   FEC
006C0:  CLRF   19
006C2:  BTFSC  FF2.7
006C4:  BSF    19.7
006C6:  BCF    FF2.7
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
006C8:  MOVLB  C
006CA:  CLRF   x2D
006CC:  MOVFF  BED,C2C
006D0:  CLRF   x2F
006D2:  MOVLW  0B
006D4:  MOVWF  x2E
006D6:  MOVLB  0
006D8:  RCALL  0426
006DA:  BTFSC  19.7
006DC:  BSF    FF2.7
006DE:  MOVFF  01,BEE
006E2:  MOVLW  0A
006E4:  MOVLB  B
006E6:  ADDWF  01,W
006E8:  MOVWF  01
006EA:  MOVLW  00
006EC:  ADDWFC 02,W
006EE:  MOVWF  03
006F0:  MOVF   01,W
006F2:  ADDLW  2A
006F4:  MOVWF  FE9
006F6:  MOVLW  07
006F8:  ADDWFC 03,W
006FA:  MOVWF  FEA
006FC:  CLRF   FEF
006FE:  INCF   xED,F
00700:  BRA    05FE
....................     } 
00702:  MOVLB  0
00704:  GOTO   0946 (RETURN)
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
*
03D5A:  MOVLB  B
03D5C:  CLRF   xED
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
03D5E:  MOVF   x76,W
03D60:  SUBLW  FF
03D62:  BNZ   3D6A
....................     { 
....................         ui8QueueStatus = 1;  
03D64:  MOVLW  01
03D66:  MOVWF  xED
....................     } 
03D68:  BRA    3D6C
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
03D6A:  CLRF   xED
....................     } 
....................     return ui8QueueStatus; 
03D6C:  MOVFF  BED,01
03D70:  MOVLB  0
03D72:  GOTO   46EE (RETURN)
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
*
011F4:  MOVLB  B
011F6:  MOVF   x76,W
011F8:  SUBLW  FF
011FA:  BNZ   11FE
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
011FC:  CLRF   x76
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
011FE:  MOVLW  01
01200:  ADDWF  x77,W
01202:  MOVWF  xFC
01204:  CLRF   19
01206:  BTFSC  FF2.7
01208:  BSF    19.7
0120A:  BCF    FF2.7
0120C:  MOVFF  FE8,C33
01210:  MOVLW  64
01212:  MOVLB  C
01214:  MOVWF  x34
01216:  MOVLB  0
01218:  CALL   0182
0121C:  BTFSC  19.7
0121E:  BSF    FF2.7
01220:  MOVFF  00,B77
01224:  CLRF   19
01226:  BTFSC  FF2.7
01228:  BSF    19.7
0122A:  BCF    FF2.7
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
0122C:  MOVLB  C
0122E:  CLRF   x2D
01230:  MOVFF  B77,C2C
01234:  CLRF   x2F
01236:  MOVLW  0B
01238:  MOVWF  x2E
0123A:  MOVLB  0
0123C:  CALL   0426
01240:  BTFSC  19.7
01242:  BSF    FF2.7
01244:  MOVFF  01,BFB
01248:  MOVLW  04
0124A:  MOVLB  B
0124C:  ADDWF  01,W
0124E:  MOVWF  01
01250:  MOVLW  00
01252:  ADDWFC 02,W
01254:  MOVWF  03
01256:  MOVF   01,W
01258:  ADDLW  2A
0125A:  MOVWF  FE9
0125C:  MOVLW  07
0125E:  ADDWFC 03,W
01260:  MOVWF  FEA
01262:  MOVFF  70D,FEC
01266:  MOVF   FED,F
01268:  MOVFF  70C,FEF
0126C:  CLRF   19
0126E:  BTFSC  FF2.7
01270:  BSF    19.7
01272:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
01274:  MOVLB  C
01276:  CLRF   x2D
01278:  MOVFF  B77,C2C
0127C:  CLRF   x2F
0127E:  MOVLW  0B
01280:  MOVWF  x2E
01282:  MOVLB  0
01284:  CALL   0426
01288:  BTFSC  19.7
0128A:  BSF    FF2.7
0128C:  MOVFF  01,BFB
01290:  MOVLW  06
01292:  MOVLB  B
01294:  ADDWF  01,W
01296:  MOVWF  01
01298:  MOVLW  00
0129A:  ADDWFC 02,W
0129C:  MOVWF  03
0129E:  MOVF   01,W
012A0:  ADDLW  2A
012A2:  MOVWF  FE9
012A4:  MOVLW  07
012A6:  ADDWFC 03,W
012A8:  MOVWF  FEA
012AA:  MOVFF  708,FEF
012AE:  MOVFF  709,FEC
012B2:  MOVFF  70A,FEC
012B6:  MOVFF  70B,FEC
012BA:  CLRF   19
012BC:  BTFSC  FF2.7
012BE:  BSF    19.7
012C0:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
012C2:  MOVLB  C
012C4:  CLRF   x2D
012C6:  MOVFF  B77,C2C
012CA:  CLRF   x2F
012CC:  MOVLW  0B
012CE:  MOVWF  x2E
012D0:  MOVLB  0
012D2:  CALL   0426
012D6:  BTFSC  19.7
012D8:  BSF    FF2.7
012DA:  MOVFF  01,BFB
012DE:  MOVLW  0A
012E0:  MOVLB  B
012E2:  ADDWF  01,W
012E4:  MOVWF  01
012E6:  MOVLW  00
012E8:  ADDWFC 02,W
012EA:  MOVWF  03
012EC:  MOVF   01,W
012EE:  ADDLW  2A
012F0:  MOVWF  FE9
012F2:  MOVLW  07
012F4:  ADDWFC 03,W
012F6:  MOVWF  FEA
012F8:  MOVFF  70E,FEF
012FC:  CLRF   19
012FE:  BTFSC  FF2.7
01300:  BSF    19.7
01302:  BCF    FF2.7
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
01304:  MOVLB  C
01306:  CLRF   x2D
01308:  MOVFF  B77,C2C
0130C:  CLRF   x2F
0130E:  MOVLW  0B
01310:  MOVWF  x2E
01312:  MOVLB  0
01314:  CALL   0426
01318:  BTFSC  19.7
0131A:  BSF    FF2.7
0131C:  MOVLW  2A
0131E:  MOVLB  B
01320:  ADDWF  01,W
01322:  MOVWF  FE9
01324:  MOVLW  07
01326:  ADDWFC 02,W
01328:  MOVWF  FEA
0132A:  MOVFF  710,FEF
0132E:  MOVFF  711,FEC
01332:  MOVFF  712,FEC
01336:  MOVFF  713,FEC
0133A:  MOVLB  0
0133C:  GOTO   157A (RETURN)
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
*
0405E:  CLRF   19
04060:  BTFSC  FF2.7
04062:  BSF    19.7
04064:  BCF    FF2.7
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight, 
....................                                                                                                    g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
04066:  MOVLB  C
04068:  CLRF   x2D
0406A:  MOVFF  B76,C2C
0406E:  CLRF   x2F
04070:  MOVLW  0B
04072:  MOVWF  x2E
04074:  MOVLB  0
04076:  CALL   0426
0407A:  BTFSC  19.7
0407C:  BSF    FF2.7
0407E:  MOVFF  02,BEE
04082:  MOVFF  01,BED
04086:  MOVLW  2A
04088:  MOVLB  B
0408A:  ADDWF  01,W
0408C:  MOVWF  FE9
0408E:  MOVLW  07
04090:  ADDWFC 02,W
04092:  MOVWF  FEA
04094:  MOVFF  FEF,BEF
04098:  MOVFF  FEC,BF0
0409C:  MOVFF  FEC,BF1
040A0:  MOVFF  FEC,BF2
040A4:  CLRF   19
040A6:  BTFSC  FF2.7
040A8:  BSF    19.7
040AA:  BCF    FF2.7
040AC:  MOVLB  C
040AE:  CLRF   x2D
040B0:  MOVFF  B76,C2C
040B4:  CLRF   x2F
040B6:  MOVLW  0B
040B8:  MOVWF  x2E
040BA:  MOVLB  0
040BC:  CALL   0426
040C0:  BTFSC  19.7
040C2:  BSF    FF2.7
040C4:  MOVFF  01,BF3
040C8:  MOVLW  04
040CA:  MOVLB  B
040CC:  ADDWF  01,W
040CE:  MOVWF  01
040D0:  MOVLW  00
040D2:  ADDWFC 02,W
040D4:  MOVWF  03
040D6:  MOVF   01,W
040D8:  ADDLW  2A
040DA:  MOVWF  FE9
040DC:  MOVLW  07
040DE:  ADDWFC 03,W
040E0:  MOVWF  FEA
040E2:  MOVFF  FEC,BF4
040E6:  MOVF   FED,F
040E8:  MOVFF  FEF,BF3
040EC:  CLRF   19
040EE:  BTFSC  FF2.7
040F0:  BSF    19.7
040F2:  BCF    FF2.7
040F4:  MOVLB  C
040F6:  CLRF   x2D
040F8:  MOVFF  B76,C2C
040FC:  CLRF   x2F
040FE:  MOVLW  0B
04100:  MOVWF  x2E
04102:  MOVLB  0
04104:  CALL   0426
04108:  BTFSC  19.7
0410A:  BSF    FF2.7
0410C:  MOVFF  01,BF5
04110:  MOVLW  06
04112:  MOVLB  B
04114:  ADDWF  01,W
04116:  MOVWF  01
04118:  MOVLW  00
0411A:  ADDWFC 02,W
0411C:  MOVWF  03
0411E:  MOVF   01,W
04120:  ADDLW  2A
04122:  MOVWF  FE9
04124:  MOVLW  07
04126:  ADDWFC 03,W
04128:  MOVWF  FEA
0412A:  MOVFF  FEF,BF5
0412E:  MOVFF  FEC,BF6
04132:  MOVFF  FEC,BF7
04136:  MOVFF  FEC,BF8
0413A:  CLRF   19
0413C:  BTFSC  FF2.7
0413E:  BSF    19.7
04140:  BCF    FF2.7
04142:  MOVLB  C
04144:  CLRF   x2D
04146:  MOVFF  B76,C2C
0414A:  CLRF   x2F
0414C:  MOVLW  0B
0414E:  MOVWF  x2E
04150:  MOVLB  0
04152:  CALL   0426
04156:  BTFSC  19.7
04158:  BSF    FF2.7
0415A:  MOVFF  01,BF9
0415E:  MOVLW  0A
04160:  MOVLB  B
04162:  ADDWF  01,W
04164:  MOVWF  01
04166:  MOVLW  00
04168:  ADDWFC 02,W
0416A:  MOVWF  03
0416C:  MOVF   01,W
0416E:  ADDLW  2A
04170:  MOVWF  FE9
04172:  MOVLW  07
04174:  ADDWFC 03,W
04176:  MOVWF  FEA
04178:  MOVFF  FEF,BF9
0417C:  MOVLW  C0
0417E:  MOVWF  FF6
04180:  MOVLW  03
04182:  MOVWF  FF7
04184:  MOVLW  1F
04186:  MOVWF  xFA
04188:  MOVLB  0
0418A:  RCALL  3D76
0418C:  MOVFF  99,BFA
04190:  MOVLW  1B
04192:  MOVLB  B
04194:  MOVWF  xFB
04196:  MOVLB  0
04198:  RCALL  3DA2
0419A:  MOVLW  E1
0419C:  MOVWF  FF6
0419E:  MOVLW  03
041A0:  MOVWF  FF7
041A2:  MOVLW  03
041A4:  MOVLB  B
041A6:  MOVWF  xFA
041A8:  MOVLB  0
041AA:  RCALL  3D76
041AC:  MOVLW  10
041AE:  MOVWF  FE9
041B0:  MOVFF  9B,BFB
041B4:  MOVFF  9A,BFA
041B8:  RCALL  3E46
041BA:  MOVLW  E7
041BC:  MOVWF  FF6
041BE:  MOVLW  03
041C0:  MOVWF  FF7
041C2:  MOVLW  03
041C4:  MOVLB  B
041C6:  MOVWF  xFA
041C8:  MOVLB  0
041CA:  RCALL  3D76
041CC:  MOVLW  10
041CE:  MOVWF  FE9
041D0:  MOVFF  9D,BFB
041D4:  MOVFF  9C,BFA
041D8:  RCALL  3E46
041DA:  MOVLW  ED
041DC:  MOVWF  FF6
041DE:  MOVLW  03
041E0:  MOVWF  FF7
041E2:  MOVLW  03
041E4:  MOVLB  B
041E6:  MOVWF  xFA
041E8:  MOVLB  0
041EA:  RCALL  3D76
041EC:  MOVLW  41
041EE:  MOVWF  FE9
041F0:  MOVFF  A1,BFD
041F4:  MOVFF  A0,BFC
041F8:  MOVFF  9F,BFB
041FC:  MOVFF  9E,BFA
04200:  RCALL  3F9E
04202:  MOVLW  F3
04204:  MOVWF  FF6
04206:  MOVLW  03
04208:  MOVWF  FF7
0420A:  MOVLW  03
0420C:  MOVLB  B
0420E:  MOVWF  xFA
04210:  MOVLB  0
04212:  RCALL  3D76
04214:  MOVLW  41
04216:  MOVWF  FE9
04218:  MOVFF  A5,BFD
0421C:  MOVFF  A4,BFC
04220:  MOVFF  A3,BFB
04224:  MOVFF  A2,BFA
04228:  RCALL  3F9E
0422A:  MOVLW  F9
0422C:  MOVWF  FF6
0422E:  MOVLW  03
04230:  MOVWF  FF7
04232:  MOVLW  03
04234:  MOVLB  B
04236:  MOVWF  xFA
04238:  MOVLB  0
0423A:  RCALL  3D76
0423C:  MOVLW  41
0423E:  MOVWF  FE9
04240:  MOVFF  BF2,BFD
04244:  MOVFF  BF1,BFC
04248:  MOVFF  BF0,BFB
0424C:  MOVFF  BEF,BFA
04250:  RCALL  3F9E
04252:  MOVLW  24
04254:  MOVLB  E
04256:  BTFSS  x37.4
04258:  BRA    4256
0425A:  MOVWF  xDD
0425C:  MOVLW  10
0425E:  MOVWF  FE9
04260:  MOVFF  BF4,BFB
04264:  MOVFF  BF3,BFA
04268:  MOVLB  0
0426A:  RCALL  3E46
0426C:  MOVLW  24
0426E:  MOVLB  E
04270:  BTFSS  x37.4
04272:  BRA    4270
04274:  MOVWF  xDD
04276:  MOVLW  41
04278:  MOVWF  FE9
0427A:  MOVFF  BF8,BFD
0427E:  MOVFF  BF7,BFC
04282:  MOVFF  BF6,BFB
04286:  MOVFF  BF5,BFA
0428A:  MOVLB  0
0428C:  RCALL  3F9E
0428E:  MOVLW  24
04290:  MOVLB  E
04292:  BTFSS  x37.4
04294:  BRA    4292
04296:  MOVWF  xDD
04298:  MOVFF  BF9,BFA
0429C:  MOVLW  1B
0429E:  MOVLB  B
042A0:  MOVWF  xFB
042A2:  MOVLB  0
042A4:  RCALL  3DA2
042A6:  GOTO   470E (RETURN)
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
*
042F8:  MOVLW  01
042FA:  MOVLB  B
042FC:  MOVWF  xED
042FE:  CLRF   xEE
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
04300:  CLRF   xEE
04302:  MOVF   xEE,W
04304:  SUBLW  13
04306:  BNC   436C
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
04308:  MOVLW  03
0430A:  SUBWF  xEE,W
0430C:  CLRF   03
0430E:  ADDLW  15
04310:  MOVWF  FE9
04312:  MOVLW  07
04314:  ADDWFC 03,W
04316:  MOVWF  FEA
04318:  MOVF   FEF,W
0431A:  SUBLW  4F
0431C:  BNZ   4368
0431E:  MOVLW  02
04320:  SUBWF  xEE,W
04322:  CLRF   03
04324:  ADDLW  15
04326:  MOVWF  FE9
04328:  MOVLW  07
0432A:  ADDWFC 03,W
0432C:  MOVWF  FEA
0432E:  MOVF   FEF,W
04330:  SUBLW  6B
04332:  BNZ   4368
04334:  MOVLW  01
04336:  SUBWF  xEE,W
04338:  CLRF   03
0433A:  ADDLW  15
0433C:  MOVWF  FE9
0433E:  MOVLW  07
04340:  ADDWFC 03,W
04342:  MOVWF  FEA
04344:  MOVF   FEF,W
04346:  SUBLW  61
04348:  BNZ   4368
0434A:  CLRF   03
0434C:  MOVF   xEE,W
0434E:  ADDLW  15
04350:  MOVWF  FE9
04352:  MOVLW  07
04354:  ADDWFC 03,W
04356:  MOVWF  FEA
04358:  MOVF   FEF,W
0435A:  SUBLW  79
0435C:  BNZ   4368
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
0435E:  CLRF   xED
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
04360:  MOVLB  0
04362:  BRA    42DA
....................             break; 
04364:  MOVLB  B
04366:  BRA    436C
....................         } 
04368:  INCF   xEE,F
0436A:  BRA    4302
....................     } 
....................          
....................     return ui8RetVal; 
0436C:  MOVFF  BED,01
04370:  MOVLB  0
04372:  GOTO   4736 (RETURN)
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
....................  
.................... unsigned int16 g_ui16PrevItemCount = 0; 
.................... unsigned int16 g_ui16ItemCount     = 0; 
....................  
....................  // TESTING  
....................     unsigned int8 ui8Counter = 0; 
....................  
.................... // IBU Received message process proc 
.................... void ProcessIBUMsg() 
*
01340:  MOVLB  B
01342:  CLRF   xFA
.................... {    
....................     ST_IBU_DATA_NODE stIBURcvNode; 
....................     unsigned int8  ui8LoopCount = 0; 
....................  
....................     // Get Node from IBU Receive Message Queue 
....................     DeleteIBUMsgQueue(&g_stIBURcvQueue, &stIBURcvNode); 
01344:  MOVLW  03
01346:  MOVWF  xFC
01348:  MOVLW  55
0134A:  MOVWF  xFB
0134C:  MOVLW  0B
0134E:  MOVWF  xFE
01350:  MOVLW  ED
01352:  MOVWF  xFD
01354:  MOVLB  0
01356:  BRA    110E
....................      
....................     // Valid message present in IBU receive buffer 
....................     // So go for process the data 
....................     switch(stIBURcvNode.g_ui8ArrIBUData[0]) 
01358:  MOVLB  B
0135A:  MOVF   xEF,W
0135C:  XORLW  68
0135E:  MOVLB  0
01360:  BZ    13A0
01362:  XORLW  0E
01364:  BZ    1402
01366:  XORLW  0F
01368:  BZ    1406
0136A:  XORLW  EF
0136C:  BZ    140A
0136E:  XORLW  F6
01370:  BTFSC  FD8.2
01372:  BRA    145C
01374:  XORLW  01
01376:  BTFSC  FD8.2
01378:  BRA    1460
0137A:  XORLW  F2
0137C:  BTFSC  FD8.2
0137E:  BRA    1464
01380:  XORLW  04
01382:  BTFSC  FD8.2
01384:  BRA    1468
01386:  XORLW  03
01388:  BTFSC  FD8.2
0138A:  BRA    14BA
0138C:  XORLW  13
0138E:  BTFSC  FD8.2
01390:  BRA    1586
01392:  XORLW  0E
01394:  BTFSC  FD8.2
01396:  BRA    1590
01398:  XORLW  03
0139A:  BTFSC  FD8.2
0139C:  BRA    159A
0139E:  BRA    15A4
....................     { 
....................         case IBU_CMD_RESET_CALIB_DATA: 
....................             // Store receive data. 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
013A0:  MOVLW  01
013A2:  MOVLB  B
013A4:  MOVWF  xFA
013A6:  MOVF   xFA,W
013A8:  SUBLW  08
013AA:  BNC   13E0
....................             { 
....................                 g_unIBUResetCalibData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
013AC:  MOVLW  01
013AE:  SUBWF  xFA,W
013B0:  CLRF   03
013B2:  ADDLW  E9
013B4:  MOVWF  01
013B6:  MOVLW  00
013B8:  ADDWFC 03,F
013BA:  MOVFF  03,BFC
013BE:  CLRF   03
013C0:  MOVF   xFA,W
013C2:  ADDLW  EF
013C4:  MOVWF  FE9
013C6:  MOVLW  0B
013C8:  ADDWFC 03,W
013CA:  MOVWF  FEA
013CC:  MOVFF  FEF,BFD
013D0:  MOVFF  BFC,FEA
013D4:  MOVFF  01,FE9
013D8:  MOVFF  BFD,FEF
013DC:  INCF   xFA,F
013DE:  BRA    13A6
....................             } 
....................              
....................             // Retrieve and store the dynamic ADC tare value. 
....................             g_ui32TareADCValueForCalibration    = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForTare; 
013E0:  MOVFF  EC,4B9
013E4:  MOVFF  EB,4B8
013E8:  MOVFF  EA,4B7
013EC:  MOVFF  E9,4B6
....................             g_ui32gWeightADCValueForCalibration = g_unIBUResetCalibData.m_stIBUResetCalibData.m_ui32CalibADCForWeight; 
013F0:  MOVFF  F0,4BD
013F4:  MOVFF  EF,4BC
013F8:  MOVFF  EE,4BB
013FC:  MOVFF  ED,4BA
....................             break; 
01400:  BRA    15A6
....................         case IBU_CMD_START_CALIBRATION: 
....................             break; 
01402:  MOVLB  B
01404:  BRA    15A6
....................         case IBU_CMD_RESET_CALIB_POINT:             
....................             break; 
01406:  MOVLB  B
01408:  BRA    15A6
....................         case IBU_CMD_PROD_TARE_DATA: 
....................         { 
....................             for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0140A:  MOVLW  01
0140C:  MOVLB  B
0140E:  MOVWF  xFA
01410:  MOVF   xFA,W
01412:  SUBLW  08
01414:  BNC   144A
....................             { 
....................                 g_unIBUProdModeTrData.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
01416:  MOVLW  01
01418:  SUBWF  xFA,W
0141A:  CLRF   03
0141C:  ADDLW  D5
0141E:  MOVWF  01
01420:  MOVLW  00
01422:  ADDWFC 03,F
01424:  MOVFF  03,BFC
01428:  CLRF   03
0142A:  MOVF   xFA,W
0142C:  ADDLW  EF
0142E:  MOVWF  FE9
01430:  MOVLW  0B
01432:  ADDWFC 03,W
01434:  MOVWF  FEA
01436:  MOVFF  FEF,BFD
0143A:  MOVFF  BFC,FEA
0143E:  MOVFF  01,FE9
01442:  MOVFF  BFD,FEF
01446:  INCF   xFA,F
01448:  BRA    1410
....................             } 
....................             g_ui32RunningTareValue = (unsigned int16)(g_unIBUProdModeTrData.m_stTareData.m_i32TareData); 
0144A:  MOVLB  4
0144C:  CLRF   xCF
0144E:  CLRF   xCE
01450:  MOVFF  DA,4CD
01454:  MOVFF  D9,4CC
....................         } 
....................              
....................             break; 
01458:  MOVLB  B
0145A:  BRA    15A6
....................         case IBU_CMD_PRE_PROD_AVG_WEIGHT: 
....................             break; 
0145C:  MOVLB  B
0145E:  BRA    15A6
....................         case IBU_CMD_PRE_PROD_TOLERANCE: 
....................             break; 
01460:  MOVLB  B
01462:  BRA    15A6
....................         case IBU_CMD_START_PROD: 
....................             break; 
01464:  MOVLB  B
01466:  BRA    15A6
....................         case IBU_CMD_PROD_AVG_WT_DATA: 
....................             { 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
01468:  MOVLW  01
0146A:  MOVLB  B
0146C:  MOVWF  xFA
0146E:  MOVF   xFA,W
01470:  SUBLW  08
01472:  BNC   14A8
....................                 { 
....................                     g_unIBUProdModeAvg.m_ui8Arr[ui8LoopCount-1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
01474:  MOVLW  01
01476:  SUBWF  xFA,W
01478:  CLRF   03
0147A:  ADDLW  F1
0147C:  MOVWF  01
0147E:  MOVLW  00
01480:  ADDWFC 03,F
01482:  MOVFF  03,BFC
01486:  CLRF   03
01488:  MOVF   xFA,W
0148A:  ADDLW  EF
0148C:  MOVWF  FE9
0148E:  MOVLW  0B
01490:  ADDWFC 03,W
01492:  MOVWF  FEA
01494:  MOVFF  FEF,BFD
01498:  MOVFF  BFC,FEA
0149C:  MOVFF  01,FE9
014A0:  MOVFF  BFD,FEF
014A4:  INCF   xFA,F
014A6:  BRA    146E
....................                 } 
....................                  
....................                 g_ui32RunningAvgWt = g_unIBUProdModeAvg.m_stAvgData.m_i32CurAvg; 
014A8:  MOVFF  F4,4CB
014AC:  MOVFF  F3,4CA
014B0:  MOVFF  F2,4C9
014B4:  MOVFF  F1,4C8
....................             } 
....................             break;             
014B8:  BRA    15A6
....................         case IBU_CMD_PROD_WEIGH_DATA: 
....................             { 
....................                  
....................                 // TESTING. 
....................                 //output_toggle(PIN_OUT_DO_00); 
....................  
....................                 // Copy individual Box data. 
....................                 for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
014BA:  MOVLW  01
014BC:  MOVLB  B
014BE:  MOVWF  xFA
014C0:  MOVF   xFA,W
014C2:  SUBLW  08
014C4:  BNC   14FA
....................                 { 
....................                     g_unIBUProdModeWtStsData.m_ui8Arr[ui8LoopCount - 1] = stIBURcvNode.g_ui8ArrIBUData[ui8LoopCount]; 
014C6:  MOVLW  01
014C8:  SUBWF  xFA,W
014CA:  CLRF   03
014CC:  ADDLW  CD
014CE:  MOVWF  01
014D0:  MOVLW  00
014D2:  ADDWFC 03,F
014D4:  MOVFF  03,BFC
014D8:  CLRF   03
014DA:  MOVF   xFA,W
014DC:  ADDLW  EF
014DE:  MOVWF  FE9
014E0:  MOVLW  0B
014E2:  ADDWFC 03,W
014E4:  MOVWF  FEA
014E6:  MOVFF  FEF,BFD
014EA:  MOVFF  BFC,FEA
014EE:  MOVFF  01,FE9
014F2:  MOVFF  BFD,FEF
014F6:  INCF   xFA,F
014F8:  BRA    14C0
....................                 } 
....................                  
....................                 // Update current box weight in register. 
....................                 g_stProdModeCurrBoxData.m_i32PipeWeight = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_i32PipeWeight; 
014FA:  MOVFF  D0,70B
014FE:  MOVFF  CF,70A
01502:  MOVFF  CE,709
01506:  MOVFF  CD,708
....................                 // Insert current box data to variables for Display in HMI 
....................                 g_ui32CurrentWt = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
0150A:  MOVFF  70B,4C5
0150E:  MOVFF  70A,4C4
01512:  MOVFF  709,4C3
01516:  MOVFF  708,4C2
....................                  
....................                 // Update Current box count in register. 
....................                 //g_ui16PipeCount = g_unIBUProdModeBoxCount.m_stBoxCount.m_ui16BoxCount; 
....................                 g_ui16PipeCount = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PipeCount; 
0151A:  MOVFF  D2,4BF
0151E:  MOVFF  D1,4BE
....................                 g_ui16ItemCount = g_ui16PipeCount; 
01522:  MOVFF  4BF,B7B
01526:  MOVFF  4BE,B7A
....................                  
....................                 // Update last box pass status. 
....................                 g_ui16CurrentPassStatus = g_unIBUProdModeWtStsData.m_stWeighingStatusData.m_ui16PassStatus; 
0152A:  MOVFF  D4,4C7
0152E:  MOVFF  D3,4C6
....................                  
....................                 // Update HMI Data Trigger Status. 
....................                 //g_ui8HMITriggerStatus = 1; 
....................  
....................                 if(g_ui16ItemCount > 0 && g_ui16PrevItemCount != g_ui16ItemCount) 
01532:  MOVF   x7A,F
01534:  BNZ   153A
01536:  MOVF   x7B,F
01538:  BZ    1584
0153A:  MOVF   x7A,W
0153C:  SUBWF  x78,W
0153E:  BNZ   1546
01540:  MOVF   x7B,W
01542:  SUBWF  x79,W
01544:  BZ    1584
....................                 { 
....................                     // Update production mode current box data. 
....................                     g_stProdModeCurrBoxData.m_ui16SequenceNo = g_ui16PipeCount; 
01546:  MOVFF  4BF,70D
0154A:  MOVFF  4BE,70C
....................                     g_stProdModeCurrBoxData.m_i32PipeWeight = g_ui32CurrentWt; 
0154E:  MOVFF  4C5,70B
01552:  MOVFF  4C4,70A
01556:  MOVFF  4C3,709
0155A:  MOVFF  4C2,708
....................                     g_stProdModeCurrBoxData.m_ui16RejectionStatus = g_ui16CurrentPassStatus;  // TODO 
0155E:  MOVFF  4C7,70F
01562:  MOVFF  4C6,70E
....................                     g_stProdModeCurrBoxData.m_ui32TimeStamp = g_ui32UnixTimeInSec; 
01566:  MOVFF  C0,713
0156A:  MOVFF  BF,712
0156E:  MOVFF  BE,711
01572:  MOVFF  BD,710
....................                     // Insert current box data in GPRS send Message queue. 
....................                     InsertInPipeDataQueue(); 
01576:  MOVLB  0
01578:  BRA    11F4
....................  
....................                     // update previous item count for next box reference. 
....................                     g_ui16PrevItemCount = g_ui16ItemCount; 
0157A:  MOVFF  B7B,B79
0157E:  MOVFF  B7A,B78
01582:  MOVLB  B
....................                 } 
....................             } 
....................             break;             
01584:  BRA    15A6
....................         case IBU_CMD_PRE_PROD_TOL_STORE_ACK: 
....................             // No need to parse data. 
....................             // This is acknowledgement message. Transfer to HMI. 
....................             g_ui8ToleranceStoreAck = 1; 
01586:  MOVLW  01
01588:  MOVLB  4
0158A:  MOVWF  xDD
....................             break; 
0158C:  MOVLB  B
0158E:  BRA    15A6
....................         case IBU_CMD_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure below rated alarm occurred. 
....................             // Set flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 1; 
01590:  MOVLW  01
01592:  MOVLB  4
01594:  MOVWF  xEE
....................             break; 
01596:  MOVLB  B
01598:  BRA    15A6
....................         case IBU_CMD_RESET_AIR_PRESSURE_ALARM: 
....................             // Remaining all bytes are padding. 
....................             // No need to parse that. 
....................              
....................             // This command denotes air-pressure recovers. 
....................             // Now it is above rated. 
....................             // Reset flag to transfer the message to HMI. 
....................             g_ui8AirPressureAlarm = 0; 
0159A:  MOVLB  4
0159C:  CLRF   xEE
....................             break; 
0159E:  MOVLB  B
015A0:  BRA    15A6
015A2:  MOVLB  0
....................         default : 
....................             break; 
015A4:  MOVLB  B
....................     } 
015A6:  MOVLB  0
015A8:  GOTO   4678 (RETURN)
.................... }    
....................  
....................  
....................  
.................... #endif	/* VM_IBU_PROCESS_M1_H */ 
....................  
....................  
.................... #include "mzLANCommConfig.h" 
.................... /*  
....................  * File:   mzLANCommConfig.h 
....................  * Author: Andrian 
....................  * 
....................  * Created on 26 March 2020, 9:56 PM 
....................  */ 
....................  
.................... #ifndef MZ_LAN_COMM_CONFIG_H 
.................... #define	MZ_LAN_COMM_CONFIG_H 
....................  
.................... #include "vmM1Common.h" 
....................  
....................  
.................... #define LAN_DATA_SENDING_SEQUENCE_1         1 
.................... #define LAN_DATA_SENDING_SEQUENCE_2         2 
.................... #define LAN_DATA_SENDING_SEQUENCE_3         3 
.................... #define LAN_DATA_SENDING_SEQUENCE_4         4 
.................... #define LAN_DATA_SENDING_SEQUENCE_5         5 
....................  
.................... #define SERVER_RESPONSE_RECEIVE_TIMEOUT     3 
.................... #define DATA_RESEND_INTERVAL_TIMEOUT        10 
....................  
.................... #define SIZE_LAN_COMM_RCV_BUFFER            20 
....................  
.................... typedef struct _ST_PIPE_DATA_NODE 
.................... { 
....................     unsigned int32 m_ui32TimeStamp; 
....................     unsigned int16 m_ui16SequenceNo; 
....................     unsigned int32 m_ui32ItemWeight; 
....................     unsigned int8  m_ui8RejectionStatus; 
.................... } ST_PIPE_DATA_NODE; 
....................  
.................... typedef struct _ST_PIPE_DATA_QUEUE 
.................... { 
....................     ST_PIPE_DATA_NODE m_stArrGPRSDataNode[SIZE_GPRS_DATA_NODE_QUEUE]; 
....................     int8              m_i8Front; 
....................     int8              m_i8Rear; 
.................... } ST_PIPE_DATA_QUEUE; 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ***************** Below -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
.................... unsigned int8  g_fDataSendingSequence                           = 0; 
.................... unsigned int8  g_ui8LANCommRxBuffer[SIZE_LAN_COMM_RCV_BUFFER]   = {0}; 
.................... unsigned int8  g_ui8LANCommRxByteCount                          = 0; 
....................  
....................  
....................  
.................... ST_PIPE_DATA_QUEUE   g_stPipeDataSendQueue; 
.................... // ***************************************************************************** 
.................... // ***************** Above -> Global Variable Declarations ********************* 
.................... // ***************************************************************************** 
....................  
....................  
.................... void InitLANCommRxInterrupt(void) 
.................... { 
....................     clear_interrupt(INT_RDA5); 
....................     enable_interrupts(INT_RDA5); 
.................... } 
....................  
.................... void ResetLANCommRxBuffer(void) 
.................... { 
....................     // Clear buffer. 
....................     memset(g_ui8LANCommRxBuffer, 0, SIZE_LAN_COMM_RCV_BUFFER); 
....................      
....................     // Reset byte count. 
....................     g_ui8LANCommRxByteCount = 0; 
....................      
.................... } 
....................  
.................... void InitializeLANMsgHeader(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Restore Machine ID.  
....................     ui8MachineID = ReadMachineIDFromEEPROM(); 
....................     g_stLANDataHeader.m_ui8MachineID = ui8MachineID; 
....................      
....................     // Remaining all header data will be send from HMI before start  
....................     // the production. 
.................... } 
....................  
....................  
.................... #INT_RDA5 
.................... void LANData_rcv_isr(void) 
.................... { 
....................     // Read the received byte. 
....................     g_ui8LANCommRxBuffer[g_ui8LANCommRxByteCount] = fgetc(LAN_USR); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8LANCommRxByteCount++; 
....................      
....................     // Check the buffer size. 
....................     if(g_ui8LANCommRxByteCount >= SIZE_LAN_COMM_RCV_BUFFER) 
....................     { 
....................         // If reach to maximum; circulate the buffer. 
....................         g_ui8LANCommRxByteCount = 0; 
....................     } 
....................      
....................     // Clear the interrupt. 
....................     clear_interrupt(INT_RDA5); 
.................... } 
....................  
....................  
.................... void InitializePipeDataQueue(void) 
.................... { 
....................     // Initialize front and rear of the queue 
....................     g_stPipeDataSendQueue.m_i8Front = -1; 
....................     g_stPipeDataSendQueue.m_i8Rear = -1; 
....................      
....................     // Initialize each queue element 
....................     for(unsigned int8 ui8LoopCount = 0; ui8LoopCount < SIZE_GPRS_DATA_NODE_QUEUE; ui8LoopCount++) 
....................     { 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32ItemWeight = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui16SequenceNo = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui32TimeStamp  = 0; 
....................         g_stPipeDataSendQueue.m_stArrGPRSDataNode[ui8LoopCount].m_ui8RejectionStatus = 0; 
....................     } 
....................  
.................... } 
....................  
.................... unsigned int8 IsPipeDataQueueEmpty(void) 
.................... { 
....................     unsigned int8 ui8QueueStatus = 0; 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         ui8QueueStatus = 1;  
....................     } 
....................     else 
....................     { 
....................         ui8QueueStatus = 0; 
....................     } 
....................     return ui8QueueStatus; 
.................... } 
....................  
....................  
.................... void InsertInPipeDataQueue(void) 
.................... { 
....................     if (-1 == g_stPipeDataSendQueue.m_i8Front) 
....................     { 
....................         g_stPipeDataSendQueue.m_i8Front = 0; 
....................     } 
....................      
....................     g_stPipeDataSendQueue.m_i8Rear = (g_stPipeDataSendQueue.m_i8Rear + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
....................      
....................     // Insert Data 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui16SequenceNo = g_stProdModeCurrBoxData.m_ui16SequenceNo; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32ItemWeight = (unsigned int32)g_stProdModeCurrBoxData.m_i32PipeWeight; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui8RejectionStatus = (unsigned int8)g_stProdModeCurrBoxData.m_ui16RejectionStatus; 
....................     g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Rear].m_ui32TimeStamp = g_stProdModeCurrBoxData.m_ui32TimeStamp;     
.................... } 
....................  
....................  
.................... void SendDataFromQ(void) 
.................... { 
....................     // Set web service URL. 
....................     //fprintf(GSM_M66, "http://pipetrackerlive.com/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui16MaxWeight,g_stLANDataHeader.m_ui16MinWeight, 
....................     //                                                                                                                         g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
....................  
....................     fprintf(LAN_USR, "/api/Test/GetStringGetMethod?a=%u&b=%Lu&c=%Lu&d=%Lu&e=%Lu&m=%Lu$%Lu$%Lu$%u", g_stLANDataHeader.m_ui8MachineID, g_stLANDataHeader.m_ui16BasicMaterialStandard, g_stLANDataHeader.m_ui16PipeSpecification,g_stLANDataHeader.m_ui32MaxWeight,g_stLANDataHeader.m_ui32MinWeight, 
....................                                                                                                    g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32TimeStamp, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui16SequenceNo, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui32ItemWeight, g_stPipeDataSendQueue.m_stArrGPRSDataNode[g_stPipeDataSendQueue.m_i8Front].m_ui8RejectionStatus); 
.................... } 
....................  
....................  
.................... unsigned int8 CheckServerResponse(void) 
.................... { 
....................     unsigned int8 ui8RetVal = 1; 
....................     unsigned int8 ui8LoopCounter = 0; 
....................      
....................     // Loop through receive buffer. 
....................     for(ui8LoopCounter = 0; ui8LoopCounter < SIZE_LAN_COMM_RCV_BUFFER; ui8LoopCounter++) 
....................     { 
....................         // Check for expected response. 
....................         if(g_ui8LANCommRxBuffer[ui8LoopCounter - 3] == 'O' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 2] == 'k' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 1] == 'a' && 
....................            g_ui8LANCommRxBuffer[ui8LoopCounter - 0] == 'y') 
....................         { 
....................             // Expected response received. 
....................             // Set return value. 
....................             ui8RetVal = 0; 
....................             // Reset receive buffer. 
....................             ResetLANCommRxBuffer();             
....................             break; 
....................         } 
....................     } 
....................          
....................     return ui8RetVal; 
.................... } 
....................  
....................  
.................... #endif	/* MZ_LAN_COMM_CONFIG_H */ 
....................  
....................  
.................... #include "vmRS485Config.h" 
.................... #ifndef _VI_RS485_CONFIG_H_ 
.................... #define _VI_RS485_CONFIG_H_ 
....................  
.................... #include "../Common/vmCRCConfig.h" 
.................... #ifndef _VM_CRC_CONFIG_H_ 
.................... #define _VM_CRC_CONFIG_H_ 
....................  
.................... // Table of CRC values for highorder byte. 
.................... unsigned int8 const auchCRCHi[] =  
.................... { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... // Table of CRC values for loworder byte. 
.................... unsigned int8 const auchCRCLo[] =  
.................... { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // CRC calculation. 
.................... static unsigned int16 ModbusCRC16 (unsigned int8* puiMsg,   // Message to calculate CRC upon. 
....................                                    unsigned short usDataLen) // Quantity of bytes in message. 
.................... { 
....................     unsigned int8 uchCRCHi = 0xFF; // High byte of CRC initialized. 
....................     unsigned int8 uchCRCLo = 0xFF; // Low byte of CRC initialized. 
....................     unsigned int8 uIndex;          // Will index into CRC lookup table. 
....................  
....................     while (usDataLen--) // Loop through message buffer. 
....................     { 
....................         uIndex = uchCRCLo ^ *puiMsg++; // Calculate the CRC. 
....................         uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
....................         uchCRCHi = auchCRCLo[uIndex]; 
....................     } 
....................  
....................     return ((((unsigned int16)uchCRCHi) << 8) | uchCRCLo); 
.................... } 
....................  
.................... unsigned int16 calculateCrc( unsigned int8* pDataBuff, unsigned int8 uiDataLen ) 
.................... { 
.................... 	unsigned int16 uiCRC        = 0x00; 
.................... 	unsigned int16 shRemainder  = 0xFFFF; 
.................... 	unsigned int16 shGP         = 40961; 
.................... 	unsigned int8  uiByteCount  = 0; 
.................... 	unsigned int8  bShiftCount  = 0; 
.................... 	unsigned int8  bShiftCarry  = 0; 
....................  
.................... 	while (1) 
.................... 	{ 
.................... 		if (uiByteCount == uiDataLen) 
.................... 		{ 
.................... 			break; 
.................... 		} 
....................  
.................... 		uiByteCount++; 
.................... 		bShiftCount = 0; 
....................  
.................... 		while (1) 
.................... 		{ 
.................... 			if (0 == bShiftCount) 
.................... 			{ 
.................... 				if (1 == uiByteCount) 
.................... 				{ 
.................... 					uiCRC = (pDataBuff[uiByteCount - 1]) ^ shRemainder; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 					uiCRC = uiCRC ^ (pDataBuff[uiByteCount - 1]); 
.................... 				} 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				uiCRC = uiCRC ^ shGP; 
.................... 			} 
....................  
.................... 		    NoBitCarry: 
....................  
.................... 			bShiftCount++; 
....................  
.................... 			if (bShiftCount > 8) 
.................... 			{ 
.................... 				break; 
.................... 			} 
....................  
.................... 			bShiftCarry = uiCRC & 1; 
....................  
.................... 			uiCRC = uiCRC >> 1; 
....................  
.................... 			if (1 == bShiftCarry) 
.................... 			{ 
.................... 				continue; 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				goto NoBitCarry; 
.................... 			} 
.................... 		} 
.................... 	} 
....................  
.................... 	return uiCRC; 
.................... } 
....................  
.................... #endif /* _VM_CRC_CONFIG_H_ */ 
....................  
.................... #include "../Common/vmModbusGlobal.h" 
.................... #ifndef _VI_MODBUS_GOBAL_H_ 
.................... #define _VI_MODBUS_GOBAL_H_ 
....................  
.................... #include "vmIBUGlobal.h" 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE    64   
.................... #define MODBUS_REG_BUFFER_SIZE          10   
.................... #define MAX_RUNNING_PRODUCTS            8 // Maximum is 7..but here 8 is taken to maintain correspondenc between product ID & array index..i.e. index 0 is not used. 
....................                                           // data storing starts from index 1 and ends at index 7. 
.................... #define MODBUS_IS_VALID_SLAVE_ID             12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID         13 
....................  
....................  
....................  
....................  
.................... typedef struct _ST_CUR_BATCH_INFO 
.................... { 
....................     int16 m_i16AvgWeight; 
....................     int16 m_i16PositiveTol; 
....................     int16 m_i16NegativeTol; 
.................... } ST_CUR_BATCH_INFO; 
....................  
....................  
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationWeight; 
.................... //unsigned int16 g_ui16RegisterCurrentCalibrationPoint; 
.................... unsigned int32 g_ui32TareADCValueForCalibration = 0; 
.................... unsigned int32 g_ui32gWeightADCValueForCalibration = 0; 
.................... //unsigned int16 g_ui16gAvgWtForCalibration; 
....................  
....................  
.................... // use for production  
.................... unsigned int16 g_ui16PipeCount = 0; 
.................... unsigned int16 g_ui16PipeCountPrev; 
.................... unsigned int32 g_ui32CurrentWt = 0; 
.................... unsigned int16 g_ui16CurrentPassStatus = 0; 
.................... unsigned int32 g_ui32RunningAvgWt = 0; 
.................... unsigned int32 g_ui32RunningTareValue = 0; 
.................... //unsigned int16 g_ui16ServerStatus; 
....................  
.................... //unsigned int16 g_ui16FlagForSetTareValue; 
....................  
....................  
....................  
.................... // use for pre production 
.................... //unsigned int16 g_ui16CurrProdIndex = 0; 
.................... unsigned int16 g_ui16CurrProdAvgWt = 0; 
.................... unsigned int16 g_ui16CurrProdPvTol = 0; 
.................... unsigned int16 g_ui16CurrProdNvTol = 0; 
....................  
.................... // Use for Current Mode 
.................... unsigned int16 g_ui16CurrentMode = 0; 
....................  
.................... // Use for detect start calibration. 
.................... unsigned int8  g_fStartCalibration = 0; 
....................  
....................  
.................... // Use for store load cell factor. 
.................... unsigned int16 g_ui16CurrLoadCellFactor = 0; 
....................  
.................... // Use for Store Running Production Type Selection. 
.................... //unsigned int8  g_ui8CurrProductionType = 0; 
....................  
.................... // Use for Store HMI TimeStamp 
.................... unsigned int16  g_ui16HMITimeStamp = 0; 
....................  
.................... // Use for Passing Box Product Index. 
.................... //unsigned int16  g_ui16CurrProdIndex = 0; 
....................  
.................... // Use for Tolerance store acknowledge. 
.................... unsigned int8   g_ui8ToleranceStoreAck = 0; 
....................  
.................... // Use for Server Machine ID. 
.................... unsigned int8   g_ui8MachineID = 0; 
....................  
.................... // Use for AT-OK response check time. 
.................... unsigned int8  g_ui8ATResponseCheckTime = 0; 
....................  
.................... // Use for data sending interval time. 
.................... unsigned int8 g_ui8DataSendingIntervalTime = 0; 
....................  
.................... // Use for HTTP GET session time. 
.................... unsigned int8 g_ui8HTTPGETSessionTime = 0; 
....................  
.................... // Use for Wireless Modem power cut time for reset. 
.................... unsigned int8 g_ui8WirelessModemResetTime = 0; 
....................  
.................... // Use for Wireless modem network reconnection halt time. 
.................... unsigned int8 g_ui8WirelessModemNWReccntHaltTime = 0; 
....................  
.................... // Use for Pipe presence delay time. 
.................... unsigned int16 g_ui16PipePresenceDelayTime = 0; 
....................  
.................... // Use for pipe stabilization delay time. 
.................... unsigned int16 g_ui16PipeStabilizationDelayTime = 0; 
....................  
.................... // Use for Pipe transfer delay time. 
.................... unsigned int16 g_ui16PipeTransferDelayTime = 0; 
....................  
.................... // Use for wireless modem periodic reset interval time. 
.................... unsigned int8  g_ui8WirelessModemPeriodicResetIntervalTime = 0; 
....................  
.................... // Use for Shift number storing. 
.................... unsigned int8  g_ui8ShiftNumber = 0; 
....................  
.................... // Use for Actual Machine Up time storing in one shift. 
.................... unsigned int16 g_ui16TotalMachineUpTime = 0; 
....................  
.................... // Use for Air-pressure below rated alarm . 
.................... unsigned int8  g_ui8AirPressureAlarm = 0; 
....................  
.................... // Use for SIM Operator ID. 
.................... unsigned int8 g_ui8SIMOperatorID = 0; 
....................  
.................... // Use for Weighing cylinder up activation delay. 
.................... unsigned int16 g_ui16WeighingCylinderUpActivationDelay = 0; 
....................  
.................... // Use for product basic material and standard and standard specification and pressure rating. 
.................... unsigned int8  g_ui8BasicMaterialStandard = 0; 
.................... unsigned int8  g_ui8StandardSpecification = 0; 
.................... unsigned int8  g_ui8PressureRating        = 0; 
....................  
.................... // Use for pipe specification. 
.................... unsigned int8  g_ui8PipeOD                = 0; 
.................... unsigned int8  g_ui8PipeLength            = 0; 
....................  
.................... //void ResetIBUPreProdDataNode(void) 
.................... //{ 
.................... //    unsigned int8 ui8LoopCount = 0; 
.................... //    for(ui8LoopCount = 0; ui8LoopCount < MULTI_PROD_MAX_VARIETY; ui8LoopCount++) 
.................... //    {    
.................... //        // Tolerance Node. 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MaxWt = 0; 
.................... //        g_unIBUArrTolNode[ui8LoopCount].m_stIBUTolNode.m_i32MinWt = 0; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
....................  
.................... #endif /* _VI_MODBUS_GOBAL_H_ */ 
....................  
....................  
.................... #include "../Common/vmIBUConfig.h" 
.................... #ifndef _VI_IBU_CONFIG_H_ 
.................... #define _VI_IBU_CONFIG_H_ 
....................  
.................... #include "vmCRCConfig.h" 
.................... #include "vmIBUGlobal.h" 
.................... #include "vmCircularQ.h" 
....................  
.................... #define IBU_MSG_BYTE_COUNT                       9 //5 
.................... //#define IBU_DATA_BITS_LENGTH                     10 
.................... //#define IBU_DATA_BYTES_LENGTH                    10 
.................... //#define IBU_BOARD_ID                             1 
....................  
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_OFF             0 
.................... #define IBU_WAIT_FOR_ACK_TIMEOUT_ON              1 
.................... #define DELAY_IBU_MSG_ACK_NOT_RCV                30 
....................  
....................  
.................... #ifdef M1_COMM_MODULE 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)  // 78us Instead of 104us we load 91.2 for per bit time. 
.................... #else 
....................     #define IBU_RX_1_BT_CUSTOMISED_VAL_9600        (0xFFFF - 0x0039 + 1)//   IBU_RX_BIT_TIME_T1LOAD_VAL_9600  // 104 us 
.................... #endif 
.................... //#define IBU_RX_1_BT_CUSTOMISED_VAL_9600           (0xFFFF - 0x0031 + 1)  // Instead of 104us we load 78 us for per bit time. 
.................... #define IBU_RX_BIT_TIME_1_2_T1LOAD_VAL_9600       (0xFFFF - 0x004E + 1) 
.................... #define IBU_RX_BIT_TIME_1_3_T1LOAD_VAL_9600       (0xFFFF - 0x0051 + 1) 
.................... #define IBU_RX_BIT_TIME_1_4_T1LOAD_VAL_9600       (0xFFFF - 0x005B + 1) 
....................  
....................  
.................... #define IBU_RX_BIT_TIME_1_5_T1LOAD_VAL_19200     (0xFFFF - 0x0031 + 1) // For 19200 
.................... #define IBU_RX_BIT_TIME_T1LOAD_VAL_19200         (0xFFFF - 0x0041 + 1) // For 19200 
....................  
.................... #define SIZE_IBU_SEND_BYTE_SEGMENT                15  //1+3+8+3, 1 Start Bit, 3 Sequence Bits, 8 bits of Data and 3 Stop Bits; Total 15bits in one segment/ custised byte 
....................  
.................... #define IBU_TIMER_0_CRITICAL_ON                   0 
.................... #define IBU_TIMER_0_CRITICAL_OFF                  1 
....................  
.................... #define IBU_RCV_COMPLETE                          10 
.................... #define IBU_RDY_TO_RCV_NEXT                       11 
.................... #define IBU_SENDING_BUSY                          1 
.................... #define IBU_SENDING_FREE                          0 
.................... #define SIZE_IBU_SEND_RCV_ARRAY                   4 + IBU_MSG_BYTE_COUNT // 1+1+IBU_MSG_BYTE_COUNT+2 
.................... #define SIZE_IBU_COMPLETE_SEND_MSG                SIZE_IBU_SEND_RCV_ARRAY + 5 // 3 Byte STX and 2 Byte ETX 
.................... #define IBU_MSG_TYPE_MSG                          33 
.................... #define IBU_MSG_TYPE_ACK                          44 
....................  
.................... #define SIZE_CAM_RCV_BUFF                         20 
.................... //***************************************************************************** 
.................... // Below -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
.................... unsigned int8 g_ui8CameraRcvBuffer[SIZE_CAM_RCV_BUFF] = {0}; 
.................... unsigned int8 g_ui8CamRcvByteCount                    = 0; 
.................... //***************************************************************************** 
.................... // Above -> Data Structure for Interboard Communication *********************** 
.................... //***************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Below -> Interboard Communication  RX #  From M1_COMM ********************** 
.................... //***************************************************************************** 
....................  
.................... // CHANGE V9.0 
.................... typedef struct _ST_IBU_DATA_NODE 
.................... { 
....................     unsigned int8  m_ui8SeqNum; 
....................     unsigned int8  m_ui8MsgType;    // Either MSG or ACK 
....................     unsigned int8  g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
....................     unsigned int16 m_CRC; 
.................... } ST_IBU_DATA_NODE; 
....................  
.................... //typedef struct _ST_IBU_DATA_NODE 
.................... //{ 
.................... //    unsigned int8 g_ui8ArrIBUData[IBU_MSG_BYTE_COUNT]; 
.................... //} ST_IBU_DATA_NODE; 
....................  
.................... #define SIZE_IBU_DATA_SEND_QUEUE            15 
....................  
.................... typedef struct _ST_IBU_MSG_QUEUE 
.................... { 
....................     ST_IBU_DATA_NODE m_stArrIBUDataNode[SIZE_IBU_DATA_SEND_QUEUE]; 
....................     int8             m_i8Front; 
....................     int8             m_i8Rear; 
.................... } ST_IBU_MSG_QUEUE; 
.................... //***************************************************************************** 
.................... // Below -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
.................... //UN_INT_BOARD_BYTE_TYPE    g_unIBURcvData; 
.................... unsigned int8             g_ui8IBURcvBitCount = 0; 
.................... unsigned int8             g_ui8IBUTxBitCount  = 0; 
....................  
.................... // TESTING 
.................... unsigned int8             g_ui8IBUDataToSend = 0xA5; 
.................... unsigned int8             g_fIBUCommStatus   = 0; 
....................  
.................... ST_IBU_DATA_NODE          g_stIBURcvData; 
.................... ST_IBU_DATA_NODE          g_stIBUSendData; 
.................... unsigned int8             g_ui8ArrSendSingleMSG[IBU_MSG_BYTE_COUNT*(SIZE_IBU_SEND_BYTE_SEGMENT)] = {0}; // 
.................... unsigned int8             g_fIBUDataReceived = 0; 
....................  
.................... //ST_IBU_DATA_SEND_QUEUE    g_stIBUDataSendQueue; 
.................... unsigned int8             g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... //UN_IBU_RCV_BYTE_NODE      g_unIBURcvByteNode; 
....................  
.................... ST_IBU_MSG_QUEUE          g_stIBUSendQueue; 
.................... ST_IBU_MSG_QUEUE          g_stIBURcvQueue; 
....................  
.................... unsigned int8             g_ui8fTimer0State    = IBU_TIMER_0_CRITICAL_OFF; 
.................... unsigned int8             g_ui8IBURcvByteCount = 0; 
.................... unsigned int8             g_fIBUDataRcvStatus  = 0; 
....................  
.................... int8                      g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
.................... unsigned int16            g_ui16IBUWaitForACKTikCount  = 0; 
.................... unsigned int8             g_ui8IBURcvDataTemp[SIZE_IBU_SEND_RCV_ARRAY]; 
.................... //***************************************************************************** 
.................... // Above -> Global Variable Declaration *************************************** 
.................... //***************************************************************************** 
....................  
....................  
.................... void InitIBURxInterrupt(void) 
.................... { 
....................     // Enable IBU Rcv interrupt. 
....................     clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #ifdef M0_ADC_MODULE 
.................... // ############### Should not be here; Must be in specific camera config header.############################ // 
.................... void InitCamRxInterrupt(void) 
.................... { 
....................     // Enable camera communication receive interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... 	enable_interrupts(INT_RDA4);     
.................... } 
....................  
.................... #INT_RDA4 
.................... void rda4_isr(void) 
.................... { 
....................     // Receive buffer. 
....................     g_ui8CameraRcvBuffer[g_ui8CamRcvByteCount] = fgetc(CAMERA); 
....................      
....................     // Increment receive byte count. 
....................     g_ui8CamRcvByteCount++; 
....................      
....................     // Check with buffer size. 
....................     if(g_ui8CamRcvByteCount >= SIZE_CAM_RCV_BUFF) 
....................     { 
....................         // Reset byte count. 
....................         g_ui8CamRcvByteCount = 0; 
....................     } 
....................      
....................     // Clear interrupt. 
....................     clear_interrupt(INT_RDA4); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////// Camera config header TESTING part : Temporary /////////////////////////////////////////// 
....................  
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving START /////////////// 
....................  
.................... void InitializeDataQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     int iLoopCount1 = 0; 
....................     int iLoopCount2 = 0; 
....................     pstIBUMSGQueue->m_i8Front = pstIBUMSGQueue->m_i8Rear = -1; 
....................      
....................     for (iLoopCount1 = 0; iLoopCount1 < SIZE_IBU_DATA_SEND_QUEUE; iLoopCount1++) 
....................     { 
....................         for (iLoopCount2 = 0; iLoopCount2 < IBU_MSG_BYTE_COUNT; iLoopCount2++) 
....................         { 
....................            pstIBUMSGQueue->m_stArrIBUDataNode[iLoopCount1].g_ui8ArrIBUData[iLoopCount2] = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void CopyIBUMsg(ST_IBU_DATA_NODE* pstIBUSource, ST_IBU_DATA_NODE* pstIBUDDest) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................      
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         pstIBUDDest->g_ui8ArrIBUData[i8LoopCount] = pstIBUSource->g_ui8ArrIBUData[i8LoopCount]; 
....................     } 
.................... } 
....................  
.................... /* Function to create Circular queue */ 
.................... void InsertIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (!pstIBUData) 
....................     { 
....................         return; 
....................     } 
....................      
.................... //    if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
.................... //            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)%(SIZE_IBU_DATA_SEND_QUEUE-1)))  
.................... //    {  
.................... //        //printf("\nQueue is Full");  
.................... //        return; 
.................... //    } 
....................     if ((pstIBUMSGQueue->m_i8Front == 0 && pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1) ||  
....................            (pstIBUMSGQueue->m_i8Rear == (pstIBUMSGQueue->m_i8Front-1)))  
....................     {  
....................         //printf("\nQueue is Full");  
....................         return; 
....................     }     
....................      
....................     else if (pstIBUMSGQueue->m_i8Front == -1) /* Insert First Element */ 
....................     {  
....................         pstIBUMSGQueue->m_i8Front = 0; 
....................         pstIBUMSGQueue->m_i8Rear  = 0; 
....................          
....................         // Insert Data 
....................         //arr[g_stIBUDataSendQueue.m_i8Rear] = value; 
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else if (pstIBUMSGQueue->m_i8Rear == SIZE_IBU_DATA_SEND_QUEUE-1 && pstIBUMSGQueue->m_i8Front != 0)  
....................     {  
....................         pstIBUMSGQueue->m_i8Rear = 0;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     }  
....................    
....................     else 
....................     {  
....................         pstIBUMSGQueue->m_i8Rear++;  
....................         CopyIBUMsg(pstIBUData, &(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Rear])); 
....................     } 
....................      
.................... //    if (IBU_CMD_PROD_WEIGH_DATA == pstIBUData->g_ui8ArrIBUData[0]) 
.................... //    { 
.................... //        output_toggle(PIN_OUT_DO_00); 
.................... //    } 
.................... }  
....................  
.................... void DeleteIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
....................     return; 
.................... } 
....................  
.................... void GetIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue, ST_IBU_DATA_NODE* pstIBUData)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     // Copy Message Node from Front 
....................     CopyIBUMsg(&(pstIBUMSGQueue->m_stArrIBUDataNode[pstIBUMSGQueue->m_i8Front]), pstIBUData); 
....................    
.................... } 
....................  
.................... // This Function will remove the first Node from Message Queue 
.................... void RemoveIBUMsgQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue)  
.................... { 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     {  
....................         //printf("\nQueue is Empty");  
....................         return;  
....................     }  
....................  
....................     if (pstIBUMSGQueue->m_i8Front == pstIBUMSGQueue->m_i8Rear)  
....................     {  
....................         pstIBUMSGQueue->m_i8Front = -1;  
....................         pstIBUMSGQueue->m_i8Rear  = -1;  
....................     }  
....................     else if (pstIBUMSGQueue->m_i8Front == SIZE_IBU_DATA_SEND_QUEUE-1)  
....................         pstIBUMSGQueue->m_i8Front = 0;  
....................     else 
....................         pstIBUMSGQueue->m_i8Front++;  
....................    
.................... } 
....................  
.................... unsigned int8 IsMSGInIBUQueue(ST_IBU_MSG_QUEUE *pstIBUMSGQueue) 
.................... { 
....................     unsigned int8 ui8RetVal = 0; 
....................     if (pstIBUMSGQueue->m_i8Front == -1) 
....................     { 
....................         ui8RetVal = 0; 
....................     } 
....................     else 
....................     { 
....................         ui8RetVal = 1; 
....................     } 
....................      
....................     return ui8RetVal; 
.................... } 
....................  
.................... ////////////// Common QUEUE for Data Sending and Receiving END ///////////////// 
.................... // CHANGE V9.0 
.................... #define MAX_SEND_TRY            10 
.................... unsigned int8 g_ui8UARTMsgSeq = 0; 
.................... unsigned int8 g_ui8ArrSendBuffer[SIZE_IBU_SEND_RCV_ARRAY] = {0}; // Seq No -> 1 Byte, MSG Type -> 1 Byte, Data -> 9 Byte, CRC -> 2 Byte 
.................... unsigned int16 g_ui16CRCValue = 0; 
.................... unsigned int8  g_ui8SendTryCount = 0; 
....................  
.................... void SendIBUMSGFromQ() 
.................... { 
....................     int8          i8LoopCount    = 0; 
....................      
....................     // Check if it is the last message does not get ACK 
....................     if (g_ui8SendTryCount >= MAX_SEND_TRY) 
....................     { 
....................         // Ignore the Message and Proceed for next Message 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Remove the message from Send Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................         return; 
....................     } 
....................  
....................     // Increment the Send Message Try Count 
....................     g_ui8SendTryCount++; 
....................      
....................     // Initialize the Send Array 
....................     for (i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................  
....................     // Get Node from Queue 
....................     //DeleteIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................     GetIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
....................      
....................     // Insert the Sequence Number 
....................     if (1 == g_ui8SendTryCount) 
....................     { 
....................         if (255 == g_ui8UARTMsgSeq) 
....................         { 
....................           g_ui8UARTMsgSeq = 0;   
....................         } 
....................         else 
....................         { 
....................           ++g_ui8UARTMsgSeq;   
....................         }        
....................     } 
....................      
....................     g_stIBUSendData.m_ui8SeqNum = g_ui8UARTMsgSeq; 
....................      
....................     g_ui8ArrSendBuffer[0]  = g_ui8UARTMsgSeq; 
....................     g_ui8ArrSendBuffer[1]  = IBU_MSG_TYPE_MSG; 
....................      
....................     g_ui8ArrSendBuffer[2]  = g_stIBUSendData.g_ui8ArrIBUData[0]; 
....................     g_ui8ArrSendBuffer[3]  = g_stIBUSendData.g_ui8ArrIBUData[1]; 
....................     g_ui8ArrSendBuffer[4]  = g_stIBUSendData.g_ui8ArrIBUData[2]; 
....................     g_ui8ArrSendBuffer[5]  = g_stIBUSendData.g_ui8ArrIBUData[3]; 
....................     g_ui8ArrSendBuffer[6]  = g_stIBUSendData.g_ui8ArrIBUData[4]; 
....................     g_ui8ArrSendBuffer[7]  = g_stIBUSendData.g_ui8ArrIBUData[5]; 
....................     g_ui8ArrSendBuffer[8]  = g_stIBUSendData.g_ui8ArrIBUData[6]; 
....................     g_ui8ArrSendBuffer[9]  = g_stIBUSendData.g_ui8ArrIBUData[7]; 
....................     g_ui8ArrSendBuffer[10] = g_stIBUSendData.g_ui8ArrIBUData[8]; 
....................     //g_ui8ArrSendBuffer[11] = g_stIBUSendData.g_ui8ArrIBUData[9]; 
....................      
.................... //    g_ui8ArrSendBuffer[12] = 0; 
.................... //    g_ui8ArrSendBuffer[13] = 0; 
....................      
....................      
....................     // Insert MSG CRC 
....................     // CRC calculation 
....................     g_ui16CRCValue = calculateCrc(g_ui8ArrSendBuffer, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................  
....................     // Stuff CRC 
....................     g_ui8ArrSendBuffer[11] = (unsigned int8)((g_ui16CRCValue >> 0) & 0xFF); 
....................  
....................     g_ui8ArrSendBuffer[12] = (unsigned int8)((g_ui16CRCValue >> 8) & 0xFF); 
....................  
....................     // Send Start Text to protect spurious data. 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     fputc(STX, UART); 
....................     // Send Original Data. 
....................     for (i8LoopCount = 0; i8LoopCount < SIZE_IBU_SEND_RCV_ARRAY; i8LoopCount++) 
....................     { 
....................         fputc(g_ui8ArrSendBuffer[i8LoopCount], UART); 
....................         //delay_us(1); 
....................     } 
....................     fputc(ETX, UART); 
....................     fputc(ETX, UART); 
....................     delay_us(5); 
....................      
....................     // Start the Timer for Ack 
....................     g_fIBUMsgAckDelayStatus = IBU_WAIT_FOR_ACK_TIMEOUT_ON; 
....................      
....................     // Reset flag denoting IBU is free now. 
....................     //g_fIBUSendBusy = IBU_SENDING_FREE; 
.................... } 
....................  
.................... void ResetIBURcvBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBURcvData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
....................      
....................     // Reset rcv buffer byte count. 
....................     g_ui8IBURcvByteCount = 0; 
.................... } 
....................  
....................  
.................... void ResetIBUSendBuffer(void) 
.................... { 
....................     int8 i8LoopCount = 0; 
....................     for(i8LoopCount = 0; i8LoopCount < IBU_MSG_BYTE_COUNT; i8LoopCount++) 
....................     { 
....................         g_stIBUSendData.g_ui8ArrIBUData[i8LoopCount] = 0; 
....................     } 
.................... } 
....................  
.................... #define SIZE_RCV_BUFFER           100 
.................... #define FLAG_STX_FOUND              1 
.................... #define FLAG_STX_NOT_FOUND          0 
.................... #define FLAG_ETX_FOUND              1 
.................... #define FLAG_ETX_NOT_FOUND          0 
.................... unsigned int8 g_ui8ArrRCVBuffer[SIZE_RCV_BUFFER + 2] = {0}; // 2 Bytes extra just to prevent 
....................                                                             // unauthorized access beyond Full Array Length 
.................... unsigned int8 g_ui8RCVQFront         = 0; 
.................... unsigned int8 g_ui8RCVQRear          = 0; 
.................... unsigned int8 g_ui8FlagETXFound      = 0; 
.................... unsigned int8 g_ui8FlagSTXFound      = 0; 
.................... unsigned int8 g_ui8TempRcvMSG[SIZE_IBU_SEND_RCV_ARRAY] = {0}; 
.................... //unsigned int8 g_ui8SendMsgSeq = 0; 
....................  
.................... void ProcessACK(unsigned int8 ui8MsgSeqNo) 
.................... { 
....................     // Try to match the Send Message Sequence Number for which we are waiting for Ack 
....................     if (g_ui8UARTMsgSeq == ui8MsgSeqNo) 
....................     { 
....................         // Remove the first message node from Send MSG Queue 
....................         RemoveIBUMsgQueue(&g_stIBUSendQueue); 
....................          
....................         // Reset Send Try 
....................         g_ui8SendTryCount = 0; 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now. 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
....................     else 
....................     { 
....................         // Some Acknowledgment has arrived but somehow the sequence number got corrupted 
....................         // Need to Resend the message Again 
....................          
....................         // Reset Timer 
....................         g_fIBUMsgAckDelayStatus      = IBU_WAIT_FOR_ACK_TIMEOUT_OFF; 
....................         g_ui16IBUWaitForACKTikCount  = 0; 
....................          
....................         // Reset flag denoting IBU is free now 
....................         g_fIBUSendBusy = IBU_SENDING_FREE; 
....................     } 
.................... } 
....................  
.................... void CheckIBUReceiveQ() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8Count       = 0; 
....................     unsigned int8 ui8CurNextPos = g_stRcvQueue.m_ui8Front; 
....................     unsigned int8 ui8STXPos       = 0; 
....................      
....................     g_ui8RCVQFront = g_stRcvQueue.m_ui8Front; 
....................     g_ui8RCVQRear  = g_stRcvQueue.m_ui8Rear; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Check for the at least two consecutive STXs 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         // Find the next Position 
....................         ui8CurNextPos = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................          
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front] && 
....................             STX == g_stRcvQueue.m_ui8QArr[ui8CurNextPos]) 
....................         { 
....................             // We got Two Consecutive STXs 
....................             break; 
....................         } 
....................         else 
....................         { 
....................             // Update Queue Front 
....................             g_stRcvQueue.m_ui8Front = ui8CurNextPos; 
....................             g_ui8ElementInQ--; 
....................         } 
....................     } 
....................      
....................     // Now Check how we exit from the above loop 
....................     // If there is no STX found through out the stretch 
....................     if (0 == g_ui8ElementInQ) 
....................     { 
....................         // The message exhausted 
....................         return; 
....................     } 
....................     // So we found two consecutive STXs. There might be more STXs 
....................     // Now check for the final STX and ETX pair 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16  17 
....................     while (g_ui8ElementInQ > SIZE_IBU_SEND_RCV_ARRAY) 
....................     { 
....................         // Get the Expected STX Position 
....................         ui8STXPos = (g_stRcvQueue.m_ui8Front + 14) % SIZE_RCV_QUEUE; 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             if (ETX == g_stRcvQueue.m_ui8QArr[ui8STXPos]) 
....................             { 
....................                 // Perfect Message Found 
....................                 break; 
....................             } 
....................             else 
....................             { 
....................                 g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................                 g_ui8ElementInQ--; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // STX Train Exhausted, No chance to get a complete message 
....................             return; 
....................         } 
....................     } 
....................      
....................     g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................     g_ui8ElementInQ--; 
....................     // We have got a complete message 
....................     // Copy the message from Receive Queue to Receive Buffer 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................     { 
....................         g_ui8IBURcvDataTemp[ui8Count] = g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]; 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................      
....................     // Move the front upto next STX or end of current element count 
....................     while (g_ui8ElementInQ) 
....................     { 
....................         if (STX == g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Front]) 
....................         { 
....................             // It might be STX of next message 
....................             // Queue front is pointing to this STX and let us return from here 
....................             break; 
....................         } 
....................         g_stRcvQueue.m_ui8Front = (g_stRcvQueue.m_ui8Front + 1) % SIZE_RCV_QUEUE; 
....................         g_ui8ElementInQ--; 
....................     } 
....................      
....................     // Get Next Rear Position 
....................     ui8CurNextPos = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................     if (g_stRcvQueue.m_ui8Front == ui8CurNextPos) 
....................     { 
....................         // No farther elements in the queue 
....................         g_stRcvQueue.m_ui8Front = g_stRcvQueue.m_ui8Rear = -1; 
....................     } 
....................      
....................     // Now let us process the Received Message 
....................     // There are two types of IBU Messages 
....................     //     1. Acknowledgment against a Fresh Message 
....................     //     2. Fresh Message Received 
....................     // SEQ ACK D1 D2 D3 D4 D5 D6 D7 D8 D9 CRC1 CRC2  
....................     //  0   1   2  3  4  5  6  7  8  9 10  11   12   
....................     // For ACK Message 
....................     if (IBU_MSG_TYPE_ACK == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Send the MSG Sequence Number to process Acknowledgment 
....................         ProcessACK(g_ui8IBURcvDataTemp[0]); 
....................         return; 
....................     } 
....................      
....................     // For Fresh Message Received 
....................     if (IBU_MSG_TYPE_MSG == g_ui8IBURcvDataTemp[1]) 
....................     { 
....................         // Check the Message CRC 
....................         // Calculate CRC 
....................         g_ui16CRCValue = calculateCrc(g_ui8IBURcvDataTemp, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................          
....................         // Validate CRC. 
....................         if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8IBURcvDataTemp[12] && 
....................            ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8IBURcvDataTemp[11]) 
....................         { 
....................             // Insert the Message into IBU Receive Queue 
....................             g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8IBURcvDataTemp[2]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8IBURcvDataTemp[3]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8IBURcvDataTemp[4]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8IBURcvDataTemp[5]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8IBURcvDataTemp[6]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8IBURcvDataTemp[7]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8IBURcvDataTemp[8]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8IBURcvDataTemp[9]; 
....................             g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8IBURcvDataTemp[10]; 
....................  
....................             // Insert Message into IBC Receive Queue 
....................             InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................             // Send Acknowledgment 
....................             g_ui8IBURcvDataTemp[1] = IBU_MSG_TYPE_ACK; 
....................              
....................             // No need to hold the Send Lock, because this function is called from main thread 
....................             // and only main thread can send IBU Data 
....................             // Send Start Text to protect spurious data. 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             fputc(STX, UART); 
....................             // Send Original Data. 
....................             for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................             { 
....................                 fputc(g_ui8IBURcvDataTemp[ui8Count], UART); 
....................             } 
....................             fputc(ETX, UART); 
....................             fputc(ETX, UART); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // For Invalid CRC 
....................         // Nothing to Do 
....................     } 
....................      
....................     // All Elements exhausted g_ui8ElementInQ == 0 
....................     return; 
.................... } 
....................  
.................... void CheckIBUReceiveBuffer() 
.................... { 
....................     unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
....................     unsigned int8 ui8Count       = 0; 
....................      
....................     g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
....................     g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
....................      
....................     // Step 1: Check for three consecutive STX 
....................     for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
....................     { 
....................         if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
....................         { 
....................             // Check for STX in Next two Position 
....................             if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
....................                 STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
....................             { 
....................                 // Got Three STXs 
....................                 g_ui8FlagSTXFound = FLAG_STX_FOUND; 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................      
....................     // If the Buffer exhausted and STX not found 
....................     if (ui8CurPosition == g_ui8RCVQRear) 
....................     { 
....................         // Update front and rear and exit, may be we got spurious data 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................      
....................     // Now Check for the ETX 
....................     if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
....................     { 
....................         g_ui8FlagETXFound = FLAG_ETX_FOUND;  //TODO: No use of this variable, can be removed 
....................     } 
....................     else 
....................     { 
....................         // No ETX Found 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................          
....................         return; 
....................     } 
....................      
....................     // STX and ETX Both are found 
....................     // Now check MSG Type 
....................     if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
....................     { 
....................         // This is an Acknowledgment Message 
....................         // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................         //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................  
....................         ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................         return; 
....................     } 
....................      
....................     // If the MSG is not ACK that means fresh MSG received 
....................     // Now check for CRC 
....................     // STX STX STX SEQ ACK D1 D2 D3 D4 D5  D6  D7  D8  D9  CRC1 CRC2 ETX  ETX 
....................     //  0   1   2   3   4   5  6  7  8  9  10  11  12  13   14   15   16   17 
....................     for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
....................     { 
....................         g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................     } 
....................      
.................... //    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
....................      
....................     // Calculate CRC 
....................     g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
....................      
....................     // Validate CRC. 
....................     if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
....................        ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
....................     { 
....................         // Insert the Message into IBU Receive Queue 
....................         g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
....................          
....................         g_stIBURcvData.g_ui8ArrIBUData[5] = g_ui8TempRcvMSG[7]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[6] = g_ui8TempRcvMSG[8]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[7] = g_ui8TempRcvMSG[9]; 
....................         g_stIBURcvData.g_ui8ArrIBUData[8] = g_ui8TempRcvMSG[10]; 
....................  
....................  
....................         // Insert Message into IBC Receive Queue 
....................         InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
....................  
....................         // Reset receive buffer. 
....................         ResetIBURcvBuffer(); 
....................          
....................         // Send Acknowledgment 
....................         g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
....................         g_ui8TempRcvMSG[11] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
....................         g_ui8TempRcvMSG[12] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
....................          
....................         // No need to hold the Send Lock, because this function is called from main thread 
....................         // and only main thread can send IBU Data 
....................         // Send Start Text to protect spurious data. 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         fputc(STX, UART); 
....................         // Send Original Data. 
....................         for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
....................         { 
....................             fputc(g_ui8TempRcvMSG[ui8Count], UART); 
....................         } 
....................         fputc(ETX, UART); 
....................         fputc(ETX, UART); 
....................         delay_us(5); 
....................     } 
....................     else  // For Invalid CRC 
....................     { 
....................         // Receive message got corrupted 
....................         // Reset Receive MSG Array 
....................         g_ui8RCVQFront = 0; 
....................         g_ui8RCVQRear  = 0; 
....................     } 
....................      
....................     g_ui8RCVQFront = 0; 
....................     g_ui8RCVQRear  = 0; 
.................... } 
....................  
.................... ////////void CheckIBUReceiveBuffer() 
.................... ////////{ 
.................... ////////    unsigned int8 ui8CurPosition = g_ui8RCVQFront; 
.................... ////////    unsigned int8 ui8Count       = 0; 
.................... ////////     
.................... ////////    g_ui8FlagSTXFound = FLAG_STX_NOT_FOUND; 
.................... ////////    g_ui8FlagETXFound = FLAG_ETX_NOT_FOUND; 
.................... ////////     
.................... ////////    // Step 1: Check for three consecutive STX 
.................... ////////    for (ui8CurPosition = 0; ui8CurPosition < g_ui8RCVQRear; ui8CurPosition++) 
.................... ////////    { 
.................... ////////        if (STX == g_ui8ArrRCVBuffer[ui8CurPosition]) 
.................... ////////        { 
.................... ////////            // Check for STX in Next two Position 
.................... ////////            if (STX == g_ui8ArrRCVBuffer[ui8CurPosition + 1] && 
.................... ////////                STX == g_ui8ArrRCVBuffer[ui8CurPosition + 2]) 
.................... ////////            { 
.................... ////////                // Got Three STXs 
.................... ////////                g_ui8FlagSTXFound = FLAG_STX_FOUND; 
.................... ////////                break; 
.................... ////////            } 
.................... ////////        } 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the Buffer exhausted and STX not found 
.................... ////////    if (ui8CurPosition == g_ui8RCVQRear) 
.................... ////////    { 
.................... ////////        // Update front and rear and exit, may be we got spurious data 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////     
.................... ////////    // Now Check for the ETX 
.................... ////////    if (ETX == g_ui8ArrRCVBuffer[ui8CurPosition + 2 + SIZE_IBU_SEND_RCV_ARRAY + 1]) 
.................... ////////    { 
.................... ////////        g_ui8FlagETXFound = FLAG_ETX_FOUND; 
.................... ////////    } 
.................... ////////    else 
.................... ////////    { 
.................... ////////        // No ETX Found 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////         
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // STX and ETX Both are found 
.................... ////////    // Now check MSG Type 
.................... ////////    if(IBU_MSG_TYPE_ACK == g_ui8ArrRCVBuffer[ui8CurPosition + 4]) 
.................... ////////    { 
.................... ////////        // This is an Acknowledgment Message 
.................... ////////        // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////        //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////        ProcessACK(g_ui8ArrRCVBuffer[ui8CurPosition + 3]); 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////        return; 
.................... ////////    } 
.................... ////////     
.................... ////////    // If the MSG is not ACK that means fresh MSG received 
.................... ////////    // Now check for CRC 
.................... ////////    // STX STX STX SEQ ACK D1 D2 D3 D4 D5 CRC1 CRC2 ETX ETX 
.................... ////////    //  0   1   2   3   4   5  6  7  8  9  10   11   12  13 
.................... ////////    for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY - 2; ui8Count++) 
.................... ////////    { 
.................... ////////        g_ui8TempRcvMSG[ui8Count] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////    } 
.................... ////////     
.................... //////////    g_ui8TempRcvMSG[ui8Count]     = 0; 
.................... //////////    g_ui8TempRcvMSG[ui8Count + 1] = 0; 
.................... ////////     
.................... ////////    // Calculate CRC 
.................... ////////    g_ui16CRCValue = calculateCrc(g_ui8TempRcvMSG, SIZE_IBU_SEND_RCV_ARRAY - 2); 
.................... ////////     
.................... ////////    // Validate CRC. 
.................... ////////    if(((g_ui16CRCValue >> 8) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1] && 
.................... ////////       ((g_ui16CRCValue >> 0) & 0xFF) == g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]) 
.................... ////////    { 
.................... ////////        // Insert the Message into IBU Receive Queue 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[0] = g_ui8TempRcvMSG[2]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[1] = g_ui8TempRcvMSG[3]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[2] = g_ui8TempRcvMSG[4]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[3] = g_ui8TempRcvMSG[5]; 
.................... ////////        g_stIBURcvData.g_ui8ArrIBUData[4] = g_ui8TempRcvMSG[6]; 
.................... //////// 
.................... ////////        // Insert Message into IBC Receive Queue 
.................... ////////        InsertIBUMsgQueue(&g_stIBURcvQueue, &g_stIBURcvData); 
.................... //////// 
.................... ////////        // Reset receive buffer. 
.................... ////////        ResetIBURcvBuffer(); 
.................... ////////         
.................... ////////        // Send Acknowledgment 
.................... ////////        g_ui8TempRcvMSG[1] = IBU_MSG_TYPE_ACK; 
.................... ////////        g_ui8TempRcvMSG[7] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count]; 
.................... ////////        g_ui8TempRcvMSG[8] = g_ui8ArrRCVBuffer[ui8CurPosition + 3 + ui8Count + 1]; 
.................... ////////         
.................... ////////        // No need to hold the Send Lock, because this function is called from main thread 
.................... ////////        // and only main thread can send IBU Data 
.................... ////////        // Send Start Text to protect spurious data. 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        fputc(STX, UART); 
.................... ////////        // Send Original Data. 
.................... ////////        for (ui8Count = 0; ui8Count < SIZE_IBU_SEND_RCV_ARRAY; ui8Count++) 
.................... ////////        { 
.................... ////////            fputc(g_ui8TempRcvMSG[ui8Count], UART); 
.................... ////////        } 
.................... ////////        fputc(ETX, UART); 
.................... ////////        fputc(ETX, UART); 
.................... ////////        delay_us(5); 
.................... ////////    } 
.................... ////////    else  // For Invalid CRC 
.................... ////////    { 
.................... ////////        // Receive message got corrupted 
.................... ////////        // Reset Receive MSG Array 
.................... ////////        g_ui8RCVQFront = 0; 
.................... ////////        g_ui8RCVQRear  = 0; 
.................... ////////    } 
.................... ////////     
.................... ////////    g_ui8RCVQFront = 0; 
.................... ////////    g_ui8RCVQRear  = 0; 
.................... ////////} 
....................  
.................... ////////#INT_RDA HIGH 
.................... ////////void uart1_Rx_isr(void) 
.................... ////////{ 
.................... ////////    // Receive byte from interrupt.    
.................... ////////    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //////// 
.................... ////////    // Clear interrupt. 
.................... ////////    clear_interrupt(INT_RDA); 
.................... ////////} 
.................... #define ETX_FOUND      1 
.................... #define ETX_NOT_FOUND  0 
.................... unsigned int8 g_ui8CompleteMSGFound = ETX_FOUND; 
....................  
.................... #INT_RDA HIGH 
.................... void uart1_Rx_isr(void) 
.................... { 
....................     // Receive byte from interrupt 
....................     if (-1 == g_stRcvQueue.m_ui8Front) 
....................     { 
....................         g_stRcvQueue.m_ui8Front = 0; 
....................     } 
....................     g_stRcvQueue.m_ui8Rear = (g_stRcvQueue.m_ui8Rear + 1) % SIZE_RCV_QUEUE; 
....................      
....................     g_stRcvQueue.m_ui8QArr[g_stRcvQueue.m_ui8Rear] = fgetc(UART); 
....................      
....................     // Clear interrupt 
....................     clear_interrupt(INT_RDA); 
....................      
....................  
.................... //    g_ui8ArrRCVBuffer[g_ui8RCVQRear++] = fgetc(UART); 
.................... //     
.................... //    if ( (g_ui8RCVQRear - g_ui8RCVQFront) > 14 && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 1] == ETX && 
.................... //        g_ui8ArrRCVBuffer[g_ui8RCVQRear - 2] == ETX  ) 
.................... //    { 
.................... //        g_ui8CompleteMSGFound = ETX_FOUND; 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... } 
....................  
.................... // Before 9.0 
.................... //#INT_RDA HIGH 
.................... //void uart1_Rx_isr(void) 
.................... //{ 
.................... //    // Receive byte from interrupt. 
.................... //    g_ui8IBUTempByte = fgetc(UART); 
.................... //     
.................... //    if(STX == g_ui8IBUTempByte)// && !g_fDataReady) 
.................... //    { 
.................... //        g_fDataReady = 1; 
.................... //        //disable_interrupts(INT_RDA3); 
.................... //    } 
.................... //    else if(g_fDataReady) 
.................... //    { 
.................... //        // Receive Original data byte. 
.................... //        g_stIBURcvData.g_ui8ArrIBUData[g_ui8IBURcvByteCount] = g_ui8IBUTempByte; 
.................... //         
.................... //        // Increment byte count. 
.................... //        g_ui8IBURcvByteCount++; 
.................... //         
.................... //        // Check if all bytes are received. 
.................... //        if(IBU_MSG_BYTE_COUNT == g_ui8IBURcvByteCount) 
.................... //        { 
.................... //            // Raise a flag to denote all data bytes are received..now process the data. 
.................... //            g_fIBUDataRcvStatus = IBU_RCV_COMPLETE; 
.................... //             
.................... //            // Reset Flag. 
.................... //            g_fDataReady = 0; 
.................... //             
.................... //            //enable_interrupts(INT_RDA3); 
.................... //            //clear_interrupt(INT_RDA3); 
.................... //        } 
.................... //    } 
.................... //    else 
.................... //    { 
.................... //        /* Do Nothing */ 
.................... //    } 
.................... // 
.................... //    // Clear interrupt. 
.................... //    clear_interrupt(INT_RDA); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif /* _VI_IBU_CONFIG_H_ */ 
....................  
.................... #include "vmM1Common.h" 
.................... /*  
....................  * File:   vmM1Common.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on July 8, 2019, 3:52 PM 
....................  */ 
....................  
.................... #ifndef VM_M1_COMMON_H 
.................... #define	VM_M1_COMMON_H 
....................  
.................... #include "time.h" 
.................... // ################ RS485 Related Inclusion Start ############################## 
....................  
.................... #define RS485_TX_BUFF_SIZE                      20 
.................... #define RS485_RX_BUFF_SIZE                      50 
....................  
.................... #define FLAG_RS485_DATA_READY                   1 
.................... #define FLAG_RS485_DATA_NOT_READY               0 
....................  
.................... #define FLAG_RS485_DATA_SEND_ON                 1 
.................... #define FLAG_RS485_DATA_SEND_DONE               2 
.................... #define FLAG_RS485_DATA_SEND_OFF                3 
....................  
.................... #define RS485_9600_1_BYTE_RCV_TIME              1040 
.................... #define RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT 9 
....................  
.................... #define DELAY_TIME_RTS_BEFORE                   1 
.................... #define DELAY_TIME_RTS_AFTER                    2 
....................  
.................... #define ISR_TOTAL_BYTE_RECEIVE_TIME             9 //5 
.................... #define ISR_RECEIVED_ALL_BYTE                   21 
.................... #define ISR_PROCESSED_ALL_BYTE                  22 
.................... #define ISR_IS_READY                            40 
.................... #define ISR_IS_NOT_READY                        41 
.................... #define ISR_TOTAL_8_BYTE_RECEIVE_TIME           3 //9 
.................... #define ISR_TOTAL_19_BYTE_RECEIVE_TIME          7//21 
....................  
.................... #define MODBUS_IS_VALID_SLAVE_ID                12 
.................... #define MODBUS_IS_NOT_VALID_SLAVE_ID            13 
.................... #define ISR_RECEIVED_ALL_BYTES                  21 
.................... #define ISR_PROCESSED_ALL_BYTES                 22 
....................  
.................... #define SINGLE_VARIETY_PRODUCTION               10 
.................... #define MULTI_VARIETY_PRODUCTION                11 
....................  
.................... // ################ RS485 Related Inclusion End ################################ 
....................  
.................... // ################ GPRS Related Inclusion Start ############################### 
....................  
.................... #define GPRS_CONNECTED                          1 
.................... #define GPRS_NOT_CONNECTED                      0 
....................  
.................... #define  GPRS_CONNECTION_FAILS                  30 
.................... #define  GPRS_HTTP_ENABLE_FAILS                 31 
.................... #define  GPRS_SET_BEARER_ID_FAILS               32 
.................... #define  GPRS_SET_WEB_SERVICE_URL_FAILS         33 
.................... #define  GPRS_START_HTTP_GET_SESSION_FAILS      34 
....................  
.................... // ############### GPRS Related Inclusion End ################################## 
....................  
....................  
.................... // ***************************************************************************** 
.................... // ****************** Global Variable Declarations ***************************** 
.................... // ***************************************************************************** 
....................  
.................... // ################### RS485 Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsReadyToReceiveByte                = ISR_IS_NOT_READY; 
.................... unsigned int8  g_ui8ISRReceiveByteTimeCounter         = 0; 
.................... unsigned int8  g_fISRAllByteReceived                  = ISR_PROCESSED_ALL_BYTE; 
....................  
.................... unsigned int8 g_RS485TxBuffer[RS485_TX_BUFF_SIZE] = {0}; 
.................... unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... unsigned int8  g_fRS485DataReady                  = FLAG_RS485_DATA_NOT_READY; 
.................... unsigned int8  g_ui8ByteToSend                    = 0; 
.................... unsigned int8  g_ui8fRS485DataSend                = FLAG_RS485_DATA_SEND_OFF; 
....................  
.................... unsigned int8  g_fIsValidSlaveID                      = MODBUS_IS_VALID_SLAVE_ID; 
.................... unsigned int16 g_ui16ISRAllBytesExpectedRcvTime        = 250; 
.................... unsigned int8  g_fISRReceivedByteStatus               = ISR_PROCESSED_ALL_BYTES; 
.................... unsigned int8  g_ui8UnexpectedSlaveIDIgnoreCounter    = 0; 
....................  
....................  
.................... // ################### RS485 Related Stuffs -> Ends ############################ 
....................  
.................... // ################### Timer Related Stuffs -> Starts ########################## 
....................  
.................... unsigned int8  g_fIsTimedOut                          = 0; 
....................  
.................... unsigned int16 g_ui16TimeOutMilliseconds              = 0; 
.................... unsigned int8  g_fShouldLookForTimeOut                = 0; 
....................  
.................... void SetTimeout(unsigned int8 ui8TimedOutSeconds) 
.................... { 
....................     // Convert timeout seconds into milliseconds 
....................     g_ui16TimeOutMilliseconds = ui8TimedOutSeconds * 1000; 
....................      
....................     // Set flag denoting now timer should look for timeout value 
....................     g_fShouldLookForTimeOut = 1; 
.................... } 
....................  
.................... #define MIN_DELAY               100 
.................... unsigned int8 g_ui8DelayLoopIncr  = 0; 
.................... unsigned int8 g_ui8DelayLoopCount  = 0; 
.................... void mz_delay_ms(unsigned int16 ui16Time) 
.................... { 
.................... 	g_ui8DelayLoopCount = ui16Time / MIN_DELAY; 
....................      
....................     for (g_ui8DelayLoopIncr = 0; g_ui8DelayLoopIncr < g_ui8DelayLoopCount; g_ui8DelayLoopIncr++) 
....................     { 
....................         delay_ms(MIN_DELAY); 
....................         restart_wdt(); 
....................     } 
.................... } 
....................  
.................... // ################### Timer Related Stuffs -> Ends ############################ 
....................  
....................  
.................... unsigned int32 g_ui32HookedUpTimeStampPerMinute = 0; 
....................  
.................... typedef struct _ST_LAN_DATA_HEADER 
.................... { 
....................     unsigned int8    m_ui8MachineID; 
....................     unsigned int16   m_ui16BasicMaterialStandard; 
....................     unsigned int16   m_ui16PipeSpecification; 
....................     unsigned int32   m_ui32MaxWeight; 
....................     unsigned int32   m_ui32MinWeight; 
....................      
.................... } ST_LAN_DATA_HEADER;  
....................  
.................... ST_LAN_DATA_HEADER       g_stLANDataHeader; 
....................  
.................... unsigned int8 g_fIsLastElementInGPRSQueue = 0; 
....................  
.................... struct_tm g_stHMITime; 
.................... struct_tm g_stHMITimeTemp; 
.................... struct_tm* g_pstHMITimeTemp = &g_stHMITimeTemp; 
.................... time_t g_ui32UnixTimeInSec = 0; 
....................  
.................... #endif	/* VM_M1_COMMON_H */ 
....................  
....................  
.................... #include "mzEEPROMConfig_MCU1.h" 
.................... /*  
....................  * File:   mzEEPROMConfig_MCU1.h 
....................  * Author: mrinmoy 
....................  * 
....................  * Created on January 10, 2020, 4:11 PM 
....................  */ 
....................  
.................... #ifndef MZ_EEPROM_CONFIG_MCU1_H 
.................... #define	MZ_EEPROM_CONFIG_MCU1_H 
....................  
.................... #include "../Common/vmEEPROMConfig.h" 
....................  
....................  
.................... #define  EEPROM_ADDRESS_FOR_MACHINE_ID                      10 
.................... #define  EEPROM_ADDRESS_FOR_INTERVAL                        12 
.................... #define  EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME               17 // 4-byte data. It will take 4 address memory block. 
.................... #define  EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID                 22 
....................  
.................... void WriteMachineIDToEEPROM(unsigned int8 ui8MachineID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID,ui8MachineID); 
.................... } 
....................  
....................  unsigned int8 ReadMachineIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8MachineID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8MachineID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_MACHINE_ID); 
....................      
....................     return ui8MachineID; 
.................... } 
....................   
....................  
....................  
.................... void WriteIntervalToEEPROM(unsigned int8 ui8IntervalTime) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL,ui8IntervalTime); 
.................... } 
....................  
....................  unsigned int8 ReadIntervalFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8DataSendInterval = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8DataSendInterval = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_INTERVAL); 
....................      
....................     return ui8DataSendInterval; 
.................... } 
....................  
....................   
.................... void WriteCurrentUnixTimeToEEPROM(unsigned int32 ui32CurrentUnixTime)  
.................... { 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8   ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     // Parse the MSB part of unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 16) & 0x0000FFFF); 
....................      
....................     // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
....................      
....................     // Increment address. 
....................     ui8EEPROMAddress += 2; 
....................      
....................     // Parse LSB part of the unix time register. 
....................     ui16Temp = (unsigned int16)((ui32CurrentUnixTime >> 0) & 0x0000FFFF); 
....................      
....................         // Write data in EEPROM. 
....................     WriteEEPROMInt16(ui8EEPROMAddress, ui16Temp); 
.................... } 
....................  
.................... unsigned int32 ReadStoredUnixTimeFromEEPROM(void) 
.................... { 
....................     unsigned int32 ui32StoredUnixTime = 0; 
....................     unsigned int16 ui16Temp = 0; 
....................     unsigned int8  ui8EEPROMAddress = 0; 
....................      
....................     ui8EEPROMAddress = EEPROM_ADDRESS_FOR_CURRENT_UNIX_TIME; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ui16Temp; 
....................      
....................     ui32StoredUnixTime = (ui32StoredUnixTime << 16); 
....................     ui8EEPROMAddress += 2; 
....................      
....................     ui16Temp = ReadEEPROMInt16(ui8EEPROMAddress); 
....................     ui32StoredUnixTime = ((ui32StoredUnixTime & 0xFFFF0000) | ui16Temp); 
....................      
....................      
....................     // This stored data may be fresh or may be 1 minute past time. 
....................     // To covered up we manipulate it; we add 30 seconds with stored time. 
....................     ui32StoredUnixTime = ui32StoredUnixTime + 30; 
....................      
....................     return ui32StoredUnixTime;     
.................... } 
....................  
.................... void WriteSIMOperatorIDToEEPROM(unsigned int8 ui8SIMOperatorID) 
.................... { 
....................     // Write the data into memory. 
....................     WriteEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID,ui8SIMOperatorID);     
.................... } 
....................  
....................  
.................... unsigned int8 ReadSIMOPeratorIDFromEEPROM(void) 
.................... { 
....................     unsigned int8 ui8SIMOperatorID = 0; 
....................      
....................     // Fetch Machine ID from memory. 
....................     ui8SIMOperatorID = ReadEEPROMInt8(EEPROM_ADDRESS_FOR_SIM_OPERATOR_ID); 
....................      
....................     return ui8SIMOperatorID;     
.................... } 
....................      
....................  
.................... #endif	/* MZ_EEPROM_CONFIG_MCU1_H */ 
....................  
....................  
....................  
....................  
.................... //#define PIN_HIGH     			0 
.................... //#define PIN_LOW      			1 
....................  
.................... #define SLAVE_ID                                            0x1 
....................  
.................... #define MODE_ADDRESS                                        0x05 
.................... #define ADDRESS_FOR_SELECT_PRODUCTION_TYPE                  0x04 
.................... #define ADDRESS_FOR_SCRAP_ON_MODE                           0x99 
.................... #define ADRESS_FOR_HMI_TIMESTAMP                            0x47 
.................... #define ADDRESS_FOR_MACHINE_ID                              0x90 
....................  
....................  
.................... #define ADDRESS_FOR_SET_LOAD_CELL_FACTOR                    0x282 
.................... #define ADDRESS_FOR_CALIB_TARE_ADC_VALUE                    0x296 
.................... #define ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE                  0x298 
....................  
.................... #define ADDRESS_FOR_CURRENT_CALIBRATION_WT                  0x310 
.................... #define ADDRESS_FOR_START_CALIBRATION                       0x299 
.................... #define ADDRESS_FOR_RUNNING_VAR_PROD_DETAILS                0x420 
.................... #define ADDRESS_FOR_SELECTED_PRODUCT_INDEX                  0x540 
.................... #define ADDRESS_FOR_CURRENT_CBB_PRODUCT_INDEX               0x250  
....................  
.................... // use for production 
.................... #define ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION                 0x560 
.................... #define ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION                0x562 
.................... #define ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION            0x564 // SET 1 for accept 
.................... #define ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION            0x566 
.................... #define ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION                0x568 
.................... #define ADDRESS_FOR_WRITE_TARE_VALUE                        0x570 
.................... #define ADDRESS_FOR_HMI_DATA_UPDATE_TRIGGER                 0x760 
....................  
.................... // use for preproduction 
.................... #define ADDRESS_FOR_PRODUCTION_INDEX_PRE_PRODUCTION         0x500 
.................... #define ADDRESS_FOR_PRODUCTION_AVG_WT_PRE_PRODUCTION        0x550 
.................... #define ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION        0x552 
.................... #define ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION        0x554 
....................  
.................... #define ADDRESS_FOR_CALCULATED_MIN_MAX_WT                   0x50 
.................... #define ADDRESS_FOR_TOL_STORE_SEEKING_ACK                   0x88 
.................... #define ADDRESS_FOR_TOL_STORE_SETTING_ACK                   0x89 
.................... #define ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD         0x190 
.................... #define ADDRESS_FOR_PIPE_SPECIFICATION                      0x193 
.................... #define ADDRESS_FOR_PRE_PROD_MAX_MIN_WT                     0x52 
.................... #define ADDRESS_FOR_AT_OK_TIMER_SETTING                     0x53 
.................... #define ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING          0x54 
.................... #define ADDRESS_FOR_HTTP_GET_SESSION_TIMER_SETTING          0x55 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_TIMER_SETTING      0x56 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_NETWORK_RECONNECTION_HALT_TIME      0x57 
.................... #define ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME                0x58 
.................... #define ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME           0x59 
.................... #define ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME                0x60 
.................... #define ADDRESS_FOR_WIRELESS_MODEM_RESET_INTERVAL_TIME      0x61 
.................... #define ADDRESS_FOR_SHIFT_NUMBER                            0x62 
.................... #define ADDRESS_FOR_SHIFT_DURATION                          0x63 
.................... #define ADDRESS_FOR_SELECT_SIM_OPERATOR                     0x64 
.................... #define ADDRESS_FOR_AIR_PRESSURE_ALARM                      0x65 
.................... #define ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY   0x66 
....................  
.................... // use for calibration type set 
.................... #define ADDRESS_FOR_CALIBRATION_TYPE                        0x710 
.................... #define ADDRESS_FOR_AUTO_CALIB_SAMPLE_COUNT                 0x711 
....................  
.................... // RS485 Communication related stuff 
.................... #define SIZE_RS485_RX_BUFF                                  50 
.................... #define SIZE_RS485_TX_BUFF                                  50 
.................... #define ISR_1ST_BYTE_RECEIVED                               0 
.................... #define ISR_1ST_BYTE_PROCESSED                              1 
.................... #define MODBUS_FNCODE_READ_COIL_STATUS                      1 
.................... #define MODBUS_FNCODE_READ_HOLDING_REGISTER                 3 
.................... #define MODBUS_FNCODE_WRITE_SINGLE_REGISTER                 6 
.................... #define MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER               16 
.................... #define MODBUS_SINGLE_REG_READ_WRITE_RX_BYTE_COUNT          8 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_READ                  9 
.................... #define MODBUS_RESPONSE_TO_MASTER_FOR_WRITE                 10 
.................... #define MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL            0 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #define SIZE_TEMP_ARR_CRC_VALID                        15 
.................... #define MSG_QUEUE_EMPTY                                 0 
.................... #define MSG_QUEUE_NOT_EMPTY                             1 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIN                  8 
.................... #define MODBUS_MASTER_QUERY_LENGTH_MIX                 12 
.................... #define MODBUS_MASTER_QUERY_READ_REG_LENGTH             8 
.................... #define MODBUS_MASTER_QUERY_SINGLE_WRITE_REG_LENGTH     8 
....................  
.................... #define STATUS_ON                                       10 
.................... #define STATUS_OFF                                      11 
....................  
....................  
.................... //#define RS485_RX_BUFF_SIZE 		50 
....................  
.................... //unsigned int8 g_RS485RxBuffer[RS485_RX_BUFF_SIZE] = {0}; 
....................  
.................... typedef struct _ST_ISR_QUEUE_MEMBERS 
.................... { 
....................     unsigned int8 m_ui8Arr[RS485_RX_BUFF_SIZE]; 
....................     int8 m_i8Front; 
....................     int8 m_i8Rear; 
....................      
.................... }ST_ISR_QUEUE_MEMBERS; 
....................  
....................  
.................... //ST_ISR_QUEUE_MEMBERS g_stUART2RcvBuffModbus; 
.................... unsigned int8 g_ui8TempByte = 0; 
.................... //unsigned int8 g_ui8TempArrForCRCValidation[SIZE_TEMP_ARR_CRC_VALID] = {0}; 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define REG_DATA_LO_TO_HI                       1 // 1 = lo byte first, 2 = lo byte last 
....................  
.................... unsigned int8 g_ui8RS485Rxbuffer[SIZE_RS485_RX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485Txbuffer[SIZE_RS485_TX_BUFF] = {0}; 
.................... unsigned int8 g_ui8RS485RxByteCount                  = 0; 
.................... unsigned int8 g_fModbusMultiRegWriteTimeCountStats   = STATUS_OFF; 
.................... unsigned int8 g_fISRFirstBytesStatus                 = ISR_1ST_BYTE_PROCESSED; 
....................  
.................... unsigned int8 g_ui8Test                  = 0; 
.................... unsigned int16 g_ui16BitFillingTemp      = 0; 
.................... unsigned int32 g_ui32BitFillingTemp      = 0; 
....................  
....................  
.................... // Initialize RS485 receive interrupt. 
.................... void InitRS485RxInterrupt(void) 
.................... { 
....................     // Enable interrupt.  
....................     clear_interrupt(INT_RDA3); 
*
005D2:  MOVLB  E
005D4:  MOVF   xEA,W
.................... 	enable_interrupts(INT_RDA3); 
005D6:  BSF    x2D.1
005D8:  MOVLB  0
005DA:  GOTO   4630 (RETURN)
.................... } 
....................  
.................... void ResetRS485RXBuffer(void) 
.................... { 
....................     // clear buffer. 
....................     memset(g_ui8RS485Rxbuffer, 0, SIZE_RS485_RX_BUFF); 
*
01750:  MOVLW  0B
01752:  MOVWF  FEA
01754:  MOVLW  7E
01756:  MOVWF  FE9
01758:  CLRF   00
0175A:  CLRF   02
0175C:  MOVLW  32
0175E:  MOVWF  01
01760:  CALL   09BE
....................     // Reset byte count. 
....................     g_ui8RS485RxByteCount = 0; 
01764:  MOVLB  B
01766:  CLRF   xE2
01768:  MOVLB  0
0176A:  RETURN 0
....................      
.................... } 
....................  
.................... #INT_RDA3 
.................... void RS485_RxByteReady_ISR3(void) 
*
0048E:  MOVLB  0
.................... { 
....................      
....................     // Checking for Is ISR ready flag. 
....................     if(ISR_IS_NOT_READY == g_fIsReadyToReceiveByte && g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
00490:  MOVF   3E,W
00492:  SUBLW  29
00494:  BNZ   04D6
00496:  MOVF   x8A,W
00498:  SUBLW  0C
0049A:  BNZ   04D6
....................     { 
....................         ++g_ui8Test; 
0049C:  MOVLB  B
0049E:  INCF   xE5,F
....................         g_ui8TempByte = fgetc(RS485); 
004A0:  MOVLB  0
004A2:  RCALL  040C
004A4:  MOVFF  01,B7D
....................          
....................         // Checking for is the request/response for valid slave..i.e. slaveID 
....................         if(SLAVE_ID == g_ui8TempByte) 
004A8:  MOVLB  B
004AA:  DECFSZ x7D,W
004AC:  BRA    04CA
....................         { 
....................             g_fIsReadyToReceiveByte = ISR_IS_READY; 
004AE:  MOVLW  28
004B0:  MOVWF  3E
....................             g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
004B2:  CLRF   03
004B4:  MOVF   xE2,W
004B6:  ADDLW  7E
004B8:  MOVWF  FE9
004BA:  MOVLW  0B
004BC:  ADDWFC 03,W
004BE:  MOVWF  FEA
004C0:  MOVFF  B7D,FEF
....................             g_ui8RS485RxByteCount++; 
004C4:  INCF   xE2,F
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_RECEIVED;             
004C6:  CLRF   xE4
....................         } 
004C8:  BRA    04D2
....................         else 
....................         { 
....................             // change flag status if slave id does not match. 
....................             g_fIsValidSlaveID = MODBUS_IS_NOT_VALID_SLAVE_ID; 
004CA:  MOVLW  0D
004CC:  MOVLB  0
004CE:  MOVWF  x8A
004D0:  MOVLB  B
....................         } 
....................  
....................     } 
004D2:  BRA    0598
004D4:  MOVLB  0
....................     else if(g_fIsValidSlaveID == MODBUS_IS_VALID_SLAVE_ID) 
004D6:  MOVF   x8A,W
004D8:  SUBLW  0C
004DA:  BNZ   059A
....................     { 
....................         g_ui8TempByte = fgetc(RS485); 
004DC:  RCALL  040C
004DE:  MOVFF  01,B7D
....................          
....................         // Checking for ISR 2nd received byte i.e. function code. 
....................         if(ISR_1ST_BYTE_RECEIVED == g_fISRFirstBytesStatus) 
004E2:  MOVLB  B
004E4:  MOVF   xE4,F
004E6:  BNZ   050E
....................         { 
....................             // change flag status. 
....................             g_fISRFirstBytesStatus = ISR_1ST_BYTE_PROCESSED; 
004E8:  MOVLW  01
004EA:  MOVWF  xE4
....................              
....................             // Set ISR all byte expected receive timing. 
....................             if(g_ui8TempByte == MODBUS_FNCODE_READ_HOLDING_REGISTER || g_ui8TempByte == MODBUS_FNCODE_WRITE_SINGLE_REGISTER) 
004EC:  MOVF   x7D,W
004EE:  SUBLW  03
004F0:  BZ    04F8
004F2:  MOVF   x7D,W
004F4:  SUBLW  06
004F6:  BNZ   0504
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_8_BYTE_RECEIVE_TIME; 
004F8:  MOVLB  0
004FA:  CLRF   x8C
004FC:  MOVLW  03
004FE:  MOVWF  x8B
....................             } 
00500:  BRA    0510
00502:  MOVLB  B
....................             else if(g_ui8TempByte == MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER) 
00504:  MOVF   x7D,W
00506:  SUBLW  10
00508:  BNZ   050E
....................             { 
....................                 // Set flag to calculate and  load receive time. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_ON; 
0050A:  MOVLW  0A
0050C:  MOVWF  xE3
....................                  
....................                 // Load the time. 
....................                 //g_ui16ISRAllBytesExpectedRcvTime = ISR_TOTAL_19_BYTE_RECEIVE_TIME; 
....................             } 
0050E:  MOVLB  0
....................             else 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................         } 
....................          
....................         // Check multi register receive time calculation status.(This will depend upon number of register requested for by master) 
....................         if(STATUS_ON == g_fModbusMultiRegWriteTimeCountStats) 
00510:  MOVLB  B
00512:  MOVF   xE3,W
00514:  SUBLW  0A
00516:  BNZ   057C
....................         { 
....................             // Check byte count. 
....................             if(7 == g_ui8RS485RxByteCount) 
00518:  MOVF   xE2,W
0051A:  SUBLW  07
0051C:  BNZ   057C
....................             { 
....................                 // Load the time. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (RS485_9600_1_BYTE_RCV_TIME * (RS485_MULTIPLE_REG_BASIC_RCV_BYTE_COUNT + g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1])); 
0051E:  MOVLW  01
00520:  SUBWF  xE2,W
00522:  CLRF   03
00524:  ADDLW  7E
00526:  MOVWF  FE9
00528:  MOVLW  0B
0052A:  ADDWFC 03,W
0052C:  MOVWF  FEA
0052E:  MOVF   FEF,W
00530:  ADDLW  09
00532:  MOVLB  C
00534:  MOVWF  x2B
00536:  MOVLW  04
00538:  MOVWF  x2D
0053A:  MOVLW  10
0053C:  MOVWF  x2C
0053E:  CLRF   x2F
00540:  MOVFF  C2B,C2E
00544:  MOVLB  0
00546:  RCALL  0426
00548:  MOVFF  02,8C
0054C:  MOVFF  01,8B
....................  
....................                 // Manipulate data. 
....................                 g_ui16ISRAllBytesExpectedRcvTime = (g_ui16ISRAllBytesExpectedRcvTime / 1000); 
00550:  MOVFF  8C,C2C
00554:  MOVFF  8B,C2B
00558:  MOVLW  03
0055A:  MOVLB  C
0055C:  MOVWF  x2E
0055E:  MOVLW  E8
00560:  MOVWF  x2D
00562:  MOVLB  0
00564:  RCALL  0448
00566:  MOVFF  02,8C
0056A:  MOVFF  01,8B
....................                 g_ui16ISRAllBytesExpectedRcvTime = g_ui16ISRAllBytesExpectedRcvTime + 2; 
0056E:  MOVLW  02
00570:  ADDWF  x8B,F
00572:  MOVLW  00
00574:  ADDWFC x8C,F
....................  
....................                 // Reset flag status. 
....................                 g_fModbusMultiRegWriteTimeCountStats = STATUS_OFF; 
00576:  MOVLW  0B
00578:  MOVLB  B
0057A:  MOVWF  xE3
....................             }             
....................         } 
....................          
....................         // Store the data byte in receive buffer. 
....................         g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount] = g_ui8TempByte; 
0057C:  CLRF   03
0057E:  MOVF   xE2,W
00580:  ADDLW  7E
00582:  MOVWF  FE9
00584:  MOVLW  0B
00586:  ADDWFC 03,W
00588:  MOVWF  FEA
0058A:  MOVFF  B7D,FEF
....................      
....................         // Increment receive byte count. 
....................         g_ui8RS485RxByteCount++; 
0058E:  INCF   xE2,F
....................          
....................         // Check received byte count with buffer size. 
....................         if(g_ui8RS485RxByteCount >= SIZE_RS485_RX_BUFF) 
00590:  MOVF   xE2,W
00592:  SUBLW  31
00594:  BC    0598
....................         { 
....................             // Reset byte count. 
....................             g_ui8RS485RxByteCount = 0; 
00596:  CLRF   xE2
....................         } 
....................      
....................     } 
00598:  MOVLB  0
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................      
....................     // TESTING 
....................     if(g_ui8RS485RxByteCount == 8) 
0059A:  MOVLB  B
0059C:  MOVF   xE2,W
0059E:  SUBLW  08
005A0:  BNZ   05A6
....................     { 
....................         g_ui8RS485RxByteCount = 8; 
005A2:  MOVLW  08
005A4:  MOVWF  xE2
....................     } 
....................      
....................      
.................... 	// Clear interrupt. 
.................... 	clear_interrupt(INT_RDA3); 
005A6:  MOVLB  E
005A8:  MOVF   xEA,W
005AA:  BCF    x37.1
005AC:  MOVLB  0
005AE:  GOTO   008A
.................... } 
....................  
.................... void SetProductSpecificationForServer(void) 
*
02A54:  MOVLB  B
02A56:  CLRF   xF9
02A58:  CLRF   xF8
02A5A:  CLRF   xFB
02A5C:  CLRF   xFA
02A5E:  MOVLW  0A
02A60:  MOVWF  xFC
.................... { 
....................     unsigned int16 ui162ndAPIParameter = 0; 
....................     unsigned int16 ui163rdAPIParameter = 0; 
....................     unsigned int8  ui8Multiplier       = 10; 
....................  
....................      
....................     // Accumulate individual data from HMI for server API string. 
....................     // Take basic material and standard of production. 
....................     ui162ndAPIParameter = g_ui8BasicMaterialStandard; 
02A62:  CLRF   xF9
02A64:  MOVFF  4F2,BF8
....................      
....................     // Now combine specification of that standard used. 
....................     if(g_ui8StandardSpecification <= 9) 
02A68:  MOVLB  4
02A6A:  MOVF   xF3,W
02A6C:  SUBLW  09
02A6E:  BNC   2A7A
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02A70:  MOVLW  0A
02A72:  MOVLB  B
02A74:  MOVWF  xFC
....................          
....................     } 
02A76:  BRA    2A86
02A78:  MOVLB  4
....................     else if(g_ui8StandardSpecification <= 99) 
02A7A:  MOVF   xF3,W
02A7C:  SUBLW  63
02A7E:  BNC   2A88
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02A80:  MOVLW  64
02A82:  MOVLB  B
02A84:  MOVWF  xFC
....................     } 
02A86:  MOVLB  4
02A88:  CLRF   19
02A8A:  BTFSC  FF2.7
02A8C:  BSF    19.7
02A8E:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     } 
....................      
....................     // Combine the two specification. 
....................     ui162ndAPIParameter = ui162ndAPIParameter * ui8Multiplier; 
02A90:  MOVFF  BF9,C2D
02A94:  MOVFF  BF8,C2C
02A98:  MOVLB  C
02A9A:  CLRF   x2F
02A9C:  MOVFF  BFC,C2E
02AA0:  MOVLB  0
02AA2:  CALL   0426
02AA6:  BTFSC  19.7
02AA8:  BSF    FF2.7
02AAA:  MOVFF  02,BF9
02AAE:  MOVFF  01,BF8
....................     ui162ndAPIParameter = ui162ndAPIParameter + g_ui8StandardSpecification; 
02AB2:  MOVLB  4
02AB4:  MOVF   xF3,W
02AB6:  MOVLB  B
02AB8:  ADDWF  xF8,F
02ABA:  MOVLW  00
02ABC:  ADDWFC xF9,F
....................  
....................     // Now combine Pressure rating specification used for for that standard. 
....................     if(g_ui8PressureRating <= 9) 
02ABE:  MOVLB  4
02AC0:  MOVF   xF4,W
02AC2:  SUBLW  09
02AC4:  BNC   2AD0
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02AC6:  MOVLW  0A
02AC8:  MOVLB  B
02ACA:  MOVWF  xFC
....................          
....................     } 
02ACC:  BRA    2ADC
02ACE:  MOVLB  4
....................     else if(g_ui8PressureRating <= 99) 
02AD0:  MOVF   xF4,W
02AD2:  SUBLW  63
02AD4:  BNC   2ADE
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02AD6:  MOVLW  64
02AD8:  MOVLB  B
02ADA:  MOVWF  xFC
....................     } 
02ADC:  MOVLB  4
02ADE:  CLRF   19
02AE0:  BTFSC  FF2.7
02AE2:  BSF    19.7
02AE4:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     }     
....................      
....................     // Now combine pressure specification of that production. 
....................     ui162ndAPIParameter = ui162ndAPIParameter * ui8Multiplier; 
02AE6:  MOVFF  BF9,C2D
02AEA:  MOVFF  BF8,C2C
02AEE:  MOVLB  C
02AF0:  CLRF   x2F
02AF2:  MOVFF  BFC,C2E
02AF6:  MOVLB  0
02AF8:  CALL   0426
02AFC:  BTFSC  19.7
02AFE:  BSF    FF2.7
02B00:  MOVFF  02,BF9
02B04:  MOVFF  01,BF8
....................     ui162ndAPIParameter = ui162ndAPIParameter + g_ui8PressureRating; 
02B08:  MOVLB  4
02B0A:  MOVF   xF4,W
02B0C:  MOVLB  B
02B0E:  ADDWF  xF8,F
02B10:  MOVLW  00
02B12:  ADDWFC xF9,F
....................      
....................     // second parameter of API string is ready. 
....................     // Put it at GPRS message header. 
....................     g_stLANDataHeader.m_ui16BasicMaterialStandard = ui162ndAPIParameter; 
02B14:  MOVFF  BF9,9B
02B18:  MOVFF  BF8,9A
....................      
....................     // Now make 3rd parameter of API string. 
....................     // Take pipe OD. 
....................     ui163rdAPIParameter = g_ui8PipeOD; 
02B1C:  CLRF   xFB
02B1E:  MOVFF  4F5,BFA
....................      
....................     // Now combine Pipe length used for for that standard. 
....................     if(g_ui8PipeLength <= 9) 
02B22:  MOVLB  4
02B24:  MOVF   xF6,W
02B26:  SUBLW  09
02B28:  BNC   2B34
....................     { 
....................         // One digit number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 10; 
02B2A:  MOVLW  0A
02B2C:  MOVLB  B
02B2E:  MOVWF  xFC
....................          
....................     } 
02B30:  BRA    2B40
02B32:  MOVLB  4
....................     else if(g_ui8PipeLength <= 99) 
02B34:  MOVF   xF6,W
02B36:  SUBLW  63
02B38:  BNC   2B42
....................     { 
....................         // Two digit  number. 
....................         // Set multiplier. 
....................         ui8Multiplier = 100;         
02B3A:  MOVLW  64
02B3C:  MOVLB  B
02B3E:  MOVWF  xFC
....................     } 
02B40:  MOVLB  4
02B42:  CLRF   19
02B44:  BTFSC  FF2.7
02B46:  BSF    19.7
02B48:  BCF    FF2.7
....................     else 
....................     { 
....................         /* Do Nothing */ 
....................     }     
....................      
....................     // Now combine pipe length. 
....................     ui163rdAPIParameter = ui163rdAPIParameter * ui8Multiplier; 
02B4A:  MOVFF  BFB,C2D
02B4E:  MOVFF  BFA,C2C
02B52:  MOVLB  C
02B54:  CLRF   x2F
02B56:  MOVFF  BFC,C2E
02B5A:  MOVLB  0
02B5C:  CALL   0426
02B60:  BTFSC  19.7
02B62:  BSF    FF2.7
02B64:  MOVFF  02,BFB
02B68:  MOVFF  01,BFA
....................     ui163rdAPIParameter = ui163rdAPIParameter + g_ui8PipeLength; 
02B6C:  MOVLB  4
02B6E:  MOVF   xF6,W
02B70:  MOVLB  B
02B72:  ADDWF  xFA,F
02B74:  MOVLW  00
02B76:  ADDWFC xFB,F
....................      
....................     // Third parameter is ready. 
....................     // Put it in GPRS message header. 
....................     g_stLANDataHeader.m_ui16PipeSpecification = ui163rdAPIParameter; 
02B78:  MOVFF  BFB,9D
02B7C:  MOVFF  BFA,9C
02B80:  MOVLB  0
02B82:  GOTO   3C84 (RETURN)
....................      
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void SendMulResponseToMaster(unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow) 
*
01A8C:  MOVLB  B
01A8E:  CLRF   xFD
01A90:  CLRF   xFE
01A92:  MOVLB  C
01A94:  CLRF   x00
01A96:  MOVLB  B
01A98:  CLRF   xFF
.................... { 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................          
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
01A9A:  CLRF   03
01A9C:  MOVF   xFE,W
01A9E:  ADDLW  B0
01AA0:  MOVWF  FE9
01AA2:  MOVLW  0B
01AA4:  ADDWFC 03,W
01AA6:  MOVWF  FEA
01AA8:  MOVLW  01
01AAA:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AAC:  INCF   xFE,F
....................     // Stuff  the function code. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
01AAE:  CLRF   03
01AB0:  MOVF   xFE,W
01AB2:  ADDLW  B0
01AB4:  MOVWF  FE9
01AB6:  MOVLW  0B
01AB8:  ADDWFC 03,W
01ABA:  MOVWF  FEA
01ABC:  MOVLW  03
01ABE:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AC0:  INCF   xFE,F
....................     // Stuff number of data bytes to follow. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01AC2:  CLRF   03
01AC4:  MOVF   xFE,W
01AC6:  ADDLW  B0
01AC8:  MOVWF  FE9
01ACA:  MOVLW  0B
01ACC:  ADDWFC 03,W
01ACE:  MOVWF  FEA
01AD0:  MOVFF  BFC,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AD4:  INCF   xFE,F
....................  
....................     // For CBB Count. Register-> 560 & 561 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 8) & 0xFF); 
01AD6:  CLRF   03
01AD8:  MOVF   xFE,W
01ADA:  ADDLW  B0
01ADC:  MOVWF  FE9
01ADE:  MOVLW  0B
01AE0:  ADDWFC 03,W
01AE2:  MOVWF  FEA
01AE4:  MOVFF  4BF,00
01AE8:  MOVLB  C
01AEA:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01AEE:  MOVLB  B
01AF0:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16PipeCount >> 0) & 0xFF); 
01AF2:  CLRF   03
01AF4:  MOVF   xFE,W
01AF6:  ADDLW  B0
01AF8:  MOVWF  FE9
01AFA:  MOVLW  0B
01AFC:  ADDWFC 03,W
01AFE:  MOVWF  FEA
01B00:  MOVFF  4BF,C04
01B04:  MOVFF  4BE,00
01B08:  MOVLB  C
01B0A:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B0E:  MOVLB  B
01B10:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01B12:  CLRF   03
01B14:  MOVF   xFE,W
01B16:  ADDLW  B0
01B18:  MOVWF  FE9
01B1A:  MOVLW  0B
01B1C:  ADDWFC 03,W
01B1E:  MOVWF  FEA
01B20:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B22:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01B24:  CLRF   03
01B26:  MOVF   xFE,W
01B28:  ADDLW  B0
01B2A:  MOVWF  FE9
01B2C:  MOVLW  0B
01B2E:  ADDWFC 03,W
01B30:  MOVWF  FEA
01B32:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B34:  INCF   xFE,F
....................      
....................     // For Current CBB Weight. Register-> 562 & 563 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32CurrentWt << 16) & 0xFFFF0000); 
01B36:  MOVFF  4C3,BEB
01B3A:  MOVFF  4C2,BEA
01B3E:  MOVLB  C
01B40:  CLRF   00
01B42:  CLRF   01
01B44:  MOVFF  01,BE9
01B48:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01B4C:  MOVFF  BEA,BE6
01B50:  MOVFF  BEB,BE7
01B54:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01B56:  CLRF   03
01B58:  MOVLB  B
01B5A:  MOVF   xFE,W
01B5C:  ADDLW  B0
01B5E:  MOVWF  FE9
01B60:  MOVLW  0B
01B62:  ADDWFC 03,W
01B64:  MOVWF  FEA
01B66:  MOVFF  BE7,00
01B6A:  MOVLB  C
01B6C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B70:  MOVLB  B
01B72:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01B74:  CLRF   03
01B76:  MOVF   xFE,W
01B78:  ADDLW  B0
01B7A:  MOVWF  FE9
01B7C:  MOVLW  0B
01B7E:  ADDWFC 03,W
01B80:  MOVWF  FEA
01B82:  MOVFF  BE7,C04
01B86:  MOVFF  BE6,00
01B8A:  MOVLB  C
01B8C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01B90:  MOVLB  B
01B92:  INCF   xFE,F
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32CurrentWt >> 16) & 0xFFFF); 
01B94:  MOVFF  4C4,BE6
01B98:  MOVFF  4C5,BE7
01B9C:  MOVLB  C
01B9E:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01BA0:  CLRF   03
01BA2:  MOVLB  B
01BA4:  MOVF   xFE,W
01BA6:  ADDLW  B0
01BA8:  MOVWF  FE9
01BAA:  MOVLW  0B
01BAC:  ADDWFC 03,W
01BAE:  MOVWF  FEA
01BB0:  MOVFF  BE7,00
01BB4:  MOVLB  C
01BB6:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BBA:  MOVLB  B
01BBC:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01BBE:  CLRF   03
01BC0:  MOVF   xFE,W
01BC2:  ADDLW  B0
01BC4:  MOVWF  FE9
01BC6:  MOVLW  0B
01BC8:  ADDWFC 03,W
01BCA:  MOVWF  FEA
01BCC:  MOVFF  BE7,C04
01BD0:  MOVFF  BE6,00
01BD4:  MOVLB  C
01BD6:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BDA:  MOVLB  B
01BDC:  INCF   xFE,F
....................  
....................     // For Pass CBB Status. Register-> 564 & 565 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 8) & 0xFF); 
01BDE:  CLRF   03
01BE0:  MOVF   xFE,W
01BE2:  ADDLW  B0
01BE4:  MOVWF  FE9
01BE6:  MOVLW  0B
01BE8:  ADDWFC 03,W
01BEA:  MOVWF  FEA
01BEC:  MOVFF  4C7,00
01BF0:  MOVLB  C
01BF2:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01BF6:  MOVLB  B
01BF8:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16CurrentPassStatus >> 0) & 0xFF); 
01BFA:  CLRF   03
01BFC:  MOVF   xFE,W
01BFE:  ADDLW  B0
01C00:  MOVWF  FE9
01C02:  MOVLW  0B
01C04:  ADDWFC 03,W
01C06:  MOVWF  FEA
01C08:  MOVFF  4C7,C04
01C0C:  MOVFF  4C6,00
01C10:  MOVLB  C
01C12:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C16:  MOVLB  B
01C18:  INCF   xFE,F
....................      
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01C1A:  CLRF   03
01C1C:  MOVF   xFE,W
01C1E:  ADDLW  B0
01C20:  MOVWF  FE9
01C22:  MOVLW  0B
01C24:  ADDWFC 03,W
01C26:  MOVWF  FEA
01C28:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C2A:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = 0; 
01C2C:  CLRF   03
01C2E:  MOVF   xFE,W
01C30:  ADDLW  B0
01C32:  MOVWF  FE9
01C34:  MOVLW  0B
01C36:  ADDWFC 03,W
01C38:  MOVWF  FEA
01C3A:  CLRF   FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01C3C:  INCF   xFE,F
....................  
....................     // For Production Running Average. Register-> 566 & 567 
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningAvgWt << 16) & 0xFFFF0000); 
01C3E:  MOVFF  4C9,BEB
01C42:  MOVFF  4C8,BEA
01C46:  MOVLB  C
01C48:  CLRF   00
01C4A:  CLRF   01
01C4C:  MOVFF  01,BE9
01C50:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01C54:  MOVFF  BEA,BE6
01C58:  MOVFF  BEB,BE7
01C5C:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01C5E:  CLRF   03
01C60:  MOVLB  B
01C62:  MOVF   xFE,W
01C64:  ADDLW  B0
01C66:  MOVWF  FE9
01C68:  MOVLW  0B
01C6A:  ADDWFC 03,W
01C6C:  MOVWF  FEA
01C6E:  MOVFF  BE7,00
01C72:  MOVLB  C
01C74:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C78:  MOVLB  B
01C7A:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01C7C:  CLRF   03
01C7E:  MOVF   xFE,W
01C80:  ADDLW  B0
01C82:  MOVWF  FE9
01C84:  MOVLW  0B
01C86:  ADDWFC 03,W
01C88:  MOVWF  FEA
01C8A:  MOVFF  BE7,C04
01C8E:  MOVFF  BE6,00
01C92:  MOVLB  C
01C94:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01C98:  MOVLB  B
01C9A:  INCF   xFE,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningAvgWt >> 16) & 0xFFFF); 
01C9C:  MOVFF  4CA,BE6
01CA0:  MOVFF  4CB,BE7
01CA4:  MOVLB  C
01CA6:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01CA8:  CLRF   03
01CAA:  MOVLB  B
01CAC:  MOVF   xFE,W
01CAE:  ADDLW  B0
01CB0:  MOVWF  FE9
01CB2:  MOVLW  0B
01CB4:  ADDWFC 03,W
01CB6:  MOVWF  FEA
01CB8:  MOVFF  BE7,00
01CBC:  MOVLB  C
01CBE:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01CC2:  MOVLB  B
01CC4:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01CC6:  CLRF   03
01CC8:  MOVF   xFE,W
01CCA:  ADDLW  B0
01CCC:  MOVWF  FE9
01CCE:  MOVLW  0B
01CD0:  ADDWFC 03,W
01CD2:  MOVWF  FEA
01CD4:  MOVFF  BE7,C04
01CD8:  MOVFF  BE6,00
01CDC:  MOVLB  C
01CDE:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01CE2:  MOVLB  B
01CE4:  INCF   xFE,F
....................      
....................     // For Running Tare Weight. Register-> 568 & 569 
....................     // Example: If the four bytes are like 1234 then it will be filled as 3412  
....................     // Hold the MSB first 
....................     g_ui32BitFillingTemp = (unsigned int32)((g_ui32RunningTareValue << 16) & 0xFFFF0000); 
01CE6:  MOVFF  4CD,BEB
01CEA:  MOVFF  4CC,BEA
01CEE:  MOVLB  C
01CF0:  CLRF   00
01CF2:  CLRF   01
01CF4:  MOVFF  01,BE9
01CF8:  MOVFF  00,BE8
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32BitFillingTemp >> 16) & 0x0000FFFF); 
01CFC:  MOVFF  BEA,BE6
01D00:  MOVFF  BEB,BE7
01D04:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF); 
01D06:  CLRF   03
01D08:  MOVLB  B
01D0A:  MOVF   xFE,W
01D0C:  ADDLW  B0
01D0E:  MOVWF  FE9
01D10:  MOVLW  0B
01D12:  ADDWFC 03,W
01D14:  MOVWF  FEA
01D16:  MOVFF  BE7,00
01D1A:  MOVLB  C
01D1C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D20:  MOVLB  B
01D22:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF); 
01D24:  CLRF   03
01D26:  MOVF   xFE,W
01D28:  ADDLW  B0
01D2A:  MOVWF  FE9
01D2C:  MOVLW  0B
01D2E:  ADDWFC 03,W
01D30:  MOVWF  FEA
01D32:  MOVFF  BE7,C04
01D36:  MOVFF  BE6,00
01D3A:  MOVLB  C
01D3C:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D40:  MOVLB  B
01D42:  INCF   xFE,F
....................      
....................     g_ui16BitFillingTemp = (unsigned int16)((g_ui32RunningTareValue >> 16) & 0xFFFF); 
01D44:  MOVFF  4CE,BE6
01D48:  MOVFF  4CF,BE7
01D4C:  MOVLB  C
01D4E:  CLRF   03
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 8) & 0xFF);; 
01D50:  CLRF   03
01D52:  MOVLB  B
01D54:  MOVF   xFE,W
01D56:  ADDLW  B0
01D58:  MOVWF  FE9
01D5A:  MOVLW  0B
01D5C:  ADDWFC 03,W
01D5E:  MOVWF  FEA
01D60:  MOVFF  BE7,00
01D64:  MOVLB  C
01D66:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D6A:  MOVLB  B
01D6C:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((g_ui16BitFillingTemp >> 0) & 0xFF);; 
01D6E:  CLRF   03
01D70:  MOVF   xFE,W
01D72:  ADDLW  B0
01D74:  MOVWF  FE9
01D76:  MOVLW  0B
01D78:  ADDWFC 03,W
01D7A:  MOVWF  FEA
01D7C:  MOVFF  BE7,C04
01D80:  MOVFF  BE6,00
01D84:  MOVLB  C
01D86:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
01D8A:  MOVLB  B
01D8C:  INCF   xFE,F
....................      
....................     // CRC calculation. 
....................     ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
01D8E:  MOVLW  0B
01D90:  MOVLB  C
01D92:  MOVWF  x0C
01D94:  MOVLW  B0
01D96:  MOVWF  x0B
01D98:  MOVFF  BFE,C0D
01D9C:  MOVLB  0
01D9E:  CALL   0B00
01DA2:  MOVFF  02,C00
01DA6:  MOVFF  01,BFF
....................  
....................     // Stuff CRC 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
01DAA:  CLRF   03
01DAC:  MOVLB  B
01DAE:  MOVF   xFE,W
01DB0:  ADDLW  B0
01DB2:  MOVWF  FE9
01DB4:  MOVLW  0B
01DB6:  ADDWFC 03,W
01DB8:  MOVWF  FEA
01DBA:  MOVFF  BFF,00
01DBE:  MOVLB  C
01DC0:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;                 
01DC4:  MOVLB  B
01DC6:  INCF   xFE,F
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01DC8:  CLRF   03
01DCA:  MOVF   xFE,W
01DCC:  ADDLW  B0
01DCE:  MOVWF  FE9
01DD0:  MOVLW  0B
01DD2:  ADDWFC 03,W
01DD4:  MOVWF  FEA
01DD6:  MOVLB  C
01DD8:  MOVFF  C00,00
01DDC:  MOVFF  00,FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++;  
01DE0:  MOVLB  B
01DE2:  INCF   xFE,F
....................      
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01DE4:  BSF    F7F.0
01DE6:  BCF    F87.0
....................     delay_ms(2); 
01DE8:  MOVLW  02
01DEA:  MOVLB  C
01DEC:  MOVWF  x0B
01DEE:  MOVLB  0
01DF0:  RCALL  176C
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01DF2:  MOVLB  B
01DF4:  CLRF   xFD
01DF6:  MOVF   xFE,W
01DF8:  SUBWF  xFD,W
01DFA:  BC    1E1C
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01DFC:  CLRF   03
01DFE:  MOVF   xFD,W
01E00:  ADDLW  B0
01E02:  MOVWF  FE9
01E04:  MOVLW  0B
01E06:  ADDWFC 03,W
01E08:  MOVWF  FEA
01E0A:  MOVFF  FEF,C01
01E0E:  MOVLB  C
01E10:  MOVF   x01,W
01E12:  MOVLB  0
01E14:  RCALL  179C
01E16:  MOVLB  B
01E18:  INCF   xFD,F
01E1A:  BRA    1DF6
....................     } 
....................      
....................     delay_ms(3); 
01E1C:  MOVLW  03
01E1E:  MOVLB  C
01E20:  MOVWF  x0B
01E22:  MOVLB  0
01E24:  RCALL  176C
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0);     
01E26:  BCF    F7F.0
01E28:  BCF    F87.0
01E2A:  GOTO   2DC2 (RETURN)
....................      
.................... } 
....................  
.................... void SendResponseToMaster(unsigned int8 ui8ResponseType, unsigned int8 ui8FuncCode, unsigned int16 ui16StartAddress, unsigned int8 ui8DataBytesToFollow, int32 ui32RegData) 
*
017A8:  MOVLB  C
017AA:  CLRF   x04
017AC:  CLRF   x03
017AE:  CLRF   x06
017B0:  CLRF   x05
017B2:  CLRF   x07
017B4:  CLRF   x08
017B6:  CLRF   x0A
017B8:  CLRF   x09
.................... { 
....................     unsigned int16 ui16NoOfRegisterToFollow = 0; 
....................     unsigned int16 ui16CRCValue             = 0; 
....................     unsigned int8  ui8SendByteCount         = 0; 
....................     unsigned int8  ui8DataBytesToSend       = 0; 
....................     unsigned int16 ui16RegisterData         = 0; 
....................      
....................     // Stuff generic slave ID for all responses. 
....................     g_ui8RS485Txbuffer[ui8DataBytesToSend] = SLAVE_ID; 
017BA:  CLRF   03
017BC:  MOVF   x08,W
017BE:  ADDLW  B0
017C0:  MOVWF  FE9
017C2:  MOVLW  0B
017C4:  ADDWFC 03,W
017C6:  MOVWF  FEA
017C8:  MOVLW  01
017CA:  MOVWF  FEF
....................     // Increment counter. 
....................     ui8DataBytesToSend++; 
017CC:  INCF   x08,F
....................      
....................     // Step 1: Parse response type 
....................     if(MODBUS_RESPONSE_TO_MASTER_FOR_READ == ui8ResponseType) 
017CE:  MOVLB  B
017D0:  MOVF   xFA,W
017D2:  SUBLW  09
017D4:  BTFSS  FD8.2
017D6:  BRA    193A
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
017D8:  MOVF   xFB,W
017DA:  XORLW  03
017DC:  MOVLB  0
017DE:  BZ    17E2
017E0:  BRA    1934
....................         { 
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Stuff  the function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = MODBUS_FNCODE_READ_HOLDING_REGISTER; 
017E2:  CLRF   03
017E4:  MOVLB  C
017E6:  MOVF   x08,W
017E8:  ADDLW  B0
017EA:  MOVWF  FE9
017EC:  MOVLW  0B
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVLW  03
017F4:  MOVWF  FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
017F6:  INCF   x08,F
....................                  
....................                 // Parse the no of registers to response 
....................                 if(2 == ui8DataBytesToFollow) // For WORD. 
017F8:  MOVLB  B
017FA:  MOVF   xFE,W
017FC:  SUBLW  02
017FE:  BNZ   1852
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01800:  CLRF   03
01802:  MOVLB  C
01804:  MOVF   x08,W
01806:  ADDLW  B0
01808:  MOVWF  FE9
0180A:  MOVLW  0B
0180C:  ADDWFC 03,W
0180E:  MOVWF  FEA
01810:  MOVFF  BFE,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
01814:  INCF   x08,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData); 
01816:  MOVFF  C00,C0A
0181A:  MOVFF  BFF,C09
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
0181E:  CLRF   03
01820:  MOVF   x08,W
01822:  ADDLW  B0
01824:  MOVWF  FE9
01826:  MOVLW  0B
01828:  ADDWFC 03,W
0182A:  MOVWF  FEA
0182C:  MOVFF  C0A,00
01830:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
01834:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
01836:  CLRF   03
01838:  MOVF   x08,W
0183A:  ADDLW  B0
0183C:  MOVWF  FE9
0183E:  MOVLW  0B
01840:  ADDWFC 03,W
01842:  MOVWF  FEA
01844:  MOVFF  C09,00
01848:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
0184C:  INCF   x08,F
....................                 } 
0184E:  BRA    18E0
01850:  MOVLB  B
....................                 else if(4 == ui8DataBytesToFollow) // For DOUBLE WORD 
01852:  MOVF   xFE,W
01854:  SUBLW  04
01856:  BNZ   18E2
....................                 { 
....................                     // Stuff number of data bytes to follow. 
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8DataBytesToFollow; 
01858:  CLRF   03
0185A:  MOVLB  C
0185C:  MOVF   x08,W
0185E:  ADDLW  B0
01860:  MOVWF  FE9
01862:  MOVLW  0B
01864:  ADDWFC 03,W
01866:  MOVWF  FEA
01868:  MOVFF  BFE,FEF
....................                     // Increment counter. 
....................                     ui8DataBytesToSend++; 
0186C:  INCF   x08,F
....................                     // Stuff the data. 
....................                     ui16RegisterData = (unsigned int16)(ui32RegData);  // 1st WORD of the DOUBLE WORD 
0186E:  MOVFF  C00,C0A
01872:  MOVFF  BFF,C09
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
01876:  CLRF   03
01878:  MOVF   x08,W
0187A:  ADDLW  B0
0187C:  MOVWF  FE9
0187E:  MOVLW  0B
01880:  ADDWFC 03,W
01882:  MOVWF  FEA
01884:  MOVFF  C0A,00
01888:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
0188C:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
0188E:  CLRF   03
01890:  MOVF   x08,W
01892:  ADDLW  B0
01894:  MOVWF  FE9
01896:  MOVLW  0B
01898:  ADDWFC 03,W
0189A:  MOVWF  FEA
0189C:  MOVFF  C09,00
018A0:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;  
018A4:  INCF   x08,F
....................                     ui16RegisterData = (unsigned int16)(ui32RegData >> 16);  // 2nd WORD of the DOUBLE WORD 
018A6:  MOVFF  C01,C09
018AA:  MOVFF  C02,C0A
018AE:  CLRF   03
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 8) & 0xFF); 
018B0:  CLRF   03
018B2:  MOVF   x08,W
018B4:  ADDLW  B0
018B6:  MOVWF  FE9
018B8:  MOVLW  0B
018BA:  ADDWFC 03,W
018BC:  MOVWF  FEA
018BE:  MOVFF  C0A,00
018C2:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++; 
018C6:  INCF   x08,F
....................                     g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16RegisterData >> 0) & 0xFF); 
018C8:  CLRF   03
018CA:  MOVF   x08,W
018CC:  ADDLW  B0
018CE:  MOVWF  FE9
018D0:  MOVLW  0B
018D2:  ADDWFC 03,W
018D4:  MOVWF  FEA
018D6:  MOVFF  C09,00
018DA:  MOVFF  00,FEF
....................                     //Increment counter.  
....................                     ui8DataBytesToSend++;                     
018DE:  INCF   x08,F
....................                 } 
018E0:  MOVLB  B
....................                 else 
....................                 { 
....................                     /* Do Nothing */ 
....................                 }  
....................                  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, ui8DataBytesToSend); 
018E2:  MOVLW  0B
018E4:  MOVLB  C
018E6:  MOVWF  x0C
018E8:  MOVLW  B0
018EA:  MOVWF  x0B
018EC:  MOVFF  C08,C0D
018F0:  MOVLB  0
018F2:  CALL   0B00
018F6:  MOVFF  02,C06
018FA:  MOVFF  01,C05
....................                  
....................                 // Stuff CRC value. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
018FE:  CLRF   03
01900:  MOVLB  C
01902:  MOVF   x08,W
01904:  ADDLW  B0
01906:  MOVWF  FE9
01908:  MOVLW  0B
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVFF  C05,00
01912:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01916:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01918:  CLRF   03
0191A:  MOVF   x08,W
0191C:  ADDLW  B0
0191E:  MOVWF  FE9
01920:  MOVLW  0B
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  MOVFF  C06,00
0192A:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0192E:  INCF   x08,F
....................                 break; 
01930:  BRA    1936
01932:  MOVLB  0
....................             default: 
....................                 break; 
01934:  MOVLB  C
....................         } 
....................     } 
01936:  BRA    1A4A
01938:  MOVLB  B
....................     else // Respond against write. 
....................     { 
....................         // Step 2: Parse function code 
....................         switch(ui8FuncCode) 
0193A:  MOVF   xFB,W
0193C:  XORLW  06
0193E:  MOVLB  0
01940:  BZ    1948
01942:  XORLW  16
01944:  BZ    196E
01946:  BRA    1A46
....................         { 
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Stuff reply in RS485 transmit buffer. 
....................                 memcpy(g_ui8RS485Txbuffer, g_ui8RS485Rxbuffer, g_ui8RS485RxByteCount); 
01948:  MOVLW  0B
0194A:  MOVWF  FEA
0194C:  MOVLW  B0
0194E:  MOVWF  FE9
01950:  MOVLW  0B
01952:  MOVWF  FE2
01954:  MOVLW  7E
01956:  MOVWF  FE1
01958:  MOVLB  B
0195A:  MOVF   xE2,W
0195C:  MOVWF  01
0195E:  BZ    1968
01960:  MOVFF  FE6,FEE
01964:  DECFSZ 01,F
01966:  BRA    1960
....................                 ui8DataBytesToSend = g_ui8RS485RxByteCount; 
01968:  MOVFF  BE2,C08
....................                 break; 
0196C:  BRA    1A48
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Stuff function code. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = ui8FuncCode; 
0196E:  CLRF   03
01970:  MOVLB  C
01972:  MOVF   x08,W
01974:  ADDLW  B0
01976:  MOVWF  FE9
01978:  MOVLW  0B
0197A:  ADDWFC 03,W
0197C:  MOVWF  FEA
0197E:  MOVFF  BFB,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++; 
01982:  INCF   x08,F
....................                  
....................                 // Stuff data address of the first register. 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 8) & 0xFF); 
01984:  CLRF   03
01986:  MOVF   x08,W
01988:  ADDLW  B0
0198A:  MOVWF  FE9
0198C:  MOVLW  0B
0198E:  ADDWFC 03,W
01990:  MOVWF  FEA
01992:  MOVFF  BFD,00
01996:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
0199A:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16StartAddress >> 0) & 0xFF); 
0199C:  CLRF   03
0199E:  MOVF   x08,W
019A0:  ADDLW  B0
019A2:  MOVWF  FE9
019A4:  MOVLW  0B
019A6:  ADDWFC 03,W
019A8:  MOVWF  FEA
019AA:  MOVFF  BFD,C0E
019AE:  MOVFF  BFC,00
019B2:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019B6:  INCF   x08,F
....................  
....................                 // Stuff no of registers written. 
....................                 ui16NoOfRegisterToFollow = (unsigned int16)(ui8DataBytesToFollow / 2); 
019B8:  BCF    FD8.0
019BA:  MOVLB  B
019BC:  RRCF   xFE,W
019BE:  MOVLB  C
019C0:  CLRF   x04
019C2:  MOVWF  x03
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 8) & 0xFF); 
019C4:  CLRF   03
019C6:  MOVF   x08,W
019C8:  ADDLW  B0
019CA:  MOVWF  FE9
019CC:  MOVLW  0B
019CE:  ADDWFC 03,W
019D0:  MOVWF  FEA
019D2:  MOVFF  C04,00
019D6:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019DA:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16NoOfRegisterToFollow >> 0) & 0xFF); 
019DC:  CLRF   03
019DE:  MOVF   x08,W
019E0:  ADDLW  B0
019E2:  MOVWF  FE9
019E4:  MOVLW  0B
019E6:  ADDWFC 03,W
019E8:  MOVWF  FEA
019EA:  MOVFF  C03,00
019EE:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
019F2:  INCF   x08,F
....................  
....................                 // CRC calculation. 
....................                 ui16CRCValue = calculateCrc(g_ui8RS485Txbuffer, 6); 
019F4:  MOVLW  0B
019F6:  MOVWF  x0C
019F8:  MOVLW  B0
019FA:  MOVWF  x0B
019FC:  MOVLW  06
019FE:  MOVWF  x0D
01A00:  MOVLB  0
01A02:  CALL   0B00
01A06:  MOVFF  02,C06
01A0A:  MOVFF  01,C05
....................                  
....................                 // Stuff CRC 
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 0) & 0xFF); 
01A0E:  CLRF   03
01A10:  MOVLB  C
01A12:  MOVF   x08,W
01A14:  ADDLW  B0
01A16:  MOVWF  FE9
01A18:  MOVLW  0B
01A1A:  ADDWFC 03,W
01A1C:  MOVWF  FEA
01A1E:  MOVFF  C05,00
01A22:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A26:  INCF   x08,F
....................                 g_ui8RS485Txbuffer[ui8DataBytesToSend] = (unsigned int8)((ui16CRCValue >> 8) & 0xFF); 
01A28:  CLRF   03
01A2A:  MOVF   x08,W
01A2C:  ADDLW  B0
01A2E:  MOVWF  FE9
01A30:  MOVLW  0B
01A32:  ADDWFC 03,W
01A34:  MOVWF  FEA
01A36:  MOVFF  C06,00
01A3A:  MOVFF  00,FEF
....................                 // Increment counter. 
....................                 ui8DataBytesToSend++;                 
01A3E:  INCF   x08,F
....................                  
....................                 break; 
01A40:  MOVLB  B
01A42:  BRA    1A48
01A44:  MOVLB  0
....................             default: 
....................                 break; 
01A46:  MOVLB  B
01A48:  MOVLB  C
....................         } 
....................     } 
....................      
....................     // Data Sending procedure. 
....................     // Make RTS pin transmit active. 
....................     output_bit(PIN_RS485_RTS, 1); 
01A4A:  BSF    F7F.0
01A4C:  BCF    F87.0
....................     delay_ms(2); 
01A4E:  MOVLW  02
01A50:  MOVWF  x0B
01A52:  MOVLB  0
01A54:  RCALL  176C
....................      
....................     // Send bytes. 
....................     for(ui8SendByteCount = 0; ui8SendByteCount < ui8DataBytesToSend; ui8SendByteCount++) 
01A56:  MOVLB  C
01A58:  CLRF   x07
01A5A:  MOVF   x08,W
01A5C:  SUBWF  x07,W
01A5E:  BC    1A7E
....................     { 
....................         fputc(g_ui8RS485Txbuffer[ui8SendByteCount], RS485); 
01A60:  CLRF   03
01A62:  MOVF   x07,W
01A64:  ADDLW  B0
01A66:  MOVWF  FE9
01A68:  MOVLW  0B
01A6A:  ADDWFC 03,W
01A6C:  MOVWF  FEA
01A6E:  MOVFF  FEF,C0B
01A72:  MOVF   x0B,W
01A74:  MOVLB  0
01A76:  RCALL  179C
01A78:  MOVLB  C
01A7A:  INCF   x07,F
01A7C:  BRA    1A5A
....................     } 
....................      
....................     delay_ms(3); 
01A7E:  MOVLW  03
01A80:  MOVWF  x0B
01A82:  MOVLB  0
01A84:  RCALL  176C
....................     // Make RTS pin transmit inactive..receive mode on. 
....................     output_bit(PIN_RS485_RTS, 0); 
01A86:  BCF    F7F.0
01A88:  BCF    F87.0
01A8A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void ProcessUART2ReceivedData(void) 
*
02B86:  MOVLB  B
02B88:  CLRF   xEE
02B8A:  CLRF   xED
02B8C:  CLRF   xEF
02B8E:  CLRF   xF1
02B90:  CLRF   xF0
02B92:  CLRF   xF3
02B94:  CLRF   xF2
02B96:  CLRF   xF4
02B98:  CLRF   xF5
02B9A:  CLRF   xF6
02B9C:  MOVLW  06
02B9E:  MOVWF  xF7
.................... { 
....................     unsigned int16 ui16ModbusCRCvalue       = 0; 
....................     unsigned int8  fIsValidCRC              = 0; 
....................     unsigned int16 ui16StartAddtess         = 0; 
....................     unsigned int16 ui16NoOfRegistersToRead  = 0; 
....................     unsigned int8  ui8LoopCount             = 0; 
....................     unsigned int8  ui8NoOfDataBytesToFollow = 0; 
....................     unsigned int8  ui8NoOfVariety           = 0; 
....................     unsigned int8  ui8WriteMulRegParseByteIndx = 6; 
....................      
....................  
....................     // Calculate CRC for data redundancy check. 
....................     // Calculate CRC with all bytes except last two. 
....................     ui16ModbusCRCvalue = calculateCrc(g_ui8RS485Rxbuffer, (g_ui8RS485RxByteCount - 2));     
02BA0:  MOVLW  02
02BA2:  SUBWF  xE2,W
02BA4:  MOVWF  xF8
02BA6:  MOVLW  0B
02BA8:  MOVLB  C
02BAA:  MOVWF  x0C
02BAC:  MOVLW  7E
02BAE:  MOVWF  x0B
02BB0:  MOVFF  BF8,C0D
02BB4:  MOVLB  0
02BB6:  CALL   0B00
02BBA:  MOVFF  02,BEE
02BBE:  MOVFF  01,BED
....................      
....................     // Validate CRC. 
....................     if(((ui16ModbusCRCvalue >> 8) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 1] && 
....................        ((ui16ModbusCRCvalue >> 0) & 0xFF) == g_ui8RS485Rxbuffer[g_ui8RS485RxByteCount - 2]) 
02BC2:  MOVFF  BEE,BF8
02BC6:  MOVLB  B
02BC8:  CLRF   xF9
02BCA:  MOVLW  01
02BCC:  SUBWF  xE2,W
02BCE:  CLRF   03
02BD0:  ADDLW  7E
02BD2:  MOVWF  FE9
02BD4:  MOVLW  0B
02BD6:  ADDWFC 03,W
02BD8:  MOVWF  FEA
02BDA:  MOVF   FEF,W
02BDC:  SUBWF  xEE,W
02BDE:  BNZ   2C0A
02BE0:  MOVF   xF9,F
02BE2:  BNZ   2C0A
02BE4:  MOVFF  BED,BF8
02BE8:  CLRF   xF9
02BEA:  MOVLW  02
02BEC:  SUBWF  xE2,W
02BEE:  CLRF   03
02BF0:  ADDLW  7E
02BF2:  MOVWF  FE9
02BF4:  MOVLW  0B
02BF6:  ADDWFC 03,W
02BF8:  MOVWF  FEA
02BFA:  MOVF   FEF,W
02BFC:  SUBWF  xED,W
02BFE:  BNZ   2C0A
02C00:  MOVF   xF9,F
02C02:  BNZ   2C0A
....................     { 
....................         // Set flag denoting received byte string CRC validation successful. 
....................         fIsValidCRC = 1; 
02C04:  MOVLW  01
02C06:  MOVWF  xEF
....................     } 
02C08:  BRA    2C12
....................     else 
....................     { 
....................         // Error occured in received data bytes 
....................         ResetRS485RXBuffer(); 
02C0A:  MOVLB  0
02C0C:  CALL   1750
02C10:  MOVLB  B
....................     } 
....................      
....................     // If CRC validation turns out to true. 
....................     if(fIsValidCRC) 
02C12:  MOVF   xEF,F
02C14:  BTFSC  FD8.2
02C16:  GOTO   3C88
....................     { 
....................         // Parse function code and process accordingly. 
....................         switch(g_ui8RS485Rxbuffer[1]) 
02C1A:  MOVF   x7F,W
02C1C:  XORLW  01
02C1E:  MOVLB  0
02C20:  BZ    2C38
02C22:  XORLW  02
02C24:  BZ    2C3C
02C26:  XORLW  05
02C28:  BTFSC  FD8.2
02C2A:  BRA    2FC4
02C2C:  XORLW  16
02C2E:  BTFSC  FD8.2
02C30:  GOTO   38CA
02C34:  GOTO   3C86
....................         { 
....................             case MODBUS_FNCODE_READ_COIL_STATUS: 
....................                  
....................                 break; 
02C38:  GOTO   3C86
....................             case MODBUS_FNCODE_READ_HOLDING_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02C3C:  MOVLB  B
02C3E:  CLRF   xF1
02C40:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02C44:  MOVFF  BF0,BF1
02C48:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02C4A:  MOVF   x81,W
02C4C:  IORWF  xF0,F
....................  
....................                 // Process the data at that address. 
....................                 switch(ui16StartAddtess) 
02C4E:  MOVF   xF0,W
02C50:  MOVWF  00
02C52:  MOVF   xF1,W
02C54:  MOVWF  03
02C56:  MOVLW  02
02C58:  SUBWF  03,W
02C5A:  BNZ   2C66
02C5C:  MOVLW  96
02C5E:  SUBWF  00,W
02C60:  MOVLB  0
02C62:  BZ    2CF2
02C64:  MOVLB  B
02C66:  MOVLW  02
02C68:  SUBWF  03,W
02C6A:  BNZ   2C76
02C6C:  MOVLW  98
02C6E:  SUBWF  00,W
02C70:  MOVLB  0
02C72:  BZ    2D3E
02C74:  MOVLB  B
02C76:  MOVLW  05
02C78:  SUBWF  03,W
02C7A:  BNZ   2C88
02C7C:  MOVLW  60
02C7E:  SUBWF  00,W
02C80:  MOVLB  0
02C82:  BTFSC  FD8.2
02C84:  BRA    2D8A
02C86:  MOVLB  B
02C88:  MOVLW  05
02C8A:  SUBWF  03,W
02C8C:  BNZ   2C9A
02C8E:  MOVLW  62
02C90:  SUBWF  00,W
02C92:  MOVLB  0
02C94:  BTFSC  FD8.2
02C96:  BRA    2DFE
02C98:  MOVLB  B
02C9A:  MOVLW  05
02C9C:  SUBWF  03,W
02C9E:  BNZ   2CAC
02CA0:  MOVLW  66
02CA2:  SUBWF  00,W
02CA4:  MOVLB  0
02CA6:  BTFSC  FD8.2
02CA8:  BRA    2E4A
02CAA:  MOVLB  B
02CAC:  MOVLW  05
02CAE:  SUBWF  03,W
02CB0:  BNZ   2CBE
02CB2:  MOVLW  68
02CB4:  SUBWF  00,W
02CB6:  MOVLB  0
02CB8:  BTFSC  FD8.2
02CBA:  BRA    2E96
02CBC:  MOVLB  B
02CBE:  MOVLW  05
02CC0:  SUBWF  03,W
02CC2:  BNZ   2CD0
02CC4:  MOVLW  64
02CC6:  SUBWF  00,W
02CC8:  MOVLB  0
02CCA:  BTFSC  FD8.2
02CCC:  BRA    2EE2
02CCE:  MOVLB  B
02CD0:  MOVF   03,W
02CD2:  BNZ   2CE0
02CD4:  MOVLW  88
02CD6:  SUBWF  00,W
02CD8:  MOVLB  0
02CDA:  BTFSC  FD8.2
02CDC:  BRA    2F2C
02CDE:  MOVLB  B
02CE0:  MOVF   03,W
02CE2:  BNZ   2CF0
02CE4:  MOVLW  65
02CE6:  SUBWF  00,W
02CE8:  MOVLB  0
02CEA:  BTFSC  FD8.2
02CEC:  BRA    2F74
02CEE:  MOVLB  B
02CF0:  BRA    2FBE
....................                 { 
....................                     case ADDRESS_FOR_CALIB_TARE_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02CF2:  MOVLB  B
02CF4:  CLRF   xF3
02CF6:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02CFA:  MOVFF  BF2,BF3
02CFE:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);   
02D00:  MOVF   x83,W
02D02:  IORWF  xF2,F
....................  
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32TareADCValueForCalibration); 
02D04:  BCF    FD8.0
02D06:  RLCF   xF2,W
02D08:  MOVWF  xF8
02D0A:  RLCF   xF3,W
02D0C:  MOVWF  xF9
02D0E:  MOVLW  09
02D10:  MOVWF  xFA
02D12:  MOVLW  03
02D14:  MOVWF  xFB
02D16:  MOVFF  BF1,BFD
02D1A:  MOVFF  BF0,BFC
02D1E:  MOVFF  BF8,BFE
02D22:  MOVFF  4B9,C02
02D26:  MOVFF  4B8,C01
02D2A:  MOVFF  4B7,C00
02D2E:  MOVFF  4B6,BFF
02D32:  MOVLB  0
02D34:  CALL   17A8
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02D38:  CALL   1750
....................                          
....................                         break; 
02D3C:  BRA    2FC0
....................                     case ADDRESS_FOR_CALIB_WEIGHT_ADC_VALUE: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02D3E:  MOVLB  B
02D40:  CLRF   xF3
02D42:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D46:  MOVFF  BF2,BF3
02D4A:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02D4C:  MOVF   x83,W
02D4E:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32gWeightADCValueForCalibration);                         
02D50:  BCF    FD8.0
02D52:  RLCF   xF2,W
02D54:  MOVWF  xF8
02D56:  RLCF   xF3,W
02D58:  MOVWF  xF9
02D5A:  MOVLW  09
02D5C:  MOVWF  xFA
02D5E:  MOVLW  03
02D60:  MOVWF  xFB
02D62:  MOVFF  BF1,BFD
02D66:  MOVFF  BF0,BFC
02D6A:  MOVFF  BF8,BFE
02D6E:  MOVFF  4BD,C02
02D72:  MOVFF  4BC,C01
02D76:  MOVFF  4BB,C00
02D7A:  MOVFF  4BA,BFF
02D7E:  MOVLB  0
02D80:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02D84:  CALL   1750
....................                          
....................                         break; 
02D88:  BRA    2FC0
....................                     case ADDRESS_FOR_CBB_COUNT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02D8A:  MOVLB  B
02D8C:  CLRF   xF3
02D8E:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02D92:  MOVFF  BF2,BF3
02D96:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02D98:  MOVF   x83,W
02D9A:  IORWF  xF2,F
....................  
....................                         // Check for number of registers requested for. 
....................                         if(ui16NoOfRegistersToRead > 1) 
02D9C:  MOVF   xF3,F
02D9E:  BNZ   2DA6
02DA0:  MOVF   xF2,W
02DA2:  SUBLW  01
02DA4:  BC    2DC6
....................                         { 
....................                             // Step 2: Send response to master with requested data. 
....................                             SendMulResponseToMaster(ui16StartAddtess, (ui16NoOfRegistersToRead * 2)); 
02DA6:  BCF    FD8.0
02DA8:  RLCF   xF2,W
02DAA:  MOVWF  xF8
02DAC:  RLCF   xF3,W
02DAE:  MOVWF  xF9
02DB0:  MOVFF  BF1,BFB
02DB4:  MOVFF  BF0,BFA
02DB8:  MOVFF  BF8,BFC
02DBC:  MOVLB  0
02DBE:  GOTO   1A8C
....................                         } 
02DC2:  BRA    2DF8
02DC4:  MOVLB  B
....................                         else 
....................                         {                         
....................                             // Step 2: Send response to master with requested data. 
....................                             SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16PipeCount);                                                 
02DC6:  BCF    FD8.0
02DC8:  RLCF   xF2,W
02DCA:  MOVWF  xF8
02DCC:  RLCF   xF3,W
02DCE:  MOVWF  xF9
02DD0:  MOVLW  09
02DD2:  MOVWF  xFA
02DD4:  MOVLW  03
02DD6:  MOVWF  xFB
02DD8:  MOVFF  BF1,BFD
02DDC:  MOVFF  BF0,BFC
02DE0:  MOVFF  BF8,BFE
02DE4:  MOVLB  C
02DE6:  CLRF   x02
02DE8:  CLRF   x01
02DEA:  MOVFF  4BF,C00
02DEE:  MOVFF  4BE,BFF
02DF2:  MOVLB  0
02DF4:  CALL   17A8
....................                         } 
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02DF8:  CALL   1750
....................                          
....................                         break; 
02DFC:  BRA    2FC0
....................                     case ADDRESS_FOR_CURRENT_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02DFE:  MOVLB  B
02E00:  CLRF   xF3
02E02:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02E06:  MOVFF  BF2,BF3
02E0A:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02E0C:  MOVF   x83,W
02E0E:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32CurrentWt);                                                                         
02E10:  BCF    FD8.0
02E12:  RLCF   xF2,W
02E14:  MOVWF  xF8
02E16:  RLCF   xF3,W
02E18:  MOVWF  xF9
02E1A:  MOVLW  09
02E1C:  MOVWF  xFA
02E1E:  MOVLW  03
02E20:  MOVWF  xFB
02E22:  MOVFF  BF1,BFD
02E26:  MOVFF  BF0,BFC
02E2A:  MOVFF  BF8,BFE
02E2E:  MOVFF  4C5,C02
02E32:  MOVFF  4C4,C01
02E36:  MOVFF  4C3,C00
02E3A:  MOVFF  4C2,BFF
02E3E:  MOVLB  0
02E40:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E44:  CALL   1750
....................                          
....................                         break; 
02E48:  BRA    2FC0
....................                     case ADDRESS_FOR_RUNNING_AVG_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02E4A:  MOVLB  B
02E4C:  CLRF   xF3
02E4E:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02E52:  MOVFF  BF2,BF3
02E56:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02E58:  MOVF   x83,W
02E5A:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningAvgWt);                                                                         
02E5C:  BCF    FD8.0
02E5E:  RLCF   xF2,W
02E60:  MOVWF  xF8
02E62:  RLCF   xF3,W
02E64:  MOVWF  xF9
02E66:  MOVLW  09
02E68:  MOVWF  xFA
02E6A:  MOVLW  03
02E6C:  MOVWF  xFB
02E6E:  MOVFF  BF1,BFD
02E72:  MOVFF  BF0,BFC
02E76:  MOVFF  BF8,BFE
02E7A:  MOVFF  4CB,C02
02E7E:  MOVFF  4CA,C01
02E82:  MOVFF  4C9,C00
02E86:  MOVFF  4C8,BFF
02E8A:  MOVLB  0
02E8C:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02E90:  CALL   1750
....................                          
....................                         break; 
02E94:  BRA    2FC0
....................                     case ADDRESS_FOR_TARE_VALUE_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02E96:  MOVLB  B
02E98:  CLRF   xF3
02E9A:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02E9E:  MOVFF  BF2,BF3
02EA2:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02EA4:  MOVF   x83,W
02EA6:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui32RunningTareValue);                                                                         
02EA8:  BCF    FD8.0
02EAA:  RLCF   xF2,W
02EAC:  MOVWF  xF8
02EAE:  RLCF   xF3,W
02EB0:  MOVWF  xF9
02EB2:  MOVLW  09
02EB4:  MOVWF  xFA
02EB6:  MOVLW  03
02EB8:  MOVWF  xFB
02EBA:  MOVFF  BF1,BFD
02EBE:  MOVFF  BF0,BFC
02EC2:  MOVFF  BF8,BFE
02EC6:  MOVFF  4CF,C02
02ECA:  MOVFF  4CE,C01
02ECE:  MOVFF  4CD,C00
02ED2:  MOVFF  4CC,BFF
02ED6:  MOVLB  0
02ED8:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02EDC:  CALL   1750
....................                          
....................                         break; 
02EE0:  BRA    2FC0
....................                     case ADDRESS_FOR_PASS_STATUS_WT_IN_PRODUCTION: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02EE2:  MOVLB  B
02EE4:  CLRF   xF3
02EE6:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02EEA:  MOVFF  BF2,BF3
02EEE:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02EF0:  MOVF   x83,W
02EF2:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui16CurrentPassStatus);                                                                         
02EF4:  BCF    FD8.0
02EF6:  RLCF   xF2,W
02EF8:  MOVWF  xF8
02EFA:  RLCF   xF3,W
02EFC:  MOVWF  xF9
02EFE:  MOVLW  09
02F00:  MOVWF  xFA
02F02:  MOVLW  03
02F04:  MOVWF  xFB
02F06:  MOVFF  BF1,BFD
02F0A:  MOVFF  BF0,BFC
02F0E:  MOVFF  BF8,BFE
02F12:  MOVLB  C
02F14:  CLRF   x02
02F16:  CLRF   x01
02F18:  MOVFF  4C7,C00
02F1C:  MOVFF  4C6,BFF
02F20:  MOVLB  0
02F22:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
02F26:  CALL   1750
....................                         break; 
02F2A:  BRA    2FC0
....................                     case ADDRESS_FOR_TOL_STORE_SEEKING_ACK: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02F2C:  MOVLB  B
02F2E:  CLRF   xF3
02F30:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02F34:  MOVFF  BF2,BF3
02F38:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]);                         
02F3A:  MOVF   x83,W
02F3C:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8ToleranceStoreAck); 
02F3E:  BCF    FD8.0
02F40:  RLCF   xF2,W
02F42:  MOVWF  xF8
02F44:  RLCF   xF3,W
02F46:  MOVWF  xF9
02F48:  MOVLW  09
02F4A:  MOVWF  xFA
02F4C:  MOVLW  03
02F4E:  MOVWF  xFB
02F50:  MOVFF  BF1,BFD
02F54:  MOVFF  BF0,BFC
02F58:  MOVFF  BF8,BFE
02F5C:  MOVLB  C
02F5E:  CLRF   x02
02F60:  CLRF   x01
02F62:  CLRF   x00
02F64:  MOVFF  4DD,BFF
02F68:  MOVLB  0
02F6A:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                          
02F6E:  CALL   1750
....................                         break; 
02F72:  BRA    2FC0
....................                     case ADDRESS_FOR_AIR_PRESSURE_ALARM: 
....................                         // Step 1: Accumulate number of registers to read. 
....................                         ui16NoOfRegistersToRead = g_ui8RS485Rxbuffer[4]; 
02F74:  MOVLB  B
02F76:  CLRF   xF3
02F78:  MOVFF  B82,BF2
....................                         ui16NoOfRegistersToRead = ((ui16NoOfRegistersToRead << 8) & 0xFF00); 
02F7C:  MOVFF  BF2,BF3
02F80:  CLRF   xF2
....................                         ui16NoOfRegistersToRead = (ui16NoOfRegistersToRead | g_ui8RS485Rxbuffer[5]); 
02F82:  MOVF   x83,W
02F84:  IORWF  xF2,F
....................                          
....................                         // Step 2: Send response to master with requested data. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_READ, MODBUS_FNCODE_READ_HOLDING_REGISTER, ui16StartAddtess, (ui16NoOfRegistersToRead * 2), g_ui8AirPressureAlarm); 
02F86:  BCF    FD8.0
02F88:  RLCF   xF2,W
02F8A:  MOVWF  xF8
02F8C:  RLCF   xF3,W
02F8E:  MOVWF  xF9
02F90:  MOVLW  09
02F92:  MOVWF  xFA
02F94:  MOVLW  03
02F96:  MOVWF  xFB
02F98:  MOVFF  BF1,BFD
02F9C:  MOVFF  BF0,BFC
02FA0:  MOVFF  BF8,BFE
02FA4:  MOVLB  C
02FA6:  CLRF   x02
02FA8:  CLRF   x01
02FAA:  CLRF   x00
02FAC:  MOVFF  4EE,BFF
02FB0:  MOVLB  0
02FB2:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
02FB6:  CALL   1750
....................                         break;                         
02FBA:  BRA    2FC0
02FBC:  MOVLB  B
....................                     default: 
....................                         break; 
02FBE:  MOVLB  0
....................                 } 
....................                 break; 
02FC0:  GOTO   3C86
....................             case MODBUS_FNCODE_WRITE_SINGLE_REGISTER: 
....................                 // Accumulate register address. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
02FC4:  MOVLB  B
02FC6:  CLRF   xF1
02FC8:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
02FCC:  MOVFF  BF0,BF1
02FD0:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
02FD2:  MOVF   x81,W
02FD4:  IORWF  xF0,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
02FD6:  MOVF   xF0,W
02FD8:  MOVWF  00
02FDA:  MOVF   xF1,W
02FDC:  MOVWF  03
02FDE:  MOVLW  02
02FE0:  SUBWF  03,W
02FE2:  BNZ   2FF0
02FE4:  MOVLW  82
02FE6:  SUBWF  00,W
02FE8:  MOVLB  0
02FEA:  BTFSC  FD8.2
02FEC:  BRA    30EA
02FEE:  MOVLB  B
02FF0:  MOVF   03,W
02FF2:  BNZ   3000
02FF4:  MOVLW  05
02FF6:  SUBWF  00,W
02FF8:  MOVLB  0
02FFA:  BTFSC  FD8.2
02FFC:  BRA    319A
02FFE:  MOVLB  B
03000:  MOVLW  02
03002:  SUBWF  03,W
03004:  BNZ   3012
03006:  MOVLW  99
03008:  SUBWF  00,W
0300A:  MOVLB  0
0300C:  BTFSC  FD8.2
0300E:  BRA    32BE
03010:  MOVLB  B
03012:  MOVLW  05
03014:  SUBWF  03,W
03016:  BNZ   3024
03018:  MOVLW  52
0301A:  SUBWF  00,W
0301C:  MOVLB  0
0301E:  BTFSC  FD8.2
03020:  BRA    334C
03022:  MOVLB  B
03024:  MOVLW  05
03026:  SUBWF  03,W
03028:  BNZ   3036
0302A:  MOVLW  54
0302C:  SUBWF  00,W
0302E:  MOVLB  0
03030:  BTFSC  FD8.2
03032:  BRA    339E
03034:  MOVLB  B
03036:  MOVF   03,W
03038:  BNZ   3046
0303A:  MOVLW  99
0303C:  SUBWF  00,W
0303E:  MOVLB  0
03040:  BTFSC  FD8.2
03042:  BRA    344E
03044:  MOVLB  B
03046:  MOVF   03,W
03048:  BNZ   3056
0304A:  MOVLW  89
0304C:  SUBWF  00,W
0304E:  MOVLB  0
03050:  BTFSC  FD8.2
03052:  BRA    34B6
03054:  MOVLB  B
03056:  MOVF   03,W
03058:  BNZ   3066
0305A:  MOVLW  90
0305C:  SUBWF  00,W
0305E:  MOVLB  0
03060:  BTFSC  FD8.2
03062:  BRA    34E6
03064:  MOVLB  B
03066:  MOVF   03,W
03068:  BNZ   3076
0306A:  MOVLW  54
0306C:  SUBWF  00,W
0306E:  MOVLB  0
03070:  BTFSC  FD8.2
03072:  BRA    3522
03074:  MOVLB  B
03076:  MOVF   03,W
03078:  BNZ   3086
0307A:  MOVLW  58
0307C:  SUBWF  00,W
0307E:  MOVLB  0
03080:  BTFSC  FD8.2
03082:  BRA    355A
03084:  MOVLB  B
03086:  MOVF   03,W
03088:  BNZ   3096
0308A:  MOVLW  59
0308C:  SUBWF  00,W
0308E:  MOVLB  0
03090:  BTFSC  FD8.2
03092:  BRA    3608
03094:  MOVLB  B
03096:  MOVF   03,W
03098:  BNZ   30A6
0309A:  MOVLW  60
0309C:  SUBWF  00,W
0309E:  MOVLB  0
030A0:  BTFSC  FD8.2
030A2:  BRA    36B8
030A4:  MOVLB  B
030A6:  MOVF   03,W
030A8:  BNZ   30B6
030AA:  MOVLW  62
030AC:  SUBWF  00,W
030AE:  MOVLB  0
030B0:  BTFSC  FD8.2
030B2:  BRA    3768
030B4:  MOVLB  B
030B6:  MOVF   03,W
030B8:  BNZ   30C6
030BA:  MOVLW  63
030BC:  SUBWF  00,W
030BE:  MOVLB  0
030C0:  BTFSC  FD8.2
030C2:  BRA    3798
030C4:  MOVLB  B
030C6:  MOVF   03,W
030C8:  BNZ   30D6
030CA:  MOVLW  64
030CC:  SUBWF  00,W
030CE:  MOVLB  0
030D0:  BTFSC  FD8.2
030D2:  BRA    37DE
030D4:  MOVLB  B
030D6:  MOVF   03,W
030D8:  BNZ   30E6
030DA:  MOVLW  66
030DC:  SUBWF  00,W
030DE:  MOVLB  0
030E0:  BTFSC  FD8.2
030E2:  BRA    3816
030E4:  MOVLB  B
030E6:  GOTO   38C6
....................                 { 
....................                     case ADDRESS_FOR_SET_LOAD_CELL_FACTOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrLoadCellFactor = g_ui8RS485Rxbuffer[4]; 
030EA:  MOVLB  4
030EC:  CLRF   xDA
030EE:  MOVFF  B82,4D9
....................                         g_ui16CurrLoadCellFactor = ((g_ui16CurrLoadCellFactor << 8) & 0xFF00); 
030F2:  MOVFF  4D9,4DA
030F6:  MOVLB  4
030F8:  CLRF   xD9
030FA:  MOVLB  4
....................                         g_ui16CurrLoadCellFactor = (g_ui16CurrLoadCellFactor | g_ui8RS485Rxbuffer[5]); 
030FC:  MOVLB  B
030FE:  MOVF   x83,W
03100:  MOVLB  4
03102:  IORWF  xD9,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03104:  MOVLW  0A
03106:  MOVLB  B
03108:  MOVWF  xFA
0310A:  MOVLW  06
0310C:  MOVWF  xFB
0310E:  MOVFF  BF1,BFD
03112:  MOVFF  BF0,BFC
03116:  CLRF   xFE
03118:  MOVLB  C
0311A:  CLRF   x02
0311C:  CLRF   x01
0311E:  CLRF   x00
03120:  MOVLB  B
03122:  CLRF   xFF
03124:  MOVLB  0
03126:  CALL   17A8
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0312A:  CALL   1750
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_SET_LOAD_CELL_FACTOR; 
0312E:  MOVLW  6C
03130:  MOVLB  1
03132:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16CurrLoadCellFactor = g_ui16CurrLoadCellFactor; 
03134:  MOVFF  4DA,FA
03138:  MOVFF  4D9,F9
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         g_unIBUCurrLoadCellFactor.m_stLoadCellFactor.m_ui16Padding = 0; 
0313C:  MOVLB  0
0313E:  CLRF   xFC
03140:  CLRF   xFB
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03142:  MOVLW  01
03144:  MOVLB  B
03146:  MOVWF  xF4
03148:  MOVF   xF4,W
0314A:  SUBLW  08
0314C:  BNC   3182
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUCurrLoadCellFactor.m_ui8Arr[ui8LoopCount-1]; 
0314E:  CLRF   03
03150:  MOVF   xF4,W
03152:  ADDLW  FC
03154:  MOVWF  01
03156:  MOVLW  01
03158:  ADDWFC 03,F
0315A:  MOVFF  03,BF9
0315E:  MOVLW  01
03160:  SUBWF  xF4,W
03162:  CLRF   03
03164:  ADDLW  F9
03166:  MOVWF  FE9
03168:  MOVLW  00
0316A:  ADDWFC 03,W
0316C:  MOVWF  FEA
0316E:  MOVFF  FEF,BFA
03172:  MOVFF  BF9,FEA
03176:  MOVFF  01,FE9
0317A:  MOVFF  BFA,FEF
0317E:  INCF   xF4,F
03180:  BRA    3148
....................                         } 
....................      
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
03182:  MOVLW  02
03184:  MOVWF  xF9
03186:  MOVLW  90
03188:  MOVWF  xF8
0318A:  MOVLW  01
0318C:  MOVWF  xFB
0318E:  MOVLW  FA
03190:  MOVWF  xFA
03192:  MOVLB  0
03194:  CALL   0BD4
....................                         break; 
03198:  BRA    38C8
....................                     case MODE_ADDRESS: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrentMode = g_ui8RS485Rxbuffer[4]; 
0319A:  MOVLB  4
0319C:  CLRF   xD7
0319E:  MOVFF  B82,4D6
....................                         g_ui16CurrentMode = ((g_ui16CurrentMode << 8) & 0xFF00); 
031A2:  MOVFF  4D6,4D7
031A6:  MOVLB  4
031A8:  CLRF   xD6
031AA:  MOVLB  4
....................                         g_ui16CurrentMode = (g_ui16CurrentMode | g_ui8RS485Rxbuffer[5]);  
031AC:  MOVLB  B
031AE:  MOVF   x83,W
031B0:  MOVLB  4
031B2:  IORWF  xD6,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                         
031B4:  MOVLW  0A
031B6:  MOVLB  B
031B8:  MOVWF  xFA
031BA:  MOVLW  06
031BC:  MOVWF  xFB
031BE:  MOVFF  BF1,BFD
031C2:  MOVFF  BF0,BFC
031C6:  CLRF   xFE
031C8:  MOVLB  C
031CA:  CLRF   x02
031CC:  CLRF   x01
031CE:  CLRF   x00
031D0:  MOVLB  B
031D2:  CLRF   xFF
031D4:  MOVLB  0
031D6:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
031DA:  CALL   1750
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node.                         
....................                         switch(g_ui16CurrentMode) 
031DE:  MOVLB  4
031E0:  MOVF   xD6,W
031E2:  MOVWF  00
031E4:  MOVF   xD7,W
031E6:  MOVWF  03
031E8:  MOVF   03,W
031EA:  BNZ   31F4
031EC:  MOVF   00,F
031EE:  MOVLB  0
031F0:  BZ    324A
031F2:  MOVLB  4
031F4:  MOVF   03,W
031F6:  BNZ   3202
031F8:  MOVLW  01
031FA:  SUBWF  00,W
031FC:  MOVLB  0
031FE:  BZ    3252
03200:  MOVLB  4
03202:  MOVF   03,W
03204:  BNZ   3210
03206:  MOVLW  02
03208:  SUBWF  00,W
0320A:  MOVLB  0
0320C:  BZ    325A
0320E:  MOVLB  4
03210:  MOVF   03,W
03212:  BNZ   321E
03214:  MOVLW  03
03216:  SUBWF  00,W
03218:  MOVLB  0
0321A:  BZ    3262
0321C:  MOVLB  4
0321E:  MOVF   03,W
03220:  BNZ   322C
03222:  MOVLW  06
03224:  SUBWF  00,W
03226:  MOVLB  0
03228:  BZ    326A
0322A:  MOVLB  4
0322C:  MOVF   03,W
0322E:  BNZ   323A
03230:  MOVLW  05
03232:  SUBWF  00,W
03234:  MOVLB  0
03236:  BZ    3272
03238:  MOVLB  4
0323A:  MOVF   03,W
0323C:  BNZ   3248
0323E:  MOVLW  04
03240:  SUBWF  00,W
03242:  MOVLB  0
03244:  BZ    327A
03246:  MOVLB  4
03248:  BRA    3284
....................                         { 
....................                             case BOARD_MODE_TYPE_NOTHING: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
0324A:  MOVLW  64
0324C:  MOVLB  1
0324E:  MOVWF  xFC
....................                                  
....................                                 break; 
03250:  BRA    3286
....................                             case BOARD_MODE_TYPE_HOME: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_HOME; 
03252:  MOVLW  64
03254:  MOVLB  1
03256:  MOVWF  xFC
....................                                          
....................                                 break; 
03258:  BRA    3286
....................                             case BOARD_MODE_TYPE_PRE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PRE_PROD; 
0325A:  MOVLW  6F
0325C:  MOVLB  1
0325E:  MOVWF  xFC
....................                                  
....................                                 break; 
03260:  BRA    3286
....................                             case BOARD_MODE_TYPE_PRODUCTION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_PROD; 
03262:  MOVLW  82
03264:  MOVLB  1
03266:  MOVWF  xFC
....................                                  
....................                                 break; 
03268:  BRA    3286
....................                             case BOARD_MODE_TYPE_POST_PROD: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_POST_PROD; 
0326A:  MOVLW  96
0326C:  MOVLB  1
0326E:  MOVWF  xFC
....................                                  
....................                                 break; 
03270:  BRA    3286
....................                             case BOARD_MODE_TYPE_CALIBRATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CALIB; 
03272:  MOVLW  65
03274:  MOVLB  1
03276:  MOVWF  xFC
....................                                  
....................                                 break; 
03278:  BRA    3286
....................                             case BOARD_MODE_TYPE_CONFIGURATION: 
....................                                 // Stuff IBU message header. 
....................                                 g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_MODE_CONFIG; 
0327A:  MOVLW  8D
0327C:  MOVLB  1
0327E:  MOVWF  xFC
....................                                  
....................                                 break; 
03280:  BRA    3286
03282:  MOVLB  4
....................                             default: 
....................                                 break; 
03284:  MOVLB  1
....................                         } 
....................                          
....................                         // Stuff remaining padding bytes. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03286:  MOVLW  01
03288:  MOVLB  B
0328A:  MOVWF  xF4
0328C:  MOVF   xF4,W
0328E:  SUBLW  08
03290:  BNC   32A6
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
03292:  CLRF   03
03294:  MOVF   xF4,W
03296:  ADDLW  FC
03298:  MOVWF  FE9
0329A:  MOVLW  01
0329C:  ADDWFC 03,W
0329E:  MOVWF  FEA
032A0:  CLRF   FEF
032A2:  INCF   xF4,F
032A4:  BRA    328C
....................                         } 
....................                          
....................                         // Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
032A6:  MOVLW  02
032A8:  MOVWF  xF9
032AA:  MOVLW  90
032AC:  MOVWF  xF8
032AE:  MOVLW  01
032B0:  MOVWF  xFB
032B2:  MOVLW  FA
032B4:  MOVWF  xFA
032B6:  MOVLB  0
032B8:  CALL   0BD4
....................                         break; 
032BC:  BRA    38C8
....................                     case  ADDRESS_FOR_START_CALIBRATION: 
....................                         // Step 1: accumulate data. 
....................                         g_fStartCalibration = g_ui8RS485Rxbuffer[4]; 
032BE:  MOVFF  B82,4D8
....................                         g_fStartCalibration = ((g_fStartCalibration << 8) & 0xFF00); 
032C2:  MOVLW  00
032C4:  MOVLB  4
032C6:  CLRF   xD8
....................                         g_fStartCalibration = (g_fStartCalibration | g_ui8RS485Rxbuffer[5]);                          
032C8:  MOVLB  B
032CA:  MOVF   x83,W
032CC:  MOVLB  4
032CE:  IORWF  xD8,F
....................                                  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
032D0:  MOVLW  0A
032D2:  MOVLB  B
032D4:  MOVWF  xFA
032D6:  MOVLW  06
032D8:  MOVWF  xFB
032DA:  MOVFF  BF1,BFD
032DE:  MOVFF  BF0,BFC
032E2:  CLRF   xFE
032E4:  MOVLB  C
032E6:  CLRF   x02
032E8:  CLRF   x01
032EA:  CLRF   x00
032EC:  MOVLB  B
032EE:  CLRF   xFF
032F0:  MOVLB  0
032F2:  CALL   17A8
....................                                  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
032F6:  CALL   1750
....................                                  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_START_CALIBRATION; 
032FA:  MOVLW  66
032FC:  MOVLB  1
032FE:  MOVWF  xFC
....................  
....................                         // b. Stuff data. 
....................                         // No data need to stuff 
....................  
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Remaining all bytes are padding bytes; need to stuff. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03300:  MOVLW  01
03302:  MOVLB  B
03304:  MOVWF  xF4
03306:  MOVF   xF4,W
03308:  SUBLW  08
0330A:  BNC   3320
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
0330C:  CLRF   03
0330E:  MOVF   xF4,W
03310:  ADDLW  FC
03312:  MOVWF  FE9
03314:  MOVLW  01
03316:  ADDWFC 03,W
03318:  MOVWF  FEA
0331A:  CLRF   FEF
0331C:  INCF   xF4,F
0331E:  BRA    3306
....................                         }                         
....................  
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03320:  MOVLW  02
03322:  MOVWF  xF9
03324:  MOVLW  90
03326:  MOVWF  xF8
03328:  MOVLW  01
0332A:  MOVWF  xFB
0332C:  MOVLW  FA
0332E:  MOVWF  xFA
03330:  MOVLB  0
03332:  CALL   0BD4
....................                          
....................                         // Reset Calibration point values; i.e. Tare ADC & Weight ADC values. 
....................                         g_ui32TareADCValueForCalibration = 0; 
03336:  MOVLB  4
03338:  CLRF   xB9
0333A:  CLRF   xB8
0333C:  CLRF   xB7
0333E:  CLRF   xB6
....................                         g_ui32gWeightADCValueForCalibration = 0; 
03340:  CLRF   xBD
03342:  CLRF   xBC
03344:  CLRF   xBB
03346:  CLRF   xBA
....................                         break; 
03348:  MOVLB  0
0334A:  BRA    38C8
....................                     case ADDRESS_FOR_PRODUCTION_PV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdPvTol = g_ui8RS485Rxbuffer[4]; 
0334C:  MOVLB  4
0334E:  CLRF   xD3
03350:  MOVFF  B82,4D2
....................                         g_ui16CurrProdPvTol = ((g_ui16CurrProdPvTol << 8) & 0xFF00); 
03354:  MOVFF  4D2,4D3
03358:  MOVLB  4
0335A:  CLRF   xD2
0335C:  MOVLB  4
....................                         g_ui16CurrProdPvTol = (g_ui16CurrProdPvTol | g_ui8RS485Rxbuffer[5]);                          
0335E:  MOVLB  B
03360:  MOVF   x83,W
03362:  MOVLB  4
03364:  IORWF  xD2,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);   
03366:  MOVLW  0A
03368:  MOVLB  B
0336A:  MOVWF  xFA
0336C:  MOVLW  06
0336E:  MOVWF  xFB
03370:  MOVFF  BF1,BFD
03374:  MOVFF  BF0,BFC
03378:  CLRF   xFE
0337A:  MOVLB  C
0337C:  CLRF   x02
0337E:  CLRF   x01
03380:  CLRF   x00
03382:  MOVLB  B
03384:  CLRF   xFF
03386:  MOVLB  0
03388:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0338C:  CALL   1750
....................                          
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         //g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (int16)g_ui16CurrProdPvTol; 
03390:  CLRF   xE0
03392:  CLRF   xDF
03394:  MOVFF  4D3,DE
03398:  MOVFF  4D2,DD
....................                          
....................                         // ##################################################### 
....................                         // Positive tolerance will be sent to MCU0 after negative 
....................                         // tolerance will arrive so that can be sent accumulately. 
....................                         // ##################################################### 
....................                          
.................... //                        // c. Stuff padding bytes; if needed. 
.................... //                        g_unIBUAvgNode.m_stIBUAvgNode.m_i16Padding = 0; 
.................... //                        for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
.................... //                        { 
.................... //                            g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUAvgNode.m_ui8Arr[ui8LoopCount - 1]; 
.................... //                        }                         
.................... //                         
.................... //                        // d. Insert in IBU sent message queue. 
.................... //                        InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
....................                         break; 
0339C:  BRA    38C8
....................                     case ADDRESS_FOR_PRODUCTION_NV_TOL_PRE_PRODUCTION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16CurrProdNvTol = g_ui8RS485Rxbuffer[4]; 
0339E:  MOVLB  4
033A0:  CLRF   xD5
033A2:  MOVFF  B82,4D4
....................                         g_ui16CurrProdNvTol = ((g_ui16CurrProdNvTol << 8) & 0xFF00); 
033A6:  MOVFF  4D4,4D5
033AA:  MOVLB  4
033AC:  CLRF   xD4
033AE:  MOVLB  4
....................                         g_ui16CurrProdNvTol = (g_ui16CurrProdNvTol | g_ui8RS485Rxbuffer[5]);  
033B0:  MOVLB  B
033B2:  MOVF   x83,W
033B4:  MOVLB  4
033B6:  IORWF  xD4,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);                                                 
033B8:  MOVLW  0A
033BA:  MOVLB  B
033BC:  MOVWF  xFA
033BE:  MOVLW  06
033C0:  MOVWF  xFB
033C2:  MOVFF  BF1,BFD
033C6:  MOVFF  BF0,BFC
033CA:  CLRF   xFE
033CC:  MOVLB  C
033CE:  CLRF   x02
033D0:  CLRF   x01
033D2:  CLRF   x00
033D4:  MOVLB  B
033D6:  CLRF   xFF
033D8:  MOVLB  0
033DA:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
033DE:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU message node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE;   
033E2:  MOVLW  71
033E4:  MOVLB  1
033E6:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (int16)g_ui16CurrProdNvTol; 
033E8:  MOVLB  0
033EA:  CLRF   xE4
033EC:  CLRF   xE3
033EE:  MOVFF  4D5,E2
033F2:  MOVFF  4D4,E1
....................                          
....................                         // c. Stuff padding bytes; if needed. 
....................                         // Not Needed. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
033F6:  MOVLW  01
033F8:  MOVLB  B
033FA:  MOVWF  xF4
033FC:  MOVF   xF4,W
033FE:  SUBLW  08
03400:  BNC   3436
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
03402:  CLRF   03
03404:  MOVF   xF4,W
03406:  ADDLW  FC
03408:  MOVWF  01
0340A:  MOVLW  01
0340C:  ADDWFC 03,F
0340E:  MOVFF  03,BF9
03412:  MOVLW  01
03414:  SUBWF  xF4,W
03416:  CLRF   03
03418:  ADDLW  DD
0341A:  MOVWF  FE9
0341C:  MOVLW  00
0341E:  ADDWFC 03,W
03420:  MOVWF  FEA
03422:  MOVFF  FEF,BFA
03426:  MOVFF  BF9,FEA
0342A:  MOVFF  01,FE9
0342E:  MOVFF  BFA,FEF
03432:  INCF   xF4,F
03434:  BRA    33FC
....................                         }  
....................                          
....................                         // d. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                          
03436:  MOVLW  02
03438:  MOVWF  xF9
0343A:  MOVLW  90
0343C:  MOVWF  xF8
0343E:  MOVLW  01
03440:  MOVWF  xFB
03442:  MOVLW  FA
03444:  MOVWF  xFA
03446:  MOVLB  0
03448:  CALL   0BD4
....................                         break; 
0344C:  BRA    38C8
....................                     case ADDRESS_FOR_SCRAP_ON_MODE: 
....................                         // Step 1: No data to parse..just send the mode to MCU0 for mode setting. 
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
0344E:  MOVLW  0A
03450:  MOVLB  B
03452:  MOVWF  xFA
03454:  MOVLW  06
03456:  MOVWF  xFB
03458:  MOVFF  BF1,BFD
0345C:  MOVFF  BF0,BFC
03460:  CLRF   xFE
03462:  MOVLB  C
03464:  CLRF   x02
03466:  CLRF   x01
03468:  CLRF   x00
0346A:  MOVLB  B
0346C:  CLRF   xFF
0346E:  MOVLB  0
03470:  CALL   17A8
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03474:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_SCRAP_MODE; 
03478:  MOVLW  76
0347A:  MOVLB  1
0347C:  MOVWF  xFC
....................                          
....................                         // b. Stuff padding data. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0347E:  MOVLW  01
03480:  MOVLB  B
03482:  MOVWF  xF4
03484:  MOVF   xF4,W
03486:  SUBLW  08
03488:  BNC   349E
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = 0; 
0348A:  CLRF   03
0348C:  MOVF   xF4,W
0348E:  ADDLW  FC
03490:  MOVWF  FE9
03492:  MOVLW  01
03494:  ADDWFC 03,W
03496:  MOVWF  FEA
03498:  CLRF   FEF
0349A:  INCF   xF4,F
0349C:  BRA    3484
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
0349E:  MOVLW  02
034A0:  MOVWF  xF9
034A2:  MOVLW  90
034A4:  MOVWF  xF8
034A6:  MOVLW  01
034A8:  MOVWF  xFB
034AA:  MOVLW  FA
034AC:  MOVWF  xFA
034AE:  MOVLB  0
034B0:  CALL   0BD4
....................                         break; 
034B4:  BRA    38C8
....................                     case ADDRESS_FOR_TOL_STORE_SETTING_ACK: 
....................                         // No data to parse. 
....................                         // Ack confirmation message. 
....................                         // Reset ack register. 
....................                         g_ui8ToleranceStoreAck = 0; 
034B6:  MOVLB  4
034B8:  CLRF   xDD
....................                          
....................                        // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);  
034BA:  MOVLW  0A
034BC:  MOVLB  B
034BE:  MOVWF  xFA
034C0:  MOVLW  06
034C2:  MOVWF  xFB
034C4:  MOVFF  BF1,BFD
034C8:  MOVFF  BF0,BFC
034CC:  CLRF   xFE
034CE:  MOVLB  C
034D0:  CLRF   x02
034D2:  CLRF   x01
034D4:  CLRF   x00
034D6:  MOVLB  B
034D8:  CLRF   xFF
034DA:  MOVLB  0
034DC:  CALL   17A8
....................                         
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
034E0:  CALL   1750
....................                         break; 
034E4:  BRA    38C8
....................                     case ADDRESS_FOR_MACHINE_ID: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8MachineID = g_ui8RS485Rxbuffer[5]; 
034E6:  MOVFF  B83,4DE
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL);    
034EA:  MOVLW  0A
034EC:  MOVLB  B
034EE:  MOVWF  xFA
034F0:  MOVLW  06
034F2:  MOVWF  xFB
034F4:  MOVFF  BF1,BFD
034F8:  MOVFF  BF0,BFC
034FC:  CLRF   xFE
034FE:  MOVLB  C
03500:  CLRF   x02
03502:  CLRF   x01
03504:  CLRF   x00
03506:  MOVLB  B
03508:  CLRF   xFF
0350A:  MOVLB  0
0350C:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03510:  CALL   1750
....................                          
....................                         // Step 4: Set data. 
....................                         g_stLANDataHeader.m_ui8MachineID = g_ui8MachineID; 
03514:  MOVFF  4DE,99
....................                         
....................                         // Step 5: Store data in EEPROM. 
....................                         WriteMachineIDToEEPROM(g_ui8MachineID);                         
03518:  MOVFF  4DE,BF8
0351C:  GOTO   1E64
....................                         break; 
03520:  BRA    38C8
....................                     case ADDRESS_FOR_AT_DATA_INTERVAL_TIMER_SETTING: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8DataSendingIntervalTime = g_ui8RS485Rxbuffer[5]; 
03522:  MOVFF  B83,4E0
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03526:  MOVLW  0A
03528:  MOVLB  B
0352A:  MOVWF  xFA
0352C:  MOVLW  06
0352E:  MOVWF  xFB
03530:  MOVFF  BF1,BFD
03534:  MOVFF  BF0,BFC
03538:  CLRF   xFE
0353A:  MOVLB  C
0353C:  CLRF   x02
0353E:  CLRF   x01
03540:  CLRF   x00
03542:  MOVLB  B
03544:  CLRF   xFF
03546:  MOVLB  0
03548:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0354C:  CALL   1750
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteIntervalToEEPROM(g_ui8DataSendingIntervalTime); 
03550:  MOVFF  4E0,BF8
03554:  GOTO   1E78
....................                         break;                                 
03558:  BRA    38C8
....................                     case ADDRESS_FOR_PIPE_PRESENSE_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipePresenceDelayTime = g_ui8RS485Rxbuffer[4]; 
0355A:  MOVLB  4
0355C:  CLRF   xE5
0355E:  MOVFF  B82,4E4
....................                         g_ui16PipePresenceDelayTime = ((g_ui16PipePresenceDelayTime << 8) & 0xFF00); 
03562:  MOVFF  4E4,4E5
03566:  MOVLB  4
03568:  CLRF   xE4
0356A:  MOVLB  4
....................                         g_ui16PipePresenceDelayTime = (g_ui16PipePresenceDelayTime | g_ui8RS485Rxbuffer[5]); 
0356C:  MOVLB  B
0356E:  MOVF   x83,W
03570:  MOVLB  4
03572:  IORWF  xE4,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03574:  MOVLW  0A
03576:  MOVLB  B
03578:  MOVWF  xFA
0357A:  MOVLW  06
0357C:  MOVWF  xFB
0357E:  MOVFF  BF1,BFD
03582:  MOVFF  BF0,BFC
03586:  CLRF   xFE
03588:  MOVLB  C
0358A:  CLRF   x02
0358C:  CLRF   x01
0358E:  CLRF   x00
03590:  MOVLB  B
03592:  CLRF   xFF
03594:  MOVLB  0
03596:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
0359A:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
0359E:  MOVLW  98
035A0:  MOVLB  1
035A2:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipePresenceDelayTime; 
035A4:  MOVFF  4E5,103
035A8:  MOVFF  4E4,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_PRESENCE_DELAY; // Means pipe presence delay time. 
035AC:  MOVLW  01
035AE:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
035B0:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
035B2:  MOVLB  B
035B4:  MOVWF  xF4
035B6:  MOVF   xF4,W
035B8:  SUBLW  08
035BA:  BNC   35F0
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
035BC:  CLRF   03
035BE:  MOVF   xF4,W
035C0:  ADDLW  FC
035C2:  MOVWF  01
035C4:  MOVLW  01
035C6:  ADDWFC 03,F
035C8:  MOVFF  03,BF9
035CC:  MOVLW  01
035CE:  SUBWF  xF4,W
035D0:  CLRF   03
035D2:  ADDLW  01
035D4:  MOVWF  FE9
035D6:  MOVLW  01
035D8:  ADDWFC 03,W
035DA:  MOVWF  FEA
035DC:  MOVFF  FEF,BFA
035E0:  MOVFF  BF9,FEA
035E4:  MOVFF  01,FE9
035E8:  MOVFF  BFA,FEF
035EC:  INCF   xF4,F
035EE:  BRA    35B6
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
035F0:  MOVLW  02
035F2:  MOVWF  xF9
035F4:  MOVLW  90
035F6:  MOVWF  xF8
035F8:  MOVLW  01
035FA:  MOVWF  xFB
035FC:  MOVLW  FA
035FE:  MOVWF  xFA
03600:  MOVLB  0
03602:  CALL   0BD4
....................                         break; 
03606:  BRA    38C8
....................                     case ADDRESS_FOR_PIPE_STABILIZATION_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeStabilizationDelayTime = g_ui8RS485Rxbuffer[4]; 
03608:  MOVLB  4
0360A:  CLRF   xE7
0360C:  MOVFF  B82,4E6
....................                         g_ui16PipeStabilizationDelayTime = ((g_ui16PipeStabilizationDelayTime << 8) & 0xFF00); 
03610:  MOVFF  4E6,4E7
03614:  MOVLB  4
03616:  CLRF   xE6
03618:  MOVLB  4
....................                         g_ui16PipeStabilizationDelayTime = (g_ui16PipeStabilizationDelayTime | g_ui8RS485Rxbuffer[5]); 
0361A:  MOVLB  B
0361C:  MOVF   x83,W
0361E:  MOVLB  4
03620:  IORWF  xE6,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03622:  MOVLW  0A
03624:  MOVLB  B
03626:  MOVWF  xFA
03628:  MOVLW  06
0362A:  MOVWF  xFB
0362C:  MOVFF  BF1,BFD
03630:  MOVFF  BF0,BFC
03634:  CLRF   xFE
03636:  MOVLB  C
03638:  CLRF   x02
0363A:  CLRF   x01
0363C:  CLRF   x00
0363E:  MOVLB  B
03640:  CLRF   xFF
03642:  MOVLB  0
03644:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03648:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
0364C:  MOVLW  98
0364E:  MOVLB  1
03650:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeStabilizationDelayTime; 
03652:  MOVFF  4E7,103
03656:  MOVFF  4E6,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_STABILIZATION_DELAY; // Means pipe stabilization delay time. 
0365A:  MOVLW  02
0365C:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
0365E:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03660:  MOVLW  01
03662:  MOVLB  B
03664:  MOVWF  xF4
03666:  MOVF   xF4,W
03668:  SUBLW  08
0366A:  BNC   36A0
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
0366C:  CLRF   03
0366E:  MOVF   xF4,W
03670:  ADDLW  FC
03672:  MOVWF  01
03674:  MOVLW  01
03676:  ADDWFC 03,F
03678:  MOVFF  03,BF9
0367C:  MOVLW  01
0367E:  SUBWF  xF4,W
03680:  CLRF   03
03682:  ADDLW  01
03684:  MOVWF  FE9
03686:  MOVLW  01
03688:  ADDWFC 03,W
0368A:  MOVWF  FEA
0368C:  MOVFF  FEF,BFA
03690:  MOVFF  BF9,FEA
03694:  MOVFF  01,FE9
03698:  MOVFF  BFA,FEF
0369C:  INCF   xF4,F
0369E:  BRA    3666
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
036A0:  MOVLW  02
036A2:  MOVWF  xF9
036A4:  MOVLW  90
036A6:  MOVWF  xF8
036A8:  MOVLW  01
036AA:  MOVWF  xFB
036AC:  MOVLW  FA
036AE:  MOVWF  xFA
036B0:  MOVLB  0
036B2:  CALL   0BD4
....................                         break; 
036B6:  BRA    38C8
....................                     case ADDRESS_FOR_PIPE_TRANSFER_DELAY_TIME: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16PipeTransferDelayTime = g_ui8RS485Rxbuffer[4]; 
036B8:  MOVLB  4
036BA:  CLRF   xE9
036BC:  MOVFF  B82,4E8
....................                         g_ui16PipeTransferDelayTime = ((g_ui16PipeTransferDelayTime << 8) & 0xFF00); 
036C0:  MOVFF  4E8,4E9
036C4:  MOVLB  4
036C6:  CLRF   xE8
036C8:  MOVLB  4
....................                         g_ui16PipeTransferDelayTime = (g_ui16PipeTransferDelayTime | g_ui8RS485Rxbuffer[5]); 
036CA:  MOVLB  B
036CC:  MOVF   x83,W
036CE:  MOVLB  4
036D0:  IORWF  xE8,F
....................  
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
036D2:  MOVLW  0A
036D4:  MOVLB  B
036D6:  MOVWF  xFA
036D8:  MOVLW  06
036DA:  MOVWF  xFB
036DC:  MOVFF  BF1,BFD
036E0:  MOVFF  BF0,BFC
036E4:  CLRF   xFE
036E6:  MOVLB  C
036E8:  CLRF   x02
036EA:  CLRF   x01
036EC:  CLRF   x00
036EE:  MOVLB  B
036F0:  CLRF   xFF
036F2:  MOVLB  0
036F4:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
036F8:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_STORE_PROD_DELAY_TIMERS; 
036FC:  MOVLW  98
036FE:  MOVLB  1
03700:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui16DelayTimer = g_ui16PipeTransferDelayTime; 
03702:  MOVFF  4E9,103
03706:  MOVFF  4E8,102
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8MessageHeader = PIPE_TRANSFER_DELAY; // Means pipe transfer delay time. 
0370A:  MOVLW  03
0370C:  MOVWF  x01
....................                         g_unProdDelayTimers.m_stProdDelayTimers.m_ui8Spare = 0; 
0370E:  CLRF   x04
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03710:  MOVLW  01
03712:  MOVLB  B
03714:  MOVWF  xF4
03716:  MOVF   xF4,W
03718:  SUBLW  08
0371A:  BNC   3750
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unProdDelayTimers.m_ui8Arr[ui8LoopCount - 1]; 
0371C:  CLRF   03
0371E:  MOVF   xF4,W
03720:  ADDLW  FC
03722:  MOVWF  01
03724:  MOVLW  01
03726:  ADDWFC 03,F
03728:  MOVFF  03,BF9
0372C:  MOVLW  01
0372E:  SUBWF  xF4,W
03730:  CLRF   03
03732:  ADDLW  01
03734:  MOVWF  FE9
03736:  MOVLW  01
03738:  ADDWFC 03,W
0373A:  MOVWF  FEA
0373C:  MOVFF  FEF,BFA
03740:  MOVFF  BF9,FEA
03744:  MOVFF  01,FE9
03748:  MOVFF  BFA,FEF
0374C:  INCF   xF4,F
0374E:  BRA    3716
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03750:  MOVLW  02
03752:  MOVWF  xF9
03754:  MOVLW  90
03756:  MOVWF  xF8
03758:  MOVLW  01
0375A:  MOVWF  xFB
0375C:  MOVLW  FA
0375E:  MOVWF  xFA
03760:  MOVLB  0
03762:  CALL   0BD4
....................                         break; 
03766:  BRA    38C8
....................                     case ADDRESS_FOR_SHIFT_NUMBER: 
....................                         // Step 1: accumulate data.                         
....................                         g_ui8ShiftNumber = g_ui8RS485Rxbuffer[5]; 
03768:  MOVFF  B83,4EB
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
0376C:  MOVLW  0A
0376E:  MOVLB  B
03770:  MOVWF  xFA
03772:  MOVLW  06
03774:  MOVWF  xFB
03776:  MOVFF  BF1,BFD
0377A:  MOVFF  BF0,BFC
0377E:  CLRF   xFE
03780:  MOVLB  C
03782:  CLRF   x02
03784:  CLRF   x01
03786:  CLRF   x00
03788:  MOVLB  B
0378A:  CLRF   xFF
0378C:  MOVLB  0
0378E:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
03792:  CALL   1750
....................                         break; 
03796:  BRA    38C8
....................                     case ADDRESS_FOR_SHIFT_DURATION: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16TotalMachineUpTime = g_ui8RS485Rxbuffer[4]; 
03798:  MOVLB  4
0379A:  CLRF   xED
0379C:  MOVFF  B82,4EC
....................                         g_ui16TotalMachineUpTime = ((g_ui16TotalMachineUpTime << 8) & 0xFF00); 
037A0:  MOVFF  4EC,4ED
037A4:  MOVLB  4
037A6:  CLRF   xEC
037A8:  MOVLB  4
....................                         g_ui16TotalMachineUpTime = (g_ui16TotalMachineUpTime | g_ui8RS485Rxbuffer[5]); 
037AA:  MOVLB  B
037AC:  MOVF   x83,W
037AE:  MOVLB  4
037B0:  IORWF  xEC,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
037B2:  MOVLW  0A
037B4:  MOVLB  B
037B6:  MOVWF  xFA
037B8:  MOVLW  06
037BA:  MOVWF  xFB
037BC:  MOVFF  BF1,BFD
037C0:  MOVFF  BF0,BFC
037C4:  CLRF   xFE
037C6:  MOVLB  C
037C8:  CLRF   x02
037CA:  CLRF   x01
037CC:  CLRF   x00
037CE:  MOVLB  B
037D0:  CLRF   xFF
037D2:  MOVLB  0
037D4:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
037D8:  CALL   1750
....................                          
....................                         // Send the shift related data to server for report generation. 
....................                         // Insert data in GPRS message queue. 
....................                         //InsertInGPRSQueue(); 
....................                         break; 
037DC:  BRA    38C8
....................                     case ADDRESS_FOR_SELECT_SIM_OPERATOR: 
....................                         // Step 1: accumulate data. 
....................                         g_ui8SIMOperatorID = g_ui8RS485Rxbuffer[5]; 
037DE:  MOVFF  B83,4EF
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
037E2:  MOVLW  0A
037E4:  MOVLB  B
037E6:  MOVWF  xFA
037E8:  MOVLW  06
037EA:  MOVWF  xFB
037EC:  MOVFF  BF1,BFD
037F0:  MOVFF  BF0,BFC
037F4:  CLRF   xFE
037F6:  MOVLB  C
037F8:  CLRF   x02
037FA:  CLRF   x01
037FC:  CLRF   x00
037FE:  MOVLB  B
03800:  CLRF   xFF
03802:  MOVLB  0
03804:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03808:  CALL   1750
....................  
....................                         // Step 4: Store data in EEPROM. 
....................                         WriteSIMOperatorIDToEEPROM(g_ui8SIMOperatorID);                         
0380C:  MOVFF  4EF,BF8
03810:  GOTO   1E8C
....................                         break;  
03814:  BRA    38C8
....................                     case ADDRESS_FOR_WEIGHING_CYLINDER_UP_ACTIVATION_DELAY: 
....................                         // Step 1: accumulate data. 
....................                         g_ui16WeighingCylinderUpActivationDelay = g_ui8RS485Rxbuffer[4]; 
03816:  MOVLB  4
03818:  CLRF   xF1
0381A:  MOVFF  B82,4F0
....................                         g_ui16WeighingCylinderUpActivationDelay = ((g_ui16WeighingCylinderUpActivationDelay << 8) & 0xFF00); 
0381E:  MOVFF  4F0,4F1
03822:  MOVLB  4
03824:  CLRF   xF0
03826:  MOVLB  4
....................                         g_ui16WeighingCylinderUpActivationDelay = (g_ui16WeighingCylinderUpActivationDelay | g_ui8RS485Rxbuffer[5]); 
03828:  MOVLB  B
0382A:  MOVF   x83,W
0382C:  MOVLB  4
0382E:  IORWF  xF0,F
....................                          
....................                         // Step 2: Response back to master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_SINGLE_REGISTER, ui16StartAddtess, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03830:  MOVLW  0A
03832:  MOVLB  B
03834:  MOVWF  xFA
03836:  MOVLW  06
03838:  MOVWF  xFB
0383A:  MOVFF  BF1,BFD
0383E:  MOVFF  BF0,BFC
03842:  CLRF   xFE
03844:  MOVLB  C
03846:  CLRF   x02
03848:  CLRF   x01
0384A:  CLRF   x00
0384C:  MOVLB  B
0384E:  CLRF   xFF
03850:  MOVLB  0
03852:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03856:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         //a. Stuff message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_WEGHNG_CYLDR_UP_ACT_DELAY; 
0385A:  MOVLW  9B
0385C:  MOVLB  1
0385E:  MOVWF  xFC
....................                          
....................                         // b. Stuff data. 
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16DelayTime = g_ui16WeighingCylinderUpActivationDelay; 
03860:  MOVFF  4F1,106
03864:  MOVFF  4F0,105
....................                         g_unWeighingCylinderUpActivationDelay.m_stWeighingCylinderUpActivationDelay.m_ui16Spare = 0; 
03868:  CLRF   x08
0386A:  CLRF   x07
....................                          
....................                         // c. Stuff in IBU data node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
0386C:  MOVLW  01
0386E:  MOVLB  B
03870:  MOVWF  xF4
03872:  MOVF   xF4,W
03874:  SUBLW  08
03876:  BNC   38AC
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unWeighingCylinderUpActivationDelay.m_ui8Arr[ui8LoopCount - 1]; 
03878:  CLRF   03
0387A:  MOVF   xF4,W
0387C:  ADDLW  FC
0387E:  MOVWF  01
03880:  MOVLW  01
03882:  ADDWFC 03,F
03884:  MOVFF  03,BF9
03888:  MOVLW  01
0388A:  SUBWF  xF4,W
0388C:  CLRF   03
0388E:  ADDLW  05
03890:  MOVWF  FE9
03892:  MOVLW  01
03894:  ADDWFC 03,W
03896:  MOVWF  FEA
03898:  MOVFF  FEF,BFA
0389C:  MOVFF  BF9,FEA
038A0:  MOVFF  01,FE9
038A4:  MOVFF  BFA,FEF
038A8:  INCF   xF4,F
038AA:  BRA    3872
....................                         } 
....................  
....................                         // c. Insert in IBU sent message queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData);                         
038AC:  MOVLW  02
038AE:  MOVWF  xF9
038B0:  MOVLW  90
038B2:  MOVWF  xF8
038B4:  MOVLW  01
038B6:  MOVWF  xFB
038B8:  MOVLW  FA
038BA:  MOVWF  xFA
038BC:  MOVLB  0
038BE:  CALL   0BD4
....................                         break;                         
038C2:  BRA    38C8
038C4:  MOVLB  B
....................                     default: 
....................                         break; 
038C6:  MOVLB  0
....................    
....................                 } 
....................  
....................                 break; 
038C8:  BRA    3C86
....................             case MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER: 
....................                 // Accumulate first register address to start write. 
....................                 ui16StartAddtess = g_ui8RS485Rxbuffer[2]; 
038CA:  MOVLB  B
038CC:  CLRF   xF1
038CE:  MOVFF  B80,BF0
....................                 ui16StartAddtess = ((ui16StartAddtess << 8) & 0xFF00); 
038D2:  MOVFF  BF0,BF1
038D6:  CLRF   xF0
....................                 ui16StartAddtess = (ui16StartAddtess | g_ui8RS485Rxbuffer[3]); 
038D8:  MOVF   x81,W
038DA:  IORWF  xF0,F
....................                  
....................                 // Process data at that address. 
....................                 switch(ui16StartAddtess) 
038DC:  MOVF   xF0,W
038DE:  MOVWF  00
038E0:  MOVF   xF1,W
038E2:  MOVWF  03
038E4:  MOVF   03,W
038E6:  BNZ   38F2
038E8:  MOVLW  47
038EA:  SUBWF  00,W
038EC:  MOVLB  0
038EE:  BZ    3936
038F0:  MOVLB  B
038F2:  MOVF   03,W
038F4:  BNZ   3900
038F6:  MOVLW  50
038F8:  SUBWF  00,W
038FA:  MOVLB  0
038FC:  BZ    39D2
038FE:  MOVLB  B
03900:  MOVF   03,W
03902:  BNZ   3910
03904:  MOVLW  52
03906:  SUBWF  00,W
03908:  MOVLB  0
0390A:  BTFSC  FD8.2
0390C:  BRA    3B18
0390E:  MOVLB  B
03910:  MOVLW  01
03912:  SUBWF  03,W
03914:  BNZ   3922
03916:  MOVLW  90
03918:  SUBWF  00,W
0391A:  MOVLB  0
0391C:  BTFSC  FD8.2
0391E:  BRA    3C02
03920:  MOVLB  B
03922:  MOVLW  01
03924:  SUBWF  03,W
03926:  BNZ   3934
03928:  MOVLW  93
0392A:  SUBWF  00,W
0392C:  MOVLB  0
0392E:  BTFSC  FD8.2
03930:  BRA    3C40
03932:  MOVLB  B
03934:  BRA    3C82
....................                 { 
....................                     case ADRESS_FOR_HMI_TIMESTAMP: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];                         
03936:  MOVFF  B84,BF5
....................  
....................                         // Year 
....................                         g_stHMITime.tm_year = g_ui8RS485Rxbuffer[7]; 
0393A:  CLRF   xAD
0393C:  MOVFF  B85,AC
....................                         g_stHMITime.tm_year = ((g_stHMITime.tm_year << 8) & 0xFF00); 
03940:  MOVFF  AC,AD
03944:  MOVLB  0
03946:  CLRF   xAC
03948:  MOVLB  0
....................                         g_stHMITime.tm_year = (g_stHMITime.tm_year | g_ui8RS485Rxbuffer[8]); 
0394A:  MOVLB  B
0394C:  MOVF   x86,W
0394E:  MOVLB  0
03950:  IORWF  xAC,F
....................                         // Month 
....................                         g_stHMITime.tm_mon = g_ui8RS485Rxbuffer[10] - 1; 
03952:  MOVLW  01
03954:  MOVLB  B
03956:  SUBWF  x88,W
03958:  MOVLB  0
0395A:  MOVWF  xAB
....................                         // Day 
....................                         g_stHMITime.tm_mday = g_ui8RS485Rxbuffer[12]; 
0395C:  MOVFF  B8A,AA
....................                         // Week Day 
....................                         g_stHMITime.tm_wday = g_ui8RS485Rxbuffer[14]; 
03960:  MOVFF  B8C,AE
....................                         // Hour 
....................                         g_stHMITime.tm_hour = g_ui8RS485Rxbuffer[16]; 
03964:  MOVFF  B8E,A9
....................                         // Minute 
....................                         g_stHMITime.tm_min = g_ui8RS485Rxbuffer[18]; 
03968:  MOVFF  B90,A8
....................                         // Second 
....................                         g_stHMITime.tm_sec = g_ui8RS485Rxbuffer[20]; 
0396C:  MOVFF  B92,A7
....................                          
....................                         // Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03970:  MOVLW  0A
03972:  MOVLB  B
03974:  MOVWF  xFA
03976:  MOVLW  10
03978:  MOVWF  xFB
0397A:  MOVFF  BF1,BFD
0397E:  MOVFF  BF0,BFC
03982:  MOVFF  BF5,BFE
03986:  MOVLB  C
03988:  CLRF   x02
0398A:  CLRF   x01
0398C:  CLRF   x00
0398E:  MOVLB  B
03990:  CLRF   xFF
03992:  MOVLB  0
03994:  CALL   17A8
....................  
....................                         g_ui32UnixTimeInSec = mktime(&g_stHMITime); 
03998:  MOVLB  B
0399A:  CLRF   xF9
0399C:  MOVLW  A7
0399E:  MOVWF  xF8
039A0:  MOVLB  0
039A2:  GOTO   20F4
039A6:  MOVFF  03,C0
039AA:  MOVFF  02,BF
039AE:  MOVFF  01,BE
039B2:  MOVFF  00,BD
....................                          
....................                         g_pstHMITimeTemp = localtime(&g_ui32UnixTimeInSec); 
039B6:  MOVLB  B
039B8:  CLRF   xF9
039BA:  MOVLW  BD
039BC:  MOVWF  xF8
039BE:  MOVLB  0
039C0:  GOTO   2640
039C4:  MOVFF  02,BC
039C8:  MOVFF  01,BB
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
039CC:  CALL   1750
....................                         break; 
039D0:  BRA    3C84
....................                     case ADDRESS_FOR_CALCULATED_MIN_MAX_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
039D2:  MOVFF  B84,BF5
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
039D6:  CLRF   xE0
039D8:  CLRF   xDF
039DA:  CLRF   xDE
039DC:  MOVFF  B87,DD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039E0:  MOVFF  DF,E0
039E4:  MOVFF  DE,DF
039E8:  MOVFF  DD,DE
039EC:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
039EE:  MOVLB  B
039F0:  MOVF   x88,W
039F2:  MOVLB  0
039F4:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
039F6:  MOVFF  DF,E0
039FA:  MOVFF  DE,DF
039FE:  MOVFF  DD,DE
03A02:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
03A04:  MOVLB  B
03A06:  MOVF   x85,W
03A08:  MOVLB  0
03A0A:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03A0C:  MOVFF  DF,E0
03A10:  MOVFF  DE,DF
03A14:  MOVFF  DD,DE
03A18:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
03A1A:  MOVLB  B
03A1C:  MOVF   x86,W
03A1E:  MOVLB  0
03A20:  IORWF  xDD,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
03A22:  CLRF   xE4
03A24:  CLRF   xE3
03A26:  CLRF   xE2
03A28:  MOVFF  B8B,E1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A2C:  MOVFF  E3,E4
03A30:  MOVFF  E2,E3
03A34:  MOVFF  E1,E2
03A38:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
03A3A:  MOVLB  B
03A3C:  MOVF   x8C,W
03A3E:  MOVLB  0
03A40:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A42:  MOVFF  E3,E4
03A46:  MOVFF  E2,E3
03A4A:  MOVFF  E1,E2
03A4E:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
03A50:  MOVLB  B
03A52:  MOVF   x89,W
03A54:  MOVLB  0
03A56:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03A58:  MOVFF  E3,E4
03A5C:  MOVFF  E2,E3
03A60:  MOVFF  E1,E2
03A64:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
03A66:  MOVLB  B
03A68:  MOVF   x8A,W
03A6A:  MOVLB  0
03A6C:  IORWF  xE1,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03A6E:  MOVLW  0A
03A70:  MOVLB  B
03A72:  MOVWF  xFA
03A74:  MOVLW  10
03A76:  MOVWF  xFB
03A78:  MOVFF  BF1,BFD
03A7C:  MOVFF  BF0,BFC
03A80:  MOVFF  BF5,BFE
03A84:  MOVLB  C
03A86:  CLRF   x02
03A88:  CLRF   x01
03A8A:  CLRF   x00
03A8C:  MOVLB  B
03A8E:  CLRF   xFF
03A90:  MOVLB  0
03A92:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03A96:  CALL   1750
....................  
....................                         // Step 4: Send data to MCU0. 
....................                         // Prepare IBU data node. 
....................                         // a. Stuff IBU message header. 
....................                         g_stIBUSendData.g_ui8ArrIBUData[0] = IBU_CMD_PRE_PROD_TOLERANCE; 
03A9A:  MOVLW  71
03A9C:  MOVLB  1
03A9E:  MOVWF  xFC
....................                          
....................                         // b. stuff data in node. 
....................                         for(ui8LoopCount = 1; ui8LoopCount < IBU_MSG_BYTE_COUNT; ui8LoopCount++) 
03AA0:  MOVLW  01
03AA2:  MOVLB  B
03AA4:  MOVWF  xF4
03AA6:  MOVF   xF4,W
03AA8:  SUBLW  08
03AAA:  BNC   3AE0
....................                         { 
....................                             g_stIBUSendData.g_ui8ArrIBUData[ui8LoopCount] = g_unIBUTolNode.m_ui8Arr[ui8LoopCount - 1]; 
03AAC:  CLRF   03
03AAE:  MOVF   xF4,W
03AB0:  ADDLW  FC
03AB2:  MOVWF  01
03AB4:  MOVLW  01
03AB6:  ADDWFC 03,F
03AB8:  MOVFF  03,BF9
03ABC:  MOVLW  01
03ABE:  SUBWF  xF4,W
03AC0:  CLRF   03
03AC2:  ADDLW  DD
03AC4:  MOVWF  FE9
03AC6:  MOVLW  00
03AC8:  ADDWFC 03,W
03ACA:  MOVWF  FEA
03ACC:  MOVFF  FEF,BFA
03AD0:  MOVFF  BF9,FEA
03AD4:  MOVFF  01,FE9
03AD8:  MOVFF  BFA,FEF
03ADC:  INCF   xF4,F
03ADE:  BRA    3AA6
....................                         } 
....................  
....................                         // c. Insert in IBU message send queue. 
....................                         InsertIBUMsgQueue(&g_stIBUSendQueue, &g_stIBUSendData); 
03AE0:  MOVLW  02
03AE2:  MOVWF  xF9
03AE4:  MOVLW  90
03AE6:  MOVWF  xF8
03AE8:  MOVLW  01
03AEA:  MOVWF  xFB
03AEC:  MOVLW  FA
03AEE:  MOVWF  xFA
03AF0:  MOVLB  0
03AF2:  CALL   0BD4
....................  
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03AF6:  MOVFF  E0,A1
03AFA:  MOVFF  DF,A0
03AFE:  MOVFF  DE,9F
03B02:  MOVFF  DD,9E
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt; 
03B06:  MOVFF  E4,A5
03B0A:  MOVFF  E3,A4
03B0E:  MOVFF  E2,A3
03B12:  MOVFF  E1,A2
....................                         break; 
03B16:  BRA    3C84
....................                     case ADDRESS_FOR_PRE_PROD_MAX_MIN_WT: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6];  
03B18:  MOVFF  B84,BF5
....................  
....................                         // Step 1: Accumulate data. 
....................                         // Max. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = g_ui8RS485Rxbuffer[9]; 
03B1C:  CLRF   xE0
03B1E:  CLRF   xDF
03B20:  CLRF   xDE
03B22:  MOVFF  B87,DD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B26:  MOVFF  DF,E0
03B2A:  MOVFF  DE,DF
03B2E:  MOVFF  DD,DE
03B32:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[10]); 
03B34:  MOVLB  B
03B36:  MOVF   x88,W
03B38:  MOVLB  0
03B3A:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B3C:  MOVFF  DF,E0
03B40:  MOVFF  DE,DF
03B44:  MOVFF  DD,DE
03B48:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[7]); 
03B4A:  MOVLB  B
03B4C:  MOVF   x85,W
03B4E:  MOVLB  0
03B50:  IORWF  xDD,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt << 8); 
03B52:  MOVFF  DF,E0
03B56:  MOVFF  DE,DF
03B5A:  MOVFF  DD,DE
03B5E:  CLRF   xDD
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt | g_ui8RS485Rxbuffer[8]); 
03B60:  MOVLB  B
03B62:  MOVF   x86,W
03B64:  MOVLB  0
03B66:  IORWF  xDD,F
....................                          
....................                         // Min. weight. 
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = g_ui8RS485Rxbuffer[13]; 
03B68:  CLRF   xE4
03B6A:  CLRF   xE3
03B6C:  CLRF   xE2
03B6E:  MOVFF  B8B,E1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03B72:  MOVFF  E3,E4
03B76:  MOVFF  E2,E3
03B7A:  MOVFF  E1,E2
03B7E:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[14]); 
03B80:  MOVLB  B
03B82:  MOVF   x8C,W
03B84:  MOVLB  0
03B86:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03B88:  MOVFF  E3,E4
03B8C:  MOVFF  E2,E3
03B90:  MOVFF  E1,E2
03B94:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[11]); 
03B96:  MOVLB  B
03B98:  MOVF   x89,W
03B9A:  MOVLB  0
03B9C:  IORWF  xE1,F
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt << 8); 
03B9E:  MOVFF  E3,E4
03BA2:  MOVFF  E2,E3
03BA6:  MOVFF  E1,E2
03BAA:  CLRF   xE1
....................                         g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt = (g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt | g_ui8RS485Rxbuffer[12]); 
03BAC:  MOVLB  B
03BAE:  MOVF   x8A,W
03BB0:  MOVLB  0
03BB2:  IORWF  xE1,F
....................  
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03BB4:  MOVLW  0A
03BB6:  MOVLB  B
03BB8:  MOVWF  xFA
03BBA:  MOVLW  10
03BBC:  MOVWF  xFB
03BBE:  MOVFF  BF1,BFD
03BC2:  MOVFF  BF0,BFC
03BC6:  MOVFF  BF5,BFE
03BCA:  MOVLB  C
03BCC:  CLRF   x02
03BCE:  CLRF   x01
03BD0:  CLRF   x00
03BD2:  MOVLB  B
03BD4:  CLRF   xFF
03BD6:  MOVLB  0
03BD8:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();  
03BDC:  CALL   1750
....................                          
....................                         // Set the values  in GPRS message header for server. 
....................                         g_stLANDataHeader.m_ui32MaxWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MaxWt; 
03BE0:  MOVFF  E0,A1
03BE4:  MOVFF  DF,A0
03BE8:  MOVFF  DE,9F
03BEC:  MOVFF  DD,9E
....................                         g_stLANDataHeader.m_ui32MinWeight = (unsigned int32)g_unIBUTolNode.m_stIBUTolNode.m_i32MinWt;                         
03BF0:  MOVFF  E4,A5
03BF4:  MOVFF  E3,A4
03BF8:  MOVFF  E2,A3
03BFC:  MOVFF  E1,A2
....................                         break; 
03C00:  BRA    3C84
....................                     case ADDRESS_FOR_PRODUCT_BASIC_MATERIAL_STANDARD: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03C02:  MOVFF  B84,BF5
....................                          
....................                         // Basic material and standard Specification and pressure rating of pipe has arrived. 
....................                         // 1. First register(2 bytes) contains basic material and standard 
....................                         // 2. Second register(2 bytes) contains standard specification. 
....................                         // 3. Third register (2 bytes) contains pressure rating / type. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8BasicMaterialStandard = g_ui8RS485Rxbuffer[8]; 
03C06:  MOVFF  B86,4F2
....................                         g_ui8StandardSpecification = g_ui8RS485Rxbuffer[10]; 
03C0A:  MOVFF  B88,4F3
....................                         g_ui8PressureRating        = g_ui8RS485Rxbuffer[12]; 
03C0E:  MOVFF  B8A,4F4
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03C12:  MOVLW  0A
03C14:  MOVLB  B
03C16:  MOVWF  xFA
03C18:  MOVLW  10
03C1A:  MOVWF  xFB
03C1C:  MOVFF  BF1,BFD
03C20:  MOVFF  BF0,BFC
03C24:  MOVFF  BF5,BFE
03C28:  MOVLB  C
03C2A:  CLRF   x02
03C2C:  CLRF   x01
03C2E:  CLRF   x00
03C30:  MOVLB  B
03C32:  CLRF   xFF
03C34:  MOVLB  0
03C36:  CALL   17A8
....................                          
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer();                         
03C3A:  CALL   1750
....................                         break; 
03C3E:  BRA    3C84
....................                     case ADDRESS_FOR_PIPE_SPECIFICATION: 
....................                         // Parse number of data bytes to follow. 
....................                         ui8NoOfDataBytesToFollow = g_ui8RS485Rxbuffer[6]; 
03C40:  MOVFF  B84,BF5
....................  
....................                         // Pipe specification has arrived. 
....................                         // 1. First register(2 bytes) contains pipe's outer diameter(OD). 
....................                         // 2. Second register(2 bytes) contains pipe's length. 
....................                         // Step 1: Accumulate data. 
....................                         g_ui8PipeOD = g_ui8RS485Rxbuffer[8]; 
03C44:  MOVFF  B86,4F5
....................                         g_ui8PipeLength = g_ui8RS485Rxbuffer[10]; 
03C48:  MOVFF  B88,4F6
....................                          
....................                         // Step 2: Response Back to Master. 
....................                         SendResponseToMaster(MODBUS_RESPONSE_TO_MASTER_FOR_WRITE, MODBUS_FNCODE_WRITE_MULTIPLE_REGISTER, ui16StartAddtess, ui8NoOfDataBytesToFollow, MODBUS_RESPONSE_TO_MASTER_PARAMETER_NULL); 
03C4C:  MOVLW  0A
03C4E:  MOVLB  B
03C50:  MOVWF  xFA
03C52:  MOVLW  10
03C54:  MOVWF  xFB
03C56:  MOVFF  BF1,BFD
03C5A:  MOVFF  BF0,BFC
03C5E:  MOVFF  BF5,BFE
03C62:  MOVLB  C
03C64:  CLRF   x02
03C66:  CLRF   x01
03C68:  CLRF   x00
03C6A:  MOVLB  B
03C6C:  CLRF   xFF
03C6E:  MOVLB  0
03C70:  CALL   17A8
....................  
....................                         // Step 3: Clear receive buffer. 
....................                         ResetRS485RXBuffer(); 
03C74:  CALL   1750
....................  
....................                         // Set all product specification in GPRS message header. 
....................                         SetProductSpecificationForServer(); 
03C78:  GOTO   2A54
....................                         break; 
03C7C:  MOVLB  0
03C7E:  BRA    3C84
03C80:  MOVLB  B
....................                     default: 
....................                         break; 
03C82:  MOVLB  0
....................                 } 
....................                 break; 
03C84:  BRA    3C86
....................  
....................             default: 
....................                 break; 
03C86:  MOVLB  B
....................                  
....................         } 
....................     } 
03C88:  MOVLB  0
03C8A:  GOTO   46AC (RETURN)
.................... } 
....................  
....................  
.................... #endif /* _VI_RS485_CONFIG_H_ */ 
....................  
....................  
....................  
....................  
.................... void Initialize(void) 
.................... { 
....................      
....................     // Set RS485 Transmit Inactive. 
....................     output_bit(PIN_RS485_RTS,0); 
*
0093C:  BCF    F7F.0
0093E:  BCF    F87.0
....................  
....................      
....................     // Enable Global Interrupts. 
....................     enable_interrupts(GLOBAL); 
00940:  MOVLW  C0
00942:  IORWF  FF2,F
....................      
....................  
....................     // Initialize for GPRS message queue. 
....................     InitializePipeDataQueue(); 
00944:  BRA    05F6
....................     InitializeLANMsgHeader(); 
00946:  BRA    0752
....................  
....................      
....................     // Read set of Timer values from EEPROM.  
....................     g_ui8DataSendingIntervalTime = ReadIntervalFromEEPROM(); 
00948:  BRA    0766
0094A:  MOVFF  01,4E0
....................     g_ui32UnixTimeInSec = ReadStoredUnixTimeFromEEPROM(); 
0094E:  BRA    07F2
00950:  MOVFF  03,C0
00954:  MOVFF  02,BF
00958:  MOVFF  01,BE
0095C:  MOVFF  00,BD
....................     g_ui8SIMOperatorID  = ReadSIMOPeratorIDFromEEPROM(); 
00960:  BRA    088C
00962:  MOVFF  01,4EF
....................      
....................     // Initialize the sending queue to M0 
....................     //InitializeDataSendQueue(); 
....................     InitializeDataQueue(&g_stIBURcvQueue);  
00966:  MOVLW  03
00968:  MOVLB  B
0096A:  MOVWF  xEE
0096C:  MOVLW  55
0096E:  MOVWF  xED
00970:  MOVLB  0
00972:  RCALL  08AA
....................     InitializeDataQueue(&g_stIBUSendQueue); 
00974:  MOVLW  02
00976:  MOVLB  B
00978:  MOVWF  xEE
0097A:  MOVLW  90
0097C:  MOVWF  xED
0097E:  MOVLB  0
00980:  RCALL  08AA
....................      
....................     // Initialize global variables for RS485 communication.     
....................     g_ui16PipeCount =  0; 
00982:  MOVLB  4
00984:  CLRF   xBF
00986:  CLRF   xBE
....................     g_ui16PipeCountPrev = 0; 
00988:  CLRF   xC1
0098A:  CLRF   xC0
....................     g_ui32CurrentWt = 0; 
0098C:  CLRF   xC5
0098E:  CLRF   xC4
00990:  CLRF   xC3
00992:  CLRF   xC2
....................     g_ui16CurrentPassStatus = 0; 
00994:  CLRF   xC7
00996:  CLRF   xC6
....................     g_ui32RunningAvgWt = 0; 
00998:  CLRF   xCB
0099A:  CLRF   xCA
0099C:  CLRF   xC9
0099E:  CLRF   xC8
....................     g_ui32RunningTareValue = 0; 
009A0:  CLRF   xCF
009A2:  CLRF   xCE
009A4:  CLRF   xCD
009A6:  CLRF   xCC
....................     //g_ui16ServerStatus = 0; 
....................     g_ui16CurrentMode = 0; 
009A8:  CLRF   xD7
009AA:  CLRF   xD6
....................          
....................     g_stIBURcvData.g_ui8ArrIBUData[0] = 0; 
009AC:  MOVLB  1
009AE:  CLRF   xEF
....................     g_stIBURcvData.g_ui8ArrIBUData[1] = 0; 
009B0:  CLRF   xF0
....................     g_stIBURcvData.g_ui8ArrIBUData[2] = 0; 
009B2:  CLRF   xF1
....................     g_stIBURcvData.g_ui8ArrIBUData[3] = 0; 
009B4:  CLRF   xF2
....................     g_stIBURcvData.g_ui8ArrIBUData[4] = 0; 
009B6:  CLRF   xF3
009B8:  MOVLB  0
009BA:  GOTO   463C (RETURN)
....................      
....................      
.................... }	 
....................  
.................... void main() 
*
04376:  BSF    F77.7
04378:  BCF    F77.6
0437A:  CLRF   FF8
0437C:  MOVLB  E
0437E:  BCF    x1F.5
04380:  BSF    x22.5
04382:  BCF    x23.1
04384:  BCF    x23.5
04386:  BSF    FF2.5
04388:  BSF    07.7
0438A:  MOVLW  55
0438C:  MOVLB  D
0438E:  MOVWF  xEF
04390:  MOVLW  AA
04392:  MOVWF  xEF
04394:  BCF    xEF.0
04396:  MOVLW  17
04398:  MOVLB  E
0439A:  MOVWF  x0F
0439C:  MOVLW  21
0439E:  MOVWF  x13
043A0:  MOVLW  23
043A2:  MOVWF  x17
043A4:  MOVLW  0C
043A6:  MOVWF  x68
043A8:  MOVLW  10
043AA:  MOVWF  x72
043AC:  MOVLW  14
043AE:  MOVWF  x74
043B0:  MOVLW  55
043B2:  MOVLB  D
043B4:  MOVWF  xEF
043B6:  MOVLW  AA
043B8:  MOVWF  xEF
043BA:  BSF    xEF.0
043BC:  CLRF   2F
043BE:  MOVLB  E
043C0:  BSF    xF0.3
043C2:  MOVLW  81
043C4:  MOVWF  xEC
043C6:  MOVLW  00
043C8:  MOVWF  xED
043CA:  MOVLW  A6
043CC:  MOVWF  xEF
043CE:  MOVLW  90
043D0:  MOVWF  xEE
043D2:  BCF    F9E.3
043D4:  MOVLW  40
043D6:  MOVWF  F9A
043D8:  MOVLW  A6
043DA:  MOVWF  F9D
043DC:  MOVLW  90
043DE:  MOVWF  F9C
043E0:  BSF    xE2.3
043E2:  MOVLW  2A
043E4:  MOVWF  xDE
043E6:  MOVLW  00
043E8:  MOVWF  xDF
043EA:  MOVLW  A6
043EC:  MOVWF  xE1
043EE:  MOVLW  90
043F0:  MOVWF  xE0
043F2:  CLRF   33
043F4:  CLRF   32
043F6:  MOVLW  29
043F8:  MOVWF  3E
043FA:  CLRF   3F
043FC:  MOVLW  16
043FE:  MOVWF  40
04400:  MOVLB  0
04402:  CLRF   x87
04404:  CLRF   x88
04406:  MOVLW  03
04408:  MOVWF  x89
0440A:  MOVLW  0C
0440C:  MOVWF  x8A
0440E:  CLRF   x8C
04410:  MOVLW  FA
04412:  MOVWF  x8B
04414:  MOVLW  16
04416:  MOVWF  x8D
04418:  CLRF   x8E
0441A:  CLRF   x8F
0441C:  CLRF   x91
0441E:  CLRF   x90
04420:  CLRF   x92
04422:  CLRF   x93
04424:  CLRF   x94
04426:  CLRF   x98
04428:  CLRF   x97
0442A:  CLRF   x96
0442C:  CLRF   x95
0442E:  CLRF   xA6
04430:  CLRF   xBC
04432:  MOVLW  B1
04434:  MOVWF  xBB
04436:  CLRF   xC0
04438:  CLRF   xBF
0443A:  CLRF   xBE
0443C:  CLRF   xBD
0443E:  CLRF   xCA
04440:  CLRF   xCB
04442:  CLRF   xCC
04444:  MOVLB  1
04446:  CLRF   xD3
04448:  CLRF   xE8
0444A:  CLRF   xE9
0444C:  CLRF   xEA
0444E:  MOVLW  A5
04450:  MOVWF  xEB
04452:  CLRF   xEC
04454:  MOVLB  2
04456:  CLRF   x8E
04458:  CLRF   x8F
0445A:  MOVLW  01
0445C:  MOVLB  4
0445E:  MOVWF  x1A
04460:  CLRF   x1B
04462:  CLRF   x1C
04464:  CLRF   x1D
04466:  CLRF   x1F
04468:  CLRF   x1E
0446A:  CLRF   x2D
0446C:  CLRF   x3C
0446E:  CLRF   x3B
04470:  CLRF   x3D
04472:  CLRF   xA4
04474:  CLRF   xA5
04476:  CLRF   xA6
04478:  CLRF   xA7
0447A:  MOVWF  xB5
0447C:  CLRF   xB9
0447E:  CLRF   xB8
04480:  CLRF   xB7
04482:  CLRF   xB6
04484:  CLRF   xBD
04486:  CLRF   xBC
04488:  CLRF   xBB
0448A:  CLRF   xBA
0448C:  CLRF   xBF
0448E:  CLRF   xBE
04490:  CLRF   xC5
04492:  CLRF   xC4
04494:  CLRF   xC3
04496:  CLRF   xC2
04498:  CLRF   xC7
0449A:  CLRF   xC6
0449C:  CLRF   xCB
0449E:  CLRF   xCA
044A0:  CLRF   xC9
044A2:  CLRF   xC8
044A4:  CLRF   xCF
044A6:  CLRF   xCE
044A8:  CLRF   xCD
044AA:  CLRF   xCC
044AC:  CLRF   xD1
044AE:  CLRF   xD0
044B0:  CLRF   xD3
044B2:  CLRF   xD2
044B4:  CLRF   xD5
044B6:  CLRF   xD4
044B8:  CLRF   xD7
044BA:  CLRF   xD6
044BC:  CLRF   xD8
044BE:  CLRF   xDA
044C0:  CLRF   xD9
044C2:  CLRF   xDC
044C4:  CLRF   xDB
044C6:  CLRF   xDD
044C8:  CLRF   xDE
044CA:  CLRF   xDF
044CC:  CLRF   xE0
044CE:  CLRF   xE1
044D0:  CLRF   xE2
044D2:  CLRF   xE3
044D4:  CLRF   xE5
044D6:  CLRF   xE4
044D8:  CLRF   xE7
044DA:  CLRF   xE6
044DC:  CLRF   xE9
044DE:  CLRF   xE8
044E0:  CLRF   xEA
044E2:  CLRF   xEB
044E4:  CLRF   xED
044E6:  CLRF   xEC
044E8:  CLRF   xEE
044EA:  CLRF   xEF
044EC:  CLRF   xF1
044EE:  CLRF   xF0
044F0:  CLRF   xF2
044F2:  CLRF   xF3
044F4:  CLRF   xF4
044F6:  CLRF   xF5
044F8:  CLRF   xF6
044FA:  CLRF   xF8
044FC:  CLRF   xF7
044FE:  MOVLW  0C
04500:  MOVWF  xF9
04502:  CLRF   xFB
04504:  CLRF   xFA
04506:  CLRF   xFC
04508:  CLRF   xFE
0450A:  CLRF   xFD
0450C:  MOVLW  1A
0450E:  MOVWF  xFF
04510:  MOVLB  5
04512:  CLRF   x01
04514:  CLRF   x00
04516:  CLRF   x02
04518:  MOVLW  15
0451A:  MOVWF  x03
0451C:  MOVLW  B4
0451E:  MOVWF  x04
04520:  MOVLW  2C
04522:  MOVWF  x05
04524:  MOVLW  2E
04526:  MOVWF  x06
04528:  MOVLB  6
0452A:  CLRF   xFC
0452C:  CLRF   xFB
0452E:  CLRF   xFD
04530:  CLRF   xFE
04532:  MOVLB  7
04534:  CLRF   x00
04536:  MOVLW  01
04538:  MOVLB  6
0453A:  MOVWF  xFF
0453C:  MOVLB  7
0453E:  CLRF   x02
04540:  MOVLW  02
04542:  MOVWF  x01
04544:  MOVLW  07
04546:  MOVWF  x04
04548:  MOVLW  CF
0454A:  MOVWF  x03
0454C:  CLRF   x05
0454E:  CLRF   x06
04550:  CLRF   x07
04552:  CLRF   x14
04554:  CLRF   x29
04556:  MOVLB  B
04558:  CLRF   x79
0455A:  CLRF   x78
0455C:  CLRF   x7B
0455E:  CLRF   x7A
04560:  CLRF   x7C
04562:  CLRF   x7D
04564:  CLRF   xE2
04566:  MOVLW  0B
04568:  MOVWF  xE3
0456A:  MOVLW  01
0456C:  MOVWF  xE4
0456E:  CLRF   xE5
04570:  CLRF   xE7
04572:  CLRF   xE6
04574:  CLRF   xEB
04576:  CLRF   xEA
04578:  CLRF   xE9
0457A:  CLRF   xE8
0457C:  MOVLB  E
0457E:  CLRF   x92
04580:  CLRF   x9A
04582:  CLRF   xA7
04584:  CLRF   xAF
04586:  CLRF   xB4
04588:  CLRF   xBC
0458A:  CLRF   xD2
0458C:  CLRF   xD3
0458E:  CLRF   xD1
04590:  CLRF   xD0
04592:  MOVLW  0C
04594:  MOVWF  31
04596:  MOVLW  36
04598:  MOVWF  30
0459A:  MOVLW  01
0459C:  MOVLB  C
0459E:  MOVWF  x37
045A0:  MOVLW  B0
045A2:  MOVWF  x36
045A4:  CLRF   x39
045A6:  CLRF   x38
045A8:  MOVLB  0
045AA:  BRA    45D4
045AC:  DATA 46,40
045AE:  DATA 41,00
045B0:  DATA 14,41
045B2:  DATA D4,00
045B4:  DATA 87,42
045B6:  DATA 07,00
045B8:  DATA 0D,44
045BA:  DATA 2E,00
045BC:  DATA 66,44
045BE:  DATA 3E,00
045C0:  DATA 0D,44
045C2:  DATA A8,00
045C4:  DATA FF,45
045C6:  DATA 07,00
045C8:  DATA F5,C0
045CA:  DATA 00,14
045CC:  DATA 47,15
045CE:  DATA 00,64
045D0:  DATA 4B,7E
045D2:  DATA 00,00
045D4:  MOVLW  00
045D6:  MOVWF  FF8
045D8:  MOVLW  45
045DA:  MOVWF  FF7
045DC:  MOVLW  AC
045DE:  MOVWF  FF6
045E0:  TBLRD*+
045E2:  MOVF   FF5,W
045E4:  MOVWF  00
045E6:  XORLW  00
045E8:  BZ    4610
045EA:  TBLRD*+
045EC:  MOVF   FF5,W
045EE:  MOVWF  01
045F0:  BTFSC  FE8.7
045F2:  BRA    45FE
045F4:  ANDLW  3F
045F6:  MOVWF  FEA
045F8:  TBLRD*+
045FA:  MOVF   FF5,W
045FC:  MOVWF  FE9
045FE:  BTFSC  01.6
04600:  TBLRD*+
04602:  BTFSS  01.6
04604:  TBLRD*+
04606:  MOVF   FF5,W
04608:  MOVWF  FEE
0460A:  DCFSNZ 00,F
0460C:  BRA    45E0
0460E:  BRA    4602
04610:  CLRF   FF8
04612:  MOVLB  B
04614:  CLRF   xEC
.................... { 
....................     unsigned int8 ui8RetVal                         = 0; 
....................     g_fDataSendingSequence                          = LAN_DATA_SENDING_SEQUENCE_1; 
04616:  MOVLW  01
04618:  MOVLB  7
0461A:  MOVWF  x14
....................      
.................... 	// Set Watch Dog Timer ON. 
....................     setup_wdt(WDT_4S | WDT_WINDOW_100_PERCENT); 
0461C:  MOVLW  07
0461E:  MOVLB  E
04620:  MOVWF  x3E
04622:  MOVLW  19
04624:  MOVWF  x3D
....................      
.................... 	//Initialize 1 millisecond timer. 
.................... 	Init1MSTimer(); 
04626:  MOVLB  0
04628:  GOTO   05B2
....................     	 
.................... 	//Initialize RS485 Receive interrupt. 
.................... 	InitRS485RxInterrupt(); 
0462C:  GOTO   05D2
.................... 	 
.................... 	//Initialize UART2UART Receive interrupt. 
....................     InitIBURxInterrupt(); 
04630:  GOTO   05DE
....................      
....................     // Initialize GPRS Module;EC20 Receive interrupt. 
....................     //InitM66RxInterrupt(); 
....................      
....................     // Initialize LAN Module; USR_K3 receive interrupt. 
....................     InitLANCommRxInterrupt(); 
04634:  GOTO   05EA
....................  
.................... 	// Initialize Main Global variables  
.................... 	Initialize(); 
04638:  GOTO   093C
....................      
....................     // Initialize Receive Queue 
....................     InitializeRcvQ(); 
0463C:  GOTO   09D8
....................      
....................     // Set GSM modem ready 
....................     //delay_ms(3000); 
....................      
....................  
.................... 	// Reset WDT. 
.................... 	restart_wdt(); 
04640:  MOVLB  E
04642:  MOVF   x3D,W
04644:  CLRWDT
....................  
.................... 	for(;;) 
.................... 	{  
....................         // step 1: Check if there is any message received in IBU through UART 
....................         g_ui8ElementInQ = ElementsInQ(); 
04646:  MOVLB  0
04648:  GOTO   09F6
0464C:  MOVFF  01,1D3
....................         if (g_ui8ElementInQ >= SIZE_IBU_COMPLETE_SEND_MSG) 
04650:  MOVLB  1
04652:  MOVF   xD3,W
04654:  SUBLW  11
04656:  BC    4660
....................         { 
....................             // Hopefully a Complete Message Received 
....................             CheckIBUReceiveQ(); 
04658:  MOVLB  0
0465A:  GOTO   0DB6
0465E:  MOVLB  1
....................         } 
....................  
....................         // step 2: Check if there is any message in IBC Receive Queue 
....................         if (IsMSGInIBUQueue(&g_stIBURcvQueue)) 
04660:  MOVLW  03
04662:  MOVLB  B
04664:  MOVWF  xEE
04666:  MOVLW  55
04668:  MOVWF  xED
0466A:  MOVLB  0
0466C:  CALL   10E8
04670:  MOVF   01,F
04672:  BZ    4678
....................         { 
....................             // Process IBC  
....................             ProcessIBUMsg(); 
04674:  GOTO   1340
....................         }  
....................          
....................         // Step 3: check if there is any message in IBU send queue. 
....................         // If available then process to send to UART. 
....................         if(IsMSGInIBUQueue(&g_stIBUSendQueue) &&  
....................           (IBU_SENDING_FREE == g_fIBUSendBusy)) 
04678:  MOVLW  02
0467A:  MOVLB  B
0467C:  MOVWF  xEE
0467E:  MOVLW  90
04680:  MOVWF  xED
04682:  MOVLB  0
04684:  CALL   10E8
04688:  MOVF   01,F
0468A:  BZ    46A2
0468C:  MOVLB  2
0468E:  MOVF   x8F,F
04690:  BTFSC  FD8.2
04692:  BRA    4698
04694:  MOVLB  0
04696:  BRA    46A2
....................         { 
....................             // Set flag to denote IBU is busy in sending data. 
....................             g_fIBUSendBusy = IBU_SENDING_BUSY; 
04698:  MOVLW  01
0469A:  MOVWF  x8F
....................              
....................             // Send data from queue. 
....................             SendIBUMSGFromQ(); 
0469C:  MOVLB  0
0469E:  GOTO   1624
....................         }         
....................   
....................         // Step 5: Check if a byte received in Modbus..then process data. 
....................         if(ISR_RECEIVED_ALL_BYTES == g_fISRReceivedByteStatus) 
046A2:  MOVF   x8D,W
046A4:  SUBLW  15
046A6:  BNZ   46B0
....................         {  
....................             // Process received data. 
....................             ProcessUART2ReceivedData(); 
046A8:  GOTO   2B86
....................  
....................             // Reset flag. 
....................             g_fISRReceivedByteStatus = ISR_PROCESSED_ALL_BYTES; 
046AC:  MOVLW  16
046AE:  MOVWF  x8D
....................         } 
....................          
....................         // Step 6: Check for unix time write to EEPROM signal. 
....................         if(TIME_STAMP_SIGNAL_ON == g_fTSWriteToEEPROMSignal) 
046B0:  MOVLB  5
046B2:  MOVF   x03,W
046B4:  SUBLW  14
046B6:  BNZ   46D4
....................         { 
....................             // Write data to EEPROM. 
....................             WriteCurrentUnixTimeToEEPROM(g_ui32HookedUpTimeStampPerMinute); 
046B8:  MOVFF  98,BF0
046BC:  MOVFF  97,BEF
046C0:  MOVFF  96,BEE
046C4:  MOVFF  95,BED
046C8:  MOVLB  0
046CA:  GOTO   3D0C
....................              
....................             // Reset flag state. 
....................             g_fTSWriteToEEPROMSignal = TIME_STAMP_SIGNAL_COMPLETE; 
046CE:  MOVLW  15
046D0:  MOVLB  5
046D2:  MOVWF  x03
....................         } 
....................          
....................          
....................         // Here, pipe current weight or pipe data will be sent through LAN. 
....................         // By modular data sending process we can uninterruptedly run peripheral 
....................         // process along with data sending in parallel. 
....................          
....................  // ################ Below steps are for GPRS modular data sending ###################### 
....................          
....................         // Step 1: Check modular data sending time interval & data sending sequence 
....................         //         are allowing to initiate data sending process. 
....................         if(SHOULD_SEND_DATA == g_fShouldSendData && 
....................            LAN_DATA_SENDING_SEQUENCE_1 == g_fDataSendingSequence) 
046D4:  MOVLB  4
046D6:  MOVF   xFF,W
046D8:  SUBLW  19
046DA:  BNZ   4702
046DC:  MOVLB  7
046DE:  DECFSZ x14,W
046E0:  BRA    46E4
046E2:  BRA    46E8
046E4:  MOVLB  4
046E6:  BRA    4702
....................         { 
....................             // Check if new data available in data queue. 
....................             ui8RetVal = IsPipeDataQueueEmpty(); 
046E8:  MOVLB  0
046EA:  GOTO   3D5A
046EE:  MOVFF  01,BEC
....................              
....................             if(0 == ui8RetVal)  // Queue is not empty. 
046F2:  MOVLB  B
046F4:  MOVF   xEC,F
046F6:  BNZ   4700
....................             { 
....................                 // Update sequence flag of sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_2; 
046F8:  MOVLW  02
046FA:  MOVLB  7
046FC:  MOVWF  x14
....................             } 
046FE:  MOVLB  B
....................             else    // Queue is empty. 
....................             { 
....................                 /* Do Nothing; Wait until new data available */ 
....................             } 
....................         } 
04700:  BRA    47D8
....................          
....................         // Step 2: If data present in queue then fetch according to queue front 
....................         //         and send. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_2 == g_fDataSendingSequence) 
04702:  MOVLB  7
04704:  MOVF   x14,W
04706:  SUBLW  02
04708:  BNZ   4722
....................         { 
....................             // Send data from queue. 
....................             SendDataFromQ(); 
0470A:  MOVLB  0
0470C:  BRA    405E
....................              
....................             // Set a timeout to receive success code. 
....................             g_fIsTimedOut = 0; 
0470E:  CLRF   x8F
....................             SetTimeout(SERVER_RESPONSE_RECEIVE_TIMEOUT); 
04710:  MOVLW  03
04712:  MOVLB  B
04714:  MOVWF  xED
04716:  MOVLB  0
04718:  RCALL  42AA
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_3; 
0471A:  MOVLW  03
0471C:  MOVLB  7
0471E:  MOVWF  x14
....................         } 
04720:  BRA    47D6
....................          
....................         // Step 3: check for return code from server upto set time. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 0) 
04722:  MOVF   x14,W
04724:  SUBLW  03
04726:  BNZ   474C
04728:  MOVLB  0
0472A:  MOVF   x8F,F
0472C:  BTFSC  FD8.2
0472E:  BRA    4734
04730:  MOVLB  7
04732:  BRA    474C
....................         { 
....................             // Check for server response. 
....................             ui8RetVal = CheckServerResponse(); 
04734:  BRA    42F8
04736:  MOVFF  01,BEC
....................             //ui8RetVal = 0; 
....................              
....................             // Check return value. 
....................             if(ui8RetVal == 0)  // Server response received. 
0473A:  MOVLB  B
0473C:  MOVF   xEC,F
0473E:  BNZ   4748
....................             { 
....................                 // Update sequence flag for data sending. 
....................                 g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_4; 
04740:  MOVLW  04
04742:  MOVLB  7
04744:  MOVWF  x14
....................             } 
04746:  MOVLB  B
....................             else  // No response received after parsing. 
....................             { 
....................                 /* Do Nothing */ 
....................             } 
....................                 
....................         }  
04748:  BRA    47D8
0474A:  MOVLB  7
....................          
....................         // Step 4: check if set timeout for arriving server response; is over. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_3 == g_fDataSendingSequence && 
....................                 g_fIsTimedOut == 1) 
0474C:  MOVF   x14,W
0474E:  SUBLW  03
04750:  BNZ   4772
04752:  MOVLB  0
04754:  DECFSZ x8F,W
04756:  BRA    475A
04758:  BRA    475E
0475A:  MOVLB  7
0475C:  BRA    4772
....................         { 
....................             // No response received during set time interval for expected arrival. 
....................             // Set a time interval to wait & try Once. 
....................             g_fIsTimedOut = 0; 
0475E:  CLRF   x8F
....................             SetTimeout(DATA_RESEND_INTERVAL_TIMEOUT); 
04760:  MOVLW  0A
04762:  MOVLB  B
04764:  MOVWF  xED
04766:  MOVLB  0
04768:  RCALL  42AA
....................  
....................             // Update sequence flag. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_5; 
0476A:  MOVLW  05
0476C:  MOVLB  7
0476E:  MOVWF  x14
....................         } 
04770:  BRA    47D6
....................          
....................         // Step 5: If server response code received & parsed successfully. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_4 == g_fDataSendingSequence) 
04772:  MOVF   x14,W
04774:  SUBLW  04
04776:  BNZ   47BE
....................         { 
....................             // Data from queue successfully sent to server and server response 
....................             // is also received.  
....................             // Update flags upon successful data send. 
....................              
....................             // Update data sending interval flag for next interval counting start. 
....................             g_fShouldSendData = SHOULD_NOT_SEND_DATA; 
04778:  MOVLW  1A
0477A:  MOVLB  4
0477C:  MOVWF  xFF
....................              
....................             // Handle queue front. 
....................             if (g_stPipeDataSendQueue.m_i8Front == g_stPipeDataSendQueue.m_i8Rear) 
0477E:  MOVLB  B
04780:  MOVF   x77,W
04782:  SUBWF  x76,W
04784:  BNZ   478E
....................             { 
....................                 // Queue is empty 
....................                 g_stPipeDataSendQueue.m_i8Front = g_stPipeDataSendQueue.m_i8Rear = -1; 
04786:  SETF   x77
04788:  MOVFF  B77,B76
....................             } 
0478C:  BRA    47B6
....................             else // Queue is not empty 
....................             { 
....................                 g_stPipeDataSendQueue.m_i8Front = (g_stPipeDataSendQueue.m_i8Front + 1) % SIZE_GPRS_DATA_NODE_QUEUE; 
0478E:  MOVLW  01
04790:  ADDWF  x76,W
04792:  MOVWF  xEE
04794:  CLRF   19
04796:  BTFSC  FF2.7
04798:  BSF    19.7
0479A:  BCF    FF2.7
0479C:  MOVFF  FE8,C33
047A0:  MOVLW  64
047A2:  MOVLB  C
047A4:  MOVWF  x34
047A6:  MOVLB  0
047A8:  CALL   0182
047AC:  BTFSC  19.7
047AE:  BSF    FF2.7
047B0:  MOVFF  00,B76
047B4:  MOVLB  B
....................             }  
....................              
....................             // Update sequence flag of data sending. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
047B6:  MOVLW  01
047B8:  MOVLB  7
047BA:  MOVWF  x14
....................         } 
047BC:  BRA    47D6
....................          
....................         // Step 6: If proper response is not received; after waiting for some time 
....................         //          resend data. 
....................         else if(LAN_DATA_SENDING_SEQUENCE_5 == g_fDataSendingSequence && 
....................                 1 == g_fIsTimedOut) 
047BE:  MOVF   x14,W
047C0:  SUBLW  05
047C2:  BNZ   47D6
047C4:  MOVLB  0
047C6:  DECFSZ x8F,W
047C8:  BRA    47CC
047CA:  BRA    47D0
047CC:  MOVLB  7
047CE:  BRA    47D6
....................         { 
....................             // Update sequence flag to resend data. 
....................             g_fDataSendingSequence = LAN_DATA_SENDING_SEQUENCE_1; 
047D0:  MOVLW  01
047D2:  MOVLB  7
047D4:  MOVWF  x14
....................         } 
047D6:  MOVLB  B
....................         else 
....................         { 
....................             /* Do Nothing */ 
....................         } 
....................              
.................... 		// Reset WDT. 
....................         restart_wdt();                 
047D8:  MOVLB  E
047DA:  MOVF   x3D,W
047DC:  CLRWDT
047DE:  BRA    4646
.................... 	}	 
.................... } 
....................     	 
047E0:  SLEEP 
....................  
....................  
....................  
....................  
....................  
.................... 	 

Configuration Fuses:
   Word  1: DFFF   ECH RSTOSC_EXT NOCLKOUT CKS NOFCMEN
   Word  2: FF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FFFF   WDTSW WDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

ROM data:
F00000: 01 02 03 04                                        ....
